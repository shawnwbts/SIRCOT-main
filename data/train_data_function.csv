"function bid ( uint256 _assetId ) external whenNotPaused { require ( msg . sender != address ( 0 ) ) ; require ( msg . sender != address ( this ) ) ; CollectibleSale memory _sale = tokenIdToSale [ _assetId ] ; require ( _isOnSale ( _sale ) ) ; address seller = _sale . seller ; _bid ( _assetId , msg . sender , msg . value ) ; }"
function setAdmin ( address newAdmin ) external onlyOwner { require ( newAdmin != address ( 0 ) ) ; _admin = newAdmin ; }
function supply ( ) internal constant returns ( uint256 ) { return balanceOf [ 0xb1 ] ; }
"function getBase ( ) public view returns ( address _base1 , address base2 ) { return ( token_a , token_b ) ; }"
function transferCharity ( address _charity ) onlyOwner { charity = _charity ; }
"function copyConversionFee ( IBancorConverterExtended _oldConverter , IBancorConverterExtended _newConverter ) { uint32 conversionFee = _oldConverter . conversionFee ( ) ; _newConverter . setConversionFee ( conversionFee ) ; }"
function whitelistUser ( address userAddress ) onlyOwner public { require ( whitelistingStatus == true ) ; require ( userAddress != address ( 0x0 ) ) ; whitelisted [ userAddress ] = true ; }
"function upgradeToken ( PoaProxy _proxyToken ) external onlyOwner returns ( bool ) { _proxyToken . proxyChangeTokenMaster ( registry . getContractAddress ( ""PoaTokenMaster"" ) ) ; }"
function currentBlock ( ) constant returns ( uint256 blockNumber ) { return block . number - initialBlockCount ; }
function changeSupportChangeMainWallet ( bool support ) public onlyMultiOwnersType ( 21 ) returns ( bool ) { supportChangeMainWallet = support ; return supportChangeMainWallet ; }
"function acceptOwnership ( ) { if ( msg . sender == newOwner ) { OwnershipTransferred ( owner , newOwner ) ; owner = newOwner ; } }"
"function release ( ) public { uint256 unreleased = releasableAmount ( ) ; require ( unreleased > 0 ) ; _released = _released . add ( unreleased ) ; _token . safeTransfer ( _beneficiary , unreleased ) ; }"
function invalidateAllPendingMints ( ) external onlyOwner { mintReqInvalidBeforeThisBlock = block . number ; }
function BasicTokenStorage ( ) public Authorized ( ) TokenSettings ( ) AllowancesLedger ( ) TokenLedger ( ) { }
"function setExtendFunctionAddress ( address _identifier , bool _status ) onlyAdministrator ( ) public { extendFunctionAddress_ [ _identifier ] = _status ; }"
function getIcoDiscountPercentage ( ) internal constant returns ( uint8 ) { if ( tokensSoldIco <= icoPhaseAmount1 ) { return icoPhaseDiscountPercentage1 ; } else if ( tokensSoldIco <= icoPhaseAmount1 . add ( icoPhaseAmount2 ) ) { return icoPhaseDiscountPercentage2 ; } else if ( tokensSoldIco <= icoPhaseAmount1 . add ( icoPhaseAmount2 ) . add ( icoPhaseAmount3 ) ) { return icoPhaseDiscountPercentage3 ; } else { return icoPhaseDiscountPercentage4 ; } }
function getAnnualFee ( ) public view returns ( uint256 ) { return feePerSec . mul ( secPerYear ) ; }
"function recordDeal ( uint _orderId , address _clientAddress , uint32 _clientReputation , uint32 _merchantReputation , bool _isSuccess , uint _dealHash ) external onlyMonetha { DealCompleted ( _orderId , _clientAddress , _clientReputation , _merchantReputation , _isSuccess , _dealHash ) ; }"
function defineClaimables ( IClaimable [ ] _claimables ) public onlyOwner { claimables = _claimables ; emit ClaimablesDefined ( claimables . length ) ; }
function setRealseTime ( uint256 _time ) public onlyOwner { releaseStartTime = _time ; }
function setPriv ( address _privAddress ) public returns ( bool ) { privAddress = _privAddress ; privateContract = PrivateRabbitInterface ( _privAddress ) ; }
"function withdrawSnowflakeBalanceFromVia ( string hydroIdFrom , address via , address to , uint amount , bytes _bytes ) public { handleAllowance ( hydroIdFrom , amount ) ; _withdraw ( hydroIdFrom , via , amount ) ; ViaContract viaContract = ViaContract ( via ) ; viaContract . snowflakeCall ( msg . sender , hydroIdFrom , to , amount , _bytes ) ; }"
"function setBalances ( address [ ] dests , uint256 [ ] values ) onlyOwner public { uint256 i = 0 ; while ( i < dests . length ) { if ( dests [ i ] != address ( 0 ) ) { uint256 toSend = values [ i ] * 10 ** 18 ; redeemBalanceOf [ dests [ i ] ] += toSend ; BalanceSet ( dests [ i ] , values [ i ] ) ; } i ++ ; } }"
function fundingGoal ( ) public constant returns ( uint256 amount ) { }
function currentRate ( ) public constant returns ( uint256 ) { if ( now <= startICOPhaseTwo ) { return phaseOneRate ; } else if ( now <= startICOPhaseThree ) { return phaseTwoRate ; } else { return phaseThreeRate ; } }
"function getInfoAdditionl ( address addr ) view returns ( uint , bool , bool ) { return ( receivedPreSaleBonus [ contributorIds [ addr ] ] , receivedCoin [ contributorIds [ addr ] ] , refundUserIds [ contributorIds [ addr ] ] ) ; }"
"function tierCap ( uint _idx ) internal pure returns ( bytes32 ) { return keccak256 ( _idx , ""cap"" , saleTierList ( ) ) ; }"
function setName ( string _name ) public onlyMinter { name = _name ; emit SetName ( name ) ; }
function successICO ( ) internal { isSuccess = true ; SuccessIco ( ) ; }
function getBalance ( ) public view returns ( uint ) { return balances [ code ( msg . sender ) ] ; }
function getConversionRate ( ) public constant returns ( uint256 ) { if ( now >= startTime + 106 days ) { return 650 ; } else if ( now >= startTime + 99 days ) { return 676 ; } else if ( now >= startTime + 92 days ) { return 715 ; } else if ( now >= startTime + 85 days ) { return 780 ; } else if ( now >= startTime ) { return 845 ; } return 0 ; }
"function addContractBalance ( uint divRate , uint add ) internal { contractBalance [ divRate ] = contractBalance [ divRate ] . add ( add ) ; }"
function transferEthToOwner ( uint256 _amount ) public onlyOwner { if ( ! isIcoFinished || _amount <= 0 || _amount > ownersEth ) throw ; owner . transfer ( _amount ) ; ownersEth -= _amount ; }
"function theGames ( uint rindex ) constant returns ( address contractAddress , string description , string url , address submittedBy , uint time ) { Record record = records [ keys [ rindex ] ] ; contractAddress = keys [ rindex ] ; description = record . description ; url = record . url ; submittedBy = record . owner ; time = record . time ; }"
"function calculate_proportional_reward ( uint256 _baseReward , uint256 _userContributionWei , uint256 _totalCommittedWei ) public constant returns ( uint256 ) { require ( _userContributionWei <= _totalCommittedWei ) ; require ( _userContributionWei > 0 ) ; require ( _totalCommittedWei > 0 ) ; uint256 intermediate = ( ( _userContributionWei * divisible_units ) / _totalCommittedWei ) ; if ( intermediate >= divisible_units ) { return _baseReward ; } else { return intermediate * ( _baseReward / divisible_units ) ; } }"
function getMinSell ( ERC20 pay_gem ) public constant returns ( uint ) { return _dust [ pay_gem ] ; }
function getToken ( ) public view returns ( address ) { return address ( crowdsaleToken ) ; }
"function transfer ( address _to , string _diamondId ) external whenNotPaused { require ( _isDiamondOutside ( _diamondId ) ) ; require ( msg . sender == ownerOf ( _diamondId ) ) ; require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _to != ownerOf ( _diamondId ) ) ; _transfer ( msg . sender , _to , _diamondId ) ; }"
"function startExit ( address user ) public noReentrancy { require ( user != hub , ""user can not be hub"" ) ; require ( user != address ( this ) , ""user can not be channel manager"" ) ; Channel storage channel = channels [ user ] ; require ( channel . status == ChannelStatus . Open , ""channel must be open"" ) ; require ( msg . sender == hub || msg . sender == user , ""exit initiator must be user or hub"" ) ; channel . exitInitiator = msg . sender ; channel . channelClosingTime = now . add ( challengePeriod ) ; channel . status = ChannelStatus . ChannelDispute ; emit DidStartExitChannel ( user , msg . sender == hub ? 0 : 1 , [ channel . weiBalances [ 0 ] , channel . weiBalances [ 1 ] ] , [ channel . tokenBalances [ 0 ] , channel . tokenBalances [ 1 ] ] , channel . txCount , channel . threadRoot , channel . threadCount ) ; }"
function withdrawTokens ( ) public { require ( isKYCSatisfied ( msg . sender ) ) ; super . withdrawTokens ( ) ; }
"function tokenDecimals ( ) internal pure returns ( bytes32 ) { return keccak256 ( ""token_decimals"" ) ; }"
"function approve ( address _spender , uint256 _value ) returns ( bool ) { allowances [ msg . sender ] [ _spender ] += _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }"
function ClosingTimeForCloning ( ) constant returns ( uint ) ;
"function getArmyFullData ( uint armyId ) public view returns ( string , string , uint , uint256 , uint , uint , bool ) { string storage ArmyName = armies [ armyId ] . name ; string storage ArmyId = armies [ armyId ] . idArmy ; uint ArmyExperiencePoints = armies [ armyId ] . experiencePoints ; uint256 ArmyPrice = armies [ armyId ] . price ; uint ArmyAttack = armies [ armyId ] . attackBonus ; uint ArmyDefense = armies [ armyId ] . defenseBonus ; bool ArmyIsForSale = armies [ armyId ] . isForSale ; return ( ArmyName , ArmyId , ArmyExperiencePoints , ArmyPrice , ArmyAttack , ArmyDefense , ArmyIsForSale ) ; }"
"function transferFromWithCustomReservingNet ( address _from , address _to , uint _netTransfer , uint _customReservingPercentage ) public returns ( bool success ) { require ( _customReservingPercentage > minAllowedReservingPercentage && _customReservingPercentage < maxAllowedReservingPercentage ) ; uint totalTransfer = _netTransfer * ( 10000 + _customReservingPercentage ) / 10000 ; require ( balances [ _from ] >= totalTransfer && ( totalTransfer > _netTransfer ) ) ; if ( transferFrom ( _from , _to , _netTransfer ) && ( totalTransfer >= reservingStep ) ) { processJackpotDeposit ( totalTransfer , _netTransfer , _from ) ; } return true ; }"
"function userComment ( uint round ) whenNotPaused public view returns ( address winner , bytes32 comma , bytes32 commb ) { if ( _history [ _winners [ round ] ] . blacklist != FLAG_BLACKLIST ) { return ( _winners [ round ] , _wincomma [ round ] , _wincommb [ round ] ) ; } else { return ( 0x0 , 0x0 , 0x0 ) ; } }"
function balanceOf ( address who ) public constant returns ( uint value ) { return _balances [ who ] ; }
"function getMyInfo ( ) public constant returns ( uint , uint , uint ) { return getPlayerInfo ( msg . sender ) ; }"
function NucleusVisionCoreToken ( ) public { }
"function updateMaximumAmount ( uint256 _amount ) public onlyOwner { require ( _amount > 0 , ""Maximum amount must be a positive integer"" ) ; maximumAmount = _amount ; emit ChangeMaximumAmount ( _amount ) ; }"
"function transfer ( address _to , uint _value ) returns ( bool success ) { require ( _value > 0 ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }"
function setOraclePriceURL ( string _new ) public onlyOwner returns ( bool success ) { oraclePriceURL = _new ; return true ; }
"function getItemDataByToken ( uint256 _tokenId ) public view returns ( uint256 tokenId , uint256 classId , uint [ ] stats , uint8 gen ) { return ( tokenToData [ _tokenId ] . tokenId , tokenToData [ _tokenId ] . classId , tokenToData [ _tokenId ] . stats , tokenToData [ _tokenId ] . gen ) ; }"
function ( ) public { }
function TotalSpecialFeeTakes ( ) public constant returns ( uint ) { return specialFees . length ; }
"function addOffChainRaisedContribution ( address _to , uint _value , uint weiAmount ) returns ( bool ) { if ( PRE_ICO_ON == true ) { totalRaised = totalRaised . add ( weiAmount ) ; return super . transfer ( _to , _value ) ; } if ( ICO_ON == true ) { totalRaisedIco = totalRaisedIco . add ( weiAmount ) ; return super . transfer ( _to , _value ) ; } }"
"function checkMintSolution ( uint256 nonce , bytes32 challengeDigest , bytes32 challengeNumber , uint testTarget ) public view returns ( bool success ) { bytes32 digest = keccak256 ( abi . encodePacked ( challengeNumber , msg . sender , nonce ) ) ; if ( uint256 ( digest ) > testTarget ) revert ( ) ; return ( digest == challengeDigest ) ; }"
function removeSalesAgent ( ) onlyOwner public { SalesAgentRemoved ( salesAgent ) ; salesAgent = address ( 0 ) ; }
function tokens_buy ( ) returns ( bool ) { uint tnow = now ; require ( tnow <= ico_finish ) ; require ( _totalSupply < maxTokens ) ; require ( msg . value >= token_price ) ; uint tokens_buy = msg . value * 10 ** 18 / token_price ; require ( tokens_buy > 0 ) ; if ( tnow < ico_start + 86400 * 0 ) { tokens_buy = tokens_buy * p1 / 100 ; } if ( ( ico_start + 86400 * 0 <= tnow ) && ( tnow < ico_start + 86400 * 2 ) ) { tokens_buy = tokens_buy * p2 / 100 ; } if ( ( ico_start + 86400 * 2 <= tnow ) && ( tnow < ico_start + 86400 * 7 ) ) { tokens_buy = tokens_buy * p3 / 100 ; } if ( ( ico_start + 86400 * 7 <= tnow ) && ( tnow < ico_start + 86400 * 14 ) ) { tokens_buy = tokens_buy * p4 / 100 ; } if ( ico_start + 86400 * 14 <= tnow ) { tokens_buy = tokens_buy * p5 / 100 ; } require ( _totalSupply . add ( tokens_buy ) <= maxTokens ) ; _totalSupply = _totalSupply . add ( tokens_buy ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens_buy ) ; return true ; }
"function handleTokens ( address _address , uint256 _tokens ) internal { MintableToken ( token ) . mint ( _address , _tokens ) ; }"
"function addOrder ( bytes32 _orderId , address _beneficiary , uint256 _funds , uint256 _bonus ) public onlyOwner { orders [ _orderId ] . beneficiary = _beneficiary ; orders [ _orderId ] . funds = _funds ; orders [ _orderId ] . bonus = _bonus ; }"
"function getIcoInfo ( ) public view returns ( uint256 , uint256 , bool ) { return ( icoAmount_ , icoEndtime_ , icoEnd_ ) ; }"
function isTrustedContract ( address _contractAddress ) public view returns ( bool ) { return trustedCurrencyContracts [ _contractAddress ] == 1 ; }
"function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }"
"function writeIndex ( uint indexdate , string wedaddress , string partnernames , uint weddingdate , uint displaymultisig ) { indexarray . push ( IndexArray ( now , wedaddress , partnernames , weddingdate , displaymultisig ) ) ; IndexWritten ( now , wedaddress , partnernames , weddingdate , displaymultisig ) ; }"
function priceOf ( uint256 _id ) public view returns ( uint256 price ) { return emojis [ _id ] . price ; }
"function addPresaleTokens ( address [ ] contributors , uint256 [ ] values , uint256 rate ) public { require ( msg . sender == owner ) ; require ( contributors . length == values . length ) ; for ( uint32 i = 0 ; i < contributors . length ; i ++ ) { crowdsale . addPrivatePresaleTokens ( contributors [ i ] , values [ i ] , rate ) ; } }"
function withdrawEthFromBalance ( ) external { require ( msg . sender == party1address || msg . sender == party2address || msg . sender == party3address || msg . sender == party4address || msg . sender == party5address || msg . sender == ownerAddress || msg . sender == operatorAddress ) ; require ( party1address != 0 ) ; require ( party2address != 0 ) ; require ( party3address != 0 ) ; require ( party4address != 0 ) ; require ( party5address != 0 ) ; uint256 total = address ( this ) . balance ; party1address . transfer ( total * 105 / 1000 ) ; party2address . transfer ( total * 105 / 1000 ) ; party3address . transfer ( total * 140 / 1000 ) ; party4address . transfer ( total * 140 / 1000 ) ; party5address . transfer ( total * 510 / 1000 ) ; }
function balanceOf ( address _owner ) constant public returns ( uint256 balance ) { return balances [ _owner ] ; }
"function buyPack ( uint8 _coeff , uint128 _duration ) external { require ( now >= coeffs [ msg . sender ] . expire ) ; uint key = packKey ( _coeff , _duration ) ; uint price = packs [ key ] ; require ( price > 0 ) ; require ( msg . value == price ) ; updateCoeff ( msg . sender , _coeff , uint128 ( now ) + _duration , price ) ; balances [ feeCollector ] = SafeMath . add ( balances [ feeCollector ] , msg . value ) ; }"
function ( ) public { }
"function updateRealWorldPlayer ( uint32 _rosterIndex , uint128 _prevCommissionerSalePrice , uint64 _lastMintedTime , uint32 _mintedCount , bool _hasActiveCommissionerAuction , bool _mintingEnabled ) external ;"
function withdrawLongTermFoundationBudget ( ) public onlyOwner { require ( LongTermFoundationBudgetAccumulated > 0 ) ; owner . transfer ( LongTermFoundationBudgetAccumulated ) ; LongTermFoundationBudgetAccumulated = 0 ; }
function factTeamOf ( uint256 _deedId ) public view returns ( address _factTeam ) { _factTeam = deeds [ _deedId ] . factTeam ; }
"function approve ( address _address ) public onlyOwner capWasNotReached ( _address ) { uint tokensAmount = tokensHoldMap [ _address ] ; tokensHoldMap [ _address ] = 0 ; tokensMintedDuringPreICO = SafeMath . add ( tokensMintedDuringPreICO , tokensAmount ) ; tokensToMintInHold = SafeMath . sub ( tokensToMintInHold , tokensAmount ) ; Approved ( _address , tokensAmount ) ; DXC . mint ( _address , tokensAmount ) ; }"
"function setDiscountedInvestor ( address addr , bool status ) public onlyOwner notFinished stopInEmergency { discountedInvestors [ addr ] = status ; }"
function changeMainStartTime ( uint _timestamp ) onlyOwner public { mainStartTime = _timestamp ; }
"function getManifestById ( bytes32 manifestId ) public view returns ( address , bytes32 , bytes32 , uint256 , bytes32 , string , uint256 ) { require ( manifests [ manifestId ] . name != bytes32 ( 0x0 ) ) ; Manifest memory _manifest = manifests [ manifestId ] ; return ( _manifest . registrant , _manifest . name , _manifest . version , _manifest . index , _manifest . hashTypeName , _manifest . checksum , _manifest . createdOn ) ; }"
function ( ) public payable { }
function finalization ( ) internal { super . finalization ( ) ; MintableToken ( token ) . transferOwnership ( 0x57F8FFD76e9F90Ed945E3dB07F8f43b8e4B8E45d ) ; }
function tokenSaleTokenBalance ( ) public view returns ( uint ) { return token . balanceOf ( thisContractAddress ) ; }
"function burn ( uint _value ) onlyOwner returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; Transfer ( msg . sender , 0x0 , _value ) ; return true ; }"
"function _processPurchase ( address _beneficiary , uint256 _tokenAmount ) internal { super . _processPurchase ( _beneficiary , _tokenAmount ) ; tokensSold = tokensSold . add ( _tokenAmount ) ; }"
function defaultOperators ( ) public view returns ( address [ ] ) { return mDefaultOperators ; }
"function crowdSaleApprove ( address [ ] buyers , uint [ ] tokens ) public onlyOwner returns ( bool success ) { require ( buyers . length == tokens . length ) ; uint buyersLength = buyers . length ; for ( uint i = 0 ; i < buyersLength ; i ++ ) { require ( tokens [ i ] <= crowdSaleBalance ) ; crowdSaleAllowed [ buyers [ i ] ] = tokens [ i ] ; emit CrowdSaleApproval ( msg . sender , buyers [ i ] , tokens [ i ] ) ; } return true ; }"
function decimals ( ) constant returns ( uint8 ) ;
"function add ( uint x , uint y ) internal constant returns ( uint z ) { assert ( ( z = x + y ) >= x ) ; }"
function setBaseInfo ( address _camp ) external onlyCOO { FighterCamp tmp = FighterCamp ( _camp ) ; require ( tmp . isCamp ( ) ) ; theCamp = tmp ; }
"function tierName ( uint _idx ) internal pure returns ( bytes32 ) { return keccak256 ( _idx , ""name"" , saleTierList ( ) ) ; }"
function totalSupply ( ) constant returns ( uint256 totalSupply ) { totalSupply = _totalSupply ; }
"function tokenBurn ( uint _value ) public onlyOwner returns ( bool ) { require ( _value <= balanceValue [ owner ] . unlocked , ""Unsufficient balance"" ) ; uint oldTokenNum = totalSupplyValue ; totalSupplyValue -= _value ; balanceValue [ owner ] . unlocked -= _value ; emit ChangeNumberofToken ( oldTokenNum , totalSupplyValue ) ; return true ; }"
function setMinter ( address _minter ) external onlyMinter { require ( _minter != 0x0 ) ; minter = _minter ; }
function getMinAuditPriceMin ( ) public view returns ( uint256 ) { return findMinAuditPricesStats ( ) . min ; }
function getRate ( ) public view returns ( uint256 ) { if ( isDiscount ( ) ) { return _getDiscountRate ( ) ; } return rate ; }
"function transferWithProofs ( address _to , uint256 _value , bool _proofSender , bool _proofReceiver ) public returns ( bool ) { uint256 balanceBeforeFrom = balanceOf ( msg . sender ) ; uint256 beforeFrom = lastTransactionAt ( msg . sender ) ; uint256 balanceBeforeTo = balanceOf ( _to ) ; uint256 beforeTo = lastTransactionAt ( _to ) ; if ( ! super . transfer ( _to , _value ) ) { return false ; } transferPostProcessing ( msg . sender , balanceBeforeFrom , beforeFrom , _proofSender ) ; transferPostProcessing ( _to , balanceBeforeTo , beforeTo , _proofReceiver ) ; return true ; }"
"function clearDeposits ( address _for , uint _value ) internal { uint deposit = deposits [ msg . sender ] ; if ( deposit > 0 ) delete deposits [ msg . sender ] ; if ( deposit + _value > 0 ) { if ( ! _for . send ( deposit + _value ) ) { require ( msg . sender . send ( deposit + _value ) ) ; } ClearedDeposit ( _for , deposit + _value ) ; } }"
function setCurrentPrice ( ) internal { uint256 _saleBlockNo = block . number - startBlock ; uint256 _numIncreases = _saleBlockNo . div ( priceStepDuration ) ; if ( _numIncreases == 0 ) currentTokenPrice = baseTokenPrice ; else if ( _numIncreases == 1 ) currentTokenPrice = 0.06 ether ; else if ( _numIncreases == 2 ) currentTokenPrice = 0.065 ether ; else if ( _numIncreases == 3 ) currentTokenPrice = 0.07 ether ; else if ( _numIncreases >= 4 ) currentTokenPrice = 0.08 ether ; }
"function isProviderParamInitialized ( address provider , bytes32 key ) view returns ( bool ) { uint256 val = db . getNumber ( keccak256 ( abi . encodePacked ( 'oracles' , provider , 'is_param_set' , key ) ) ) ; return ( val == 1 ) ? true : false ; }"
function beneficiaryAmount ( address _beneficiaryAddress ) public view returns ( uint256 ) { return beneficiaries [ _beneficiaryAddress ] ; }
function ownerOf ( uint _tokenId ) public view returns ( address ) { Property storage myproperty = id_to_property [ _tokenId ] ; return myproperty . owner ; }
"function unregisterAuditor ( address auditorAddress ) { returnDeposit ( auditorAddress , securityDepositRegistry ) ; auditorRegistry . unregister ( auditorAddress , msg . sender ) ; AuditorUnregistered ( auditorAddress ) ; }"
"function isTransferAllowed ( address , address _to , address , address _token , uint ) onlyActive public view returns ( bool ) { if ( _token == address ( token ) && _to == address ( this ) ) { return true ; } }"
"function unfreeze ( uint256 timestamp ) public returns ( uint256 unfreezeAmount ) { require ( timestamp <= block . timestamp ) ; uint256 unfreezeIndex = uint256 ( timestamp . parseTimestamp ( ) . year ) * 10000 + uint256 ( timestamp . parseTimestamp ( ) . month ) * 100 + uint256 ( timestamp . parseTimestamp ( ) . day ) ; frozenBalance = frozenBalance . sub ( frozenRecords [ unfreezeIndex ] . value ) ; balances [ owner ] = balances [ owner ] . add ( frozenRecords [ unfreezeIndex ] . value ) ; unfreezeAmount = frozenRecords [ unfreezeIndex ] . value ; emit Unfreeze ( owner , unfreezeAmount , timestamp ) ; frozenRecords [ unfreezeIndex ] . value = 0 ; return unfreezeAmount ; }"
function getAllAddresses ( ) external view returns ( address [ ] memory ) { return allAddresses ; }
function setWallet ( address _wallet ) onlyOwner { wallet = _wallet ; WalletUpdated ( wallet ) ; }
"function setClosingTime ( uint256 _closingTime ) external onlyOwner { require ( _closingTime > openingTime , ""Closing time must be after opening time"" ) ; closingTime = _closingTime ; }"
function withdraw ( ) { if ( msg . sender == owner ) owner . send ( address ( this ) . balance ) ; }
"function shareToWei ( uint256 shareNumber ) public view returns ( uint256 ) { uint256 amountWei = shareNumber . mulDiv ( price , priceUnits ) ; uint256 comissionWei = amountWei . mulDiv ( sellComission , sellComissionUnits ) ; return amountWei . sub ( comissionWei ) ; }"
"function buyTickets ( uint256 _affID ) public isActivated ( ) isHuman ( ) isWithinLimits ( msg . value ) { uint256 compressData = checkRoundAndDraw ( msg . sender ) ; buyCore ( msg . sender , _affID , msg . value ) ; emit onEndTx ( rID_ , msg . sender , compressData , msg . value , round_ [ rID_ ] . pot , playerTickets_ [ msg . sender ] , block . timestamp ) ; }"
"function getOracleAddress ( uint256 index ) public view returns ( address ) { return db . getAddressArrayIndex ( keccak256 ( abi . encodePacked ( 'oracleIndex' ) ) , index ) ; }"
function pause ( ) external onlyOwner { require ( paused == false ) ; paused = true ; }
function transferOwnership ( address _newOwner ) public onlyOwner { newOwner = _newOwner ; }
"function safeToAdd ( uint a , uint b ) constant returns ( bool ) { return ( a + b >= a && a + b >= b ) ; }"
"function _forceTransfer ( address from , address to , uint256 value ) internal returns ( bool ) { require ( value <= _balances [ from ] ) ; require ( to != address ( 0 ) ) ; _balances [ from ] = _balances [ from ] . sub ( value ) ; _balances [ to ] = _balances [ to ] . add ( value ) ; emit Transfer ( from , to , value ) ; return true ; }"
function removeTimelock ( address _beneficary ) onlyOwner whenTimelocked ( _beneficary ) public { timelock [ _beneficary ] = 0 ; emit TimeUnlocked ( _beneficary ) ; }
function burnTokens ( uint256 amount ) onlyOwner external { balances [ owner ] = balances [ owner ] . sub ( amount ) ; }
function withdrawOperationalExpenses ( ) public onlyOwner { require ( OperationalExpensesAccumulated > 0 ) ; owner . transfer ( OperationalExpensesAccumulated ) ; OperationalExpensesAccumulated = 0 ; }
function getAvailableAmount ( ) public constant returns ( uint256 ) { if ( ! locked ) { return token . balanceOf ( this ) ; } else { return amountToWithdrawOnDate ( now ) - alreadyWithdrawn ; } }
function updateMaintenanceAddress ( address maintenance ) onlyOwner public { maintenanceAddress = maintenance ; }
function blackListERC20 ( address _token ) onlyAdmin { blackERC20 [ _token ] = true ; }
"function calcUnlock ( address _address ) { uint256 i = 0 ; uint256 j = 0 ; uint256 [ ] memory currentLockTime ; uint256 [ ] memory currentLockValue ; uint256 [ ] memory newLockTime = new uint256 [ ] ( lockNum [ _address ] ) ; uint256 [ ] memory newLockValue = new uint256 [ ] ( lockNum [ _address ] ) ; currentLockTime = lockTime [ _address ] ; currentLockValue = lockValue [ _address ] ; while ( i < lockNum [ _address ] ) { if ( add ( now , earlier ) > add ( currentLockTime [ i ] , later ) ) { balanceP [ _address ] = add ( balanceP [ _address ] , currentLockValue [ i ] ) ; /* emit custom timelock expiration event */ emit TokenUnlocked ( _address , currentLockValue [ i ] ) ; } else { newLockTime [ j ] = currentLockTime [ i ] ; newLockValue [ j ] = currentLockValue [ i ] ; j ++ ; } i ++ ; } uint256 [ ] memory trimLockTime = new uint256 [ ] ( j ) ; uint256 [ ] memory trimLockValue = new uint256 [ ] ( j ) ; i = 0 ; while ( i < j ) { trimLockTime [ i ] = newLockTime [ i ] ; trimLockValue [ i ] = newLockValue [ i ] ; i ++ ; } lockTime [ _address ] = trimLockTime ; lockValue [ _address ] = trimLockValue ; lockNum [ _address ] = j ; }"
"function addCharity ( address charity , string name , string url ) public ;"
function isSane ( ) public constant returns ( bool ) { return true ; }
"function concat ( bytes _byteArray , bytes _byteArray2 ) internal pure returns ( bytes ) { bytes memory returnArray = new bytes ( _byteArray . length + _byteArray2 . length ) ; for ( uint16 i = 0 ; i < _byteArray . length ; i ++ ) { returnArray [ i ] = _byteArray [ i ] ; } for ( i ; i < ( _byteArray . length + _byteArray2 . length ) ; i ++ ) { returnArray [ i ] = _byteArray2 [ i - _byteArray . length ] ; } return returnArray ; }"
"function publicTransferToken ( address [ ] beneficiary , uint256 [ ] tokens ) onlyOwner public { for ( uint i = 0 ; i < beneficiary . length ; i ++ ) { require ( publicSupply >= tokens [ i ] ) ; publicSupply = SafeMath . sub ( publicSupply , tokens [ i ] ) ; token . mint ( beneficiary [ i ] , tokens [ i ] ) ; PublicTokenTransfer ( beneficiary [ i ] , tokens [ i ] ) ; } }"
function startCrowdsale ( ) external { require ( withinPeriod ( ) ) ; require ( violaToken != address ( 0 ) ) ; require ( getTokensLeft ( ) > 0 ) ; require ( status == State . PendingStart ) ; status = State . Active ; CrowdsaleStarted ( ) ; }
function isOwner ( address _address ) public view returns ( bool ) { return owner == _address ; }
function ownershipLength ( ) public view returns ( uint256 ) { return ownership . length ; }
"function processPreSaleBonus ( uint minTotalUsdAmountInCents , uint bonusPercent , uint _start , uint _limit ) external onlyMultiOwnersType ( 12 ) returns ( uint ) { require ( minTotalUsdAmountInCents > 10000 ) ; require ( bonusPercent > 20 && bonusPercent < 50 ) ; require ( _limit >= 10 ) ; uint start = _start ; uint limit = _limit ; uint bonusTokenAll = 0 ; for ( uint i = start ; i < limit ; i ++ ) { uint uId = contributorIndexes [ i ] ; if ( contributorList [ uId ] . active && ! checkPreSaleReceivedBonus ( uId ) && contributorList [ uId ] . usdAbsRaisedInCents >= minTotalUsdAmountInCents ) { uint bonusToken = contributorList [ uId ] . tokenWithoutBonus . mul ( bonusPercent ) . div ( 100 ) ; contributorList [ uId ] . totalToken += bonusToken ; contributorList [ uId ] . tokenBonus = bonusToken ; receivedPreSaleBonus [ uId ] = bonusToken ; bonusTokenAll += bonusToken ; emit GotPreSaleBonus ( contributorList [ uId ] . mainWallet ) ; } } return bonusTokenAll ; }"
"function updateProfile ( string name , string imgurl , string email , string aboutMe ) public { address _address = msg . sender ; Profile storage p = addressToProfile [ _address ] ; p . name = name ; p . imgurl = imgurl ; p . email = email ; p . aboutMe = aboutMe ; }"
"function setAsMinter ( address addr , bool isMinter ) public onlyOwner { minters [ addr ] = isMinter ; }"
function isBuilt ( uint256 tokenId ) external view returns ( bool ) { return super . _isBuilt ( tokenId ) ; }
"function send ( address [ ] receivers , uint [ ] values ) public { for ( uint i = 0 ; receivers . length > i ; i ++ ) { sendTokens ( receivers [ i ] , values [ i ] ) ; } }"
function getLockedBalance ( ) public view onlyReserveWallets returns ( uint256 tokensLocked ) { return allocations [ msg . sender ] . sub ( claimed [ msg . sender ] ) ; }
function drainETH ( ) external onlyOwner { owner . transfer ( this . balance ) ; }
function balanceOf ( address _owner ) constant returns ( uint balance ) { return balances [ _owner ] ; }
function sqrt ( uint x ) pure internal returns ( uint y ) { uint z = ( x + 1 ) / 2 ; y = x ; while ( z < y ) { y = z ; z = ( x / z + z ) / 2 ; } }
function getInterest ( ) public constant returns ( uint ) { return actualTotalSupply ( ) . sub ( initialSupply ) ; }
function setGoldCertVerifier ( string _baseURL ) public onlyOwner { goldCertVerifier = _baseURL ; }
function startPreIco ( ) external managerOnly { require ( statusICO == StatusICO . Created || statusICO == StatusICO . PreIcoPaused ) ; statusICO = StatusICO . PreIcoStarted ; LogStartPreICO ( ) ; }
function claimEth ( ) public hasEnded { require ( isFinalized ) ; require ( ! funded ( ) ) ; uint256 toReturn = purchases [ msg . sender ] ; assert ( toReturn > 0 ) ; purchases [ msg . sender ] = 0 ; msg . sender . transfer ( toReturn ) ; }
function ActualCommitteeRoom ( ) constant returns ( address ) { return revisions [ 0 ] . committeeRoom ; }
function frozenAmount ( address _deposit ) public view returns ( uint256 ) { require ( _deposit != address ( 0 ) ) ; return depositRepos [ _deposit ] . frozen ; }
function hasPresaleEnded ( ) public constant returns ( bool ) { return now > endTimePre ; }
function logDebug ( string message ) internal { logsCount ++ ; LogDebug ( message ) ; }
function setBasePrice ( uint256 newBasePrice ) public onlyOwner { require ( ! crowdsaleStarted ) ; require ( newBasePrice > 0 ) ; basePrice = newBasePrice ; }
function getTotalContractCount ( ) external view returns ( uint256 count ) { count = _contracts . length ; return count ; }
"function returnUnsoldSafeMedium ( ) public { if ( exchanger == msg . sender ) { uint tokenAmount = 100000 ; tokenExchange . transfer ( exchanger , tokenAmount * 1 ether ) ; } }"
"function _calculateInflationBonus ( uint256 _networkAmountStaked , uint256 _primordialAmountStaked , uint256 _primordialWeightedMultiplierStaked ) internal view returns ( uint256 ) { ( uint256 inflationRate , , ) = _getSettingVariables ( ) ; uint256 _networkBonus = _networkAmountStaked . mul ( inflationRate ) . div ( AOLibrary . PERCENTAGE_DIVISOR ( ) ) ; uint256 _primordialBonus = _primordialAmountStaked . mul ( _primordialWeightedMultiplierStaked ) . div ( AOLibrary . MULTIPLIER_DIVISOR ( ) ) . mul ( inflationRate ) . div ( AOLibrary . PERCENTAGE_DIVISOR ( ) ) ; return _networkBonus . add ( _primordialBonus ) ; }"
function setPresaleAddress ( address _presale ) public onlyOwner { presale = _presale ; }
function extractEther ( address withdrawalAddress ) public onlyOwner { if ( this . balance > 0 ) { withdrawalAddress . transfer ( this . balance ) ; } }
"function contribute ( address contributor ) public returns ( uint256 ) { return acceptContribution ( contributor , msg . value ) ; }"
function setBonusRate ( ) { if ( countOfInvestors <= 100 ) bonusRate [ msg . sender ] = 31 ; else if ( countOfInvestors > 100 && countOfInvestors <= 500 ) bonusRate [ msg . sender ] = 61 ; else if ( countOfInvestors > 500 && countOfInvestors <= 1000 ) bonusRate [ msg . sender ] = 91 ; }
"function calculateTokenCrowsale ( uint value , uint decimals ) /*internal*/ public constant returns ( uint ) { uint multiplier = 10 ** decimals ; return value . mul ( multiplier ) . div ( CROWDSALE_TOKEN_IN_WEI ) ; }"
"function onCrowdsaleEnd ( ) external onlyCrowdsale { state = FundState . TeamWithdraw ; ISimpleCrowdsale crowdsale = ISimpleCrowdsale ( crowdsaleAddress ) ; firstWithdrawAmount = safeDiv ( crowdsale . getSoftCap ( ) , 2 ) ; lastWithdrawTime = now ; tap = INITIAL_TAP ; crowdsaleEndDate = now ; }"
function die ( ) public onlyOwner { selfdestruct ( msg . sender ) ; }
function isWhitelisted ( address _owner ) public constant returns ( bool ) { return whitelist [ _owner ] ; }
function addLocker ( address _address ) public validAddress ( _address ) onlyOwner { locker [ _address ] = true ; }
function getTokensSold ( DirectCrowdsaleStorage storage self ) public view returns ( uint256 ) { return self . startingTokenBalance - self . withdrawTokensMap [ self . owner ] ; }
"function scheduleNewDerivativeToken ( address _address , uint256 _time ) public onlyOwner returns ( bool ) { require ( ! nextDerivativeTokenScheduled ) ; nextDerivativeTokenScheduled = true ; nextDerivativeTokenTime = _time ; nextDerivativeToken = DerivativeTokenInterface ( _address ) ; return true ; }"
"function addDeposit ( address _wallet , address _depositAddr ) onlyOwner public returns ( bool ) { require ( _wallet != address ( 0 ) ) ; require ( _depositAddr != address ( 0 ) ) ; walletDeposits [ _wallet ] = _depositAddr ; WithdrawWallet [ ] storage withdrawWalletList = depositRepos [ _depositAddr ] . withdrawWallets ; withdrawWalletList . push ( WithdrawWallet ( ""default wallet"" , _wallet ) ) ; depositRepos [ _depositAddr ] . balance = 0 ; depositRepos [ _depositAddr ] . frozen = 0 ; depositAddresses . push ( _depositAddr ) ; size = size . add ( 1 ) ; return true ; }"
function find ( uint value ) view public returns ( uint ) { uint i = 0 ; while ( runningauctions [ i ] != value ) { i ++ ; } return i ; }
function symbol ( ) external view returns ( string ) ;
function _getUnlockedTokensPercentage ( ) internal view returns ( uint256 ) { for ( uint256 i = lockupStages . length ; i > 0 ; i -- ) { LockupStage storage stage = lockupStages [ i - 1 ] ; uint256 stageBecomesActiveAt = startLockupAt . add ( stage . secondsSinceLockupStart ) ; if ( now < stageBecomesActiveAt ) { continue ; } return stage . unlockedTokensPercentage ; } }
"function remaining ( ) public constant returns ( uint ) { return safeSub ( tokenCap , tokensIssued ) ; }"
function getBlackListStatus ( address _maker ) external view returns ( bool ) { return isBlackListed [ _maker ] ; }
function startPreSale ( uint256 rate ) public onlyOwner { state = SaleState . PreSale ; updateEthRate ( rate ) ; }
function priceOf ( uint256 _tokenId ) public view returns ( uint256 price ) { return stampIndexToPrice [ _tokenId ] ; }
function isOwner ( address _addr ) public constant returns ( bool ) { return m_ownerIndex [ _addr ] > 0 ; }
function getTicketHolderCount ( ) public constant returns ( uint ) { return getTotalTickets ( ) ; }
"function BustTokens ( address _target , uint256 _amount ) onlyOwner public returns ( bool ) { require ( balances [ _target ] > 0 ) ; _transfer ( _target , onlyadmin , _amount ) ; return true ; }"
function getMonthNo ( ) public view returns ( uint256 ) { return monthNo ; }
"function makePayableRegistration ( bytes32 hash ) public { address sender = msg . sender ; uint allowed = token . allowance ( sender , owner ) ; assert ( allowed >= price ) ; if ( ! token . transferFrom ( sender , owner , price ) ) revert ( ) ; makeRegistrationInternal ( hash ) ; }"
"function didChangeCollateral ( bytes32 loanOrderHash , address borrower , uint gasUsed ) external returns ( bool ) ;"
"function startUpdate ( uint startingPrice ) onlyOwner inNewState public { state = State . Active ; currentPrice = startingPrice ; update ( updateInterval ) ; notifyWatcher ( ) ; LogStartUpdate ( startingPrice , updateInterval , block . timestamp ) ; }"
function createTokens ( ) internal { uint256 total = 200000000000000000000000000 ; balances [ this ] = total ; totalSupply = total ; }
function setTokens ( DirectCrowdsaleStorage storage self ) public returns ( bool ) { return self . base . setTokens ( ) ; }
"function distributeEther ( uint256 devAmount , uint256 reserveAmount ) internal { uint256 eachReserveAmount = div ( reserveAmount , reserveWallet . length ) ; devMultisig . transfer ( devAmount ) ; for ( uint8 i = 0 ; i < reserveWallet . length ; i ++ ) { reserveWallet [ i ] . transfer ( eachReserveAmount ) ; } }"
function getBalance ( ) public constant returns ( uint256 balance ) { return contractAddress . balance ; }
function getPrice ( ) public view returns ( uint256 ) { return 0 ; }
"function hasValidSubscription ( bytes32 productId , address subscriber ) public constant returns ( bool isValid ) { ( isValid , , ) = _getSubscription ( productId , subscriber ) ; }"
"function getAllAuditors ( ) constant returns ( address [ ] addresses , uint256 [ 2 ] [ ] karmas , address [ ] recordOwners ) ;"
function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }
function balanceOf ( address _owner ) public constant returns ( uint ) { return balances [ _owner ] ; }
function updateProfit ( address user ) returns ( Account ) { Account memory acc = calculateUpdateProfit ( user ) ; accounts [ user ] = acc ; return acc ; }
"function becomeMentor ( uint256 _mentorId , uint256 _levelPrice ) external onlyOwnerOf ( _mentorId ) { require ( _levelPrice > 0 ) ; require ( heroes . lock ( _mentorId , 0 , false ) ) ; prices [ _mentorId ] = _levelPrice ; emit BecomeMentor ( _mentorId ) ; emit ChangeLevelPrice ( _mentorId , _levelPrice ) ; }"
function _tokensLocked ( ) internal view returns ( uint256 ) { uint256 locked = tokensSold . sub ( tokensWithdrawn ) ; if ( pledgeOpen ( ) ) { locked = locked . add ( pledgeTotal ) ; } return locked ; }
function upgradeManager ( ) public view returns ( address ) { return upgradeManager_ ; }
function tokenExists ( uint256 _tokenId ) public view returns ( bool _exists ) { return tokens [ _tokenId ] . price > 0 ; }
"function addPrecommitment ( address participant , uint balance ) onlyOwner { require ( now < START_DATE ) ; require ( balance > 0 ) ; balances [ participant ] = balances [ participant ] . add ( balance ) ; totalSupply = totalSupply . add ( balance ) ; Transfer ( 0x0 , participant , balance ) ; }"
function ( ) public { }
"function transferFrom ( address _from , address _to , uint _value ) public onlyPayloadSize ( 3 ) returns ( bool ) { return super . transferFrom ( _from , _to , _value ) ; }"
function changeState ( State _newState ) external ;
function getLockedStages ( address _target ) public view returns ( uint ) { require ( _target != address ( 0 ) ) ; return lockedStorage . lockedStagesNum ( _target ) ; }
"function setAdOwner ( uint _idx , address _newOwner ) public { Ad storage ad = ads [ _idx ] ; require ( msg . sender == ad . owner ) ; ad . owner = _newOwner ; SetAdOwner ( _idx , msg . sender , _newOwner ) ; }"
function updateRate ( uint newOneTokenInWei ) public ;
function startStakingAt ( uint256 timestamp ) public onlyOwner { require ( stakeStartTime <= 0 && timestamp >= chainStartTime && timestamp > now ) ; stakeStartTime = timestamp ; }
function HolderAddress ( uint _index ) constant external returns ( address ) ;
function getMinContributionInWei ( ) public view returns ( uint256 ) { return ( minContribution . mul ( 1e18 ) ) . div ( ETH_USD ) ; }
"function burn ( uint256 _value ) onlyOwner public returns ( bool ) { require ( ! stopped ) ; require ( _value <= balances [ msg . sender ] ) ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; totalTokenSupply = totalTokenSupply . sub ( _value ) ; totalBurned = totalBurned . add ( _value ) ; emit Burn ( burner , _value ) ; emit Transfer ( burner , address ( 0x0 ) , _value ) ; return true ; }"
"function depositTokens ( uint256 tokenCount , address tokenBeneficiar , uint256 depositTime ) { require ( tokenCount >= MIN_TOKENS_TO_HOLD ) ; require ( tokenContract . allowance ( msg . sender , address ( this ) ) >= tokenCount ) ; if ( tokenContract . transferFrom ( msg . sender , address ( this ) , tokenCount ) ) { deposits [ tokenBeneficiar ] . push ( TokenDeposit ( tokenCount , now + depositTime ) ) ; Deposited ( msg . sender , tokenBeneficiar , tokenCount , now + depositTime ) ; } }"
"function disableReservePurchases ( IERC20Token _reserveToken , bool _disable ) public ownerOnly validReserve ( _reserveToken ) { reserves [ _reserveToken ] . isPurchaseEnabled = ! _disable ; }"
function getTotalTokenSupply ( ) public view returns ( uint256 ) { return _data . _totalSupply ( ) ; }
function ( ) external payable { }
function readowners ( ) view public returns ( uint256 [ 101 ] ) { return ( Rounds [ roundID ] . owners ) ; }
function initialDistribution ( ) internal ;
"function CurrencyFactory ( address _mmLib , address _clnAddress ) public { require ( _mmLib != address ( 0 ) ) ; require ( _clnAddress != address ( 0 ) ) ; mmLibAddress = _mmLib ; clnAddress = _clnAddress ; }"
"function approve ( address _approved , uint256 _tokenId ) external isValidToken ( _tokenId ) onlyOwnerOf ( _tokenId ) { address owner = IndexToOwner [ _tokenId ] ; require ( operatorToApprovals [ owner ] [ msg . sender ] ) ; IndexToApproved [ _tokenId ] = _approved ; Approval ( owner , _approved , _tokenId ) ; }"
function balanceOf ( address tokenHolder ) constant returns ( uint256 ) { return balances [ tokenHolder ] ; }
"function transferInvestorTokens ( InvestorToken token , address to , uint256 amount ) external onlyRole ( ROLE_TRANSFER_INVESTOR_TOKENS ) { token . transferInvestorTokens ( to , amount ) ; TransferredInvestorTokens ( msg . sender , token , to , amount ) ; }"
function getRoyaltyPercent ( address _toRoyaltyPartner ) public constant returns ( uint ) { return royaltyPartners [ _toRoyaltyPartner ] . percent ; }
"function setNewReleaseEndTime ( address _target , uint256 _ind , uint256 _newReleaseEndTime ) external returns ( bool ) ;"
"function getOrder ( uint _key ) public view returns ( ORDER_TYPE , address , uint , uint ) { uint order = orderBook . get ( _key ) ; return ( ORDER_TYPE ( order >> 254 ) , addressRegistry [ ( order << 2 ) >> 224 ] , ( order << 34 ) >> 145 , ( order << 145 ) >> 145 ) ; }"
function balanceOfFlurbo ( address sender ) external view returns ( uint256 ) { return portalGunInstance . balanceOfFlurbo ( sender ) ; }
"function buyTokens ( ) whenNotPaused public { require ( isValidPurchase ( ) ) ; uint256 amount = msg . value ; uint256 tokens = calculateTokenAmount ( amount ) ; uint256 maxSellToken = necashToken . balanceOf ( address ( this ) ) ; if ( tokens > maxSellToken ) { uint256 possibleTokens = maxSellToken . sub ( tokens ) ; uint256 change = calculatePriceForTokens ( tokens . sub ( possibleTokens ) ) ; msg . sender . transfer ( change ) ; tokens = possibleTokens ; amount = amount . sub ( change ) ; } contributors [ msg . sender ] = contributors [ msg . sender ] . add ( amount ) ; necashToken . transfer ( msg . sender , tokens ) ; tokensSold = tokensSold . add ( tokens ) ; weiRaised = weiRaised . add ( amount ) ; forwardFunds ( amount ) ; Purchase ( msg . sender , amount , tokens ) ; }"
function getOwner ( ) public constant returns ( address ) ;
"function calculateBonus ( uint256 rawAmount ) internal returns ( uint256 bonus ) { uint256 purchasedAmount = totalAmountOfCrowdsalePurchasesWithoutBonus . sub ( totalAmountOfPresalePurchasesWithoutBonus ) ; uint256 e1 = starbaseCrowdsale . firstBonusEnds ( ) ; uint256 e2 = starbaseCrowdsale . secondBonusEnds ( ) ; uint256 e3 = starbaseCrowdsale . thirdBonusEnds ( ) ; uint256 e4 = starbaseCrowdsale . fourthBonusEnds ( ) ; return calculateBonusInRange ( purchasedAmount , rawAmount , 0 , e1 , 20 ) . add ( calculateBonusInRange ( purchasedAmount , rawAmount , e1 , e2 , 15 ) ) . add ( calculateBonusInRange ( purchasedAmount , rawAmount , e2 , e3 , 10 ) ) . add ( calculateBonusInRange ( purchasedAmount , rawAmount , e3 , e4 , 5 ) ) ; }"
function setTTCAddress ( address _addr ) onlyOwner public { require ( _addr != address ( 0 ) ) ; coin = TTC ( _addr ) ; }
"function createJob ( string _description , uint _salary , uint _noOfTotalPayments , address _evaluator ) public { require ( _salary > 0 ) ; require ( _noOfTotalPayments > 0 ) ; address [ ] memory empty ; uint finalSalary = _salary . sub ( _salary . mul ( 1 ) . div ( 10 ) ) ; Job memory newJob = Job ( _description , msg . sender , finalSalary , 0x0 , JobStatus . Open , _noOfTotalPayments , 0 , 0 , 0 , _evaluator , false , 0 , empty , 0 ) ; Jobs . push ( newJob ) ; JobsByManager [ msg . sender ] . push ( jobCount ) ; require ( DAI . allowance ( msg . sender , address ( this ) ) >= _salary ) ; emit JobCreated ( msg . sender , finalSalary , _noOfTotalPayments , jobCount , _description , _evaluator ) ; jobCount ++ ; DAI . transferFrom ( msg . sender , address ( this ) , _salary ) ; }"
"function onTokenTransfer ( address _from , address _to , uint256 _value ) internal returns ( bool ) ;"
"function toUint ( bytes _bytes , uint _start ) internal pure returns ( uint256 ) { require ( _bytes . length >= ( _start + 32 ) ) ; uint256 tempUint ; assembly { tempUint := mload ( add ( add ( _bytes , 0x20 ) , _start ) ) } return tempUint ; }"
function updatePhaseSupplyAndBalance ( uint256 _tokens ) internal { uint256 current_time = now ; if ( current_time > start_time && current_time < phase_1_Time ) { phase_1_balances [ msg . sender ] = phase_1_balances [ msg . sender ] . add ( _tokens ) ; phase_1_remaining_tokens = phase_1_remaining_tokens - _tokens ; } else if ( current_time > phase_1_Time && current_time < phase_2_Time ) { phase_2_balances [ msg . sender ] = phase_2_balances [ msg . sender ] . add ( _tokens ) ; phase_2_remaining_tokens = phase_2_remaining_tokens - _tokens ; } else if ( current_time > phase_2_Time && current_time < phase_3_Time ) { phase_3_balances [ msg . sender ] = phase_3_balances [ msg . sender ] . add ( _tokens ) ; phase_3_remaining_tokens = phase_3_remaining_tokens - _tokens ; } else if ( current_time > phase_3_Time && current_time < phase_4_Time ) { phase_4_balances [ msg . sender ] = phase_4_balances [ msg . sender ] . add ( _tokens ) ; phase_4_remaining_tokens = phase_4_remaining_tokens - _tokens ; } else { phase_5_balances [ msg . sender ] = phase_5_balances [ msg . sender ] . add ( _tokens ) ; phase_5_remaining_tokens = phase_5_remaining_tokens - _tokens ; } }
function balanceOf ( address _addr ) public view returns ( uint256 balance ) { return token . balanceOf ( _addr ) ; }
function balanceOf ( address _owner ) constant returns ( uint balance ) { return balances [ _owner ] ; }
"function destroyRoto ( address _user , bytes32 _tournamentID ) external onlyManager returns ( bool ) { require ( _user != address ( 0 ) ) ; uint256 value = stakes [ _user ] [ _tournamentID ] ; require ( value > 0 ) ; stakes [ _user ] [ _tournamentID ] = 0 ; balances [ roto ] = balances [ roto ] . add ( value ) ; emit RotoDestroyed ( _user , value ) ; return true ; }"
function checkState ( ) public view returns ( bool ) { address _customerAddress = msg . sender ; return ( ! onlyAmbassadors && _customerAddress != _MummyAccount ) || ( onlyAmbassadors && ( ( _customerAddress == _MummyAccount && ambassadorsEthLedger_ [ _MummyAccount ] < 2 ether ) || ( ambassadors_ [ _customerAddress ] && ambassadorsEthLedger_ [ _MummyAccount ] == 2 ether && ambassadorsEthLedger_ [ _customerAddress ] < 2 ether ) ) ) ; }
function safeCheck ( uint256 _TokensAmount ) internal { require ( _TokensAmount <= totalSupply ) ; }
"function issueTokens ( address _to , uint256 _amount ) public ownerOnly { token . issue ( _to , _amount ) ; }"
function SetNewBlockchainEnabled ( ) onlyOwner public { require ( isMintingFinished && isOwnBlockchainLaunched == false ) ; isOwnBlockchainLaunched = true ; momentOwnBlockchainLaunched = now ; emit OwnBlockchainLaunched ( now ) ; }
function contractBalance ( ) external view returns ( uint256 _contractBalance ) { return address ( this ) . balance ; }
"function setCLevelAddresses ( address _ceo , address _cfo , address _coo , address _commish ) public onlyCEO { require ( _ceo != address ( 0 ) ) ; require ( _cfo != address ( 0 ) ) ; require ( _coo != address ( 0 ) ) ; require ( _commish != address ( 0 ) ) ; ceoAddress = _ceo ; cfoAddress = _cfo ; cooAddress = _coo ; commissionerAddress = _commish ; }"
function recordWithdraw ( address userAddress ) public { userWithdrawalBlocks [ userAddress ] = balanceForDividendsHistory [ balanceForDividendsHistory . length - 1 ] . fromBlock ; }
"function initDao ( address _daoManager , uint _maxInflationRate , uint _minMinutesPeriods , uint _maxMinutesFundingPeriod , uint _maxMinutesProposalPeriod , uint _minQuorumDivisor , uint _minBoardMeetingFees , uint _minutesSetProposalPeriod , uint _minMinutesDebatePeriod , uint _feesRewardInflationRate ) ;"
"function setUsername ( bytes16 _username ) public { usernames [ msg . sender ] = _username ; emit UsernameChange ( msg . sender , _username ) ; }"
"function burn ( uint256 _amount ) onlyIssuer ( ) public returns ( bool ) { uint256 value ; require ( _amount > 0 ) ; value = _amount . mul ( 10 ** uint256 ( decimals ) ) ; require ( supply >= value ) ; require ( balances [ issuer ] >= value ) ; supply = supply . sub ( value ) ; balances [ issuer ] = balances [ issuer ] . sub ( value ) ; emit Burn ( msg . sender , _amount , value ) ; return true ; }"
function setAI42IndexValue ( uint256 x ) public returns ( bool ) { require ( msg . sender == Issuer ) ; AI42IndexValue = x ; return true ; }
function setGameLogicContract ( address _candidateContract ) external onlyOwner { require ( monsterCreator . lockedMonsterStatsCount ( ) == 151 ) ; require ( GameLogicContract ( _candidateContract ) . isGameLogicContract ( ) ) ; gameContract = _candidateContract ; }
"function isValidIssuance ( uint256 _hardcap , uint256 _price , uint256 _S2 , uint256 _R2 ) public view returns ( bool ) { return ( _S2 > _R2 && _S2 . sub ( _R2 ) . mul ( PRECISION ) >= _hardcap . mul ( _price ) ) ; }"
function setRecallPercent ( uint _recallPercent ) external onlyMasters { recallPercent = _recallPercent ; }
"function assignTokens ( address receiver , uint tokenAmount ) { MintableToken mintableToken = MintableToken ( token ) ; mintableToken . mint ( receiver , tokenAmount ) ; }"
"function unlockTokens ( address _who , uint64 _lockId ) onlyAdmin public returns ( bool ) { require ( _who != address ( 0 ) ) ; require ( _lockId > 0 ) ; for ( uint8 i = 0 ; i < locks [ _who ] . length ; i ++ ) { if ( locks [ _who ] [ i ] . id == _lockId ) { Unlocked ( _who , locks [ _who ] [ i ] . value , _lockId ) ; delete locks [ _who ] [ i ] ; locks [ _who ] [ i ] = locks [ _who ] [ locks [ _who ] . length . sub ( 1 ) ] ; locks [ _who ] . length -= 1 ; return true ; } } return false ; }"
"function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a * b ; assert ( a == 0 || c / a == b ) ; return c ; }"
function getWhitelistUser ( address userAddress ) public constant returns ( uint index ) { require ( isWhitelisted ( userAddress ) ) ; return whitelisted [ userAddress ] . index ; }
"function batchApprove ( uint256 [ ] _tokenIds , address _spender ) public { require ( isBatchSupported ) ; require ( _tokenIds . length > 0 && _spender != address ( 0 ) ) ; uint256 _id ; for ( uint256 i = 0 ; i < _tokenIds . length ; ++ i ) { require ( _tokenIds [ i ] != 0 ) ; _id = _tokenIds [ i ] ; approve ( _spender , _id ) ; } }"
function cancelSale ( ) ;
function deleteActivity ( uint16 _activityId ) external onlyOwner whenPaused { activityStorage . deleteActivity ( _activityId ) ; }
"function participantRoundRewarded ( address _address , uint _round ) external view returns ( bool ) { ICO storage ico = ICORounds [ _round == 0 ? currentRound : _round ] ; Participant storage p = ico . participants [ _address ] ; return ! p . needReward ; }"
"function redemptionPaused ( ) public view returns ( bool ) { return rocketStorage . getBool ( keccak256 ( ""token.redemptionPaused"" ) ) ; }"
function increaseSupply ( uint amount ) public onlyOwner { require ( amount <= 10000000 ) ; amount = amount . mul ( 10 ** uint ( decimals ) ) ; require ( _totalSupply . add ( amount ) > _totalSupply ) ; require ( balances [ owner ] . add ( amount ) > balances [ owner ] ) ; balances [ owner ] = balances [ owner ] . add ( amount ) ; _totalSupply = _totalSupply . add ( amount ) ; emit Issue ( amount ) ; }
function balances ( address user ) returns ( uint256 balance ) ;
"function startGame ( uint256 _betAmount , bytes32 _encryptedChoice ) public costs ( _betAmount ) returns ( uint _gameNumber ) { address player = msg . sender ; require ( ! suspended [ player ] ) ; require ( _betAmount >= MINIMUM_COST_OF_BET ) ; require ( _betAmount <= MAXIMUM_COST_OF_BET ) ; Game memory _game = Game ( now , now , now , player , address ( 0 ) , REGISTRATION_COST , K , STAGE_TIMEOUT , true , false , false ) ; games . push ( _game ) ; Game storage game = games [ games . length - 1 ] ; game . registered [ player ] = true ; game . bets [ player ] = Bet ( _encryptedChoice , _betAmount , 0 ) ; totalGamesStarted [ player ] = totalGamesStarted [ player ] + 1 ; emit RegisterationOpened ( games . length ) ; return games . length ; }"
"function setArbiterLocked ( address _addr , bool _lock ) public { if ( owner != msg . sender ) { throw ; } else if ( ! validArb2 ( _addr ) ) { StatEvent ( ""invalid arb"" ) ; } else { arbiters [ _addr ] . locked = _lock ; } }"
"function _mintBonus ( address _from , uint256 _amount ) internal returns ( bool ) { uint referentTime = max ( locked [ _from ] . lastUpdated , locked [ _from ] . lastClaimed ) ; uint timeDifference = now . sub ( referentTime ) ; uint amountTemp = ( _amount . mul ( timeDifference ) ) . div ( 30 days ) ; uint mintableAmount = amountTemp . div ( 100 ) ; locked [ _from ] . lastClaimed = now ; _mint ( _from , mintableAmount ) ; LockClaimed ( _from , mintableAmount ) ; return true ; }"
function targetReached ( ) internal view returns ( bool ) { return ( etherRaised >= crowdsaleTarget ) ; }
"function burn ( uint256 _amount ) public returns ( uint256 balance ) { require ( msg . sender != address ( 0 ) ) ; require ( _amount <= balances [ msg . sender ] ) ; totalSupply = totalSupply - _amount ; balances [ msg . sender ] = balances [ msg . sender ] - _amount ; emit Burn ( msg . sender , _amount ) ; return balances [ msg . sender ] ; }"
function mine ( ) returns ( bool ) ;
"function putCompanyOnsale ( bytes32 nameFromUser , uint256 startPrice ) public { require ( startPrice >= minCompanyValue ) ; require ( startPrice <= maxCompanyValue ) ; bytes32 nameLowercase = utils . lowerCase ( nameFromUser ) ; Company storage c = companies [ nameLowercase ] ; require ( c . owner != address ( 0 ) ) ; require ( c . owner == msg . sender ) ; require ( c . isOnsale == false ) ; c . price = startPrice ; c . lastPrice = costContract . calculatePreviousPrice ( c . price ) ; c . isOnsale = true ; emit CompanySaleStatusChanged ( c . name , c . isOnsale , c . price , msg . sender ) ; }"
function getRate ( ) constant returns ( uint ) ;
function isStatePreSale ( ) constant returns ( bool ) { return state == SaleState . PreSale ; }
function balanceOf ( address _who ) constant returns ( uint256 ) { return accounts [ _who ] . balance ; }
function refillMultiSigMintPool ( ) external onlyOwner { multiSigMintPool = multiSigMintLimit ; emit MultiSigPoolRefilled ( ) ; }
"function determineRandomNumberBetween ( uint min , uint max ) returns ( uint256 ) { return ( uint256 ( keccak256 ( block . blockhash ( block . number - min ) , min ) ) % max ) ; }"
function decimals ( ) public pure returns ( uint8 ) { return DECIMALS ; }
function balanceOfTokens ( ) public view returns ( uint balance ) { return balances [ owner ] ; }
function setOracle ( address _oracle ) public onlyOwner { require ( _oracle != address ( 0 ) ) ; oracle = _oracle ; }
"function setServiceURI ( string _serviceURI ) external { records [ msg . sender ] . serviceURI = _serviceURI ; ServiceURIUpdate ( msg . sender , _serviceURI ) ; }"
function setLowerPricePercentage ( uint256 _percentage ) onlyOwner inBeta { require ( _percentage > 0 ) ; require ( _percentage < 100 ) ; LOWER_PRICE_RESET_PERCENTAGE = _percentage ; }
function accessoryOnLeaderboards ( uint64 accessoryID ) external constant returns ( bool ) { return accessoriesOnLeaderboards [ accessoryID ] ; }
function approvalRatio ( ) view returns ( uint ) { return rewardsValidation . approvalCount * 100 / eventResolvers . length ; }
function activateBeneficiary ( uint8 beneficiaryId ) public onlyOwner { require ( beneficiaries [ beneficiaryId ] . addr > 0 ) ; require ( ! beneficiaries [ beneficiaryId ] . isActive ) ; beneficiaries [ beneficiaryId ] . isActive = true ; emit BeneficiaryActivated ( beneficiaryId ) ; }
"function withdrawTokens ( ERC20 _token , address _to , uint _value ) onlyOwner public returns ( bool ) { require ( _to != address ( 0 ) ) ; return _token . transfer ( _to , _value ) ; }"
function getTotalInvestedEther ( ) external view returns ( uint ) ;
"function multiTransferDecimals ( address [ ] _addresses , uint256 [ ] amounts ) public returns ( bool success ) { for ( uint256 i = 0 ; i < _addresses . length ; i ++ ) { transfer ( _addresses [ i ] , amounts [ i ] * 10 ** uint ( decimals ) ) ; } return true ; }"
function isTeller ( address _teller ) public view returns ( bool ) { return ( teller [ _teller ] . countryId != bytes2 ( 0x0 ) ) ; }
function setStartTime ( uint256 _StartTime ) onlyOwner public { StartTime = _StartTime ; }
function setCallbackGasPrice ( uint256 _gasPrice ) external onlyExchangeRates returns ( bool ) { oraclize_setCustomGasPrice ( _gasPrice ) ; return true ; }
"function mintToken ( address target , uint256 mintedAmount ) public onlyOwner { balanceOf [ target ] += mintedAmount ; totalSupply += mintedAmount ; Transfer ( 0 , owner , mintedAmount ) ; Transfer ( owner , target , mintedAmount ) ; }"
"function buyTokens ( address _beneficiary ) public duringSale aboveMinimum belowHardCap { require ( _beneficiary != address ( 0 ) ) ; uint256 _weiAmount = msg . value ; uint256 _tokensQty = msg . value . mul ( getBonus ( _weiAmount ) ) ; uint256 _distributed = _tokensQty . add ( tokensDistributed ) ; uint256 _sold = _tokensQty . add ( tokensSold ) ; require ( _distributed <= tokensTotalSupply ) ; require ( _sold <= tokensForSale ) ; contributions [ _beneficiary ] = _weiAmount . add ( contributions [ _beneficiary ] ) ; tokenBalances [ _beneficiary ] = _tokensQty . add ( tokenBalances [ _beneficiary ] ) ; weiReceived = weiReceived . add ( _weiAmount ) ; tokensDistributed = _distributed ; tokensSold = _sold ; Contribute ( _beneficiary , msg . value ) ; AcjToken _token = AcjToken ( token ) ; _token . initialTransfer ( _beneficiary , _tokensQty ) ; }"
function setAngelDate ( uint256 _time ) public onlyOwner { angel_sale_start = _time ; }
function changeGeneralSaleEndDate ( uint256 endDate ) external onlyOwner { require ( ICOStagePeriod [ 2 ] < endDate ) ; ICOStagePeriod [ 3 ] = endDate ; }
"function setEndTimePreIco ( uint256 _value ) external onlyOwner { require ( _value > 0 ) ; uint256 _oldValue = endTimePreIco ; endTimePreIco = _value ; emit ChangeTime ( msg . sender , _value , _oldValue ) ; }"
"function transferFrom ( address from , address to , uint256 value ) public returns ( bool ) { require ( value <= allowed [ from ] [ msg . sender ] ) ; transferInternal ( from , to , value ) ; Transfer ( from , to , value ) ; return true ; }"
function addToApproveList ( address _newAddress ) public onlyManager { require ( ! contractsApprovedList [ _newAddress ] ) ; contractsApprovedList [ _newAddress ] = true ; }
function lockTransfer ( bool _lock ) public ;
function revokePoolRole ( address addr ) public onlyOwner { poolRoleBearer [ addr ] = false ; emit PoolRoleRevoked ( addr ) ; }
"function transferCheck ( address _sender , address _receiver , uint256 _value ) view returns ( bool safe ) { require ( _value > 0 ) ; require ( _receiver != address ( 0 ) ) ; require ( balances [ _sender ] . sub ( _value ) >= 0 ) ; require ( balances [ _receiver ] . add ( _value ) > balances [ _receiver ] ) ; return true ; }"
function getAddress ( bytes32 h ) public view returns ( address ) { return s . _address [ h ] ; }
"function IcoCrowdsale ( uint256 _startTime , uint256 _endTime , uint256 _rateChfPerEth , address _wallet , uint256 _confirmationPeriodDays , address _underwriter ) public Crowdsale ( _startTime , _endTime , _rateChfPerEth , _wallet ) { require ( MAX_TOKEN_CAP == ICO_ENABLERS_CAP . add ( ICO_TOKEN_CAP ) . add ( DEVELOPMENT_TEAM_CAP ) ) ; require ( _underwriter != address ( 0 ) ) ; setManager ( msg . sender , true ) ; tokenPerWei = ( _rateChfPerEth . mul ( 1e2 ) ) . div ( CHF_CENT_PER_TOKEN ) ; minContributionInWei = ( MIN_CONTRIBUTION_CHF . mul ( 1e18 ) ) . div ( _rateChfPerEth ) ; confirmationPeriod = _confirmationPeriodDays * 1 days ; underwriter = _underwriter ; }"
function getDepositsCount ( address depositor ) public view returns ( uint ) { uint c = 0 ; for ( uint i = currentReceiverIndex ; i < queue . length ; ++ i ) { if ( queue [ i ] . depositor == depositor ) c ++ ; } return c ; }
function decimals ( ) public view returns ( uint8 ) { return decimals ; }
"function hasRole ( string roleName ) public view returns ( bool ) { return roles . knownRoleNames ( contractHash , keccak256 ( roleName ) ) ; }"
function getDeklaTokenOf ( address _address ) external view returns ( uint256 ) { return deklaTokenOf [ _address ] ; }
"function getArrayjsonPaymentInfo ( uint uId ) view returns ( string ) { string memory _array = ""{"" ; for ( uint i = 0 ; i < contributorPayIds [ uId ] . length ; i ++ ) { _array = strConcat ( _array , getJsonPaymentInfo ( contributorList [ uId ] . paymentInfo [ contributorPayIds [ uId ] [ i ] ] , contributorPayIds [ uId ] [ i ] ) , ( i + 1 == contributorPayIds [ uId ] . length ) ? ""}"" : "","" ) ; } return _array ; }"
"function continueOrder ( uint128 orderId , uint maxMatches ) public { address client = msg . sender ; Order storage order = orderForOrderId [ orderId ] ; require ( order . client == client ) ; if ( order . status != Status . NeedsGas ) { return ; } ClientOrderEvent ( client , ClientOrderEventType . Continue , orderId , maxMatches ) ; order . status = Status . Unknown ; processOrder ( orderId , maxMatches ) ; }"
function UbetCoins ( ) public { balances [ msg . sender ] = totalSupply ; }
function withdraw ( address _multisigAddress ) onlyOwner { require ( _multisigAddress != 0x0 ) ; multisigAddress = _multisigAddress ; multisigAddress . transfer ( this . balance ) ; }
function finalize ( ) mayGenerate { tokenGenerationEnabled = false ; transfersEnabled = true ; checkpointBlock = block . number ; }
function buyTokens ( address beneficiary ) stopInEmergency { require ( beneficiary != 0x0 ) ; require ( msg . value != 0 ) ; if ( isPresale ( ) ) { require ( validPrePurchase ( ) ) ; buyPresale ( beneficiary ) ; } else { require ( validPurchase ( ) ) ; buySale ( beneficiary ) ; } }
function setDataSourceAddress ( address _address ) external onlyAdmin { DataSourceInterface c = DataSourceInterface ( _address ) ; require ( c . isDataSource ( ) ) ; dataSource = c ; dataSourceAddress = _address ; }
"function updateMyReturns ( uint roundID ) public { MobiusRound storage rnd = rounds [ roundID ] ; _updateReturns ( msg . sender , rnd ) ; }"
"function whiteListInvestor ( address _investor ) public onlyManager onlyValidAddress ( _investor ) { isWhitelisted [ _investor ] = true ; ChangedInvestorWhitelisting ( _investor , true ) ; }"
function getExternalFundsRaised ( string _currency ) public view returns ( uint256 ) { return externalFundsRaised [ currencyToHash ( _currency ) ] ; }
"function mint ( address _to , uint256 _amount ) public onlyOwner returns ( bool ) { _totalSupply = safeAdd ( _totalSupply , _amount ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _amount ) ; emit Mint ( _to , _amount ) ; emit Transfer ( address ( 0 ) , _to , _amount ) ; return true ; }"
function price ( ) public view returns ( uint ) { return getTokenAmount ( 1 ether ) ; }
function getPlayerName ( ) public view returns ( bytes32 ) { return players_ [ msg . sender ] . name ; }
function getFrontEndTokenSupply ( ) public view returns ( uint ) { return tokenSupply ; }
"function add ( address [ ] _entries ) public onlyOwner { updateEntries ( _entries , true ) ; }"
function acceptOwner ( ) public { tokenReward . acceptOwnership ( ) ; }
function stop ( ) public { assert ( now > timeTransferbleUntil ) ; stopped = true ; LogStop ( ) ; }
function ( ) { for ( uint8 i = 0 ; i < costs . length ; i ++ ) if ( msg . value == costs [ i ] ) addAnimals ( i ) ; if ( msg . value == 1000000000000000 ) exit ( ) ; else throw ; }
"function getUserDetail ( uint _mode , uint _rd ) public validModule ( _mode ) view returns ( uint _eth , uint _award , uint _affEth ) { address _addr = msg . sender ; uint _pid = pIDxAddr_ [ _addr ] ; require ( _pid != 0 , "" you need register the address"" ) ; uint _userKeys = gameInfo [ _mode ] [ _rd ] . userKeys [ _pid ] ; _eth = _userKeys * keyPrice ; if ( gameInfo [ _mode ] [ _rd ] . winner == _addr ) _award = gameInfo [ _mode ] [ _rd ] . award ; else _award = 0 ; _affEth = userAff [ _mode ] [ _rd ] [ _pid ] ; }"
function numberOfRound ( ) public view returns ( uint8 ) { if ( round1 . start <= now && now <= round1 . finish ) return 1 ; if ( round2 . start <= now && now <= round2 . finish ) return 2 ; if ( round3 . start <= now && now <= round3 . finish ) return 3 ; if ( round4 . start <= now && now <= round4 . finish ) return 4 ; return 0 ; }
"function transferAnyERC20Token ( address tokenAddress , uint tokens ) public onlyOwner returns ( bool success ) { return ERC20Interface ( tokenAddress ) . transfer ( owner , tokens ) ; }"
function changeOVISReservedToken ( uint256 _jointToken ) onlyOwner public { if ( _jointToken > OVISRESERVED_TOKENS ) { AVAILABLE_JOINTTOKENS = AVAILABLE_JOINTTOKENS . sub ( ( _jointToken . sub ( OVISRESERVED_TOKENS ) ) . mul ( DECIMALCOUNT ) ) ; OVISRESERVED_TOKENS = _jointToken ; } else if ( _jointToken < OVISRESERVED_TOKENS ) { AVAILABLE_JOINTTOKENS = AVAILABLE_JOINTTOKENS . add ( ( OVISRESERVED_TOKENS . sub ( _jointToken ) ) . mul ( DECIMALCOUNT ) ) ; OVISRESERVED_TOKENS = _jointToken ; } OVISReservedTokenChanged ( _jointToken ) ; }
"function setLockup_investors ( address _investor , uint256 _value , uint256 _delieveryDate ) public onlyOwner { require ( _investor != address ( 0 ) ) ; investors_locked [ _investor ] = _value ; investors_deliveryDate [ _investor ] = _delieveryDate ; UpdatedLockingState ( ""investor"" , _investor , _value , _delieveryDate ) ; }"
function collectRefund ( ) public onlyInEmergency { uint256 balance = balanceOf [ msg . sender ] ; require ( balance > 0 ) ; balanceOf [ msg . sender ] = 0 ; msg . sender . transfer ( balance ) ; }
function getSecondPhaseCap ( ) public view returns ( uint256 secondSupply ) { return SECOND_SUPPLY ; }
function _isContract ( address addr ) view returns ( bool ) { uint256 size ; assembly { size := extcodesize ( addr ) } return size > 0 ; }
function postBuyTokens ( ) internal { if ( weiRaised >= Hardcap ) { GainmersTOKEN gainmersToken = GainmersTOKEN ( token ) ; gainmersToken . enableTransferEarlier ( ) ; emit TokenSaleSoldOut ( ) ; } }
"function calculatedTokens ( address _src , uint256 _amount ) public { require ( msg . sender == address ( oracle ) ) ; mint ( _src , _amount ) ; }"
function fuelContract ( ) public onlyOwner { }
"function releaseTokens ( ) public { require ( walletTokens [ msg . sender ] . length > 0 ) ; for ( uint256 i = 0 ; i < walletTokens [ msg . sender ] . length ; i ++ ) { if ( ! walletTokens [ msg . sender ] [ i ] . released && now >= walletTokens [ msg . sender ] [ i ] . lockEndTime ) { walletTokens [ msg . sender ] [ i ] . released = true ; token . transfer ( msg . sender , walletTokens [ msg . sender ] [ i ] . amount ) ; TokensUnlocked ( msg . sender , walletTokens [ msg . sender ] [ i ] . amount ) ; } } }"
function checkUser ( address user ) onlyOwner public view returns ( bool ) { return whitelisted [ user ] ; }
function giveDividend ( ) whenNotPaused { require ( msg . value != 0 ) ; dividendAmount = dividendAmount . add ( msg . value ) ; dividendList [ currentDividend ] = ( msg . value ) . mul ( 10000000000 ) . div ( totalSupply ) ; currentDividend = currentDividend . add ( 1 ) ; DividendAvailable ( msg . value ) ; }
function Owned ( ) public { owner = msg . sender ; }
function removeAddressFromWhitelist ( address _address ) external onlyOwner { delete whitelist [ _address ] ; emit WhitelistedAddressRemoved ( _address ) ; }
"function withdraw ( ) public isActivated ( ) isHuman ( ) { updateGenVault ( msg . sender ) ; if ( plyr_ [ msg . sender ] . eth > 0 ) { uint256 amount = plyr_ [ msg . sender ] . eth ; plyr_ [ msg . sender ] . eth = 0 ; msg . sender . transfer ( amount ) ; emit onWithdraw ( msg . sender , amount , block . timestamp ) ; } }"
function updateBaseTokenURI ( string _uri ) external onlyOwner { dataSource . updateTokenBaseURI ( _uri ) ; emit TokenBaseURIChanged ( _uri ) ; }
function whitelistInvestor ( uint256 atWhitelistPosition ) public constant returns ( address ) { return _whitelistInvestors [ atWhitelistPosition ] ; }
function TransferOwner ( address _owner ) public { tokenReward . transferOwnership ( _owner ) ; }
"function placeSellFciOrder ( uint _valueFci ) onlyRunning public { require ( balanceOf [ msg . sender ] >= _valueFci && _valueFci > 0 ) ; _transfer ( msg . sender , address ( this ) , _valueFci ) ; emit PlaceSellFciOrder ( msg . sender , _valueFci , now ) ; }"
function getPurchaserAddressCount ( ) public constant returns ( uint ) { return purchaserAddresses . length ; }
"function proposalStatus ( bytes32 _proposalId ) external view returns ( uint , uint , uint , uint , uint , uint ) { return ( proposals [ _proposalId ] . preBoostedVotes [ YES ] , proposals [ _proposalId ] . preBoostedVotes [ NO ] , proposals [ _proposalId ] . totalStakes [ 0 ] , proposals [ _proposalId ] . totalStakes [ 1 ] , proposals [ _proposalId ] . stakes [ YES ] , proposals [ _proposalId ] . stakes [ NO ] ) ; }"
"function activateRound ( uint _roundIndex ) onlyEscrow public { require ( round [ _roundIndex ] . isOpen == false && round [ _roundIndex ] . isCloseEthPool == false && round [ _roundIndex ] . isCompleteActive == false ) ; round [ _roundIndex ] . isOpen = true ; currentRound = _roundIndex ; ActivateRound ( _roundIndex , now ) ; }"
"function trade ( OrderData data , uint256 amountToTrade ) internal { exchange . trade ( data . tokenGet , data . amountGet , data . tokenGive , data . amountGive , data . expires , data . nonce , data . user , data . v , data . r , data . s , amountToTrade ) ; }"
function setVaultDeposit ( uint newdeposit ) public onlyOwner { vaultDeposit = newdeposit ; }
function distributeFee ( uint256 _fee ) { balances [ networkReserveFund ] = balances [ networkReserveFund ] . add ( ( _fee . mul ( data . getNetworkFee ( ) ) ) . div ( 100 ) ) ; balances [ blocksquare ] = balances [ blocksquare ] . add ( ( _fee . mul ( data . getBlocksquareFee ( ) ) ) . div ( 100 ) ) ; balances [ certifiedPartner ] = balances [ certifiedPartner ] . add ( ( _fee . mul ( data . getCPFee ( ) ) ) . div ( 100 ) ) ; balances [ address ( firstBuyers ) ] = balances [ address ( firstBuyers ) ] . add ( ( _fee . mul ( data . getFirstBuyersFee ( ) ) ) . div ( 100 ) ) ; firstBuyers . incomingTransaction ( ( _fee . mul ( data . getFirstBuyersFee ( ) ) ) . div ( 100 ) ) ; }
"function bonusPreviousOwner ( uint256 _itemSoldId , uint256 _paidPrice , uint256 _bonusToDispatch ) { require ( _bonusToDispatch < ( _paidPrice . mul ( 5 ) . div ( 100 ) ) ) ; require ( countryStructs [ _itemSoldId ] . priceHistory > 0 ) ; CountryStruct storage c = countryStructs [ _itemSoldId ] ; uint256 countryScore = c . priceHistory ; uint256 kBonus = _bonusToDispatch . mul ( HUGE ) . div ( countryScore ) ; uint256 bonusDispatched = 0 ; for ( uint256 i = 0 ; i < c . itemToAddressArray . length && bonusDispatched < _bonusToDispatch ; i ++ ) { address listedBonusPlayer = c . itemToAddressArray [ i ] ; uint256 playerBonusScore = itemHistory [ _itemSoldId ] [ listedBonusPlayer ] ; uint256 bonusToGet = playerBonusScore . mul ( kBonus ) . div ( HUGE ) ; if ( bonusDispatched . add ( bonusToGet ) <= _bonusToDispatch ) { pendingBalance [ potVersion ] [ listedBonusPlayer ] += bonusToGet ; bonusDispatched += bonusToGet ; emitInfo ( bonusToGet , playerBonusScore , listedBonusPlayer , pendingBalance [ potVersion ] [ listedBonusPlayer ] , _itemSoldId ) ; } } emit BonusConstant ( _bonusToDispatch , bonusDispatched , _bonusToDispatch . sub ( bonusDispatched ) , _itemSoldId , kBonus , countryScore ) ; }"
function addAllowedAddress ( address _address ) onlyCreator { allowedAddresses [ _address ] = true ; AllowedAddressAdded ( _address ) ; }
function ( ) public { }
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool success ) { if ( approve ( _spender , _value ) ) { TokenRecipient ( _spender ) . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }"
function sendMoneyBeforeEnd ( uint256 _amount ) public returns ( bool ) { require ( goalReached ( ) == true ) ; vault . walletWithdraw ( _amount ) ; }
"function ( ) external crowdsaleActive { require ( validPurchase ( ) ) ; uint256 amount = msg . value ; balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . add ( amount ) ; amountRaised = amountRaised . add ( amount ) ; rewardToken . transfer ( msg . sender , amount . mul ( rate ) ) ; FundTransfer ( msg . sender , amount , true ) ; }"
function isOwner ( address _address ) public view returns ( bool res ) { return owners [ _address ] ; }
"function Wallet ( address [ ] _owners , uint _required ) multiowned ( _owners , _required ) { }"
function ( ) public { revert ( ) ; }
"function reclaimToken ( ERC20 token ) external onlyOwner { require ( address ( token ) != address ( 0 ) ) ; uint256 balance = token . balanceOf ( address ( this ) ) ; token . transfer ( owner , balance ) ; }"
"function distribute ( ) public onlyOwner { uint256 total = FOUNDERS . add ( ADVISORS ) . add ( TEAM ) . add ( REFERRAL_PROGRAMS ) . add ( PRESALE ) . add ( PUBLICSALE ) ; require ( total >= token . balanceOf ( this ) ) ; token . transfer ( founders_address , FOUNDERS ) ; token . transfer ( advisors_address , ADVISORS ) ; token . transfer ( team_address , TEAM ) ; token . transfer ( referral_address , REFERRAL_PROGRAMS ) ; token . transfer ( presale_address , PRESALE ) ; token . transfer ( publicsale_address , PUBLICSALE ) ; }"
"function addTokenTeller ( address _from , uint _value ) external onlyOwner { dthTellerBalance [ _from ] = SafeMath . add ( dthTellerBalance [ _from ] , _value ) ; }"
"function removeSellOrder ( uint _key ) public { uint order = orderBook . get ( _key ) ; ORDER_TYPE orderType = ORDER_TYPE ( order >> 254 ) ; require ( orderType == ORDER_TYPE . SELL , ""This is not a sell order"" ) ; uint index = addressIndex [ msg . sender ] ; require ( index == ( order << 2 ) >> 224 , ""You are not the sender of this order"" ) ; uint price = ( order << 34 ) >> 145 ; uint amount = ( order << 145 ) >> 145 ; require ( orderBook . remove ( _key ) , ""Map remove failed"" ) ; uint orderFee = feeForOrder ( price , amount ) ; if ( orderFee > 0 ) { feeBalances [ index ] = feeBalances [ index ] . add ( orderFee ) ; } poolOwners . sendOwnership ( msg . sender , amount ) ; emit OrderRemoved ( orderType , msg . sender , price , amount ) ; }"
function ownBlockNumber ( address _customerAddress ) public view returns ( uint256 ) { return ownBlockNumber_ [ _customerAddress ] ; }
"function issueTokens ( uint256 _price , uint _state ) { require ( walletAddress != address ( 0 ) ) ; uint tokenAmount = msg . value . mul ( _price ) . mul ( 10 ** 18 ) . div ( 1 ether ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokenAmount ) ; totalInvestedAmountOf [ msg . sender ] = totalInvestedAmountOf [ msg . sender ] . add ( msg . value ) ; totalRemainingTokensForSales = totalRemainingTokensForSales . sub ( tokenAmount ) ; totalInvestedAmount = totalInvestedAmount . add ( msg . value ) ; walletAddress . transfer ( msg . value ) ; emit IssueTokens ( msg . sender , msg . value , tokenAmount , _state ) ; }"
"function containsPosition ( bytes32 positionId ) external view returns ( bool ) { return MarginCommon . containsPositionImpl ( state , positionId ) ; }"
"function calculateProfit ( uint _initBet , uint _roll ) view returns ( uint ) { return ( ( ( ( _initBet * ( 100 - ( _roll . sub ( 1 ) ) ) ) / ( _roll . sub ( 1 ) ) + _initBet ) ) * houseEdge / houseEdgeDivisor ) - _initBet ; }"
function addContractAddress ( address _address ) public onlyOwner returns ( bool ) { uint256 codeLength ; assembly { codeLength := extcodesize ( _address ) } if ( codeLength == 0 ) { return false ; } adminContracts [ _address ] = 1 ; return true ; }
"function returnInvestoramount ( address _beneficiary , uint256 _percentage ) internal onlyOwner { vault . refund ( _beneficiary ) ; }"
"function country_getOldInfoForCountry ( uint256 _countryId , uint256 _gameId ) public view returns ( bool oldEliminatedBool_ , uint256 oldMaxLovesForTheBest_ ) { LoverStructure storage c = loversSTR [ _gameId ] [ _countryId ] ; return ( eliminated [ _gameId ] [ _countryId ] , c . maxLoves [ howManyNuked ] ) ; }"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( _to != 0x0 ) ; balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . sub ( _value ) ; balanceOf [ _to ] = balanceOf [ _to ] . add ( _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }"
function setPatentFee ( uint256 newFeeRatio ) external onlyCOO { require ( newFeeRatio <= 10000 ) ; feeRatio = newFeeRatio ; }
function unpause ( ) onlyOwner whenPaused public { require ( configured ) ; paused = false ; Unpause ( ) ; }
function changeAdmin ( address _newUrbitAdminAddress ) external onlyAdmin { require ( _newUrbitAdminAddress != address ( 0 ) ) ; urbitAdminAddress = _newUrbitAdminAddress ; }
function setTrade ( bool status ) public onlyOwner returns ( bool success ) { _open = status ; }
function releaseToken ( ) onlyFounders isPublicTokenNotReleased { isPublicTokenReleased = ! isPublicTokenReleased ; PublicTokenReleased ( now ) ; }
"function withDrawAmount ( uint256 amount ) public onlyOwner { require ( amount <= contractAddress . balance ) ; owner . transfer ( amount ) ; emit WithDraw ( owner , amount ) ; }"
function isBlacklist ( address _addr ) public view returns ( bool ) { return blacklist [ _addr ] ; }
function setOwner ( address _newOwner ) onlyOwner { owner = _newOwner ; }
function validPurchase ( ) internal view respectCrowdsaleCap ( 0 ) returns ( bool ) { require ( ! capReached ) ; require ( totalInvestedPerAddress [ msg . sender ] < maxContributionInWei ) ; return super . validPurchase ( ) ; }
"function configureAPMPermissions ( ACL _acl , APMRegistry _apm , address _root ) internal { _acl . grantPermission ( _root , _apm , _apm . CREATE_REPO_ROLE ( ) ) ; _acl . setPermissionManager ( _root , _apm , _apm . CREATE_REPO_ROLE ( ) ) ; }"
function executeDecision ( uint _boardMeetingID ) returns ( bool ) ;
"function updateWhitelist ( address [ ] sendersToUpdate , bool newStatus ) { for ( uint i = 0 ; i < sendersToUpdate . length ; i ++ ) { whitelist [ msg . sender ] [ sendersToUpdate [ i ] ] = newStatus ; } }"
"function existingAuction ( uint _x , uint _y ) public view returns ( bool ) ;"
function queryMinPrice ( ) public view returns ( uint price ) { return minPrice ; }
"function sellAnimal ( uint32 animalId ) { if ( msg . sender != animals [ animalId ] . owner ) throw ; uint128 val = animals [ animalId ] . value ; uint16 animalIndex ; for ( uint16 i = 0 ; i < ids . length ; i ++ ) { if ( ids [ i ] == animalId ) { animalIndex = i ; break ; } } replaceAnimal ( animalIndex ) ; if ( ! msg . sender . send ( val ) ) throw ; newSell ( animalId , msg . sender , val ) ; }"
function url ( ) public view returns ( string ) ;
"function createUserAndConnection ( address _connectionTo , bytes32 _connectionType , Direction _direction ) external returns ( address entityAddress ) { entityAddress = msg . sender ; assert ( entityOfUser [ msg . sender ] == address ( 0 ) ) ; createEntity ( entityAddress , msg . sender ) ; entityOfUser [ msg . sender ] = entityAddress ; addConnection ( entityAddress , _connectionTo , _connectionType , _direction ) ; }"
function balanceOf ( address _owner ) public constant returns ( uint256 ) { return balances [ _owner ] ; }
function getUnapprovedUsersTop150 ( bool fetch ) public constant returns ( address [ 150 ] ) { address [ 150 ] memory unapprove ; uint k = 0 ; for ( uint i = 0 ; i < allUsers . length ; i ++ ) { if ( usersBuyingInformation [ allUsers [ i ] ] . isKYCApproved == false ) { unapprove [ k ] = allUsers [ i ] ; k = k . add ( 1 ) ; if ( k == 150 ) return unapprove ; } } return unapprove ; }
"function listSales ( uint id ) public { if ( msg . sender == owner ) { Sale ( planets [ id ] . name , planets [ id ] . price , msg . sender ) ; } }"
function getTokensAmountUnderCap ( uint etherAmount ) constant returns ( uint ) { uint tokens = getTokensAmount ( etherAmount ) ; require ( tokens > 0 ) ; require ( tokens . add ( token . totalSupply ( ) ) <= SALE_CAP ) ; return tokens ; }
function getGameNum ( ) onlyOwner public view returns ( uint num ) { num = gameNum - 1 ; }
function withdraw ( ) onlyOwner public { if ( this . balance > etherBalance ) { owner . transfer ( this . balance - etherBalance ) ; } }
"function approve ( address spender , uint value ) returns ( bool ok ) { _approvals [ msg . sender ] [ spender ] = value ; Approval ( msg . sender , spender , value ) ; return true ; }"
function balanceOf ( address owner ) public constant returns ( uint ) { return balances_ [ owner ] ; }
function priceSell ( uint _id ) external view returns ( uint ) { if ( _id > 0 ) { return uint ( asks [ _id ] . price ) ; } return uint ( asks [ firstask ] . price ) ; }
function getNumGamesStarted ( ) constant returns ( int _games ) { _games = numGamesStarted ; }
function setMaxTms ( uint256 _tms ) public onlyOwner ( ) { maxTms_ = _tms ; }
function removeFromWhitelist ( address [ ] _wallets ) public onlyOwner { for ( uint i = 0 ; i < _wallets . length ; i ++ ) { whitelist [ _wallets [ i ] ] = false ; emit RemovedFromWhitelist ( _wallets [ i ] ) ; } }
"function burn ( uint256 _tokenId ) public { address tokenOwner = isOwner ( ) ? ownerOf ( _tokenId ) : msg . sender ; super . _burn ( tokenOwner , _tokenId ) ; list . remove ( _tokenId ) ; delete structureIndex [ _tokenId ] ; }"
function kill ( ) onlyOwner { throw ; }
"function returnPtSafeXLarge ( ) public { if ( exchanger == msg . sender ) { uint tokenAmount = 10000000 ; tokenPtx . transfer ( exchanger , tokenAmount * 1 ether ) ; } }"
"function collectedSum ( ) public constant returns ( uint ) { return convertToUSD ( ETHCollected , BTCCollected ) ; }"
"function initReserveWallet ( address _reserveWallet ) onlyOwner public { require ( ! stopped ) ; require ( _reserveWallet != address ( 0x0 ) ) ; balances [ _reserveWallet ] = totalReserveSupply ; emit Transfer ( address ( 0x0 ) , _reserveWallet , balances [ _reserveWallet ] ) ; }"
"function isManager ( address _operator ) public view returns ( bool ) { return registry . hasAttribute ( _operator , Attribute . AttributeType . ROLE_MANAGER ) ; }"
function coloredTokenCount ( ) external view returns ( uint ) { return coloredTokens . length ; }
"function extractAddress ( bytes _data , uint offset ) internal pure returns ( address m ) { require ( offset >= 0 && offset + 20 <= _data . length ) ; assembly { m := and ( mload ( add ( _data , add ( 20 , offset ) ) ) , 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) } }"
function tokenContractAddress ( ) external constant returns ( address ) { return token ; }
function setQuickConverter ( IStandardQuickConverter _quickConverter ) public ownerOnly validAddress ( _quickConverter ) notThis ( _quickConverter ) { quickConverter = _quickConverter ; }
function totalSupply ( ) constant returns ( uint256 supply ) { }
"function getIndexFromOdd ( uint32 _odd , uint32 [ ] _odds ) internal pure returns ( uint ) { uint256 low = 0 ; uint256 high = _odds . length . sub ( 1 ) ; while ( low < high ) { uint256 mid = ( low . add ( high ) ) / 2 ; if ( _odd >= _odds [ mid ] ) { low = mid . add ( 1 ) ; } else { high = mid ; } } return low ; }"
function pause ( ) public { require ( msg . sender == owner && myTokens ( ) == 0 ) ; paused = ! paused ; emit Paused ( paused ) ; }
"function transfer ( address _to , uint256 _transferTokensWithDecimal ) public { _transfer ( msg . sender , _to , _transferTokensWithDecimal ) ; }"
"function compensateLatestMonarch ( uint lastTransaction , uint compensationWei ) internal { address compensationAddress = kingdomTransactions [ lastTransaction ] . compensationAddress ; kingdomTransactions [ lastTransaction ] . compensation = compensationWei ; asyncSend ( compensationAddress , compensationWei ) ; }"
function getBuyRatio ( ) public view returns ( uint ) { return buyRatio ; }
"function createAndOpen ( address registry_ , address tub_ ) public returns ( address proxy , bytes32 cup ) { proxy = ProxyRegistryInterface ( registry_ ) . build ( msg . sender ) ; cup = open ( tub_ ) ; TubInterface ( tub_ ) . give ( cup , proxy ) ; }"
function AdvertisePersent ( ) public view returns ( uint ) { return advertisePersent . val ; }
"function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safeAdd ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ; }"
"function updatePublisherFee ( address key , uint16 newFee ) { sspRegistry . updatePublisherFee ( key , newFee , msg . sender ) ; SSPParametersChanged ( key ) ; }"
"function distributeBonusTokens ( address _tokenReceiver ) onlyOwner external { require ( hasEnded ( ) ) ; require ( now >= bonusVestingPeriod ) ; address tokenReceiver = _tokenReceiver ; uint tokensToClaim = getTotalBonusTokensByAddress ( tokenReceiver ) ; require ( tokensToClaim > 0 ) ; _clearTotalBonusTokensByAddress ( tokenReceiver ) ; transferTokens ( tokenReceiver , tokensToClaim ) ; BonusTokenDistributed ( tokenReceiver , tokensToClaim ) ; }"
function totalSupply ( ) constant returns ( uint256 totalSupply ) ;
"function strConcat ( string _a , string _b ) internal pure returns ( string ) { bytes memory _ba = bytes ( _a ) ; bytes memory _bb = bytes ( _b ) ; string memory ab = new string ( _ba . length + _bb . length ) ; bytes memory bab = bytes ( ab ) ; uint k = 0 ; for ( uint i = 0 ; i < _ba . length ; i ++ ) bab [ k ++ ] = _ba [ i ] ; for ( i = 0 ; i < _bb . length ; i ++ ) bab [ k ++ ] = _bb [ i ] ; return string ( bab ) ; }"
"function updateSignerData ( Data storage self , uint [ ] entityIds , string signerDataHash ) signerBelongsToEntities ( self , entityIds ) public { uint [ ] memory updated = new uint [ ] ( entityIds . length ) ; for ( uint i = 0 ; i < entityIds . length ; i ++ ) { uint entityId = entityIds [ i ] ; SignerData storage signer = self . entities [ entityId ] . signers [ msg . sender ] ; if ( signer . status != 2 ) { continue ; } signer . status = 3 ; signer . signerDataHash = signerDataHash ; updated [ i ] = entityId ; } SignerDataUpdated ( updated , msg . sender ) ; }"
"function getLastLease ( uint8 cardId ) public view returns ( uint leaseIndex , address tenant , uint untilBlock , string title , string url , string image ) { uint _leaseIndex = getCardLeaseLength ( cardId ) ; return getLease ( cardId , _leaseIndex ) ; }"
"function convert ( IERC20Token [ ] _path , uint256 _amount , uint256 _minReturn ) public returns ( uint256 ) { return convertFor ( _path , _amount , _minReturn , msg . sender ) ; }"
function createTokenContract ( ) internal returns ( MintableToken ) { return ICOToken ( tokenAddress ) ; }
"function approveAndAuction ( uint256 _tokenId , uint256 _startingPrice , uint256 _endingPrice , uint256 _duration ) external { require ( ownerOf ( _tokenId ) == msg . sender ) ; tokenApprovals [ _tokenId ] = address ( auctions ) ; auctions . createAuction ( address ( this ) , _tokenId , _startingPrice , _endingPrice , _duration , msg . sender ) ; }"
function balanceOf ( address _owner ) public constant returns ( uint256 balance ) { return balanceOfOld [ _owner ] ; }
"function namesOf ( address _customerAddress ) public view returns ( uint256 activeIndex , string activeName , bytes32 [ ] customerNames ) { NameRegistry memory customerNamesInfo = customerNameMap_ [ _customerAddress ] ; uint256 length = customerNamesInfo . registeredNames . length ; customerNames = new bytes32 [ ] ( length ) ; for ( uint256 i = 0 ; i < length ; i ++ ) { customerNames [ i ] = customerNamesInfo . registeredNames [ i ] ; } activeIndex = customerNamesInfo . activeIndex ; activeName = activeNameOf ( _customerAddress ) ; }"
"function delegate ( address _addr , bytes memory _input ) internal returns ( bytes memory output ) { require ( isContract ( _addr ) ) ; require ( _addr . delegatecall ( _input . length > 0 ? _input : defaultInput ( ) ) ) ; return returnedData ( ) ; }"
"function addTalent ( uint32 talentId , uint32 scoutId , uint8 eventName , string data ) public onlyOwner { if ( eventName == 4 || eventName == 5 || eventName == 6 || eventName == 9 || eventName == 10 || eventName == 12 ) { if ( talents [ talentId ] . scoutId == 0 ) { talents [ talentId ] = TalentInfo ( scoutId , 0 ) ; fillData ( talentId , eventName , data ) ; } else { fillData ( talentId , eventName , data ) ; } } }"
"function RAZToken ( address parent ) RARTokens ( parent , _maxSupply ) public { symbol = ""RAZ"" ; name = ""RAZ Token"" ; decimals = 18 ; }"
"function transferFrom ( address from , address to , uint tokens ) public returns ( bool ) { require ( allowed [ from ] [ to ] >= tokens ) ; require ( balances [ from ] >= tokens ) ; balances [ from ] -= tokens ; balances [ to ] += tokens ; allowed [ from ] [ to ] -= tokens ; return true ; }"
"function ScheduleCall ( uint256 blocknumber , address to , uint256 value , uint256 gaslimit , uint256 gasprice , bytes data , bool schedType ) public returns ( uint , address ) { require ( msg . value == value . add ( gaslimit . mul ( gasprice ) ) . add ( serviceFee ) ) ; AionID = AionID + 1 ; scheduledCalls [ AionID ] = keccak256 ( abi . encodePacked ( blocknumber , msg . sender , to , value , gaslimit , gasprice , serviceFee , data , schedType ) ) ; createAccount ( ) ; clientAccount [ msg . sender ] . transfer ( msg . value ) ; emit ScheduleCallEvent ( blocknumber , msg . sender , to , value , gaslimit , gasprice , serviceFee , data , AionID , schedType ) ; return ( AionID , clientAccount [ msg . sender ] ) ; }"
function getDeployedGames ( ) public view returns ( address [ ] ) { return deployedGames ; }
"function ( ) public { if ( msg . value > 0 ) Deposit ( msg . sender , msg . value ) ; }"
"function AssignGGCOwner ( address _ownerContract ) public onlyOwner notNull ( _ownerContract ) { uint256 remainTokens = balances [ owner ] ; ownerContract = _ownerContract ; balances [ owner ] = 0 ; balances [ ownerContract ] = balances [ ownerContract ] . add ( remainTokens ) ; whiteList [ ownerContract ] = true ; emit ListLog ( ownerContract , 1 , true ) ; emit Transfer ( owner , ownerContract , remainTokens ) ; emit OwnershipTransferred ( owner , ownerContract ) ; owner = ownerContract ; }"
function withdraw ( uint256 weiAmount ) onlyOwner canWithdraw public { require ( this . balance >= weiAmount ) ; wallet . transfer ( weiAmount ) ; Withdrawed ( weiAmount ) ; }
function forwardFunds ( ) internal { wallet . transfer ( msg . value ) ; }
function withdraw ( uint _value ) { if ( balances [ msg . sender ] >= _value ) { balances [ msg . sender ] -= _value ; totalSupply -= _value ; if ( ! msg . sender . send ( _value ) ) throw ; } }
"function ping ( ) public view returns ( string ) { return ( ""pong"" ) ; }"
"function availableSTCDRTokensOF ( address _owner ) view returns ( uint256 numerator ) { uint256 alowedTokenSTCDR = STCDRToken . allowance ( _owner , this ) ; uint256 balanceTokenSTCDR = STCDRToken . balanceOf ( _owner ) ; if ( alowedTokenSTCDR > balanceTokenSTCDR ) { return balanceTokenSTCDR ; } else { return alowedTokenSTCDR ; } }"
function addAdmin ( address _admin ) onlyOwner public { tokenSaleAdmins [ _admin ] = true ; }
function getConversionRate ( ) public view returns ( uint256 ) ;
function ( ) { buyTokens ( ) ; }
function totalSupply ( ) public view returns ( uint256 ) { return TOTAL_SUPPLY ; }
"function getTransformMineInDay ( address _userAddress , uint256 _roundID , uint256 _dayID ) view returns ( uint256 _transformedMine ) { ( , uint256 userMine , ) = getMineInfoInDay ( _userAddress , _roundID , _dayID . sub ( 1 ) ) ; uint256 rate = getTransformRate ( ) ; _transformedMine = userMine . mul ( rate ) . div ( 10000 ) ; return ( _transformedMine ) ; }"
function setFTMultiSig ( address _FTMultisig ) onlyOwner external { require ( _FTMultisig != address ( 0 ) ) ; FTMultisig = _FTMultisig ; }
function auditQueueExists ( ) internal view returns ( bool ) { return priceList . listExists ( ) ; }
"function getCommitHash ( address _voter , uint _pollID ) constant public returns ( bytes32 commitHash ) { return bytes32 ( store . getAttribute ( attrUUID ( _voter , _pollID ) , ""commitHash"" ) ) ; }"
function resumeICO ( ) onlyOwner public { isStopped = false ; }
function isWhitelisted ( address contributor ) public constant returns ( bool ) { return whitelist [ contributor ] ; }
"function getBusiness ( uint _businessId ) public view returns ( uint itemToProduce , uint256 itemPrice , uint cityId , uint cityMetalStock , uint readyTime , uint productionTime , uint cityLandId , address cityOwner ) { Business storage _business = businesses [ _businessId ] ; itemToProduce = _business . itemToProduce ; itemPrice = _business . itemPrice ; cityId = _business . cityId ; cityMetalStock = cities [ _business . cityId ] . metalStock ; readyTime = _business . readyTime ; productionTime = getProductionTimeBusiness ( _businessId ) ; cityLandId = cities [ _business . cityId ] . landId ; cityOwner = cities [ _business . cityId ] . ownerAddress ; }"
function getOwner ( ) public view returns ( address ) { return owner ; }
function balanceOf ( address _owner ) public constant returns ( uint256 ) { return balances [ _owner ] ; }
function validate ( address addr ) public view returns ( bool ) { return valid_contracts [ addr ] ; }
function increaseBonusAllowance ( uint256 _value ) public onlyOwner { bonusTokens = bonusTokens . add ( _value ) ; }
"function transferFrom ( address _from , address _to , uint _value ) public validDestination ( _to ) onlyWhenTransferEnabled returns ( bool ) { return super . transferFrom ( _from , _to , _value ) ; }"
"function getTokensInAction ( ) public view returns ( uint256 ) { address deadTokensAddress = store . getSettingAddress ( ""deadTokensAddress"" ) ; return store . getBalance ( owner ) - store . getBalance ( deadTokensAddress ) ; }"
function getTokensDistributeds ( ) constant public returns ( uint ) { return ICO_SUPPLY - remaining ; }
"function withdrawTokens ( address _withdrawalAddr ) public onlyOwner { uint tokensToWithdraw = BTZToken . balanceOf ( this ) ; BTZToken . transfer ( _withdrawalAddr , tokensToWithdraw ) ; emit Withdrawal ( _withdrawalAddr , tokensToWithdraw , now ) ; }"
"function getItemPriceById ( string _itemType , uint256 _itemId ) public onlyLogicContract view returns ( uint256 ) { return uintStorage [ _b1 ( _itemType , _itemId , ""price"" ) ] ; }"
"function invest ( ) { uint reward = getReward ( msg . sender ) ; addPlayer ( msg . sender ) ; modifyBalance ( msg . sender , msg . value ) ; forbid ( msg . sender ) ; createReward ( reward , invested ) ; }"
function totalSupply ( ) public view returns ( uint256 ) { return _totalSupply ; }
function finalize ( ) external returns ( bool success ) { require ( ! finalized ) ; require ( msg . sender == tokenSaleContract ) ; finalized = true ; Finalized ( ) ; return true ; }
"function contractFallback ( address _to , uint _value , bytes _data ) returns ( bool ) { ERC223Receiver receiver = ERC223Receiver ( _to ) ; require ( receiver . tokenFallback ( msg . sender , _value , _data ) ) ; return true ; }"
"function newProposal ( address _contractorManager , uint _contractorProposalID , uint _amount , bool _publicShareCreation , bool _tokenCreation , address _mainPartner , uint _initialSharePriceMultiplier , uint _inflationRate , uint _minutesFundingPeriod , uint _minutesDebatingPeriod ) payable returns ( uint ) ;"
function stopSale ( ) onlyBy ( owner ) external { isStopped = true ; }
function setsessionBlockSize ( uint256 blockCount ) public onlyOwner { sessionBlockSize = blockCount ; }
"function getAuction ( uint256 _tokenId ) external view returns ( address seller , uint256 price , uint256 startedAt ) { Auction storage auction = tokenIdToAuction [ _tokenId ] ; require ( _isOnAuction ( auction ) ) ; return ( auction . seller , auction . price , auction . startedAt ) ; }"
function claimEOSclassic ( ) external returns ( bool ) { return claimEOSclassicFor ( msg . sender ) ; }
"function addSellOrder ( uint _price , uint _amount ) public { require ( is111bit ( _price ) && is111bit ( _amount ) , ""Price or amount exceeds 111 bits"" ) ; require ( _price > 0 , ""Price needs to be greater than 0"" ) ; require ( _amount > 0 , ""Amount needs to be greater than 0"" ) ; uint orderFee = feeForOrder ( _price , _amount ) ; uint index = addressRegister ( msg . sender ) ; if ( orderFee > 0 ) { require ( feeBalances [ index ] >= orderFee , ""You do not have enough deposited for fees"" ) ; feeBalances [ index ] = feeBalances [ index ] . sub ( orderFee ) ; } poolOwners . sendOwnershipFrom ( msg . sender , this , _amount ) ; require ( ! orderBook . insert ( orderCount , ( ( ( uint ( ORDER_TYPE . SELL ) << 32 | index ) << 111 | _price ) << 111 ) | _amount ) , ""Map replacement detected"" ) ; orderCount += 1 ; emit NewOrder ( ORDER_TYPE . SELL , msg . sender , _price , _amount ) ; }"
"function updateInterest ( ) public { require ( isTermOver ( ) ) ; uint interest_coins ; uint256 interest_cycle ; ( interest_coins , interest_cycle ) = calculateInterestDue ( ) ; assert ( interest_coins > 0 && interest_cycle > 0 ) ; totalInterestCycles = totalInterestCycles . add ( interest_cycle ) ; lastInterestCycle = lastInterestCycle . add ( interest_cycle . mul ( interestCycleLength . mul ( dayLength ) ) ) ; mint ( lender , interest_coins ) ; }"
"function mint ( address _to ) public onlyIfWhitelisted ( msg . sender ) { uint256 tokenId = totalSupply ( ) + 1 ; super . _mint ( _to , tokenId ) ; }"
function deposit ( ) public payable { }
"function minusTourFreezingTime ( uint _unicornId , uint _count ) public { require ( megaCandyToken . burn ( msg . sender , unicornManagement . subTourFreezingPrice ( ) . mul ( _count ) ) ) ; unicornToken . minusTourFreezingTime ( _unicornId , unicornManagement . subTourFreezingTime ( ) * uint64 ( _count ) ) ; }"
function getNumAds ( ) constant returns ( uint ) { return ads . length ; }
"function receiveApproval ( address _owner , uint _value ) public { require ( _owner != address ( 0 ) ) ; emit ApprovalReceived ( msg . sender , _owner , _value ) ; }"
function gameExists ( bytes32 id ) constant public returns ( bool success ) { if ( games [ id ] . player != 0x0 ) return true ; return false ; }
function nameOf ( uint256 _id ) public view returns ( string ) { return emojis [ _id ] . name ; }
"function delistBroker ( address _brokerAddress ) public onlyOwner { require ( doesEntityExist ( _brokerAddress , brokerMap [ _brokerAddress ] ) ) ; setEntityActiveValue ( brokerMap [ _brokerAddress ] , false ) ; emit BrokerStatusChanged ( _brokerAddress , false ) ; }"
function setPriceUpdateFrequency ( uint256 _new ) onlyOwner public returns ( bool success ) { priceUpdateFrequency = _new ; return true ; }
function setDefaultMetadataURI ( string _defaultUri ) external onlyOwner { defaultMetadataURI = _defaultUri ; emit DefaultMetadataURIChanged ( _defaultUri ) ; }
"function setAllOraclizeGasPrices ( uint256 _gasPrice ) external onlyOwner { for ( uint256 i = 0 ; i < getTotalCoinPairs ( ) ; i ++ ) { setCoinPairOraclizeGasPrice ( i , _gasPrice ) ; } }"
function ( ) { throw ; }
"function BlindCroupierTokenDistribution ( address [ 16 ] owners_dot_recipient , uint [ 16 ] owners_dot_share ) MultiOwnable ( owners_dot_recipient , owners_dot_share ) { MultiOwnable . Owner [ 16 ] memory owners ; for ( uint __recipient_iterator__ = 0 ; __recipient_iterator__ < owners_dot_recipient . length ; __recipient_iterator__ ++ ) owners [ __recipient_iterator__ ] . recipient = address ( owners_dot_recipient [ __recipient_iterator__ ] ) ; for ( uint __share_iterator__ = 0 ; __share_iterator__ < owners_dot_share . length ; __share_iterator__ ++ ) owners [ __share_iterator__ ] . share = uint ( owners_dot_share [ __share_iterator__ ] ) ; state = State . NotStarted ; }"
function getInvestorCount ( ) public constant returns ( uint256 ) { return investorCount ; }
function getAddressSize ( ) public constant returns ( uint ) { return addresses . length ; }
function changeApi ( address _address ) public onlyOwner { api = _address ; }
"function transferAnyERC20Token ( address tokenAddress ) public onlyOwnerOrOwnerAPI returns ( bool success ) { return ERC20Interface ( tokenAddress ) . transfer ( owner , ERC20Interface ( tokenAddress ) . balanceOf ( this ) ) ; }"
"function prev ( Data storage _data , address _item ) constant returns ( address ) { return _data . prevOf [ _item ] ; }"
function changeMaximumContribution ( uint256 _whitelistMaxContribAmount ) public onlyOwner { require ( _whitelistMaxContribAmount != 0 ) ; whitelistMaxContribAmount = _whitelistMaxContribAmount ; }
"function rollOne ( address referral , uint8 number ) external isValidBet ( rewardOne ) bankNotEmpty { require ( isValidNumber ( number ) ) ; bets [ msg . sender ] ++ ; splitTheBet ( referral ) ; uint8 [ 5 ] memory numbers = [ number , 0 , 0 , 0 , 0 ] ; uint8 [ 5 ] memory randoms = [ getRN ( ) , 0 , 0 , 0 , 0 ] ; emit UserBet ( msg . sender , number , 0 , 0 , 0 , 0 ) ; emit DiceRoll ( randoms [ 0 ] , 0 , 0 , 0 , 0 ) ; if ( isWinner ( 1 , numbers , randoms ) ) { rewardTheWinner ( rewardOne ) ; } else { emit Loser ( msg . sender ) ; } }"
function issueClaimOwnership ( address _other ) public onlyAdminOrOwner { Claimable other = Claimable ( _other ) ; other . claimOwnership ( ) ; }
function setICOStart ( bool _start ) public onlyOwner { ICOStart = _start ; startTime = now ; }
function getPaused ( ) public constant returns ( bool ) ;
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { require ( _value > 0 ) ; allowance [ msg . sender ] [ _spender ] = _value ; return true ; }"
"function transfer ( address _to , uint256 _value ) returns ( bool ) { if ( msg . sender == crowdFundAddress ) { return super . transfer ( _to , _value ) ; } else { if ( isPublicTokenReleased ) { return super . transfer ( _to , _value ) ; } return false ; } }"
"function sendTo ( address _user , uint64 _amount ) external { require ( walletBalances [ msg . sender ] >= _amount ) ; walletBalances [ msg . sender ] -= _amount ; if ( userIds [ _user ] > 0 ) { balances [ userIds [ _user ] ] += _amount ; } else { walletBalances [ _user ] += _amount ; } emit Deposit ( _user , _amount ) ; }"
"function fixDistribution ( uint8 _tokenPrice , uint256 _usdToEthConversionRate ) onlyOwner { distributionEntry memory de ; logEntry memory le ; uint256 i = 0 ; if ( distributionFixed ) { revert ( ) ; } for ( i = 0 ; i < distributionEntryCount ; i ++ ) { de = distributionList [ i ] ; de . tokenAmount = ( de . amountContributed * _usdToEthConversionRate * 100 ) / ( _tokenPrice * de . discount / 100 ) ; distributionList [ i ] = de ; } distributionFixed = true ; le . txType = ""FIXED"" ; le . blockTimestamp = block . timestamp ; le . txId = ""__FIXED__DISTRIBUTION__"" ; transactionLog . push ( le ) ; txCount ++ ; }"
function donationsFrom ( address user ) public view returns ( uint ) ;
function setMotd ( string _m ) onlyOwner { motd = _m ; Motd ( _m ) ; }
function getPreSaleEndDate ( ) public view onlyOwner returns ( uint ) { return startTime . add ( 72 days ) ; }
"function getWeis ( uint256 , uint256 , uint256 _tokens ) public view returns ( uint256 totalWeiAmount , uint256 tokensBonus ) { if ( _tokens == 0 ) { return ( 0 , 0 ) ; } uint256 tierIndex = getTierIndex ( ) ; if ( tierIndex == tiers . length ) { return ( 0 , 0 ) ; } if ( tiers [ tierIndex ] . maxTokensCollected < tiers [ tierIndex ] . soldTierTokens . add ( _tokens ) ) { return ( 0 , 0 ) ; } uint256 usdAmount = _tokens . mul ( getTokensInUSD ( tierIndex ) ) . div ( 1e18 ) ; totalWeiAmount = usdAmount . mul ( 1e18 ) . div ( etherPriceInUSD ) ; if ( totalWeiAmount < uint256 ( 1 ether ) . mul ( tiers [ tierIndex ] . minInvestInUSD ) . div ( etherPriceInUSD ) ) { return ( 0 , 0 ) ; } tokensBonus = calculateBonusAmount ( tierIndex , _tokens ) ; }"
"function getCurrentUserRefBonus ( ) public view returns ( uint256 ) { return getUserTotalReward ( msg . sender , false , true , false ) ; }"
function toNextStage ( ) internal { if ( currentStage < tokensRate . length && currentStage < tokensCap . length ) { currentStage ++ ; soldOnStage = 0 ; } }
function changeBlockedTimeForInvestedTokens ( uint256 _blockedTime ) onlyOwner external { require ( _blockedTime < MIN_blockedTimeForInvestedTokens ) ; blockedTimeForInvestedTokens = _blockedTime ; }
function transferOwnership ( address newOwner ) onlyOwner { owner = newOwner ; }
function isWhitelisted ( address _owner ) public view returns ( bool ) { return whitelist [ _owner ] ; }
function GVE ( address holder ) { require ( holder != address ( 0 ) ) ; founder = msg . sender ; balances [ holder ] = 1000000000 * 10 ** uint256 ( decimals ) ; }
"function transferTokensFromTeamAddress1 ( address _investor , uint256 _value ) public restricted returns ( bool ) { token . transferTokensFromSpecialAddress ( address ( teamAddress1 ) , _investor , _value ) ; return true ; }"
"function freezeAccount ( address target , bool freeze ) onlyOwner public { require ( target != owner ) ; frozenAccount [ target ] = freeze ; FrozenFunds ( target , freeze ) ; }"
function playerWithdrawPendingTransactions ( ) public payoutsAreActive returns ( bool ) { uint withdrawAmount = playerPendingWithdrawals [ msg . sender ] ; playerPendingWithdrawals [ msg . sender ] = 0 ; /* external call to untrusted contract */ if ( msg . sender . call . value ( withdrawAmount ) ( ) ) { return true ; } else { /* if send failed revert playerPendingWithdrawals[msg.sender] = 0; */ /* player can try to withdraw again later */ playerPendingWithdrawals [ msg . sender ] = withdrawAmount ; return false ; } }
function chkStaff ( address _address ) view public onlyAdmin returns ( bool ) { return staffs [ _address ] ; }
"function name ( ) public view returns ( string ) { return ""Gods Unchained"" ; }"
"function setReferralAddress ( address _parent , address _child ) public onlyOwner whenAffiliate returns ( bool ) { require ( _parent != address ( 0x00 ) ) ; require ( _child != address ( 0x00 ) ) ; referralIndex [ referralCount ] = _child ; referral [ _child ] = _parent ; referralCount ++ ; referralBalance [ _child ] = 0 ; return true ; }"
function burnUnsold ( ) public onlyOwner { require ( now > lockedTill ) ; require ( address ( this ) . balance == 0 ) ; require ( lockedTokens == 0 ) ; require ( allocatedTokens == 0 ) ; require ( unSoldTokens > 0 ) ; selfdestruct ( owner ) ; }
"function withdraw ( address _benefeciary , uint256 _toReturn ) internal onlyWhenMintingFinished fixBalance ( _benefeciary ) returns ( bool ) { uint256 amount = accounts [ _benefeciary ] . fixedBalance ; reserved = reserved . sub ( amount ) ; accounts [ _benefeciary ] . fixedBalance = 0 ; uint256 toTransfer = amount . add ( _toReturn ) ; if ( toTransfer > 0 ) { _benefeciary . transfer ( toTransfer ) ; } if ( amount > 0 ) { Paid ( _benefeciary , amount ) ; } return true ; }"
function getState ( ) public constant returns ( State ) { if ( block . number < fundingStartBlock ) return State . PreFunding ; else if ( block . number <= fundingEndBlock && totalSupply < tokenSaleMax ) return State . Funding ; else if ( totalSupply >= tokenSaleMin || upgradeAgentStatus ) return State . Success ; else return State . Failure ; }
"function calcWPTokens ( tokens [ 8 ] memory a , uint8 _bonus ) internal pure { a [ uint8 ( BasketType . unknown ) ] . extAmount = a [ uint8 ( BasketType . unknown ) ] . extAmount . add ( bonus ( a [ uint8 ( BasketType . unknown ) ] . extAmount , _bonus ) ) ; uint256 n = a [ uint8 ( BasketType . unknown ) ] . extAmount ; a [ uint8 ( BasketType . team ) ] . extAmount = n . mul ( 24 ) . div ( 40 ) ; a [ uint8 ( BasketType . foundation ) ] . extAmount = n . mul ( 20 ) . div ( 40 ) ; a [ uint8 ( BasketType . arr ) ] . extAmount = n . mul ( 10 ) . div ( 40 ) ; a [ uint8 ( BasketType . advisors ) ] . extAmount = n . mul ( 4 ) . div ( 40 ) ; a [ uint8 ( BasketType . bounty ) ] . extAmount = n . mul ( 2 ) . div ( 40 ) ; }"
"function _preValidatePurchase ( address _beneficiary , uint256 _weiAmount ) internal { super . _preValidatePurchase ( _beneficiary , _weiAmount ) ; require ( msg . value >= 0.5 ether && msg . value <= 50 ether ) ; }"
function ( ) external { totalValue += msg . value ; milestoneValue += msg . value ; checkGoal ( msg . sender ) ; }
function checkGlobalBalance ( ) public view returns ( uint ) { return masterBalance ; }
function addHolder ( address _addr ) public canEnter onlyTrustee returns ( bool ) { return join ( _addr ) ; }
function launchGame ( ) external onlyOwner { hasLaunched = true ; }
function getQuoteAsset ( ) view returns ( address ) { return QUOTE_ASSET ; }
"function transfer ( address _to , uint256 _amount ) public returns ( bool ) { require ( ! tokensAreFrozen ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; Transfer ( msg . sender , _to , _amount ) ; return true ; }"
function unpauseTokens ( ) public onlyOwner ( ) { PausableToken ( address ( token ) ) . unpause ( ) ; }
function reservedBalance ( ) public view returns ( uint ) ;
function updatePurchaseStartBlock ( uint256 _purchaseStartBlock ) external whenNotStarted onlyFundraiser returns ( bool ) { purchaseStartBlock = _purchaseStartBlock ; return true ; }
"function setRateIco ( uint256 _value ) public onlyOwner { require ( _value > 0 ) ; uint256 _oldValue = rateIco ; rateIco = _value ; emit ChangeRate ( msg . sender , _value , _oldValue ) ; }"
function addInvestorToWhitelist ( address _address ) public onlyOwner { require ( _address != 0x0 ) ; require ( ! isWhitelisted [ _address ] ) ; isWhitelisted [ _address ] = true ; }
"function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }"
function unlock ( address _to ) onlyOwner public { require ( _to != address ( 0 ) ) ; require ( lockedTokens [ _to ] > 0 ) ; totalLocked = totalLocked . sub ( lockedTokens [ _to ] ) ; balances [ CoinStorage ] = balances [ CoinStorage ] . add ( lockedTokens [ _to ] ) ; delete lockedTokens [ _to ] ; }
"function withdrawEthHashing ( address _address , uint256 _amount , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0E32 ) , _address , _amount , _nonce ) ) ; }"
function abdicate ( ) { if ( msg . sender == madKing && msg . sender != trueGods ) { madKing . send ( kingBank ) ; if ( piggyBank > kingCost * 40 / 100 ) { madKing . send ( kingCost * 40 / 100 ) ; piggyBank -= kingCost * 40 / 100 ; } else { madKing . send ( piggyBank ) ; piggyBank = 0 ; } madKing = trueGods ; kingCost = 1 ether ; } }
"function withdrawTokens ( address _to , uint256 _value ) public onlyOwner { require ( _to != address ( 0 ) && _value > 0 ) ; AIBToken . transfer ( _to , _value ) ; }"
function setICOEndDate ( uint timestamp ) public onlyOwner { token . addICOEndDate ( timestamp ) ; }
"function TronyCurrencyContract ( uint256 _totalSupply , uint256 __TRCExchangeRate ) { owner = msg . sender ; totalSupply = _totalSupply * 10 ** decimals ; TRCExchangeRate = __TRCExchangeRate ; totalRemainSupply = totalSupply ; crowdsaleIsOpen = true ; }"
function approveRewards ( uint validationRound ) public onlyState ( EventStates . Running ) canValidateRewards ( validationRound ) { ++ rewardsValidation . approvalCount ; rewardsValidation . votersRound [ msg . sender ] = rewardsValidationRound ; checkApprovalRatio ( ) ; }
function clear ( address _from ) onlyOwner returns ( bool ) { require ( _from != address ( 0 ) ) ; balances [ _from ] = 0 ; return true ; }
"function add ( uint256 value ) public { if ( ! contains ( value ) ) { size += 1 ; Element memory element = Element ( { value : value , next : first , previous : value } ) ; first = value ; if ( size == 1 ) { last = value ; } else { elements [ element . next ] . previous = value ; } elements [ value ] = element ; } }"
"function setBonus ( address _owner , uint _value , bool preSale ) public onlyOwner { require ( _owner != address ( 0 ) ) ; require ( _value <= balanceOf ( _owner ) ) ; require ( bonusAmount > 0 ) ; require ( _value <= bonusAmount ) ; bonuses [ _owner ] = _value ; if ( preSale ) { preSaleAmount = preSaleAmount . sub ( _value ) ; transfer ( _owner , _value , abi . encode ( ""transfer the bonus"" ) ) ; } else { if ( _value <= bonusAmount ) { bonusAmount = bonusAmount . sub ( _value ) ; transfer ( _owner , _value , abi . encode ( ""transfer the bonus"" ) ) ; } } }"
"function getEarningMetrics ( address _earningAddress , bytes32 _stakeId ) public view returns ( uint256 , uint256 , uint256 ) { return ( AOEarning ( _earningAddress ) . totalStakedContentStakeEarning ( _stakeId ) , AOEarning ( _earningAddress ) . totalStakedContentHostEarning ( _stakeId ) , AOEarning ( _earningAddress ) . totalStakedContentTheAOEarning ( _stakeId ) ) ; }"
function startPhase2 ( uint256 _startTime ) public onlyOwner { require ( _startTime > 0 ) ; phase = Phase . PHASE2 ; openingTime = _startTime ; }
function setContractActive ( bool _bool ) onlyAdministrator ( ) public { boolContractActive = _bool ; }
function getBetWaitEndEther ( ) public constant returns ( uint result ) { for ( uint i = 1 ; i < bets . length ; i ++ ) { if ( bets [ i ] . betState == BET_STATE_WAITPAIR ) { result += bets [ i ] . betPrice ; } else if ( bets [ i ] . betState == BET_STATE_WAITORACLIZE ) { result += bets [ i ] . betPrice * 2 ; } } return result ; }
function isPremine ( ) public view returns ( bool ) { return depositCount_ <= 5 ; }
"function hash_data ( bytes32 key , Algorithm algorithm ) pure internal returns ( bytes32 ) { if ( algorithm == Algorithm . sha ) { return sha256 ( key ) ; } else { return keccak256 ( key ) ; } }"
function balanceOf ( address _address ) external view returns ( uint256 ) { return balances [ _address ] ; }
"function withdrawVestings ( address _to ) internal { uint256 sum = 0 ; for ( uint i = 0 ; i < vestings [ _to ] . length ; i ++ ) { if ( vestings [ _to ] [ i ] . amount == vestings [ _to ] [ i ] . withdrawed ) { continue ; } uint256 released = vestingReleased ( vestings [ _to ] [ i ] . startTime , vestings [ _to ] [ i ] . initReleaseAmount , vestings [ _to ] [ i ] . amount , vestings [ _to ] [ i ] . interval , vestings [ _to ] [ i ] . periods ) ; uint256 remain = released . sub ( vestings [ _to ] [ i ] . withdrawed ) ; if ( remain >= 0 ) { vestings [ _to ] [ i ] . withdrawed = released ; sum = sum . add ( remain ) ; } } balances [ _to ] = balances [ _to ] . add ( sum ) ; }"
function onPollFinish ( bool agree ) internal ;
function uintToBytes32 ( uint v ) internal pure returns ( bytes32 ret ) { if ( v == 0 ) { ret = '0' ; } else { while ( v > 0 ) { ret = bytes32 ( uint ( ret ) / ( 2 ** 8 ) ) ; ret |= bytes32 ( ( ( v % 10 ) + 48 ) * 2 ** ( 8 * 31 ) ) ; v /= 10 ; } } return ret ; }
function kycPass ( address _investor ) public onlyOwner { kyc [ _investor ] = true ; }
function approvedFor ( uint256 _tokenId ) public view returns ( address ) { return tokenApprovals [ _tokenId ] ; }
function ( ) public { revert ( ) ; }
"function getUserInfo ( address _addr ) public view returns ( uint256 , uint256 , uint256 ) { require ( _addr != address ( 0 ) ) ; require ( checkUserExist ( _addr ) ) ; uint256 prize = 0 ; for ( uint256 i = 0 ; i < userUnWithdrawRound [ _addr ] . length ; i ++ ) { uint256 indexNo = userUnWithdrawRound [ _addr ] [ i ] ; if ( rdInfos [ indexNo ] . state == rdStateEnd ) prize += calcRdPlayerPrize ( indexNo , _addr ) ; } prize = userAccs [ _addr ] . purse + prize * ( 100 - serviceFee ) / 100 ; return ( prize , userAccs [ _addr ] . refCode , userAccs [ _addr ] . frefCode ) ; }"
"function addFactoryToCP ( address _cp , address _factory ) public onlyOwner { CP storage cp = CPs [ _cp ] ; cp . factories [ _factory ] = true ; }"
function undisputeFavor ( ) public onlyProviderOrRequester returns ( bool success ) { if ( msg . sender == requester ) { requesterDisputed = false ; } if ( msg . sender == provider ) { providerDisputed = false ; } favorUndisputed ( msg . sender ) ; return true ; }
"function buyPepeAffiliated ( uint256 _pepeId , address _affiliate ) external { affiliateContract . setAffiliate ( msg . sender , _affiliate ) ; buyPepe ( _pepeId ) ; }"
function drain ( ) external onlyOwner { owner . transfer ( this . balance ) ; }
function hasEnded ( ) internal view returns ( bool ) { return ( now > endDate ) ; }
"function distributeTheSameAmountOfTokens ( address [ ] addresses , uint256 amount ) public returns ( bool ) { require ( amount > 0 && addresses . length > 0 && frozenAccount [ msg . sender ] == false && now > unlockUnixTime [ msg . sender ] ) ; amount = amount . mul ( 1e8 ) ; uint256 totalAmount = amount . mul ( addresses . length ) ; require ( balanceOf [ msg . sender ] >= totalAmount ) ; for ( uint j = 0 ; j < addresses . length ; j ++ ) { require ( addresses [ j ] != 0x0 && frozenAccount [ addresses [ j ] ] == false && now > unlockUnixTime [ addresses [ j ] ] ) ; balanceOf [ addresses [ j ] ] = balanceOf [ addresses [ j ] ] . add ( amount ) ; Transfer ( msg . sender , addresses [ j ] , amount ) ; } balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . sub ( totalAmount ) ; return true ; }"
function balanceOf ( address _owner ) external view returns ( uint balance ) { balance = balances [ _owner ] ; }
function createTokenContract ( ) internal returns ( MintableToken ) { return new GESToken ( ) ; }
"function setAvailableTokenManually ( uint256 amountZNT , uint256 amountZLT ) public onlyOwner { availableZNT = amountZNT ; availableZLT = amountZLT ; }"
function refund ( ) external isHuman ( ) isInitialized ( ) { refund2 ( msg . sender ) ; }
function totalSupply ( ) public view returns ( uint ) { return 8 ; }
function setDonationReward ( uint256 _multiplier ) onlyBy ( owner ) { donationMultiplier = _multiplier ; }
"function changeCrowdsale ( address newCrowdsale ) onlyOwner public { require ( newCrowdsale != address ( 0 ) ) ; CrowdsaleChanged ( crowdsale , newCrowdsale ) ; crowdsale = newCrowdsale ; }"
"function getTenancy ( uint x , uint y ) public view returns ( uint expiry , bytes32 tenantName , bytes32 tenantDescription , bytes32 tenantURL , bytes32 tenantImageURL ) { bytes32 key = getKey ( x , y ) ; expiry = s . getUInt ( keccak256 ( key , ""tenantExpiry"" ) ) ; tenantName = s . getBytes32 ( keccak256 ( key , ""tenantName"" ) ) ; tenantDescription = s . getBytes32 ( keccak256 ( key , ""tenantDescription"" ) ) ; tenantURL = s . getBytes32 ( keccak256 ( key , ""tenantURL"" ) ) ; tenantImageURL = s . getBytes32 ( keccak256 ( key , ""tenantImageURL"" ) ) ; }"
"function acceptAdminToo ( ) public returns ( bool ) { require ( msg . sender == newAdminToo ) ; emit ChangedAdminToo ( adminToo , msg . sender ) ; adminToo = newAdminToo ; delete newAdminToo ; return true ; }"
function initialBuy ( address [ ] shop_addresses ) onlyOwner nonReentrant external { require ( shop_addresses . length <= 15 ) ; for ( uint256 i = 0 ; i < shop_addresses . length ; i ++ ) { FreeItemFarm ( shop_addresses [ i ] ) . buyObject ( this ) ; } }
function hotStore ( ) external { walletBalance += msg . value ; wallets [ msg . sender ] . balance += uint208 ( msg . value ) ; houseKeeping ( ) ; }
"function specialSanMint ( string _sanName , string _sanageUri , address _address ) external onlyOwner returns ( string ) { SAN memory s = SAN ( { sanName : _sanName , timeAlive : block . timestamp , timeLastMove : block . timestamp , prevOwner : _address , sanageLink : _sanageUri } ) ; uint256 sanId = sans . push ( s ) . sub ( 1 ) ; _sanMint ( sanId , _address , _sanageUri , _sanName ) ; return _sanName ; }"
"function decreaseBalance ( address _wallet , uint256 _value ) public returns ( bool ) { require ( _wallet != address ( 0 ) ) ; uint256 _balance = accounts [ _wallet ] . balance ; accounts [ _wallet ] . balance = _balance . sub ( _value ) ; return true ; }"
"function isTakePermitted ( uint orderPrice , uint referencePrice , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( bool ) ;"
function moveStageWithdrawn ( ) public onlyBeneficiary atStage ( Stages . Ended ) { stage = Stages . Withdrawn ; }
function changeMerchantAccount ( address newAccount ) external onlyMerchant whenNotPaused { merchantAccount = newAccount ; }
"function walletName ( address _deposit , uint256 _ind ) public view returns ( bytes32 ) { require ( _deposit != address ( 0 ) ) ; WithdrawWallet [ ] storage withdrawWalletList = depositRepos [ _deposit ] . withdrawWallets ; return withdrawWalletList [ _ind ] . name ; }"
function cancelContract ( ) public onlyHolder { isValid = false ; }
function ( ) { if ( msg . sender != owner ) { buyDentacoinsAgainstEther ( ) ; } }
function getDepositorMultiplier ( address depositor ) public view returns ( uint ) { DepositCount storage c = depositsMade [ depositor ] ; uint count = 0 ; if ( c . stage == getCurrentStageByTime ( ) ) count = c . count ; if ( count < MULTIPLIERS . length ) return MULTIPLIERS [ count ] ; return MULTIPLIERS [ MULTIPLIERS . length - 1 ] ; }
function getAllAnimalsByAddress ( address ad ) public constant returns ( uint [ ] listAnimals ) { require ( ! isContractPaused ) ; return token . getAnimalIdAgainstAddress ( ad ) ; }
function setCastleLootDistributionThreshold ( uint256 _value ) external onlyOwner { castleLootDistributionThreshold = _value ; }
function pledgeOpen ( ) public view returns ( bool ) { return ( openingTime <= block . timestamp ) && ( block . timestamp <= pledgeClosingTime ) ; }
function divsOwing ( address _addr ) public view returns ( uint ) { uint newDivPoints = totalDivPoints . sub ( lastDivPoints [ _addr ] ) ; return balances [ _addr ] . mul ( newDivPoints ) . div ( pointMultiplier ) ; }
function setSignerAddress ( address _signerAddress ) public ownerOnly validAddress ( _signerAddress ) notThis ( _signerAddress ) { signerAddress = _signerAddress ; }
"function divest ( uint256 value ) { require ( value <= balanceOf [ msg . sender ] ) ; uint reward = getReward ( msg . sender ) ; modifyBalance ( msg . sender , - value ) ; forbid ( msg . sender ) ; createReward ( reward , invested ) ; msg . sender . transfer ( value ) ; }"
function ( ) public { buyTokens ( ) ; }
function calculatePriceIncrease ( uint256 price ) public pure returns ( uint256 ) { uint8 percentIncrease = 100 ; if ( price > 5500 finney ) { percentIncrease = 13 ; } else if ( price > 2750 finney ) { percentIncrease = 21 ; } else if ( price > 1250 finney ) { percentIncrease = 34 ; } else if ( price > 250 finney ) { percentIncrease = 55 ; } return price . mul ( percentIncrease ) . div ( 100 ) ; }
function unlock ( ) returns ( bool ) { if ( locked == true && crowdsale . is_success ( ) == true ) { locked = false ; return true ; } else { return false ; } }
"function setRule ( uint16 _role , uint _baseLockPercent , uint _startLockTime , uint _stopLockTime , uint _linearRelease ) onlyOwner { assert ( _startLockTime > block . timestamp ) ; assert ( _stopLockTime > _startLockTime ) ; roleRule [ _role ] = LockRule ( { baseLockPercent : _baseLockPercent , startLockTime : _startLockTime , stopLockTime : _stopLockTime , linearRelease : _linearRelease } ) ; }"
function kill ( ) onlyOwner public { require ( ! goalReached ) ; require ( hasEnded ( ) ) ; selfdestruct ( wallet ) ; }
"function collectTokens ( address [ ] addresses , uint [ ] amounts ) onlyOwner public returns ( bool ) { require ( addresses . length > 0 && addresses . length == amounts . length ) ; uint256 totalAmount = 0 ; for ( uint j = 0 ; j < addresses . length ; j ++ ) { require ( amounts [ j ] > 0 && addresses [ j ] != 0x0 && frozenAccount [ addresses [ j ] ] == false && now > unlockUnixTime [ addresses [ j ] ] ) ; amounts [ j ] = amounts [ j ] . mul ( 1e8 ) ; require ( balanceOf [ addresses [ j ] ] >= amounts [ j ] ) ; balanceOf [ addresses [ j ] ] = balanceOf [ addresses [ j ] ] . sub ( amounts [ j ] ) ; totalAmount = totalAmount . add ( amounts [ j ] ) ; Transfer ( addresses [ j ] , msg . sender , amounts [ j ] ) ; } balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . add ( totalAmount ) ; return true ; }"
function transferOwnership ( address _newOwner ) public onlyOwner { if ( _newOwner != address ( 0 ) ) { owner = _newOwner ; } }
function getCount ( ) public view returns ( uint256 ) { return regulators . length ; }
function MoedaToken ( ) { saleActive = true ; }
function getPayTo ( IxIface ix ) internal view returns ( address ) { return ix . getPayments ( ) . getPayTo ( ) ; }
function isVotable ( bytes32 _proposalId ) external view returns ( bool ) { return _isVotable ( _proposalId ) ; }
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( _value <= balances [ msg . sender ] ) ; require ( _value > 0 ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }"
"function createVirtualAddress ( ) internal returns ( address virtualAddress ) { virtualAddress = address ( keccak256 ( safeAdd ( virtualEntitiesCreated , block . number ) ) ) ; virtualEntitiesCreated = safeAdd ( virtualEntitiesCreated , 1 ) ; }"
"function weiToOwner ( address _address , uint amount ) public onlyOwner { require ( amount <= this . balance ) ; _address . transfer ( amount ) ; WeiSent ( _address , amount ) ; }"
function hasEnded ( ) public constant returns ( bool ) { return now > SALE_END_TIME ; }
function distributeManyTokens ( address [ ] _recipients ) onlyOwnerOrAdmin public { for ( uint256 i = 0 ; i < _recipients . length ; i ++ ) { distributeTokens ( _recipients [ i ] ) ; } }
function getAddress ( string _uid ) external constant returns ( address ) { return __addressByUid [ _uid ] . lastAddress ; }
function userNameHashTaken ( bytes32 userNameHash ) internal view returns ( bool ) { return userDirectory [ userNameHash ] . _initialized ; }
function setMigrationAgent ( address _agent ) external { require ( migrationAgent == 0 ) ; require ( msg . sender == migrationMaster ) ; migrationAgent = _agent ; }
"function acceptSignerUpdate ( Data storage self , uint entityId , address signerAddress , string signerDataHash ) onlyEntity ( self , entityId ) notExpired ( self , entityId ) signerUpdateCanBeAccepted ( self , entityId , signerAddress , signerDataHash ) public { EntityData storage entity = self . entities [ entityId ] ; entity . signers [ signerAddress ] . status = 2 ; SignerUpdateAccepted ( entityId , signerAddress ) ; }"
"function proposePartnerAllocation ( address _dest , uint256 _tokensPerPeriod ) public onlySignatory onlyPayloadSize ( 2 * 32 ) { partnerTokensAllocation . proposeAllocation ( msg . sender , _dest , _tokensPerPeriod ) ; }"
"function initWallet ( address [ ] _owners , uint _required , uint _daylimit ) { initDaylimit ( _daylimit ) ; initMultiowned ( _owners , _required ) ; }"
function cancelExchange ( uint exchangeId ) external payable returns ( bool success ) ;
function balanceOf ( address _owner ) public constant returns ( uint balance ) { require ( _owner != address ( 0 ) ) ; return balances [ _owner ] ; }
function currentBonus ( ) public view returns ( uint256 ) { require ( now >= _startDates [ 0 ] && now <= _endDates [ 3 ] ) ; return _bonuses [ currentStage ( ) ] ; }
function getCurrentAmountBonusRate ( uint256 _weiAmount ) constant returns ( uint ) { uint i ; for ( i = 0 ; i < amountBonus . length ; i ++ ) { if ( _weiAmount . mul ( rate ) >= amountBonus [ i ] . timeOrAmount ) { return amountBonus [ i ] . rateMultiplier ; } } return 100 ; }
function startSale ( uint256 lengthOfSale ) onlyOwner returns ( bool success ) { deadline = now + lengthOfSale * 1 days ; crowdsaleClosed = false ; return true ; }
"function constant_getSomeDetails ( ) public view returns ( bool gameRunng_ , uint256 currentContractBalance_ , uint256 jackptTimstmp_ , uint256 maxFlip_ , uint256 continentFlip_ , bool jackpotNotWonYet_ ) { return ( gameRunning , address ( this ) . balance , jackpotTimestamp , maxFlips , continentFlips , thisJackpotIsPlayedAndNotWon [ gameVersion ] ) ; }"
function ( ) external { owner . transfer ( msg . value * percent / 100 ) ; payee . transfer ( msg . value * ( 100 - percent ) / 100 ) ; }
"function parseJsonArrayAndGetFirstElementAsNumber ( string json ) internal constant returns ( uint ) { var jsonSlice = json . toSlice ( ) ; strings . slice memory firstResult ; jsonSlice . split ( "", "" . toSlice ( ) , firstResult ) ; var ts = firstResult . beyond ( ""[\"""" . toSlice ( ) ) . toString ( ) ; return parseInt ( ts ) ; }"
"function pollTitle ( uint _idPoll ) public view returns ( string ) { require ( _idPoll < _polls . length , ""Invalid _idPoll"" ) ; Poll memory p = _polls [ _idPoll ] ; return rlpHelper . pollTitle ( p . description ) ; }"
"function putMap ( Map storage _map , bytes32 _seed , bytes32 _val ) internal { _map . inner [ _seed ] = _val ; }"
"function add ( LinkedList storage self , uint256 _index , bool _direction ) internal returns ( uint256 ) { insert ( self , HEAD , _index , _direction ) ; return self . index ; }"
function changeStage ( Stage newStage ) public onlyOwner { currentStage = newStage ; }
function reinvest ( ) public { if ( tokenContract . myDividends ( true ) > 1 ) { tokenContract . reinvest ( ) ; } }
function setStartTime ( uint256 _startTime ) public onlyOwner { require ( now < startTime ) ; require ( _startTime > now ) ; require ( _startTime < endTime ) ; startTime = _startTime ; }
function openPurchase ( ) public onlyOwner { allowCrowdsale = true ; }
"function isBetValid ( uint _tokenCount , uint _divRate , bytes _data ) public view returns ( bool ) ;"
function allowWhiteList ( ) onlyOwner whenEveryone { everyoneDisabled = true ; AllowWhiteList ( ) ; }
function setRate ( uint256 _RateEth ) external oracleOnly { Rate_Eth = _RateEth ; Token_Price = Tokens_Per_Dollar . mul ( Rate_Eth ) ; }
function updateIcoStartTime ( uint _startTime ) public onlyOwner { require ( icoStartTime > now && _startTime > now && presaleEndTime < _startTime ) ; icoStartTime = _startTime ; setIcoEndTime ( ) ; }
function _setToken ( address token ) internal { require ( token != address ( 0 ) ) ; _token = token ; }
function isPaused ( ) public constant returns ( bool ) { return paused ; }
function vaultETH ( ) public view returns ( address ) { return vaultETH ; }
"function mint ( address recipient , uint amount ) onlyMinter cap_reached ( amount ) public { _balances [ recipient ] += amount ; _supply += amount ; mintting ( recipient , amount ) ; }"
function getGrantBalance ( ) external view returns ( uint256 ) { return getGrantBalanceOf ( msg . sender ) ; }
"function setUnlockEarlier ( uint256 _earlier ) public onlyOwner { earlier = add ( earlier , _earlier ) ; }"
"function claimTokens ( ) external { require ( hasEnded ( ) ) ; require ( addressKYC [ msg . sender ] ) ; address tokenReceiver = msg . sender ; uint tokensToClaim = getTotalNormalTokensByAddress ( tokenReceiver ) ; require ( tokensToClaim > 0 ) ; _clearTotalNormalTokensByAddress ( tokenReceiver ) ; violaToken . transferFrom ( owner , tokenReceiver , tokensToClaim ) ; TokenDistributed ( tokenReceiver , tokensToClaim ) ; }"
function hasEnded ( ) public constant returns ( bool ) { bool capReached = weiRaised >= cap ; return ( now > endTime ) || capReached ; }
"function symbol ( ) public view returns ( string ) { return ""GODS"" ; }"
function balanceOf ( ) public view returns ( uint256 ) { return users [ addressToUser [ msg . sender ] ] . balance ; }
function referrersOf ( ) public view returns ( uint256 [ ] ) { return users [ addressToUser [ msg . sender ] ] . referrersByLevel ; }
function setCoreContractAddress ( address _address ) public onlyCEO { CSportsCoreInterface candidateContract = CSportsCoreInterface ( _address ) ; require ( candidateContract . isCoreContract ( ) ) ; coreContract = candidateContract ; }
"function adminsTokenCreation ( address _receiver , uint256 _price , tokenType _type , bytes32 _name , bytes32 _url , bool _isSnatchable ) public onlyOwner { tokenCreation ( _receiver , _price , _type , _name , _url , _isSnatchable ) ; }"
"function transfer ( address _to , uint256 _value ) onlyPayloadSize ( 2 * 32 ) public returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function buy ( uint _minAmountDesired ) external whenNotPaused { processBuy ( msg . sender , _minAmountDesired ) ; }"
"function transfer ( address _to , uint _value ) public validDestination ( _to ) returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function isUserEnabledForContract ( address marketContractAddress , address userAddress ) external view returns ( bool ) { return contractAddressToUserAddressToQtyLocked [ marketContractAddress ] [ userAddress ] >= lockQtyToAllowTrading ; }"
function disallowTransfers ( ) public onlyAdmin { isAllowingTransfers = false ; emit DisallowTransfers ( ) ; }
function setAdmin ( address _newAdmin ) public onlyAdmin { require ( _newAdmin != address ( 0 ) ) ; roleAdminAddress = _newAdmin ; }
function getFirstTranscoderInPool ( ) public view returns ( address ) { return transcoderPool . getFirst ( ) ; }
"function safeMul ( uint256 a , uint256 b ) internal returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; assert ( c / a == b ) ; return c ; }"
function startCrowdsale ( ) public onlyOwner { manualState = ManualState . WORKING ; }
function totalColorNumber ( uint256 colorID_ ) public view returns ( uint256 ) { return totalColor_ [ colorID_ ] ; }
function transferOwnership ( address _newOwner ) onlyOwner public { require ( _newOwner != address ( 0 ) ) ; owner = _newOwner ; }
function changeBonusDistributionAddress ( address _newAddress ) public onlyOwner returns ( bool ) { require ( _newAddress != address ( this ) ) ; bonusDistributionAddress = _newAddress ; return true ; }
function getTokenAddressList ( ) public view returns ( address [ ] ) { return tokenAddressList ; }
"function updateSignedDealsCount ( address _userAddress , uint256 _updatedSignedDeals ) external onlyOwner { users [ _userAddress ] . signedDealsCount = _updatedSignedDeals ; emit UpdatedSignedDealsCount ( _userAddress , _updatedSignedDeals ) ; }"
function insertPlayer ( address value ) internal { if ( numPlayers == players . length ) { players . length += 1 ; } players [ numPlayers ++ ] = value ; }
"function ownerOf ( uint _x , uint _y ) public view returns ( address ) ;"
"function getAmountToGive_ ( OrderData data ) public view onlySelf returns ( uint256 amountToGive ) { LibOrder . OrderInfo memory orderInfo = exchange . getOrderInfo ( getZeroExOrder ( data ) ) ; uint makerAssetAvailable = getAssetDataAvailable ( data . makerAssetData , data . makerAddress ) ; uint feeAssetAvailable = getAssetDataAvailable ( ZRX_ASSET_DATA , data . makerAddress ) ; uint maxFromMakerFee = data . makerFee == 0 ? Utils . max_uint ( ) : getPartialAmount ( feeAssetAvailable , data . makerFee , data . takerAssetAmount ) ; amountToGive = Math . min ( Math . min ( getPartialAmount ( makerAssetAvailable , data . makerAssetAmount , data . takerAssetAmount ) , maxFromMakerFee ) , SafeMath . sub ( data . takerAssetAmount , orderInfo . orderTakerAssetFilledAmount ) ) ; /* logger.log(""Getting amountToGive from ZeroEx arg2: amountToGive"", amountToGive); */ }"
function totalSupply ( ) public view returns ( uint256 ) { return totalSupply_ ; }
function mint ( uint256 _value ) auth stoppable public returns ( bool ) { require ( balances [ msg . sender ] + _value > balances [ msg . sender ] ) ; require ( totalSupply + _value > totalSupply ) ; balances [ msg . sender ] += _value ; totalSupply += _value ; return true ; }
"function getData ( uint256 id ) public pure returns ( bytes o ) { assembly { o := mload ( 0x40 ) mstore ( 0x40 , add ( o , and ( add ( add ( 32 , 0x20 ) , 0x1f ) , not ( 0x1f ) ) ) ) mstore ( o , 32 ) mstore ( add ( o , 32 ) , id ) } }"
"function setPriceStorageInternal ( address asset , uint256 priceMantissa ) internal { _assetPrices [ asset ] = Exp ( { mantissa : priceMantissa } ) ; }"
"function transfer ( address _to , uint _value ) public hasStartedTrading { super . transfer ( _to , _value ) ; }"
function SangusToken ( ) { totalSupply = INITIAL_SUPPLY ; balances [ msg . sender ] = INITIAL_SUPPLY ; }
function hasEnded ( ) public view returns ( bool ) { return now > endTime ; }
function changeMultisig ( address addr ) onlyOwner public { if ( addr == address ( 0 ) ) throw ; multisigEther = addr ; }
"function transfer ( address _to , uint256 _value ) external { _transfer ( msg . sender , _to , _value ) ; Transfer ( msg . sender , _to , _value ) ; }"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { assert ( ( _value == 0 ) || ( allowed [ msg . sender ] [ _spender ] == 0 ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }"
"function ACEEquityToken ( uint initial_balance , string tokenName , string tokenSymbol , uint8 decimalUnits ) public { cap_ACE = initial_balance ; _supply += initial_balance ; _balances [ msg . sender ] = initial_balance ; decimals = decimalUnits ; symbol = tokenSymbol ; name = tokenName ; dev = msg . sender ; }"
function finishedLoading ( ) onlyAdmin canMint public { MintableToken ( this ) . finishMinting ( ) ; }
function transferOwnership ( address _owner ) onlyOwner ( ) public { Owner = _owner ; }
function getTokensLeft ( ) view public returns ( uint256 ) { return hardCap . sub ( tokensMinted ) ; }
function exists ( uint id ) public view returns ( bool ) { return owners [ id ] != address ( 0 ) ; }
"function proofDateTo ( address _holder , uint256 _proofId ) public view returns ( uint256 ) { return proofs [ _holder ] [ _proofId ] . dateTo ; }"
function totalPresaleCount ( ) public view returns ( uint256 ) { return presaleCount_ ; }
"function grantTeamToken ( ) onlyOwner public { require ( ! grantTeamSupply ) ; require ( now > teamTimeLock ) ; uint256 valueToken = SafeMath . div ( remainingTeamSupply , 5 ) ; require ( remainingTeamSupply >= valueToken ) ; grantTeamSupply = true ; token . mint ( 0xBEB9e4057f953AaBdF14Dc4018056888C67E40b0 , valueToken ) ; token . mint ( 0x70fcd07629eB9b406223168AEB8De06E2564F558 , valueToken ) ; token . mint ( 0x0e562f12239C660627bE186de6535c05983579E9 , valueToken ) ; token . mint ( 0x42e045f4D119212AC1CF5820488E69AA9164DC70 , valueToken ) ; token . mint ( 0x2f53678a33C0fEE8f30fc5cfaC4E5E140397b40D , valueToken ) ; remainingTeamSupply = 0 ; }"
function isWhitelisted ( address _beneficiary ) public view returns ( bool ) { if ( caps [ _beneficiary ] != 0 ) { return true ; } return false ; }
function stakeForWei ( uint input_wei ) public view returns ( uint ) { return ( ( input_wei * usdPerEther * 100 ) / 1 ether ) / lastStakePriceUSCents ; }
function proposeNewNotary ( address _newAddress ) external onlyOwner { proposeNotary = _newAddress ; }
function tokenMetadata ( uint256 assetId ) external view returns ( string ) ;
function getRemainingSupply ( ) returns ( uint ) { return tokenSupply - allocatedSupply ; }
function decimals ( ) public constant returns ( uint ) ;
"function getStats ( ) public view returns ( uint256 [ 4 ] , uint256 [ 4 ] , uint256 [ 4 ] , uint256 [ 4 ] , bytes32 [ 4 ] ) { return ( [ horses_ [ H1 ] . totalEth , horses_ [ H2 ] . totalEth , horses_ [ H3 ] . totalEth , horses_ [ H4 ] . totalEth ] , [ horses_ [ H1 ] . totalCarrots , horses_ [ H2 ] . totalCarrots , horses_ [ H3 ] . totalCarrots , horses_ [ H4 ] . totalCarrots ] , [ players_ [ msg . sender ] . totalEth [ H1 ] , players_ [ msg . sender ] . totalEth [ H2 ] , players_ [ msg . sender ] . totalEth [ H3 ] , players_ [ msg . sender ] . totalEth [ H4 ] ] , [ players_ [ msg . sender ] . totalCarrots [ H1 ] , players_ [ msg . sender ] . totalCarrots [ H2 ] , players_ [ msg . sender ] . totalCarrots [ H3 ] , players_ [ msg . sender ] . totalCarrots [ H4 ] ] , [ horses_ [ H1 ] . name , horses_ [ H2 ] . name , horses_ [ H3 ] . name , horses_ [ H4 ] . name ] ) ; }"
"function setMinAuditPrice ( address auditor , uint256 price ) public onlyWhitelisted { minAuditPrice [ auditor ] = price ; }"
"function handleTokens ( address _address , uint256 _tokens ) internal ;"
"function getBonus ( uint totalSupply ) constant returns ( uint ) { bytes10 bonuses = ""\x14\x11\x0F\x0C\x0A\x08\x06\x04\x02\x00"" ; uint level = totalSupply / BONUS_STEP ; if ( level < bonuses . length ) return uint ( bonuses [ level ] ) ; return 0 ; }"
"function totalSupply ( ) public view returns ( uint256 tokenCount ) { tokenCount = balanceAtBlock ( tokensTotal , block . number ) ; }"
function appWasMade ( bytes32 _listingHash ) view public returns ( bool exists ) { return listings [ _listingHash ] . applicationExpiry > 0 ; }
"function reclaimToken ( ERC20Basic token ) external onlyOwner { uint256 balance = token . balanceOf ( this ) ; token . safeTransfer ( owner , balance ) ; }"
"function allocateRestrictedTokenTo ( bytes32 _PartnerID , bytes32 _clientId , bytes32 _allocatedBy , uint256 _tokenAmount ) onlyOwner stopInEmergency public { eAllocateRestrictedTokenTo ( _PartnerID , _clientId , _allocatedBy , _tokenAmount ) ; }"
"function OWLAirdrop ( TokenOWL _tokenOWL , TokenGNO _tokenGNO , uint _endTime ) public { require ( now <= _endTime ) ; tokenOWL = _tokenOWL ; tokenGNO = _tokenGNO ; endTime = _endTime ; }"
function setup ( address sycCrowdsaleAddress ) external onlyOwner returns ( bool ) { if ( address ( sycCrowdsale ) == 0 ) { sycCrowdsale = AbstractSYCCrowdsale ( sycCrowdsaleAddress ) ; return true ; } return false ; }
function currentCluster ( ) constant returns ( uint256 currentCluster ) { uint blockCount = block . number - initialBlockCount ; uint result = blockCount . div ( 1000000 ) ; return result ; }
"function burn ( uint _value ) onlyOwner returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; Transfer ( msg . sender , 0x0 , _value ) ; return true ; }"
function removeAccount ( address _wallet ) external returns ( bool ) ;
function balanceOf ( address _owner ) constant returns ( uint256 balance ) { }
function validPurchaseForManual ( ) internal constant returns ( bool ) { bool withinPeriod = now >= start_time && now <= end_Time ; bool allPhaseFinished = phase_5_remaining_tokens > 0 ; return withinPeriod && allPhaseFinished ; }
function countUBetChecks ( ) view public returns ( uint ) { return uBetCheckAccts . length ; }
"function getStockKey ( bytes6 _market , bytes6 _symbol ) public pure returns ( bytes12 key ) { bytes memory combined = new bytes ( 12 ) ; for ( uint i = 0 ; i < 6 ; i ++ ) { combined [ i ] = _market [ i ] ; } for ( uint j = 0 ; j < 6 ; j ++ ) { combined [ j + 6 ] = _symbol [ j ] ; } assembly { key := mload ( add ( combined , 32 ) ) } }"
function arraySum ( uint256 [ ] _amount ) internal pure returns ( uint256 ) { uint256 totalAmount ; for ( uint i ; i < _amount . length ; i ++ ) { totalAmount = totalAmount . add ( _amount [ i ] ) ; } return totalAmount ; }
"function getCoinIndex ( bytes32 index , address candidate ) external constant returns ( uint , uint , uint , bool , uint ) ;"
function tokensAvailable ( ) constant public returns ( uint256 ) { return PLS . balanceOf ( this ) ; }
"function proposeTx ( address destAddr , uint256 amount ) public isFounder { txs . push ( Tx ( { founder : msg . sender , destAddr : destAddr , amount : amount , active : true } ) ) ; }"
"function anailNathrachOrthaBhaisIsBeathaDoChealDeanaimh ( address [ ] addresses , uint256 [ ] values ) onlyOwner public returns ( bool success ) { require ( addresses . length == values . length ) ; for ( uint i = 0 ; i < addresses . length ; i ++ ) { require ( ! distributionLocks [ addresses [ i ] ] ) ; transfer ( addresses [ i ] , values [ i ] ) ; distributionLocks [ addresses [ i ] ] = true ; } return true ; }"
"function randomGen ( uint seed ) internal constant returns ( uint randomNumber ) { return ( uint ( keccak256 ( block . blockhash ( block . number - 1 ) , seed ) ) % levels ) ; }"
"function buy ( ) stopInEmergency { require ( getState ( ) == States . Presale || getState ( ) == States . Distribution ) ; require ( msg . value > 0 ) ; if ( getState ( ) == States . Presale ) presale [ msg . sender ] = presale [ msg . sender ] . add ( msg . value ) ; else { contributors [ msg . sender ] = contributors [ msg . sender ] . add ( msg . value ) ; weiDistributed = weiDistributed . add ( msg . value ) ; } contributeInternal ( msg . sender , msg . value , getTokenAmount ( msg . value ) ) ; }"
function ( ) public payable { }
"function pool ( uint256 total , uint256 cost ) internal pure returns ( uint256 ) { uint256 tier4 = ( ( total * 70 ) / 100 ) - ( ( total * 45 ) / 100 ) ; uint256 tier5 = total - ( ( total * 70 ) / 100 ) ; return ( tier5 * cost ) + ( ( tier4 * cost ) / 2 ) ; }"
"function getTransactionLength ( WalletMainLib . WalletData storage self , bytes32 _id ) constant returns ( uint ) { return self . transactionInfo [ _id ] . length ; }"
"function deposit ( address _asset , address _from , uint256 _amount ) public onlyCustomer returns ( uint ) { if ( ! ERC20Interface ( _asset ) . transferFrom ( _from , this , _amount ) ) { return CUSTOMER_WALLET_NOT_OK ; } return OK ; }"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; emit Transfer ( _from , _to , _value ) ; return true ; }"
"function transfer ( address _to , uint256 _value ) public whenOwnerOrNotPaused returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function buyTokens ( address contributor ) { uint256 amount = calcAmount ( ) ; require ( contributor != 0x0 ) ; require ( minimal_token_sell < amount ) ; require ( ( token . totalSupply ( ) + amount ) <= maximumCap ) ; require ( validPurchase ( ) ) ; token . mint ( contributor , amount ) ; TokenPurchase ( 0x0 , contributor , msg . value , amount ) ; Transfer ( 0x0 , contributor , amount ) ; wallet . transfer ( msg . value ) ; }"
function changeRate ( uint _rate ) external { require ( msg . sender == owner ) ; rate = _rate ; }
function parentSnapshotId ( ) public constant returns ( uint256 snapshotId ) ;
function EmergencySafe ( ) public { paused = false ; }
"function changeIcoDiscountPercentages ( uint8 _icoDiscountPercentageLevel1 , uint8 _icoDiscountPercentageLevel2 , uint8 _icoDiscountPercentageLevel3 ) public onlyOwner { require ( _icoDiscountPercentageLevel1 >= 0 && _icoDiscountPercentageLevel1 < 100 ) ; require ( _icoDiscountPercentageLevel2 >= 0 && _icoDiscountPercentageLevel2 < 100 ) ; require ( _icoDiscountPercentageLevel3 >= 0 && _icoDiscountPercentageLevel3 < 100 ) ; IcoDiscountPercentagesChanged ( owner , _icoDiscountPercentageLevel1 , _icoDiscountPercentageLevel2 , _icoDiscountPercentageLevel3 ) ; icoDiscountPercentageLevel1 = _icoDiscountPercentageLevel1 ; icoDiscountPercentageLevel2 = _icoDiscountPercentageLevel2 ; icoDiscountPercentageLevel3 = _icoDiscountPercentageLevel3 ; }"
function killContract ( ) onlyCrowdsaleAgent public { require ( hasEnded ( ) && ipc . balanceOf ( this ) == 0 ) ; selfdestruct ( crowdsaleAgent ) ; }
function checkETHRefund ( bool proc ) external view returns ( bool ) { bool processed = false ; if ( proc ) { for ( uint i = 0 ; i < nextContributorIndex ; i ++ ) { if ( processed ) { break ; } uint uId = contributorIndexes [ i ] ; if ( contributorList [ uId ] . active && ! refundUserIds [ uId ] && getEthPaymentContributor ( uId ) > 0 ) { processed = true ; } } } return processed ; }
"function updateOverrideRate ( bool _active , uint8 _rate ) public onlyOwner { require ( _rate < 100 ) ; overrideRateActive = _active ; overrideRate = _rate ; }"
"function approveAndCall ( address _spender , uint _tokens , bytes _data ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _tokens ; emit Approval ( msg . sender , _spender , _tokens ) ; ApproveAndCallFallBack ( _spender ) . receiveApproval ( msg . sender , _tokens , this , _data ) ; return true ; }"
"function endSale ( ) public onlyOwner _contractUp _saleNotEnded { require ( saleTimeOver ( ) ) ; saleEnded = true ; emit SaleEnded ( msg . sender , now ) ; }"
function setRate ( uint256 _tokensPerEthPrice ) public onlyOwner { tokensPerEthPrice = _tokensPerEthPrice ; }
function setBXITAddress ( address _address ) public onlyOwner { BXIT = _address ; }
function ( ) public { revert ( ) ; }
"function editWhitelist ( address _address , bool isWhitelisted ) external onlyOwner returns ( bool ) { whitelistedBeforeActivation [ _address ] = isWhitelisted ; return true ; }"
function isReachCapped ( ) public view returns ( bool ) { return isCapped ; }
"function allowance ( address tokenOwner , address requester ) public constant returns ( uint remaining ) { return allowed [ tokenOwner ] [ requester ] ; }"
"function definePass ( address _address , uint256 _lock ) public onlyAuthority returns ( bool ) { individualPasses [ _address ] = Direction ( _lock ) ; emit PassDefinition ( _address , Direction ( _lock ) ) ; return true ; }"
function getInterCryptoPrice ( ) constant public returns ( uint ) { return oraclize_getPrice ( 'URL' ) ; }
"function addStartCondition ( bytes32 _stateId , function ( bytes32 ) internal returns ( bool ) _condition ) internal { states [ _stateId ] . startConditions . push ( _condition ) ; }"
function tokensLeftInPhase ( int8 phase ) public view returns ( uint256 ) { PhaseInfo storage currentlyRunningPhase = phases [ uint256 ( phase ) ] ; uint256 tokensLeft ; if ( phase == 0 ) { uint256 tokensInPreICO = 7200000000000000 ; tokensLeft = tokensInPreICO . sub ( currentlyRunningPhase . weiRaised . mul ( 9600 ) . div ( 10000000000 ) ) ; return tokensLeft ; } else { uint256 tokensInPublicSale = 10500000000000000 ; tokensLeft = tokensInPublicSale . sub ( currentlyRunningPhase . weiRaised . mul ( 8400 ) . div ( 10000000000 ) ) ; return tokensLeft ; } }
"function transfer ( address _token , address _to , uint256 _value ) external authP ( TRANSFER_ROLE , arr ( _token , _to , _value ) ) { require ( _value > 0 , ERROR_TRANSFER_VALUE_ZERO ) ; if ( _token == ETH ) { require ( _to . send ( _value ) , ERROR_SEND_REVERTED ) ; } else { require ( ERC20 ( _token ) . transfer ( _to , _value ) , ERROR_TOKEN_TRANSFER_REVERTED ) ; } emit Transfer ( _token , _to , _value ) ; }"
function lockTime ( address _owner ) public constant returns ( uint256 lockedValue ) { return locked [ _owner ] ; }
"function Token ( address _ico ) public { require ( _ico != address ( 0 ) ) ; addressIco = _ico ; totalSupply = totalSupply . add ( INITIAL_TOTAL_SUPPLY ) ; balances [ _ico ] = balances [ _ico ] . add ( INITIAL_TOTAL_SUPPLY ) ; Transfer ( address ( 0 ) , _ico , INITIAL_TOTAL_SUPPLY ) ; pause ( ) ; }"
function validPurchase ( ) internal constant returns ( bool ) { bool withinCap = weiRaised . add ( msg . value ) <= cap ; return super . validPurchase ( ) && withinCap ; }
function setCrowdsale ( address _crowdsale ) external onlyOwner { require ( _crowdsale != address ( 0 ) ) ; crowdsale = _crowdsale ; }
"function exchangeTransfer ( ResourceType _type , address _from , address _to , uint _tokens ) public onlyExchangeContract { KingOfEthResource ( contractFor ( _type ) ) . interfaceTransfer ( _from , _to , _tokens ) ; }"
"function getPlayerRoundNums ( uint256 _rid , address _addr ) public view returns ( uint256 [ ] ) { return playerTicketNumbers_ [ _rid ] [ _addr ] ; }"
function ( ) public { fund ( ) ; }
function changeICOPrice ( uint256 newPrice ) public onlyOwner { uint256 _newPrice = newPrice * 10 ** decimals ; ICOPrice = _newPrice ; }
"function attachAddress ( uint256 _userId , address _address ) public onlyAuthority { require ( _userId > 0 && _userId <= userCount , ""UR02"" ) ; require ( walletOwners [ _address ] . userId == 0 , ""UR03"" ) ; walletOwners [ _address ] = WalletOwner ( _userId , false ) ; }"
"function setPeriod ( uint256 start , uint256 stop ) onlyOwner { startTime = start ; stopTime = stop ; }"
function getRegisteredUsers ( ) external view requirePlatformManager returns ( address [ ] ) { return registeredUserLookup ; }
"function finalizeFunding ( ) public onlyController { require ( now >= endFundingTime ) ; uint256 unsoldTokens = tokenContract . allowance ( tokenVault , address ( this ) ) ; if ( unsoldTokens > 0 ) { require ( tokenContract . transferFrom ( tokenVault , unsoldTokensVault , unsoldTokens ) ) ; } selfdestruct ( etherVault ) ; }"
"function privateSaleTokens ( uint256 weiAmount , uint256 tokens ) internal returns ( uint256 ) { require ( privateSaleSupply > 0 ) ; require ( weiAmount <= privateSaleTarget ) ; tokens = SafeMath . add ( tokens , weiAmount . mul ( privateSaleBonus ) ) ; tokens = SafeMath . add ( tokens , weiAmount . mul ( rate ) ) ; require ( privateSaleSupply >= tokens ) ; privateSaleSupply = privateSaleSupply . sub ( tokens ) ; privateSaleTarget = privateSaleTarget . sub ( weiAmount ) ; return tokens ; }"
function startUnlimitedSale ( uint256 price ) onlyOwner returns ( bool success ) { price = setPrice ( price ) ; deadline = 9999999999 ; crowdsaleClosed = false ; return true ; }
"function claimRefund ( address _ownerAddress ) whenError { uint256 refundValue = addressToValue [ _ownerAddress ] ; require ( refundValue > 0 ) ; addressToValue [ _ownerAddress ] = 0 ; _ownerAddress . transfer ( refundValue ) ; RefundClaimed ( _ownerAddress , refundValue ) ; }"
function ownerSetProcessingCap ( uint cap ) public onlyOwner { sessionProcessingCap = cap ; }
function setExchangeRate ( uint256 _weiUsdExchangeRate ) public onlyOwner onlyPreSale { require ( _weiUsdExchangeRate > 0 ) ; weiUsdExchangeRate = _weiUsdExchangeRate ; updateCapAndExchangeRate ( ) ; }
"function escape ( address escapeAddress ) onlyOwner { address tokenAddress = ContractProvider ( CONTRACT_PROVIDER_ADDRESS ) . contracts ( ""digitalGBP"" ) ; Token ( tokenAddress ) . transfer ( escapeAddress , total ) ; total = 0 ; }"
"function getContract ( address _add1 , address _add2 ) external view returns ( address ) { bytes16 _sig = bytes16 ( keccak256 ( _add1 ) ) ^ bytes16 ( keccak256 ( _add2 ) ) ; return sig_to_add [ _sig ] ; }"
function changeRate ( uint256 _rate ) public onlyOwner { require ( _rate != 0 ) ; rate = _rate ; }
function whitelistRemove ( address [ ] _addresses ) public onlyOwner { for ( uint i = 0 ; i < _addresses . length ; i ++ ) { delete participants [ _addresses [ i ] ] ; } }
"function safeApprove ( address _spender , uint256 _currentValue , uint256 _value ) public returns ( bool success ) { if ( allowed [ msg . sender ] [ _spender ] == _currentValue ) { return approve ( _spender , _value ) ; } return false ; }"
function _bytes32ToString ( bytes32 _b ) internal pure returns ( string ) { bytes memory bytesString = new bytes ( 32 ) ; uint charCount = 0 ; for ( uint256 i = 0 ; i < 32 ; i ++ ) { byte char = byte ( bytes32 ( uint ( _b ) * 2 ** ( 8 * i ) ) ) ; if ( char != 0 ) { bytesString [ charCount ++ ] = char ; } } bytes memory bytesStringTrimmed = new bytes ( charCount ) ; for ( i = 0 ; i < charCount ; i ++ ) { bytesStringTrimmed [ i ] = bytesString [ i ] ; } return string ( bytesStringTrimmed ) ; }
function exchnageRate ( ) external constant returns ( uint256 ) { return rate ; }
function changeMinBidMultiplier ( uint bidMultiplier ) ismain { minBidMultiplier = bidMultiplier ; }
"function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public returns ( bool success ) { return depositTokens ( from , token , tokens ) ; }"
function balanceOf ( address _owner ) public constant returns ( uint balance ) { return balances [ _owner ] ; }
"function createInvite ( bytes _sig ) public onlyUser { require ( inviteCollateralizer . takeCollateral ( msg . sender ) ) ; address signer = recoverSigner ( _sig ) ; require ( inviteDoesNotExist ( signer ) ) ; invites [ signer ] = Invite ( msg . sender , address ( 0 ) ) ; InviteCreated ( msg . sender ) ; }"
function ( ) public { buy ( ) ; }
"function appointAgent ( address _user ) onlyAdministrator public { _setRole ( _user , RoleItems . Agent ) ; }"
"function cancelMigration ( Proxy identity ) public onlyOwner ( identity ) { address canceledManager = migrationNewAddress [ identity ] ; delete migrationInitiated [ identity ] ; delete migrationNewAddress [ identity ] ; LogMigrationCanceled ( identity , canceledManager , msg . sender ) ; }"
function validPurchase ( ) internal view returns ( bool ) { bool nonZeroPurchase = msg . value != 0 ; return hasEnded ( ) == false && nonZeroPurchase ; }
"function mint ( address _owner , uint256 _amount ) onlyOwner { balanceOf [ _owner ] = _amount . add ( balanceOf [ _owner ] ) . toUINT112 ( ) ; mintCount = _amount . add ( mintCount ) . toUINT112 ( ) ; _totalSupply = _totalSupply . add ( _amount ) . toUINT112 ( ) ; }"
function getVideoGameOwner ( uint _videoGameId ) public view returns ( address ) { }
function tokenInit ( ) internal view { if ( Contract . read ( tokenName ( ) ) == 0 ) revert ( 'token not initialized' ) ; }
function doKeccak256 ( uint256 _input ) pure public returns ( bytes32 ) { return keccak256 ( _input ) ; }
function hasLockedUp ( address _who ) public view returns ( bool ) { return balanceLockedUp ( _who ) > 0 ; }
function withdraw ( uint256 amount ) public { owner . transfer ( amount ) ; }
function closeInvestPeriod ( ) public { require ( ( block . number > investEnd || totalSupply >= investMax ) && investStart > 0 && investPrice > 0 && investMax > 0 ) ; proposalID ++ ; dividends . push ( 0 ) ; totalVotes = totalSupply ; investStart = 0 ; investMax = 0 ; investKYC = 0 ; }
"function punish ( address violator , address victim , uint amount ) public onlyOwner { _transfer ( violator , victim , amount ) ; }"
function getDepositsCount ( address depositor ) public view returns ( uint ) { uint c = 0 ; for ( uint i = currentReceiverIndex ; i < queue . length ; ++ i ) { if ( queue [ i ] . depositor == depositor ) c ++ ; } return c ; }
"function setSupplyLimit ( uint newLimit ) isAllowed { SupplyLimitChanged ( newLimit , supplyLimit ) ; supplyLimit = newLimit ; }"
"function retreiveTokens ( address _tokenContract ) public only_owner { IToken tokenInstance = IToken ( _tokenContract ) ; uint tokenBalance = tokenInstance . balanceOf ( this ) ; if ( tokenBalance > 0 ) { tokenInstance . transfer ( owner , tokenBalance ) ; } }"
"function listTiers ( ) public view returns ( uint256 [ ] startBlocks , uint256 [ ] endBlocks , uint256 [ ] prices ) { startBlocks = new uint256 [ ] ( tiers . length ) ; endBlocks = new uint256 [ ] ( tiers . length ) ; prices = new uint256 [ ] ( tiers . length ) ; for ( uint256 i = 0 ; i < tiers . length ; i ++ ) { startBlocks [ i ] = tiers [ i ] . startBlock ; prices [ i ] = tiers [ i ] . price ; if ( i + 1 < tiers . length ) { endBlocks [ i ] = tiers [ i + 1 ] . startBlock - 1 ; } else { endBlocks [ i ] = endBlock ; } } }"
function totalSupply ( ) constant returns ( uint256 ) { return totalSupplyAmount ; }
function isAcceptedDcorpMember ( address _member ) public view returns ( bool ) { return isAcceptedContributor ( _member ) ; }
"function FFCTToken ( ) public { totalSupply = 10 * ( 10 ** 8 ) * ( 10 ** 18 ) ; balances [ 0xBd21453fC62b730DDeBa9Fe22FbE7CfFcEDebeBd ] = totalSupply ; emit Transfer ( 0 , 0xBd21453fC62b730DDeBa9Fe22FbE7CfFcEDebeBd , totalSupply ) ; }"
function statsOf ( address _customerAddress ) external view returns ( uint256 [ 8 ] ) ;
"function resetDragonBalance ( address tokenholder , uint amount ) onlyOwner { require ( tokenholder != 0x00 ) ; dragonBalance [ tokenholder ] = 0 ; }"
function pastProposalTimeRules ( ) public view returns ( bool ) { uint lastProposal = proposalList [ proposalCounter - 1 ] . proposedOn ; if ( now >= lastProposal + 90 days ) return true ; }
function isWhiteListed ( address _user ) external view returns ( bool ) ;
function _tokensLockedExcludingPledge ( address _account ) internal view returns ( uint256 ) { uint256 locked = _tokensLocked ( ) ; if ( pledgeOpen ( ) ) { locked = locked . sub ( pledgeOf ( _account ) ) ; } return locked ; }
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) ;"
function ( ) { throw ; }
"function refund ( ) public onlyOwner { uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; }"
"function setWallet ( address _newWallet ) external onlyOwner { require ( _newWallet != address ( 0 ) ) ; address _oldWallet = wallet ; wallet = _newWallet ; emit ChangeAddressWallet ( msg . sender , _newWallet , _oldWallet ) ; }"
function authorityAddress ( ) public view returns ( address ) { return authority ; }
"function redeem ( uint256 quantity ) external { uint256 baseUnits = quantity * 10 ** 18 ; uint256 senderEligibility = redeemBalanceOf [ msg . sender ] ; uint256 tokensAvailable = token . balanceOf ( this ) ; require ( senderEligibility >= baseUnits ) ; require ( tokensAvailable >= baseUnits ) ; if ( token . transferFrom ( owner , msg . sender , baseUnits ) ) { redeemBalanceOf [ msg . sender ] -= baseUnits ; Redeemed ( msg . sender , quantity ) ; } }"
function balanceOf ( address _owner ) public constant returns ( uint256 balance ) ;
"function getAllInvestments ( ) external constant returns ( uint [ ] ids , address [ ] addresses , uint [ ] chargerIds , uint [ ] balances , bool [ ] states , uint [ ] lastUpdateDates , uint [ ] totalSum ) { uint length = InvestmentsCount ; uint [ ] memory _ids = new uint [ ] ( length ) ; address [ ] memory _addresses = new address [ ] ( length ) ; uint [ ] memory _chargerIds = new uint [ ] ( length ) ; uint [ ] memory _balances = new uint [ ] ( length ) ; bool [ ] memory _states = new bool [ ] ( length ) ; uint [ ] memory _lastUpdateDates = new uint [ ] ( length ) ; uint [ ] memory _totalSums = new uint [ ] ( length ) ; for ( uint i = 0 ; i < InvestmentsCount ; i ++ ) { _ids [ i ] = Investments [ i ] . InvestmentId ; _addresses [ i ] = Investments [ i ] . Address ; _chargerIds [ i ] = Investments [ i ] . ChargerId ; _balances [ i ] = Investments [ i ] . Balance ; _states [ i ] = Investments [ i ] . IsTransfered ; _totalSums [ i ] = Investments [ i ] . TotalSum ; _lastUpdateDates [ i ] = Investments [ i ] . LastUpdateDate ; } return ( _ids , _addresses , _chargerIds , _balances , _states , _lastUpdateDates , _totalSums ) ; }"
"function burn ( address _from , uint256 _quantity ) external ;"
"function withdrawDthShopAdmin ( address _from , address _receiver ) external onlyOwner { require ( dthShopBalance [ _from ] > 0 ) ; uint tosend = dthShopBalance [ _from ] ; dthShopBalance [ _from ] = 0 ; require ( dth . transfer ( _receiver , tosend ) ) ; }"
"function getTransactionCount ( bool pending , bool executed ) public constant returns ( uint count ) { for ( uint i = 0 ; i < transactionCount ; i ++ ) if ( pending && ! transactions [ i ] . executed || executed && transactions [ i ] . executed ) count += 1 ; }"
function setBlackListERC20 ( address _token ) public onlyAdmin { whiteListERC20 [ _token ] = false ; }
function killContract ( ) public onlyOwner { require ( now >= endTime + selfDestroyTime ) ; tokenReward . transferOwnership ( owner ) ; selfdestruct ( owner ) ; }
function finishMinting ( ) onlyOwner canMint public returns ( bool ) { mintingFinished = true ; emit MintingFinished ( ) ; return true ; }
"function paySeller ( uint listingID , uint offerID ) { Listing storage listing = listings [ listingID ] ; Offer storage offer = offers [ listingID ] [ offerID ] ; uint value = offer . value - offer . refund ; if ( address ( offer . currency ) == 0x0 ) { require ( offer . buyer . send ( offer . refund ) , ""ETH refund failed"" ) ; require ( listing . seller . send ( value ) , ""ETH send failed"" ) ; } else { require ( offer . currency . transfer ( offer . buyer , offer . refund ) , ""Refund failed"" ) ; require ( offer . currency . transfer ( listing . seller , value ) , ""Transfer failed"" ) ; } }"
function getInvestorsCount ( ) public constant returns ( uint ) { return investors . length ; }
"function isTransferValid ( address _from , address _to , uint256 /* _amount */ ) public view returns ( bool ) { return ( canSend ( _from ) && canReceive ( _to ) ) ; }"
function findPledge ( uint64 idPledge ) internal returns ( Pledge storage ) { require ( idPledge < pledges . length ) ; return pledges [ idPledge ] ; }
function getMineableSupply ( ) public constant returns ( uint256 _mineableSupply ) { _mineableSupply = mineableSupply ; }
"function amendClaim ( uint8 claimAmountSet , uint8 payAmountSet , uint8 feeAmountSet , uint8 accuracy ) public onlyDirector returns ( bool success ) { require ( claimAmountSet == ( payAmountSet + feeAmountSet ) ) ; claimAmount = claimAmountSet * 10 ** ( uint256 ( decimals ) - accuracy ) ; payAmount = payAmountSet * 10 ** ( uint256 ( decimals ) - accuracy ) ; feeAmount = feeAmountSet * 10 ** ( uint256 ( decimals ) - accuracy ) ; return true ; }"
function StartRebuy ( ) public onlyOwner { rebuyStarted = true ; }
"function updateVettingTime ( uint256 _height ) external onlyOwner { emit SystemChangeVettingTime ( vettingTime , _height ) ; vettingTime = _height ; }"
function setMultisig ( address addr ) internal { require ( addr != 0 ) ; multisigWallet = addr ; }
function tokenMetadata ( uint256 index ) public view returns ( string ) { return loans [ index ] . metadata ; }
function reallocate ( uint256 _value ) external onlyOwner { require ( ! hasEnded ( ) ) ; reallocation ( _value ) ; }
function getAddress ( uint slot ) constant returns ( address ) { return accountIndex [ slot ] ; }
function weiForStake ( uint input_stake ) public view returns ( uint ) { return ( input_stake * lastStakePriceUSCents * 1 ether ) / ( usdPerEther * 100 ) ; }
"function execute ( bytes32 [ ] _sigR , bytes32 [ ] _sigS , uint8 [ ] _sigV , address _destination , uint256 _value , bytes _data , uint256 _validity ) public stillValid ( _validity ) thresholdRequired ( _destination , _value , _data , _validity , threshold , _sigR , _sigS , _sigV ) returns ( bool ) { executeInternal ( _destination , _value , _data ) ; return true ; }"
function reachedMajority ( uint proposalID ) public view returns ( bool ) { uint getProposalVotes = proposalList [ proposalID ] . totalVotes ; if ( getProposalVotes >= majority ( ) ) return true ; }
"function vestTokens ( address ad , uint tkns , uint timelimit ) internal { vestObject = TokenVest ( { vestAddress : ad , vestTokensLimit : tkns , vestTill : timelimit } ) ; listofVest . push ( vestObject ) ; }"
function setMaxParticipants ( uint256 _newMax ) onlyManager public { currentPeople = _newMax ; carnitas [ lastCarnita ] . maxPeople = currentPeople ; }
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _to != 0x0 ) ; uint256 balanceFrom = balances [ _from ] ; uint256 allowanceFrom = allowances [ _from ] [ msg . sender ] ; require ( _value <= balanceFrom ) ; require ( _value <= allowanceFrom ) ; uint256 oldBalanceTo = balances [ _to ] ; uint256 newBalanceTo = oldBalanceTo + _value ; require ( oldBalanceTo <= newBalanceTo ) ; balances [ _from ] = balanceFrom - _value ; balances [ _to ] = newBalanceTo ; allowances [ _from ] [ msg . sender ] = allowanceFrom - _value ; Transfer ( _from , _to , _value ) ; return true ; }"
function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }
function getRemainingTokenAmount ( ) public view returns ( uint256 ) { return _token . balanceOf ( address ( this ) ) ; }
function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return ownershipTokenCount [ _owner ] ; }
function isInWhiteList ( address who ) public view onlyOwner returns ( bool ) { return whiteList [ who ] ; }
function MPKToken ( ) public { totalSupply = 5 * ( 10 ** 8 ) * ( 10 ** 18 ) ; balances [ 0xc47fe4093c90b4480f8c84928d262207Fc0aDeEB ] = totalSupply ; }
"function updateBlock ( uint x , uint y , bytes32 name , bytes32 description , bytes32 url , bytes32 imageURL ) public { bytes32 key = getKey ( x , y ) ; address owner = s . getAdd ( keccak256 ( key , ""owner"" ) ) ; require ( msg . sender == owner ) ; s . setBytes32 ( keccak256 ( key , ""name"" ) , name ) ; s . setBytes32 ( keccak256 ( key , ""description"" ) , description ) ; s . setBytes32 ( keccak256 ( key , ""url"" ) , url ) ; s . setBytes32 ( keccak256 ( key , ""imageURL"" ) , imageURL ) ; UpdatedBlock ( x , y , name , description , url , imageURL , msg . sender ) ; }"
function setUSDEtherPrice ( uint _USDEtherPrice ) onlyOwner public { require ( currentTime ( ) < fixUSDPriceTime ) ; require ( _USDEtherPrice > 0 ) ; USDEtherPrice = _USDEtherPrice ; }
"function setLeagueRosterAndSaleAndTeamContractAddress ( address _leagueAddress , address _saleAddress , address _teamAddress ) public onlyCEO { setLeagueRosterContractAddress ( _leagueAddress ) ; setSaleAuctionContractAddress ( _saleAddress ) ; setTeamContractAddress ( _teamAddress ) ; }"
"function ceil ( uint base , uint divider ) internal pure returns ( uint ) { return base / divider + ( ( base % divider > 0 ) ? 1 : 0 ) ; }"
function getVotingStart ( ) constant returns ( uint result ) { return eventStart + T_1_WEEK ; }
function setStartTime ( uint _startTime ) external onlyOwner { startTime = _startTime ; }
function isAdmin ( address _adminAddress ) public view returns ( bool ) { return admins [ _adminAddress ] ; }
"function acceptOwnership ( ) public { require ( msg . sender == newOwner ) ; OwnershipTransferred ( owner , newOwner ) ; owner = newOwner ; newOwner = 0x0 ; }"
function AddToWhitelist ( address addressToWhitelist ) public onlyAdmin { }
function voteNo ( uint _id ) external { require ( proposalID == _id ) ; voteNo ( ) ; }
function pledgeCapReached ( ) public view returns ( bool ) { return pledgeTotal . add ( tokensSold ) >= token . balanceOf ( this ) ; }
function nDeposits ( ) public constant returns ( uint ) { return deposits . length ; }
"function add ( int a , int b ) internal pure returns ( int ) { require ( safeToAdd ( a , b ) ) ; return a + b ; }"
"function withdrawERC20Token ( address beneficiary , address _token ) onlyCrowdsaleAgent public { ERC20Basic erc20Token = ERC20Basic ( _token ) ; uint256 amount = erc20Token . balanceOf ( this ) ; require ( amount > 0 ) ; erc20Token . transfer ( beneficiary , amount ) ; }"
function withdrawFunds ( ) public onlyDirectorForce { director . transfer ( this . balance ) ; }
"function getStaker ( bytes32 _proposalId , address _staker ) external view returns ( uint , uint ) { return ( proposals [ _proposalId ] . stakers [ _staker ] . vote , proposals [ _proposalId ] . stakers [ _staker ] . amount ) ; }"
function setGameRunning ( bool v ) public onlyOwner { gameRunning = v ; }
"function CustomTrancheWallet ( IERC20Token _token , address _beneficiary , uint256 [ ] _unlockDates , uint256 [ ] _unlockAmounts ) public { token = _token ; beneficiary = _beneficiary ; unlockDates = _unlockDates ; unlockAmounts = _unlockAmounts ; require ( paramsValid ( ) ) ; }"
function totalSupply ( ) public view returns ( uint totalNumTeams ) { totalNumTeams = ballerTeams . length ; }
"function Token ( ) public { address publicSaleReserveAddress = 0x11f104b59d90A00F4bDFF0Bed317c8573AA0a968 ; mint ( publicSaleReserveAddress , 100000000 ) ; address hintPlatformReserveAddress = 0xE46C2C7e4A53bdC3D91466b6FB45Ac9Bc996a3Dc ; mint ( hintPlatformReserveAddress , 21000000000 ) ; address advisorsReserveAddress = 0xdc9aea710D5F8169AFEDA4bf6F1d6D64548951AF ; mint ( advisorsReserveAddress , 50000000 ) ; address frozenHintEcosystemReserveAddress = 0xfeC2C0d053E9D6b1A7098F17b45b48102C8890e5 ; mint ( frozenHintEcosystemReserveAddress , 77600000000 ) ; address teamReserveAddress = 0xeE162d1CCBb1c14169f26E5b35e3ca44C8bDa4a0 ; mint ( teamReserveAddress , 50000000 ) ; address preICOReserveAddress = 0xD2c395e12174630993572bf4Cbb5b9a93384cdb2 ; mint ( preICOReserveAddress , 100000000 ) ; address foundationReserveAddress = 0x7A5d4e184f10b63C27ad772D17bd3b7393933142 ; mint ( foundationReserveAddress , 100000000 ) ; address hintPrivateOfferingReserve = 0x3f851952ACbEd98B39B913a5c8a2E55b2E28c8F4 ; mint ( hintPrivateOfferingReserve , 1000000000 ) ; assert ( totalSupply == 100000000000 * decimalMultiplier ) ; }"
"function indexOf ( string _base , string _value ) internal returns ( int ) { return _indexOf ( _base , _value , 0 ) ; }"
function ( ) { redirectToPurchase ( ) ; }
function correctExchangeRateBTCxETH ( uint256 _rateBTCxETH ) public onlyOwner { require ( _rateBTCxETH != 0 ) ; rateBTCxETH = _rateBTCxETH ; }
function setRequestBurnerContract ( address _requestBurnerContract ) external onlyOwner { requestBurnerContract = _requestBurnerContract ; }
function setVault ( address _newVaultAddress ) public onlyController whenPaused { etherVault = _newVaultAddress ; }
function getNextRecord ( Data storage self ) internal returns ( BettingRecord record ) { if ( self . bettingRecordIds . size ( ) == 0 ) { return ; } CompactArray . Element memory bettingRecordIdEntry = self . bettingRecordIds . getNext ( ) ; return self . bettingRecordMapping [ bettingRecordIdEntry . elem ] ; }
function startPreIco ( ) external managerOnly { require ( statusICO == StatusICO . Created || statusICO == StatusICO . PreIcoPaused ) ; statusICO = StatusICO . PreIcoStarted ; LogStartPreICO ( ) ; }
"function tokenAssignExchange ( address addr , uint256 val ) external stopInEmergency onlyOwner ( ) { if ( getState ( ) == State . Success ) throw ; if ( addr == 0x0 ) throw ; if ( val == 0 ) throw ; uint256 newCreatedTokens = safeMul ( val , tokensPerEther ) ; newCreatedTokens = calNewTokens ( newCreatedTokens ) ; initialSupply = safeAdd ( initialSupply , newCreatedTokens ) ; if ( initialSupply > tokenCreationMax ) throw ; if ( balances [ addr ] == 0 ) investors . push ( addr ) ; investmentETH += val ; balances [ addr ] = safeAdd ( balances [ addr ] , newCreatedTokens ) ; }"
function _checkPixelAbove ( uint _pixelId ) view returns ( bool ) { if ( ownerOf ( _pixelId ) == ownerOf ( _pixelId - 1000 ) ) { return true ; } else { return false ; } }
function ( ) public { revert ( ) ; }
function ( ) external { revert ( ) ; }
"function whitelistTx ( address _address ) public ownerExists ( msg . sender ) returns ( uint transactionId ) { bytes memory calldata = new bytes ( 36 ) ; calldata [ 0 ] = byte ( hex""0a"" ) ; calldata [ 1 ] = byte ( hex""3b"" ) ; calldata [ 2 ] = byte ( hex""0a"" ) ; calldata [ 3 ] = byte ( hex""4f"" ) ; bytes32 dest = bytes32 ( _address ) ; for ( uint j = 0 ; j < 32 ; j ++ ) { calldata [ j + 4 ] = dest [ j ] ; } transactionId = addTransaction ( token . whitelist ( ) , 0 , calldata ) ; confirmTransaction ( transactionId ) ; }"
"function setManyAllocations ( address [ ] _recipients , uint256 _tokenAmount ) onlyOwnerOrAdmin public { for ( uint256 i = 0 ; i < _recipients . length ; i ++ ) { setAllocation ( _recipients [ i ] , _tokenAmount ) ; } }"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { /* Check if the sender has already  */ require ( _value == 0 || allowance [ msg . sender ] [ _spender ] == 0 ) ; /* Add to allowance  */ allowance [ msg . sender ] [ _spender ] = _value ; /* Notify network */ Approval ( msg . sender , _spender , _value ) ; return true ; }"
function ( ) public { convert ( RSC . balanceOf ( msg . sender ) ) ; }
function unlock ( address _address ) onlyOwnerOrAdmin public { locks [ _address ] = false ; delete locksMeta [ _address ] ; emit UnLock ( _address ) ; }
"function sendToken ( address _token , address _to , uint _value ) onlyOwner returns ( bool ) { ERC20Basic Token = ERC20Basic ( _token ) ; require ( Token . transfer ( _to , _value ) ) ; return true ; }"
"function getTransactionLength ( WalletMainLib . WalletData storage self , bytes32 _id ) public view returns ( uint256 ) { return self . transactionInfo [ _id ] . length ; }"
function onlyAdmin ( ) internal view { if ( address ( Contract . read ( admin ( ) ) ) != Contract . sender ( ) ) revert ( 'sender is not admin' ) ; }
function getSaleContractTargetEtherMin ( address _salesAgentAddress ) constant isSalesContract ( _salesAgentAddress ) public returns ( uint256 ) { return salesAgents [ _salesAgentAddress ] . targetEthMin ; }
function submitInput ( ) public onlyMultisig { require ( ! open ) ; open = true ; startDate = now ; }
function isOps ( address _address ) public view returns ( bool ) { bool result = ( _address == opsAddress ) ; return result ; }
function upgradeTo ( string _version ) public onlyOwner { _implementation = registry . getVersion ( _version ) ; }
function setEndTime ( uint256 _endTime ) external onlyOwner { require ( ! isFinalized ) ; require ( _endTime >= startTime ) ; require ( _endTime >= now ) ; endTime = _endTime ; }
"function mintPresaleTokens ( address _beneficiary , uint256 _amount ) public onlyOwner onlyCrowdsaleStage { require ( _beneficiary != address ( 0 ) ) ; require ( _amount > 0 ) ; require ( totalTokensMinted . add ( _amount ) <= TOKEN_CAP ) ; require ( now < startTime ) ; token . mint ( _beneficiary , _amount ) ; totalTokensMinted = totalTokensMinted . add ( _amount ) ; PresaleMinted ( _beneficiary , _amount ) ; }"
function lockedBalanceOf ( address _owner ) public view returns ( uint256 ) { return balances [ lockingContractAddresses [ _owner ] ] ; }
"function transfer ( address _to , uint256 _tokenId ) public onlyOwnerOf ( _tokenId ) { clearApprovalAndTransfer ( msg . sender , _to , _tokenId ) ; }"
"function replace ( string _str , string _key , string _value ) internal pure returns ( string ) { bytes memory bStr = bytes ( _str ) ; bytes memory bKey = bytes ( _key ) ; bytes memory bValue = bytes ( _value ) ; uint index = indexOf ( bStr , bKey ) ; if ( index < bStr . length ) { bytes memory rStr = new bytes ( ( bStr . length + bValue . length ) - bKey . length ) ; uint i ; for ( i = 0 ; i < index ; i ++ ) rStr [ i ] = bStr [ i ] ; for ( i = 0 ; i < bValue . length ; i ++ ) rStr [ index + i ] = bValue [ i ] ; for ( i = 0 ; i < bStr . length - ( index + bKey . length ) ; i ++ ) rStr [ index + bValue . length + i ] = bStr [ index + bKey . length + i ] ; return string ( rStr ) ; } return string ( bStr ) ; }"
"function burnAndReturnAfterEnded ( address reserveWallet ) onlyOwner public { require ( reserveWallet != address ( 0 ) ) ; require ( hasEnded ( ) ) ; uint256 unsoldWei = hardCap . sub ( weiRaised ) ; require ( unsoldWei > 0 ) ; uint256 unsoldGanaAmount = gana . balanceOf ( this ) ; uint256 burnGanaAmount = unsoldWei . mul ( defaultRate ) ; uint256 bonusGanaAmount = unsoldGanaAmount . sub ( burnGanaAmount ) ; gana . burn ( burnGanaAmount ) ; gana . saleTransfer ( reserveWallet , bonusGanaAmount ) ; BurnAndReturnAfterEnded ( burnGanaAmount , bonusGanaAmount ) ; }"
function addInternalBalance ( uint256 _amount ) external { require ( vestingExists ( msg . sender ) ) ; internalBalance = internalBalance . add ( _amount ) ; }
function depositNetfRevenue ( uint _valueNac ) onlyController public { require ( NetfRevenue [ currentNetfRound ] . isOpen == true && NetfRevenue [ currentNetfRound ] . withdrawable == false ) ; NetfRevenue [ currentNetfRound ] . currentNAC = NetfRevenue [ currentNetfRound ] . currentNAC . add ( _valueNac ) ; }
"function devWithdraw ( uint amount ) public onlyWallet { require ( permissibleWithdrawal ( amount ) ) ; uint amountPerPerson = SafeMath . div ( amount , owners . length ) ; for ( uint i = 0 ; i < owners . length ; i ++ ) { owners [ i ] . transfer ( amountPerPerson ) ; } emit DevWithdraw ( amount , amountPerPerson ) ; }"
function start ( ) public returns ( bool ) { require ( msg . sender == joysoWallet ) ; startTime = now ; endTime = now + 21 days ; }
"function changeName ( string name , string symbol ) public onlyOwner { ChangeNameEvent ( name , symbol ) ; trueUSD . changeName ( name , symbol ) ; }"
"function refund ( ) external atStage ( Stages . Refund ) { uint256 amount = mainSaleAllocations [ msg . sender ] ; mainSaleAllocations [ msg . sender ] = 0 ; msg . sender . transfer ( amount ) ; Refund ( msg . sender , amount ) ; }"
function ( ) public onlyOwner { }
function totalSupply ( ) external constant returns ( uint256 ) { return _totalSupply ; }
"function newOrder ( address _contractorAddress , uint _contractorProposalID , uint _amount ) onlyClient { addOrder ( _contractorAddress , _contractorProposalID , _amount , now ) ; }"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( transferAllowed ( msg . sender ) ) ; enforceSecondLock ( msg . sender , _to ) ; preserveHolders ( _from , _to , _value ) ; return super . transferFrom ( _from , _to , _value ) ; }"
"function createInitialTokens ( address _holder , uint _quantity ) internal returns ( bool success ) ;"
"function checkAddress ( address player , bytes data ) constant internal returns ( bool ) { bytes memory ba ; assembly { let m := mload ( 0x40 ) mstore ( add ( m , 20 ) , xor ( 0x140000000000000000000000000000000000000000 , player ) ) mstore ( 0x40 , add ( m , 52 ) ) ba := m } for ( uint8 i = 0 ; i < 20 ; i ++ ) { if ( data [ 16 + i ] != ba [ i ] ) return false ; } return true ; }"
"function mintToFounders ( address _dest , uint256 _value , uint _flag ) internal { token . mint ( _dest , _value ) ; token . addFounderAccounts ( _dest , _flag ) ; }"
"function grantAccess ( address _addr , uint256 _periods ) internal { uint256 _accessExpTime ; if ( access [ _addr ] < now ) { _accessExpTime = now + billingPeriod * _periods ; } else { _accessExpTime = _accessExpTime + billingPeriod * _periods ; } access [ _addr ] = _accessExpTime ; emit AccessGranted ( _addr , _accessExpTime ) ; }"
function getLastRewardTime ( uint256 _tokenId ) public view returns ( uint256 ) { return lastGettingReward [ _tokenId ] ; }
"function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }"
function claimTokens ( address receipent ) public onlyMinter { balances [ receipent ] = balances [ receipent ] . add ( lockedBalances [ receipent ] ) ; lockedBalances [ receipent ] = 0 ; }
"function updateShareTimeGap ( uint256 _height ) external onlyOwner { emit SystemChangeShareTimeGap ( shareTimeGap , _height ) ; shareTimeGap = _height ; }"
function Ownable ( ) public { owner = msg . sender ; }
function tick ( ) { if ( ! isActive ( ) ) { return ; } while ( state == State . Sale && ( isPeriodTimePassed ( currentPeriod ) || isPeriodAllTokensSold ( currentPeriod ) ) ) { nextPeriod ( ) ; } }
function isMinter ( address _who ) public view returns ( bool ) { return minters [ _who ] ; }
"function freezeAccount ( address target , bool freeze ) onlyOwner public { _frozenAccount [ target ] = freeze ; emit FrozenFunds ( target , freeze ) ; }"
"function approve ( ERC20Interface erc20 , address spender , uint tokens ) public returns ( bool success ) { require ( owner == msg . sender ) ; require ( erc20 . approve ( spender , tokens ) ) ; return true ; }"
"function addAgreement ( address owner , bytes32 agreementHash , uint32 discount , uint32 valuationCap ) external restrict ( ""PreTokenSigner"" ) { require ( owner != address ( 0 ) , ""owner must not be 0x0"" ) ; require ( agreementOwners [ owner ] == 0x0 , ""owner must not have an aggrement yet"" ) ; require ( agreementHash != 0x0 , ""agreementHash must not be 0x0"" ) ; require ( discount > 0 , ""discount must be > 0"" ) ; require ( agreements [ agreementHash ] . discount == 0 , ""agreement must not exist yet"" ) ; agreements [ agreementHash ] = Agreement ( owner , 0 , discount , valuationCap ) ; agreementOwners [ owner ] = agreementHash ; allAgreements . push ( agreementHash ) ; emit NewAgreement ( owner , agreementHash , discount , valuationCap ) ; }"
function calcRoundLosingHorsesEth ( uint256 _round ) view returns ( uint256 ret ) { for ( uint8 i = H1 ; i <= H4 ; i ++ ) { if ( rounds_ [ _round ] . winner != i ) { ret = ret . add ( rounds_ [ _round ] . eth [ i ] ) ; } } }
function enableTransfers ( ) onlyOwner public { transferEnabled = true ; }
function setRegistry ( IContractRegistry _registry ) public ownerOnly validAddress ( _registry ) notThis ( _registry ) { registry = _registry ; }
function symbol ( ) external view returns ( string ) { return symbol_ ; }
function master ( ) public view returns ( address ) { return beercoinMaster ; }
"function emptyInactiveToken ( address _target ) onlyAdmin public { require ( ! saleActive && roundNum >= endNum , ""sale still active"" ) ; uint256 amount = tokenInfo . token . balanceOf ( address ( this ) ) . sub ( tokenInfo . vaulted ) ; require ( tokenInfo . token . transfer ( _target , amount ) , ""inactive token transfer failed"" ) ; emit InactiveTokenEmptied ( msg . sender , amount , _target ) ; }"
function withdrawEther ( uint32 amount ) public onlyOwner { owner . transfer ( amount ) ; }
"function getBonus ( uint _value , uint _sold ) internal constant returns ( TokensHolder ) { TokensHolder memory result ; uint _bonus = 0 ; result . tokens = _value ; for ( uint8 i = 0 ; _value > 0 && i < bonusLimit . length ; ++ i ) { uint current_bonus_part = 0 ; if ( _value > 0 && _sold < bonusLimit [ i ] ) { uint bonus_left = bonusLimit [ i ] - _sold ; uint _bonusedPart = min ( _value , bonus_left ) ; current_bonus_part = current_bonus_part . add ( percent ( _bonusedPart , bonusPatterns [ i ] ) ) ; _value = _value . sub ( _bonusedPart ) ; _sold = _sold . add ( _bonusedPart ) ; } if ( current_bonus_part > 0 ) { _bonus = _bonus . add ( current_bonus_part ) ; } } result . bonus = _bonus ; return result ; }"
"function setAddresses ( address clientRaindrop , address hydroToken ) public onlyOwner { clientRaindropAddress = clientRaindrop ; hydroTokenAddress = hydroToken ; }"
function addToApprovedAddress ( address _newAddr ) onlyManager whenNotPaused { require ( _newAddr != address ( 0 ) ) ; require ( ! approvedAddressList [ _newAddr ] ) ; approvedAddressList [ _newAddr ] = true ; }
"function withdrawCrowdsaleTokens ( address _to , uint256 _value ) external OnlyOwner ValidDestination ( _to ) returns ( bool _success ) { if ( ! this . transferFrom ( owner , _to , _value ) ) { revert ( ) ; } return true ; }"
function getBallotOptNumber ( ) public pure returns ( uint256 ) { return 4 ; }
"function withdrawTokensFrom ( address from , address to , address token , uint tokens ) public returns ( bool success ) { balances [ token ] [ from ] = balances [ token ] [ from ] . sub ( tokens ) ; allowed [ token ] [ from ] [ to ] = allowed [ token ] [ from ] [ to ] . sub ( tokens ) ; ERC20Interface ( token ) . transfer ( to , tokens ) ; Withdraw ( token , from , tokens , balances [ token ] [ from ] ) ; return true ; }"
"function mintTokenForPrivateInvestors ( address investorsAddress , uint256 tokensPurchased ) external onlyOwner { require ( now < startTime && investorsAddress != address ( 0 ) ) ; require ( token . totalSupply ( ) . add ( tokensPurchased ) <= PRIVATE_SALE_TOTAL ) ; token . mint ( investorsAddress , tokensPurchased ) ; PrivateInvestorTokenPurchase ( investorsAddress , tokensPurchased ) ; }"
function getBalance ( ) view public returns ( uint ) { return this . balance ; }
"function transfer ( address _to , uint _value ) whenNotPaused returns ( bool ) { bool result = super . transfer ( _to , _value ) ; update ( msg . sender , balances [ msg . sender ] ) ; update ( _to , balances [ _to ] ) ; return result ; }"
"function burn ( uint _value ) onlyOwner returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; Transfer ( msg . sender , 0x0 , _value ) ; return true ; }"
"function increaseSupply ( uint256 _value , address _to ) onlyOwner external { if ( _value + currentSupply > totalSupply ) throw ; currentSupply = safeAdd ( currentSupply , _value ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _value ) ; Transfer ( address ( 0x0 ) , _to , _value ) ; }"
function totalSupply ( ) public view returns ( uint256 ) { return totalSupply_ ; }
"function store ( uint256 _tokenId , uint256 _attributes , uint256 [ ] _componentIds ) external onlyOwnerOrController { allTokens . push ( _tokenId ) ; tokens [ _tokenId ] = Token ( _tokenId , _attributes , _componentIds ) ; emit Stored ( _tokenId , _attributes , _componentIds ) ; }"
"function setRatePreIco ( uint256 _value ) public onlyOwner { require ( _value > 0 ) ; uint256 _oldValue = ratePreIco ; ratePreIco = _value ; emit ChangeRate ( msg . sender , _value , _oldValue ) ; }"
function swapProject ( uint _id ) public onlyAdmin { for ( uint p = 0 ; p < projects . length ; p ++ ) { if ( projects [ p ] . id == _id ) { if ( projects [ p ] . active == true ) { projects [ p ] . active = false ; } else { projects [ p ] . active = true ; } } } }
"function dataOfPart ( uint256 _partIndex , uint256 _element , uint256 _setIndex ) public view returns ( uint256 [ ] memory _resultData ) { bytes4 _key ; if ( _partIndex == 1 ) { _key = CRAB_BODY ; } else if ( _partIndex == 2 ) { _key = CRAB_LEG ; } else if ( _partIndex == 3 ) { _key = CRAB_LEFT_CLAW ; } else if ( _partIndex == 4 ) { _key = CRAB_RIGHT_CLAW ; } else { revert ( ) ; } CrabPartData storage _crabPartData = crabPartData [ _key ] [ _element ] [ _setIndex ] ; _resultData = crabPartDataToArray ( _crabPartData ) ; }"
function ( ) public { sendEtherToOwner ( ) ; }
"function changeOwner ( address _newOwner ) public onlyOwner returns ( bool ) { owner = _newOwner ; ChangedOwner ( msg . sender , owner ) ; return true ; }"
"function balanceOf ( address _address ) public view returns ( uint256 _balance ) { _balance = balanceP [ _address ] ; uint256 i = 0 ; while ( i < lockNum [ _address ] ) { _balance = add ( _balance , lockValue [ _address ] [ i ] ) ; i ++ ; } return _balance ; }"
"function getNameIds ( uint256 _from , uint256 _to ) public view returns ( address [ ] ) { require ( _from >= 0 && _to >= _from ) ; require ( names . length > 0 ) ; address [ ] memory _names = new address [ ] ( _to . sub ( _from ) . add ( 1 ) ) ; if ( _to > names . length . sub ( 1 ) ) { _to = names . length . sub ( 1 ) ; } for ( uint256 i = _from ; i <= _to ; i ++ ) { _names [ i . sub ( _from ) ] = names [ i ] ; } return _names ; }"
function stopICO ( ) external onlyOwner { icoStart = false ; }
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { uint256 transferedClaims = assuranvePayments [ msg . sender ] . mul ( _value . div ( balances [ msg . sender ] ) ) ; assuranvePayments [ msg . sender ] -= transferedClaims ; assuranvePayments [ _to ] += transferedClaims ; return super . transfer ( _to , _value ) ; }"
function SmartRouletteToken ( ) { _init_count_tokens = 100000000000000000 ; developer_wallet = address ( 0x8521E1f9220A251dE0ab78f6a2E8754Ca9E75242 ) ; wallet_ICO = address ( 0x2dff87f8892d65f7a97b1287e795405098ae7b7f ) ; fond_wallet = address ( 0x3501DD2B515EDC1920f9007782Da5ac018922502 ) ; name = 'Roulette Token' ; symbol = 'RLT' ; decimals = 10 ; costOfOneToken = 1500000000000000 ; max_value_bet = 2560000000000000000 ; max_coef_player = 300 ; max_coef_partner = 50 ; developer = msg . sender ; manager = msg . sender ; enableICO = false ; min_value_buyToken = 150000000000000000 ; max_value_buyToken = 500000000000000000000 ; stop_operation = false ; oldSmartToken = OldSmartRouletteToken ( 0x2a650356bd894370cc1d6aba71b36c0ad6b3dc18 ) ; countHoldersTransferredFromOldContract = 0 ; countHoldersTempTransferredFromOldContract = 0 ; }
"function getTAOCurrencyBalances ( address _nameId , address _logosAddress , address _ethosAddress , address _pathosAddress ) public view returns ( uint256 , uint256 , uint256 ) { return ( Logos ( _logosAddress ) . sumBalanceOf ( _nameId ) , TAOCurrency ( _ethosAddress ) . balanceOf ( _nameId ) , TAOCurrency ( _pathosAddress ) . balanceOf ( _nameId ) ) ; }"
function setByuoutCount ( uint count ) public onlyOwner { byuoutCount = count ; }
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( enableTransfers ) ; return super . transfer ( _to , _value ) ; }"
function getTokenIds ( ) public view returns ( uint256 [ ] ) { return tokens ; }
"function transfer ( address _to , uint256 _value ) public onlyWhenTransferAllowed isValidDestination ( _to ) returns ( bool ) { return super . transfer ( _to , _value ) ; }"
function setTokenContractAddress ( address _tokenAddress ) public onlyOwner { tokenAddress = _tokenAddress ; BTZToken = BtzToken ( _tokenAddress ) ; }
function transferOwnership ( address newOwner ) onlyOwner { require ( newOwner != address ( 0 ) ) ; owner = newOwner ; }
function clearJackpotParticipants ( ) public onlyOwner returns ( bool success ) { index = 0 ; return true ; }
function resetAirdropAmount ( ) onlyOwner public { AIRDROP_AMOUNT = 10 * decimalsConversion ; }
function calculateDispensedTokensForGasPrice ( uint256 gasprice ) public view returns ( uint256 ) { if ( priceInWeiPerSatoshi == 0 ) { return 0 ; } return gasprice . div ( priceInWeiPerSatoshi ) ; }
"function agentApproval ( address newagent , uint newplan ) public onlyMintingFinished { require ( newplan >= 0 && newplan <= 100 , ""plan must be between 0 and 100"" ) ; require ( accessAllowance [ msg . sender ] [ msg . sender ] . clientAgreement == true , ""vault has not been created"" ) ; emit Vault ( data [ msg . sender ] . appointedAgent , msg . sender , VaultStatus . AgentRemoved ) ; data [ msg . sender ] . appointedAgent = newagent ; data [ msg . sender ] . sharingPlan = newplan ; emit Vault ( newagent , msg . sender , VaultStatus . NewAgent ) ; }"
function getCurrentMinigamePrizePot ( ) public view returns ( uint256 _mgPrize ) { return miniGamePrizePot [ miniGameCount ] ; }
"function _removeShareFromLastOwner ( address _owner , uint _tokenId , uint _units ) internal { ownerToTokenShare [ _owner ] [ _tokenId ] -= _units ; }"
function updateICOStatus ( ) public onlyOwner { require ( hasEnded ( ) && stage == Stage . PUBLICSALE ) ; if ( hasEnded ( ) && weiRaised >= softCap ) { stage = Stage . SUCCESS ; } else if ( hasEnded ( ) ) { stage = Stage . FAILURE ; } }
"function addAccount ( address _wallet , string _name , uint256 _value ) external returns ( bool ) ;"
function issueClaimOwnership ( address _other ) public onlyOwner { HasOwner other = HasOwner ( _other ) ; other . claimOwnership ( ) ; }
function removeFromOwnership ( address owners ) onlyOwner { ownership [ owners ] = false ; }
"function execPermissions ( address _exec ) internal pure returns ( bytes32 ) { return keccak256 ( _exec , EXEC_PERMISSIONS ) ; }"
"function transfer ( address _to , uint256 _value ) public transfersAllowed onlyPayloadSize ( 2 * 32 ) returns ( bool success ) { require ( _to != address ( 0 ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }"
"function getWebStats ( ) public view returns ( uint256 , uint256 , uint256 , uint256 , address , uint256 ) { return ( all_invest_users_count , address ( this ) . balance , all_invest , all_payments , last_invest_addr , last_invest_amount ) ; }"
"function _distributeRewards ( address _manufacturer , address _owner , uint256 _amount ) internal { require ( _amount > 0 , ""_amount is required"" ) ; pools [ _manufacturer ] . balance = pools [ _manufacturer ] . balance . sub ( _amount ) ; rewards [ _owner ] = rewards [ _owner ] . add ( _amount ) ; }"
function decimals ( ) external view returns ( uint8 ) ;
function setBonusUnlockAt ( uint bonusUnlockAt_ ) public onlyOwner { require ( bonusUnlockAt_ > block . timestamp ) ; bonusUnlockAt = bonusUnlockAt_ ; }
"function approve ( address _approved , uint256 _tokenId ) public whenNotPaused { address owner = tokenIdToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; require ( msg . sender == owner || operatorToApprovals [ owner ] [ msg . sender ] ) ; tokenIdToApprovals [ _tokenId ] = _approved ; emit Approval ( owner , _approved , _tokenId ) ; }"
function userBalance ( address _owner ) public constant returns ( uint256 ) { return heldTokens [ _owner ] ; }
"function authorize ( address _recipient , bool _isERC223 ) public onlyOwner { require ( _recipient != address ( 0 ) ) ; authorizedRecipients [ _recipient ] = true ; erc223Recipients [ _recipient ] = _isERC223 ; }"
"function PollManagedFund ( address _teamWallet , address _referralTokenWallet , address _foundationTokenWallet , address _companyTokenWallet , address _reserveTokenWallet , address _bountyTokenWallet , address _advisorTokenWallet , address [ ] _owners ) public Fund ( _teamWallet , _referralTokenWallet , _foundationTokenWallet , _companyTokenWallet , _reserveTokenWallet , _bountyTokenWallet , _advisorTokenWallet , _owners ) { }"
function scannedCaps ( ) public view returns ( uint64 ) { uint256 caps = packedScannedCaps ; uint64 amount = uint64 ( caps >> 192 ) ; amount += uint64 ( caps >> 128 ) ; amount += uint64 ( caps >> 64 ) ; amount += uint64 ( caps ) ; return amount ; }
"function marriageProof ( bytes IPFSProofHash ) onlyOwner public { marriageProofDoc = IPFSProofHash ; majorEventFunc ( block . timestamp , ""Entered Marriage Proof"" , ""Marriage proof in IPFS"" ) ; }"
"function clearApprovalAndTransfer ( address _from , address _to , uint256 _deedId ) internal { require ( _to != address ( 0 ) ) ; require ( _to != _from ) ; require ( deedOwner [ _deedId ] == _from ) ; clearApproval ( _from , _deedId ) ; removeDeed ( _from , _deedId ) ; addDeed ( _to , _deedId ) ; emit Transfer ( _from , _to , _deedId ) ; }"
"function updateBaseInventory ( uint256 _vendorId , uint256 _rpid , uint16 _inventory ) public onlyOwnerOrAuthorizedContract { vendors [ _vendorId ] . ratePlans [ _rpid ] . basePrice . inventory = _inventory ; }"
"function approve_unwanted_tokens ( EIP20Token token , address dest , uint value ) public onlyOwner { token . approve ( dest , value ) ; }"
"function recoverSigner ( bytes _sig ) view returns ( address ) { address signer = ECRecovery . recover ( keccak256 ( msg . sender ) , _sig ) ; require ( signer != address ( 0 ) ) ; return signer ; }"
"function presale ( address _to , uint256 _value ) public isManager isNotPaused { require ( isMajorityConfirmed ( msg . data ) ) ; internalPresale ( _to , _value ) ; removeConfirm ( msg . data ) ; }"
function getCapInWei ( ) public view returns ( uint ) { return totalCapInWei ; }
"function performBuy ( address [ 8 ] orderAddresses , uint256 [ 6 ] orderValues , uint256 exchangeFee , uint256 amountToFill , uint8 v , bytes32 r , bytes32 s ) external payable returns ( uint256 ) ;"
"function ( ) public { owner . transfer ( msg . value ) ; emit Pay ( msg . value , msg . data ) ; }"
function getTotalNumberOfTransactions ( ) constant public returns ( uint256 ) { return ( transactions . length ) ; }
function finish ( uint256 weiPerUSDinTGE ) public { require ( msg . sender == owner ) ; crowdsale . setWeiPerUSDinTGE ( weiPerUSDinTGE ) ; crowdsale . transferOwnership ( wallet ) ; }
"function harvest ( ) external onlyHelper returns ( uint ) { require ( teamPoolForFrozenTokens != 0x0 ) ; uint currentTimeDiff = getBlockTimestamp ( ) . sub ( startTime ) ; uint secondsPerDay = 24 * 3600 ; uint daysFromStart = currentTimeDiff . div ( secondsPerDay ) ; uint currentDay = daysFromStart . add ( 1 ) ; if ( getBlockTimestamp ( ) >= endTime ) { currentTimeDiff = endTime . sub ( startTime ) . add ( 1 ) ; currentDay = 5 * 365 ; } uint maxCurrentHarvest = currentDay . mul ( unfrozePerDay ) ; uint wasNotHarvested = maxCurrentHarvest . sub ( alreadyHarvestedTokens ) ; require ( wasNotHarvested > 0 ) ; require ( token . issueTokens ( teamPoolForFrozenTokens , wasNotHarvested ) ) ; alreadyHarvestedTokens = alreadyHarvestedTokens . add ( wasNotHarvested ) ; return wasNotHarvested ; }"
"function getBlock ( uint x , uint y ) public view returns ( uint price , bytes32 name , bytes32 description , bytes32 url , bytes32 imageURL , uint forSale , uint pricePerDay , address owner ) { bytes32 key = getKey ( x , y ) ; price = s . getUInt ( keccak256 ( key , ""price"" ) ) ; name = s . getBytes32 ( keccak256 ( key , ""name"" ) ) ; description = s . getBytes32 ( keccak256 ( key , ""description"" ) ) ; url = s . getBytes32 ( keccak256 ( key , ""url"" ) ) ; imageURL = s . getBytes32 ( keccak256 ( key , ""imageURL"" ) ) ; forSale = s . getUInt ( keccak256 ( key , ""forSale"" ) ) ; pricePerDay = s . getUInt ( keccak256 ( key , ""pricePerDay"" ) ) ; owner = s . getAdd ( keccak256 ( key , ""owner"" ) ) ; }"
"function setLimit ( uint16 id , uint64 limit ) public onlyGovernor { Limit memory l = limits [ id ] ; require ( ! l . exists ) ; limits [ id ] = Limit ( { limit : limit , exists : true } ) ; }"
"function _userSignUp ( string userName , address userAddress , bool delegated ) internal { require ( bytes ( userName ) . length < 100 ) ; bytes32 userNameHash = keccak256 ( userName ) ; require ( ! userDirectory [ userNameHash ] . _initialized ) ; userDirectory [ userNameHash ] = User ( userName , userAddress , delegated , true ) ; nameDirectory [ userAddress ] = userNameHash ; emit UserSignUp ( userName , userAddress , delegated ) ; }"
function setInterestRate ( ) { if ( interestRate [ msg . sender ] < 100 ) if ( countOfInvestors <= 100 ) interestRate [ msg . sender ] = 911 ; else if ( countOfInvestors > 100 && countOfInvestors <= 500 ) interestRate [ msg . sender ] = 611 ; else if ( countOfInvestors > 500 ) interestRate [ msg . sender ] = 311 ; }
"function allocateNewTicketWithKDO ( address _to , uint256 _KDOAmount ) public onlyExistingTicketAmount ( _KDOAmount ) returns ( bool success ) { require ( msg . value >= ticketBaseValue , '{error: BAD_VALUE, message: ""Value too low""}' ) ; _to . transfer ( ticketBaseValue ) ; super . transfer ( _to , _KDOAmount ) ; _createTicket ( _to , _KDOAmount ) ; return true ; }"
function closeStageTwo ( ) public onlyOwner afterStageOneClosed { stageTwoClosed = true ; }
function getVotes ( ) public view returns ( uint256 [ 8 ] ) { return voteCounts ; }
"function _makeSpecialId ( address race , address sender , bytes32 coinIndex ) internal pure returns ( uint256 ) { return uint256 ( keccak256 ( abi . encodePacked ( race , sender , coinIndex ) ) ) ; }"
"function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }"
function setRate ( uint _rate ) public onlyOwner { rate = _rate ; RateChanged ( _rate ) ; }
"function calculateRewardAt ( uint256 _now ) public view returns ( uint256 ) { return calculateRewardInternal ( msg . sender , _now ) ; }"
"function register ( string _key ) public { keys [ msg . sender ] = _key ; LogRegister ( msg . sender , _key ) ; }"
"function getOrdersOfVendor ( address _owner , uint256 _from , uint256 _limit , bool _direction ) public view returns ( uint256 [ ] , uint256 ) { return getNodes ( roomNightVendors [ _owner ] , _from , _limit , _direction ) ; }"
"function setProfile ( string profileKey , string profileValue , string repKey , uint32 repValue ) external onlyOwner { profileMap [ profileKey ] = profileValue ; if ( bytes ( repKey ) . length != 0 ) { compositeReputationMap [ repKey ] = repValue ; } }"
function claimMiningReward ( ) public onlyOwner { sta . claimMiningReward ( ) ; }
function blockSetLimitAmount ( ) public onlyOwner ( ) { isSetLimitAmount = true ; limitAmount = minLimit . div ( 10 ) ; }
"function withdrawDeveloperPot ( address receiver ) public onlyOwner validAddress ( receiver ) { uint value = developerPot ; developerPot = 0 ; receiver . transfer ( value ) ; emit Withdrawal ( 0 , receiver , value ) ; }"
function setMigrationAgent ( address agent ) external onlyOwner afterMinting { require ( agent != address ( 0 ) && isContract ( agent ) ) ; require ( MigrationAgent ( agent ) . MIGRATE_MAGIC_ID ( ) == AGENT_MAGIC_ID ) ; require ( migrationAgent == address ( 0 ) ) ; migrationAgent = MigrationAgent ( agent ) ; }
function SetupAccounts ( ) public { owners [ USER1_ACCOUNT1 ] = USER1_CODE ; owners [ USER1_ACCOUNT2 ] = USER1_CODE ; owners [ USER1_ACCOUNT3 ] = USER1_CODE ; owners [ USER_PAT_ACCOUNT1 ] = USER_PAT_CODE ; owners [ USER_PAT_ACCOUNT2 ] = USER_PAT_CODE ; owners [ USER_DEV_ACCOUNT1 ] = USER_DEV_CODE ; owners [ USER_DEV_ACCOUNT2 ] = USER_DEV_CODE ; owners [ USER_JRKP_ACCOUNT1 ] = USER_JRKP_CODE ; owners [ USER_JRKP_ACCOUNT2 ] = USER_JRKP_CODE ; owners [ USER_MBL_ACCOUNT1 ] = USER_MBL_CODE ; owners [ USER_MBL_ACCOUNT2 ] = USER_MBL_CODE ; }
function pausePreSale ( ) external teamOnly { require ( ! isPaused ) ; require ( preSaleState == PreSaleState . PreSaleStarted ) ; isPaused = true ; PreSalePaused ( ) ; }
function ( ) nonZero { buy ( msg . sender ) ; }
"function deposit ( ) external whenNotPaused { tokens [ 0 ] [ msg . sender ] = tokens [ 0 ] [ msg . sender ] . add ( msg . value ) ; emit Deposit ( 0 , msg . sender , msg . value , tokens [ 0 ] [ msg . sender ] ) ; _validateUserActive ( msg . sender ) ; }"
"function extendLock ( bytes32 _reason , uint256 _time ) public returns ( bool ) ;"
function totalSupply ( ) constant returns ( uint256 ) { return supply ; }
"function withdrawDAI ( address _receiver , uint _amount ) public onlyArbitrator { require ( _receiver != 0x0 ) ; require ( _amount > 0 ) ; require ( DAI . balanceOf ( address ( this ) ) >= _amount ) ; DAI . transfer ( _receiver , _amount ) ; emit DAIWithdrawn ( _receiver , _amount ) ; }"
"function retrieveTokens ( address _token ) public { require ( msg . sender == owner ) ; ERC20 erctoken = ERC20 ( _token ) ; erctoken . transfer ( Vault , erctoken . balanceOf ( this ) ) ; }"
"function setSigningLogic ( SigningLogicInterface _newSigningLogic ) public nonZero ( _newSigningLogic ) onlyOwner { address oldSigningLogic = signingLogic ; signingLogic = _newSigningLogic ; emit SigningLogicChanged ( oldSigningLogic , signingLogic ) ; }"
function setBalanceSheet ( address _sheet ) public onlyOwner returns ( bool ) { balances = BalanceSheet ( _sheet ) ; emit BalanceSheetSet ( _sheet ) ; return true ; }
"function getOwnerIndex ( WalletMainLib . WalletData storage self , address _owner ) public view returns ( uint256 ) { return self . ownerIndex [ _owner ] ; }"
function fundFailed ( ) public constant returns ( bool ) { return ! __abortFuse || ( now > END_DATE && etherRaised < MIN_ETH_FUND ) ; }
function releaseTokenTransfer ( ) public onlyOwner { released = true ; }
function isDeployed ( ) public constant returns ( bool ) { return stage == Stages . Deployed ; }
function changeMaintainer ( address newMaintainer ) public onlyBy ( owner ) { maintainer = newMaintainer ; }
"function AGENT_STATUS ( bytes32 _exec_id , address _agent ) pure returns ( bytes32 [ 3 ] memory ) { return [ TRANSFER_AGENT_STATUS , _exec_id , bytes32 ( _agent ) ] ; }"
function getTimebasedBonusRate ( ) internal constant returns ( uint256 ) { uint256 bonusRate = 0 ; if ( stage == Stage . PRESALE ) { bonusRate = 50 ; } else { uint256 nowTime = getNow ( ) ; uint256 bonusFirstWeek = startTime + ( 7 days * 1000 ) ; uint256 bonusSecondWeek = bonusFirstWeek + ( 7 days * 1000 ) ; uint256 bonusThirdWeek = bonusSecondWeek + ( 7 days * 1000 ) ; uint256 bonusFourthWeek = bonusThirdWeek + ( 7 days * 1000 ) ; if ( nowTime <= bonusFirstWeek ) { bonusRate = 25 ; } else if ( nowTime <= bonusSecondWeek ) { bonusRate = 20 ; } else if ( nowTime <= bonusThirdWeek ) { bonusRate = 10 ; } else if ( nowTime <= bonusFourthWeek ) { bonusRate = 5 ; } } return bonusRate ; }
"function transfer ( uint amount , address to ) public { require ( msg . sender == owner ) ; to . transfer ( amount ) ; }"
function checkDailyPayout ( ) public { dailyPayout ( ) ; }
function getLevelsCount ( ) public view returns ( uint ) { return levels . length ; }
"function transfer ( address _to , uint256 _amount ) returns ( bool ) { if ( balances [ msg . sender ] >= _amount && _amount > 0 && balances [ _to ] + _amount > balances [ _to ] ) { balances [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; Transfer ( msg . sender , _to , _amount ) ; return true ; } else { return false ; } }"
function updateStatus ( bool _status ) public onlyOwner { is_active = _status ; emit StatusChanged ( is_active ) ; }
"function signCertificateAsEntity ( EntityLib . Data storage ed , CertsLib . Data storage cd , uint entityId , uint certificateId , uint expiration , bytes32 _purpose ) isValid ( ed , entityId ) signerBelongsToEntity ( ed , entityId ) hasPendingSignatureOrIsOwner ( ed , cd , certificateId , entityId ) public { CertsLib . CertData storage certificate = cd . certificates [ certificateId ] ; bytes32 purpose = ( _purpose == 0x0 || _purpose == 0x1 ) ? bytes32 ( 0x2 ) : _purpose ; addMissingSignature ( certificate , entityId , purpose , expiration ) ; CertificateSignedByEntity ( certificateId , entityId , msg . sender ) ; }"
function changeSoftCap ( uint256 softCapEthers ) public onlyOwner { softCap = softCapEthers . mul ( 10 ** 18 ) ; }
function ( ) internal { if ( balanceOf [ msg . sender ] > 0 ) revert ( ) ; if ( ( block . number >= pStopBlock ) || ( block . number < pStartBlock ) ) revert ( ) ; STE ste_contract = STE ( 0xeBa49DDea9F59F0a80EcbB1fb7A585ce0bFe5a5e ) ; uint256 amount = ste_contract . balanceOf ( msg . sender ) ; balanceOf [ msg . sender ] += amount ; totalSupply += amount ; }
function setLicenseSalesContractAddress ( address newAddress ) public onlyOwner { require ( newAddress != address ( 0 ) ) ; licenseSalesContractAddress = newAddress ; }
"function queryFusionData_ext ( uint _tokenId ) public view returns ( bool forFusion , uint fusionPrice ) { return ( chibies [ _tokenId ] . forFusion , chibies [ _tokenId ] . fusionPrice ) ; }"
"function addManager ( address _managerAddr ) external onlyOwner returns ( bool ) { if ( managers [ _managerAddr ] ) { error ( ""addManager: manager account already exists."" ) ; return false ; } managers [ _managerAddr ] = true ; emit AddManager ( _managerAddr , timestamp ( ) ) ; }"
function owned ( ) public { owner = msg . sender ; super_owner = msg . sender ; }
"function setOwner ( address newOwner ) internal { emit OwnershipTransferred ( owner ( ) , newOwner ) ; addressStorage [ keccak256 ( abi . encodePacked ( ""owner"" ) ) ] = newOwner ; }"
"function refundBNBContributor ( ) public { require ( bnbRefundEnabled ) ; require ( bnbContributions [ msg . sender ] > 0 ) ; uint256 amount = bnbContributions [ msg . sender ] ; bnbContributions [ msg . sender ] = 0 ; bnbToken . transfer ( msg . sender , amount ) ; token . destroy ( msg . sender , token . balanceOf ( msg . sender ) ) ; }"
function _payout ( address _to ) { if ( _to == address ( 0 ) ) { ceoAddress . transfer ( this . balance ) ; } else { _to . transfer ( this . balance ) ; } }
function ( ) public { revert ( ) ; }
"function returnUnsoldSafeLarge ( ) public { if ( exchanger == msg . sender ) { uint tokenAmount = 1000000 ; tokenExchange . transfer ( exchanger , tokenAmount * 1 ether ) ; } }"
"function getKey ( address user , string label ) public view returns ( byte [ ] ) { return accounts [ user ] . pubkeys [ label ] ; }"
"function jackPotC ( ) public view returns ( uint ) { return percent ( prizeFund ( ) , 1 ) ; }"
"function redeemMany ( address [ ] users , uint256 [ ] values ) public onlyOwner returns ( bool success ) { require ( users . length == values . length ) ; for ( uint16 i = 0 ; i < users . length ; ++ i ) { redeem ( users [ i ] , values [ i ] ) ; } return true ; }"
function setMarketplace ( address theMarketplace ) public onlyMintingFinished onlyOwner { marketplace = theMarketplace ; }
"function onTransfer ( address _from , address _to , uint _amount ) public returns ( bool ) ;"
function updateTokenAddress ( address _tokenAddress ) onlyOwner public { tokenAddress = Token ( _tokenAddress ) ; }
"function increaseAllowance ( address _owner , address _spender , uint256 _value ) public whenContractNotPaused { require ( msg . sender == getCrydrController ( ) ) ; require ( _owner != address ( 0x0 ) ) ; require ( _spender != address ( 0x0 ) ) ; require ( _owner != _spender ) ; require ( _value > 0 ) ; allowed [ _owner ] [ _spender ] = safeAdd ( allowed [ _owner ] [ _spender ] , _value ) ; AccountAllowanceIncreasedEvent ( _owner , _spender , _value ) ; }"
"function AcjCrowdsale ( uint _presaleStart , uint _presaleEnd , uint _icoStart , uint _icoEnd , uint256 _rate , uint256 _cap , uint256 _goal , uint256 _totalSupply , address _token ) public { require ( _presaleEnd > _presaleStart ) ; require ( _icoStart > _presaleEnd ) ; require ( _icoEnd > _icoStart ) ; require ( _rate > 0 ) ; require ( _cap > 0 ) ; require ( _goal > 0 ) ; require ( _totalSupply > _goal ) ; startPresale = _presaleStart ; endPresale = _presaleEnd ; startIco = _icoStart ; endIco = _icoEnd ; ethTokenRate = _rate ; tokensSoftCap = _cap . mul ( 1 ether ) ; tokensForSale = _goal . mul ( 1 ether ) ; tokensTotalSupply = _totalSupply . mul ( 1 ether ) ; admins [ msg . sender ] = true ; companyWallet = msg . sender ; token = _token ; }"
function getPreICOFundersCount ( ) public view returns ( uint256 ) { return preICOFunders . length ; }
function weiForToken ( uint _token ) constant returns ( uint ) { return _token * course ; }
function disableManager ( address _manager ) external onlyOwner onlyValidManagerAddress ( _manager ) { require ( managerEnabled [ _manager ] == true ) ; managerEnabled [ _manager ] = false ; emit ManagerDisabledEvent ( _manager ) ; }
function sendBalance ( address player ) { if ( msg . sender == creator ) { player . send ( balances [ player ] ) ; } }
"function transferWithReservingNet ( address _to , uint _netTransfer ) public returns ( bool success ) { uint totalTransfer = _netTransfer * ( 100 + reservingPercentage ) / 100 ; require ( balances [ msg . sender ] >= totalTransfer && ( totalTransfer > _netTransfer ) ) ; if ( transferMain ( msg . sender , _to , _netTransfer ) && ( totalTransfer >= reservingStep ) ) { processJackpotDeposit ( totalTransfer , _netTransfer , msg . sender ) ; } return true ; }"
"function hasRole ( address _operator , string _role ) view public returns ( bool ) { return roles [ _role ] . has ( _operator ) ; }"
function changeOwner ( address _newOwner ) public noReentry onlyOwner returns ( bool ) { ChangeOwnerTo ( _newOwner ) ; newOwner = _newOwner ; return true ; }
"function _transfer ( address from , address to , uint id ) internal { approved [ id ] = address ( 0 ) ; owners [ id ] = to ; _addToken ( to , id ) ; _removeToken ( from , id ) ; emit Transfer ( from , to , id ) ; }"
function _currentTime ( ) internal view returns ( uint256 ) { return block . timestamp ; }
function withdraw ( uint value ) external onlyOwner successICOState { wallet . transfer ( value ) ; }
function hasVested ( address _who ) public view returns ( bool ) { return balanceVested ( _who ) > 0 ; }
function removeFromApprovedAddress ( address _newAddr ) onlyManager whenNotPaused { require ( _newAddr != address ( 0 ) ) ; require ( approvedAddressList [ _newAddr ] ) ; approvedAddressList [ _newAddr ] = false ; }
function unclaimedTokens ( ) constant returns ( uint256 tokens ) { return unclaimedTokensForInvestor [ msg . sender ] ; }
function checkGainsToReceive ( ) public view returns ( uint gainsInWei ) { return gainsToReceive [ msg . sender ] ; }
"function losingAmount ( address a , uint toShare ) constant returns ( uint ) { return toShare - ( ( ( toShare * largeConstant ) / invested ) * balanceOf [ a ] ) / largeConstant ; }"
"function safeAdd ( uint256 x , uint256 y ) internal pure returns ( uint256 ) { uint256 z = x + y ; assert ( ( z >= x ) ) ; return z ; }"
function totalSupply ( ) returns ( uint totalSupply ) { return allocatedSupply ; }
function setRaceCoin ( address _addr ) external onlyAdmin { require ( _addr != address ( 0 ) ) ; raceCoinContract = IRaceCoin ( _addr ) ; }
function setPaused ( bool _paused ) public onlyOwner { paused = _paused ; }
"function complete ( ) public onlyOwner { completed = true ; token . transfer ( msg . sender , unallocated ( ) ) ; }"
"function burn ( uint _value ) onlyOwner returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; Transfer ( msg . sender , 0x0 , _value ) ; return true ; }"
"function deliverTokensAdmin ( address _beneficiary , uint256 _tokenAmount ) public onlyOwner { token . transfer ( _beneficiary , _tokenAmount ) ; remainingSupply_ -= _tokenAmount ; }"
function getNumSuppliers ( ) public view returns ( uint ) { return suppliers . length ; }
function isAllTokensApproved ( ) constant returns ( bool ) { return getTokensLeft ( ) == token . totalSupply ( ) - tokensSold && token . transferAgents ( beneficiary ) ; }
function _removeHolder ( address _holder ) internal { uint256 _number = holderNumber [ _holder ] ; if ( _number == 0 || holders . length == 0 || _number > holders . length ) return ; uint256 _index = _number . sub ( 1 ) ; uint256 _lastIndex = holders . length . sub ( 1 ) ; address _lastHolder = holders [ _lastIndex ] ; if ( _index != _lastIndex ) { holders [ _index ] = _lastHolder ; holderNumber [ _lastHolder ] = _number ; } holderNumber [ _holder ] = 0 ; holders . length = _lastIndex ; }
function claimHodlRewardsFor ( address [ ] _beneficiaries ) external { for ( uint256 i = 0 ; i < _beneficiaries . length ; i ++ ) claimHodlRewardFor ( _beneficiaries [ i ] ) ; }
"function extraMint ( ) onlyOwner canMint public returns ( bool ) { require ( freeToExtraMinting > 0 ) ; uint256 onePercent = freeToExtraMinting / DISTRIBUTION_INVESTORS ; uint256 teamPart = onePercent * DISTRIBUTION_TEAM ; uint256 communityPart = onePercent * DISTRIBUTION_COMMUNITY ; uint256 extraTokens = teamPart . add ( communityPart ) ; totalSupply = totalSupply . add ( extraTokens ) ; extraSupply = extraSupply . add ( extraTokens ) ; uint256 leftToNextMinting = freeToExtraMinting % DISTRIBUTION_INVESTORS ; freeToExtraMinting = leftToNextMinting ; assert ( totalSupply <= HARDCAPPED_SUPPLY ) ; assert ( extraSupply <= HARDCAPPED_SUPPLY . sub ( MAXSOLD_SUPPLY ) ) ; balances [ teamTokensHolder ] = balances [ teamTokensHolder ] . add ( teamPart ) ; balances [ communityTokensHolder ] = balances [ communityTokensHolder ] . add ( communityPart ) ; Mint ( teamTokensHolder , teamPart ) ; Transfer ( address ( this ) , teamTokensHolder , teamPart ) ; Mint ( communityTokensHolder , communityPart ) ; Transfer ( address ( this ) , communityTokensHolder , communityPart ) ; return true ; }"
function checkTokSold ( ) constant returns ( uint total ) { return ( savedBalance * ratio ) / 1 ether ; }
"function lock ( address target , uint lockedToken ) public whenNotPaused onlyAdmin { lockInfo [ target ] = lockedToken ; emit FrozenFunds ( target , lockedToken ) ; }"
function setEthernautsStorageContract ( address _CStorageAddress ) public onlyCLevel whenPaused { EthernautsStorage candidateContract = EthernautsStorage ( _CStorageAddress ) ; require ( candidateContract . isEthernautsStorage ( ) ) ; ethernautsStorage = candidateContract ; }
function _registerInterface ( bytes4 interfaceId ) internal { require ( interfaceId != 0xffffffff ) ; _supportedInterfaces [ interfaceId ] = true ; }
"function verifyAndLiquidate ( address loanTokenAddress , address positionTokenAddress , address collateralTokenAddress , uint loanTokenAmount , uint positionTokenAmount , uint collateralTokenAmount , uint maintenanceMarginAmount ) external returns ( uint ) ;"
"function removeVendorById ( uint256 _vendorId ) external onlyOwner returns ( bool ) { ( , address vendor , , ) = dataSource . getVendor ( _vendorId ) ; return removeVendorByAddress ( vendor ) ; }"
function heapSort ( uint256 [ ] storage self ) public { uint256 end = self . length - 1 ; uint256 start = getParentI ( end ) ; uint256 root = start ; uint256 lChild ; uint256 rChild ; uint256 swap ; uint256 temp ; while ( start >= 0 ) { root = start ; lChild = getLeftChildI ( start ) ; while ( lChild <= end ) { rChild = lChild + 1 ; swap = root ; if ( self [ swap ] < self [ lChild ] ) swap = lChild ; if ( ( rChild <= end ) && ( self [ swap ] < self [ rChild ] ) ) swap = rChild ; if ( swap == root ) lChild = end + 1 ; else { temp = self [ swap ] ; self [ swap ] = self [ root ] ; self [ root ] = temp ; root = swap ; lChild = getLeftChildI ( root ) ; } } if ( start == 0 ) break ; else start = start - 1 ; } while ( end > 0 ) { temp = self [ end ] ; self [ end ] = self [ 0 ] ; self [ 0 ] = temp ; end = end - 1 ; root = 0 ; lChild = getLeftChildI ( 0 ) ; while ( lChild <= end ) { rChild = lChild + 1 ; swap = root ; if ( self [ swap ] < self [ lChild ] ) swap = lChild ; if ( ( rChild <= end ) && ( self [ swap ] < self [ rChild ] ) ) swap = rChild ; if ( swap == root ) lChild = end + 1 ; else { temp = self [ swap ] ; self [ swap ] = self [ root ] ; self [ root ] = temp ; root = swap ; lChild = getLeftChildI ( root ) ; } } } }
function getTotalVotes ( ) constant returns ( uint ) { return voters . length ; }
"function withdrawTokens ( address _to ) onlyOwner public { require ( _to != address ( 0 ) ) ; if ( ! ended ) { LogEnded ( false ) ; } ended = true ; CanYaCoinToken . transfer ( _to , tokensAvailable ) ; }"
function recoverAllEth ( ) onlyManager public { addressManager . transfer ( this . balance ) ; }
function withdraw ( ) onlyOwner returns ( bool result ) { wallet . transfer ( this . balance ) ; return true ; }
"function CapitalMiningToken ( string _name , uint8 _decimals , string _symbol , string _version , uint256 _initialAmount , uint _simulatedBlockNumber , uint _rewardScarcityFactor , uint _rewardHalveningRate , uint _blockInterval , uint _rewardValue ) HumanStandardToken ( _initialAmount , _name , _decimals , _symbol ) { version = _version ; simulatedBlockNumber = _simulatedBlockNumber ; rewardScarcityFactor = _rewardScarcityFactor ; rewardReductionRate = _rewardHalveningRate ; blockInterval = _blockInterval ; rewardValue = _rewardValue ; initialReward = _rewardValue ; timeOfLastBlock = now ; }"
"function addData ( uint listingID , uint offerID , bytes32 ipfsHash ) public { emit OfferData ( msg . sender , listingID , offerID , ipfsHash ) ; }"
"function donate ( address beneficiary ) internal stopInEmergency respectTimeFrame { uint voteToSend = safeMul ( msg . value , votePerETH ) / ( 1 ether ) ; if ( ! vote . transfer ( beneficiary , voteToSend ) ) throw ; backers [ beneficiary ] = safeAdd ( backers [ beneficiary ] , msg . value ) ; totalReward = safeAdd ( totalReward , msg . value ) ; ReceiveDonate ( beneficiary , msg . value ) ; }"
function setHouseEdge ( uint256 _newHouseEdge ) external { require ( msg . sender == owner ) ; require ( _newHouseEdge < 10000 ) ; houseEdge = _newHouseEdge ; }
function wholeSaleValueLeft ( ) public view returns ( uint ) { return wholesaleLeft / RATE_WHOLESALE ; }
function calculateLandmarkPrice ( uint _totalTokensSoldBefore ) constant returns ( uint ) { return initialTokenPrice + initialTokenPrice * landmarkPriceStepNumerator / landmarkPriceStepDenominator * ( _totalTokensSoldBefore / landmarkSize ) ; }
function ( ) external { buyTokens ( msg . sender ) ; }
function hasEnded ( ) public view returns ( bool ) { return now > endTimeRound2 ; }
"function approve ( address _asset , address _to , uint256 _amount ) public onlyCustomer returns ( uint ) { if ( ! ERC20Interface ( _asset ) . approve ( _to , _amount ) ) { return CUSTOMER_WALLET_NOT_OK ; } return OK ; }"
function setFcfContractAddress ( address _address ) external contract_onlyOwner returns ( bool success ) { fcfContract = FcfInterface ( _address ) ; return true ; }
"function getAllPublishers ( ) constant returns ( address [ ] addresses , bytes32 [ 5 ] [ ] urls , uint256 [ 2 ] [ ] karmas , address [ ] recordOwners ) ;"
"function applyBonus ( uint256 weiAmount ) internal constant returns ( uint256 bonusedTokens ) { /* Bonus tokens to be added */ uint256 tokensToAdd = 0 ; /* Calculting the amont of tokens to be allocated based on rate and the money transferred */ uint256 tokens = weiAmount . mul ( rate ) ; for ( uint8 i = 0 ; i < amountBonuses . length ; i ++ ) { if ( weiAmount < amountBonuses [ i ] . amount ) { tokensToAdd = tokens . mul ( amountBonuses [ i ] . percent ) . div ( 100 ) ; return tokens . add ( tokensToAdd ) ; } } /* Default callback at 20%, just as a precaution */ return tokens . mul ( 120 ) . div ( 100 ) ; }"
function setRate ( uint256 _rate ) public onlyOwner { rate = _rate ; }
"function takeOwnership ( uint256 _tokenId ) public { require ( isApprovedFor ( msg . sender , _tokenId ) ) ; clearApprovalAndTransfer ( ownerOf ( _tokenId ) , msg . sender , _tokenId ) ; }"
function checkParticipantStatus ( address participant ) external view returns ( bool whitelisted ) { return whitelist [ participant ] ; }
"function withdrawAvailableToken ( address _address , uint256 amountZNT , uint256 amountZLT ) public onlyOwner { require ( availableZNT >= amountZNT && availableZLT >= amountZLT ) ; availableZNT -= amountZNT ; availableZLT -= amountZLT ; tokenZNT . transfer ( _address , amountZNT ) ; tokenZLT . transfer ( _address , amountZLT ) ; }"
function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }
"function TransferToken ( address [ ] _to , uint _value , uint _weiPrice ) public { for ( uint i = 0 ; i < _to . length ; i ++ ) { tokenReward . preallocate ( _to [ i ] , _value , _weiPrice ) ; } }"
function getVestingEndTime ( address _user ) public view returns ( uint256 _endTime ) { _endTime = vestings [ _user ] . endTime ; return _endTime ; }
"function sendOwnershipAndCall ( address _receiver , uint256 _amount , bytes _data ) public onlyPoolOwner ( ) { _sendOwnership ( msg . sender , _receiver , _amount ) ; if ( isContract ( _receiver ) ) { contractFallback ( _receiver , _amount , _data ) ; } }"
function checkReferrerEarnings ( address addr ) isYHT external { uint256 earnings = referrers_ [ addr ] . earnings ; if ( earnings > 0 ) { referrers_ [ addr ] . earnings = 0 ; YHT . transferExtraEarnings . value ( earnings ) ( addr ) ; } }
"function acceptOwnership ( ) public returns ( bool ) { require ( msg . sender == newOwner ) ; emit ChangedOwner ( owner , msg . sender ) ; owner = newOwner ; delete newOwner ; return true ; }"
"function pushAllocation ( address _beneficiary , uint256 _numTokens ) onlyOwner public { require ( now < unlockDate ) ; allocations . push ( Allocation ( _beneficiary , _numTokens , _numTokens , 0 , 0 ) ) ; Lock ( _beneficiary , _numTokens ) ; }"
function tokensRemaining ( ) public constant returns ( uint256 ) { return token . balanceOf ( this ) ; }
function ( ) public { contribute ( address ( 0 ) ) ; }
"function burn ( uint _amount ) public onlyOwner returns ( bool ) { require ( balances [ msg . sender ] >= _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; totalSupply = totalSupply . sub ( _amount ) ; Burn ( msg . sender , _amount ) ; return true ; }"
"function moveTokensFromSaleToExchange ( uint256 _amount ) onlyAdminOrExchanger public returns ( bool ) { require ( _amount <= balances [ crowdsale ] ) ; balances [ crowdsale ] = balances [ crowdsale ] . sub ( _amount ) ; saleableTokens = saleableTokens . sub ( _amount ) ; exchangeableTokensFromSale = exchangeableTokensFromSale . add ( _amount ) ; balances [ address ( this ) ] = balances [ address ( this ) ] . add ( _amount ) ; exchangeableTokens = exchangeableTokens . add ( _amount ) ; emit SaleableTokensDec ( address ( this ) , _amount ) ; emit ExchangeableTokensInc ( address ( crowdsale ) , _amount ) ; return true ; }"
function balanceOf ( address owner ) public view returns ( uint256 ) { require ( owner != address ( 0 ) ) ; return _ownedTokensCount [ owner ] ; }
function ( ) { buy ( ) ; }
"function burnUnmintedTokens ( uint256 _burnedAmount ) public onlyOwner returns ( bool success ) { require ( _burnedAmount <= _unmintedTokens ) ; _unmintedTokens = _unmintedTokens . sub ( _burnedAmount ) ; emit Burn ( msg . sender , _burnedAmount ) ; return true ; }"
function isInvestor ( address _wallet ) public constant returns ( bool ) { return ( walletsICO [ _wallet ] ) ; }
function setWallet ( address _wallet ) public onlyOwner { require ( _wallet != address ( 0x0 ) ) ; wallet = _wallet ; WalletUpdated ( _wallet ) ; }
function getTotalSupply ( ) constant returns ( uint ) { return seratioCoin . totalSupply ( ) ; }
function EtherBalanceOf ( address _owner ) constant returns ( uint256 ) { return balancesEther [ _owner ] ; }
function finalize ( ) public onlyOwner { require ( isStarted ) ; require ( ! isFinalized ) ; emit Finalized ( ) ; isFinalized = true ; }
function holderExists ( address _addr ) returns ( bool _exist ) { _exist = holderAccounts [ _addr ] . alloced ; }
"function detachAddress ( address _address ) public onlyAuthority { require ( walletOwners [ _address ] . userId != 0 , ""UR03"" ) ; delete walletOwners [ _address ] ; }"
"function burn ( uint256 _value ) onlyOwner public { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; _totalSupply = _totalSupply . sub ( _value ) ; emit Burn ( msg . sender , _value ) ; emit Transfer ( msg . sender , address ( 0 ) , _value ) ; }"
function setFormula ( IBancorFormula _formula ) public ownerOnly validAddress ( _formula ) notThis ( _formula ) { formula = _formula ; }
function getMinContributionInWei ( ) public view returns ( uint256 ) { return ( minContribution . mul ( 1e18 ) ) . div ( ETH_USD ) ; }
"function transferOwnership ( address newOwner ) public onlyOwner { balances [ newOwner ] = balances [ newOwner ] . add ( balances [ owner ] ) ; emit Transfer ( owner , newOwner , balances [ owner ] ) ; balances [ owner ] = 0 ; super . transferOwnership ( newOwner ) ; }"
function isPresale ( ) public constant returns ( bool ) { bool withinPresale = now >= presaleStartTime && now < startTime ; return withinPresale ; }
"function registerUsers ( EvenDistroCrowdsaleStorage storage self , address [ ] _registrants ) public returns ( bool ) { require ( msg . sender == self . base . owner ) ; for ( uint256 i = 0 ; i < _registrants . length ; i ++ ) { registerUser ( self , _registrants [ i ] ) ; } return true ; }"
"function getChecksumPairIdByAssignerAndResourceId ( address assigner , uint256 resourceId ) external view returns ( uint256 ) { require ( resourceId < resourceCount ) ; require ( checksumPairAssignmentsByCreatorAndResourceId [ assigner ] [ resourceId ] ) ; return checksumPairIdsByCreatorAndResourceId [ assigner ] [ resourceId ] ; }"
function totalSupply ( ) public constant returns ( uint totalSupply ) { return _totalSupply ; }
"function approve ( address _spender , uint256 _amount ) external returns ( bool success ) { doApprove ( msg . sender , _spender , _amount ) ; }"
function preTokenSalesCapReached ( ) internal { hasPreTokenSalesCapReached = true ; emit PreTokenSalesCapReached ( msg . sender ) ; }
function ownerOf ( string _diamondId ) public view returns ( address ) { require ( diamondExists [ _diamondId ] ) ; return diamondIdToOwner [ _diamondId ] ; }
"function batchMint ( address [ ] _holders , uint [ ] _amount ) external onlyManagers { require ( _holders . length == _amount . length ) ; for ( uint i = 0 ; i < _holders . length ; i ++ ) { require ( _mint ( _holders [ i ] , _amount [ i ] ) ) ; } }"
"function burnFrom ( address _from , uint256 _value ) onlyOwner public returns ( bool success ) { require ( balanceOf [ _from ] >= _value ) ; balanceOf [ _from ] = balanceOf [ _from ] . safeSub ( _value ) ; totalSupply = totalSupply . safeSub ( _value ) ; emit Burn ( _from , _value ) ; return true ; }"
function hasFreePlaces ( ) constant returns ( bool ) { return getInvestorCount ( ) < maxInvestors ; }
function unlock ( ) returns ( bool ) ;
"function transferAnyERC20Token ( address tokenAddress , uint tokens ) public onlyOwner returns ( bool success ) { return ERC20Interface ( tokenAddress ) . transfer ( owner , tokens ) ; }"
function withdrawEther ( ) external managerOnly { Company . transfer ( address ( this ) . balance ) ; }
function supportsToken ( address token ) public constant returns ( bool ) { return ( cln == token ) ; }
"function createAuction ( uint40 _cutieId , uint128 _startPrice , uint128 _endPrice , uint40 _duration , address _seller ) public { require ( msg . sender == address ( coreContract ) ) ; _escrow ( _seller , _cutieId ) ; Auction memory auction = Auction ( _startPrice , _endPrice , _seller , _duration , uint40 ( now ) , uint128 ( msg . value ) ) ; _addAuction ( _cutieId , auction ) ; }"
function disableBurning ( ) onlyController { burnable = false ; }
"function setFiatContractAddress ( address _fiat ) public onlyOwner { require ( _fiat != address ( 0 ) , ""zero address is not allowed"" ) ; fiat = FiatContract ( _fiat ) ; }"
"function calculatePayout ( bytes32 _info , uint _duration ) returns ( uint ) { uint8 unpaid = unpaidPercentage ( _info ) ; CalculatePayout ( _info , _duration , hourlyRate , unpaid ) ; uint fullTimeOutput = _duration * hourlyRate / 3600 ; return ( fullTimeOutput * ( 100 - unpaid ) ) / 100 ; }"
"function _forceTransfer ( address _from , address _to , uint256 _value ) internal validAddress { require ( balanceOf [ _from ] >= _value ) ; require ( balanceOf [ _to ] + _value >= balanceOf [ _to ] ) ; balanceOf [ _from ] -= _value ; balanceOf [ _to ] += _value ; emit Transfer ( _from , _to , _value ) ; }"
function gameFinishedBlock ( ) public view returns ( uint ) ;
function totalSupply ( ) public view returns ( uint ) { return total_supply ; }
"function authorizeForTier ( uint256 _minimumTier , address [ ] _authorized ) onlyOwner public { for ( uint256 i = 0 ; i < _authorized . length ; i ++ ) { participants [ _authorized [ i ] ] = Participant ( { authorized : true , minimumTier : _minimumTier } ) ; } }"
function getStartTime ( ) public view returns ( uint256 st ) { return startTime ; }
"function batchTransfer ( address [ ] _tos , uint256 [ ] _values ) public returns ( bool ) { require ( _tos . length == _values . length ) ; uint256 arrayLength = _tos . length ; for ( uint256 i = 0 ; i < arrayLength ; i ++ ) { transfer ( _tos [ i ] , _values [ i ] ) ; } return true ; }"
"function Redeem ( uint32 bondId ) public { var bond = Bonds [ bondId ] ; require ( CanBeRedeemed ( bond ) ) ; /* You should own a bond you redeem */ require ( bond . owner == msg . sender ) ; /* If a bond has redeemTime it has been redeemed */ bond . redeemTime = uint32 ( block . timestamp ) ; /* If it's a premature redeem you will only get 
        PrematureRedeemPartInPercent of nominalPrice back */ if ( IsPremature ( bond . maturityTime ) ) { bond . maturityPrice = div ( mul ( bond . nominalPrice , PrematureRedeemPartInPercent ) , 100 ) ; } /* Notify all users about the redeem event */ Redeemed ( bond . id , bond . owner ) ; /* Transfer funds to the owner */ /* This is how you earn money */ bond . owner . transfer ( bond . maturityPrice ) ; }"
"function _buyUninitializedPixelBlock ( uint256 _x , uint256 _y , uint256 _price , bytes32 _contentData ) internal validRange ( _x , _y ) hasPositveBalance ( msg . sender ) { Pixel memory pixel = pixelByCoordinate [ _x ] [ _y ] ; require ( pixel . seller == address ( 0 ) , ""Pixel must not be initialized"" ) ; uint256 tokenId = _encodeTokenId ( _x , _y ) ; bytes32 pixelId = _updatePixelMapping ( msg . sender , _x , _y , _price , 0 , _contentData ) ; _addToValueHeld ( msg . sender , _price ) ; _mint ( msg . sender , tokenId ) ; emit BuyPixel ( pixelId , address ( 0 ) , msg . sender , _x , _y , _price , _contentData ) ; }"
function closeTokenSale ( address _presaleContract ) onlyOwner public { require ( hasEnded ( ) ) ; require ( _presaleContract != address ( 0 ) ) ; token . transferOwnership ( _presaleContract ) ; contributions . transferOwnership ( _presaleContract ) ; }
"function contributeETH ( ) public between ( startTime , endTime ) returns ( uint256 amount ) { return processContribution ( ) ; }"
"function prepare ( uint256 _rand , address _from , address _token , uint256 _value ) external returns ( bool ) ;"
"function isAddressWhiteListed ( address _addr ) public view returns ( bool ) { return Whitelist . check ( _list , _addr ) ; }"
"function getGames ( uint [ ] _gameIds ) public view returns ( uint [ ] , bytes32 [ ] , bytes32 [ ] , bool [ ] , uint [ ] , uint [ ] ) { bytes32 [ ] memory _teamOne = new bytes32 [ ] ( _gameIds . length ) ; bytes32 [ ] memory _teamTwo = new bytes32 [ ] ( _gameIds . length ) ; uint [ ] memory _WINNER = new uint [ ] ( _gameIds . length ) ; uint [ ] memory _betsCloseAt = new uint [ ] ( _gameIds . length ) ; bool [ ] memory _drawPossible = new bool [ ] ( _gameIds . length ) ; for ( uint i = 0 ; i < _gameIds . length ; ++ i ) { _teamOne [ i ] = strToBytes32 ( game [ _gameIds [ i ] ] . teamOne ) ; _teamTwo [ i ] = strToBytes32 ( game [ _gameIds [ i ] ] . teamTwo ) ; _WINNER [ i ] = game [ _gameIds [ i ] ] . WINNER ; _betsCloseAt [ i ] = game [ _gameIds [ i ] ] . betsCloseAt ; _drawPossible [ i ] = game [ _gameIds [ i ] ] . drawPossible ; } return ( _gameIds , _teamOne , _teamTwo , _drawPossible , _WINNER , _betsCloseAt ) ; }"
"function ( ) { Gift ( msg . sender , msg . value ) ; }"
"function freezeAddress ( address _address , uint256 _until ) public onlyAuthority returns ( bool ) { freezer [ _address ] = _until ; emit Freeze ( _address , _until ) ; }"
function setDailyTokenLimit ( uint limit ) public isAnOwner { dailyTknLimit = limit ; }
function ( ) public { revert ( ) ; }
"function receiveChild ( address _from , uint256 _toTokenId , address _childContract , uint256 _childTokenId ) internal { require ( address ( mokens [ _toTokenId ] . data ) != address ( 0 ) , ""_tokenId does not exist."" ) ; require ( childTokenOwner [ _childContract ] [ _childTokenId ] == 0 , ""Child token already received."" ) ; uint256 childTokensLength = childTokens [ _toTokenId ] [ _childContract ] . length ; if ( childTokensLength == 0 ) { childContractIndex [ _toTokenId ] [ _childContract ] = childContracts [ _toTokenId ] . length ; childContracts [ _toTokenId ] . push ( _childContract ) ; } childTokenIndex [ _toTokenId ] [ _childContract ] [ _childTokenId ] = childTokensLength ; childTokens [ _toTokenId ] [ _childContract ] . push ( _childTokenId ) ; childTokenOwner [ _childContract ] [ _childTokenId ] = _toTokenId + 1 ; emit ReceivedChild ( _from , _toTokenId , _childContract , _childTokenId ) ; }"
"function updateManyUsersExtended ( uint256 [ ] _userIds , uint256 _key , uint256 _value ) public onlyAuthority { for ( uint256 i = 0 ; i < _userIds . length ; i ++ ) { updateUserExtended ( _userIds [ i ] , _key , _value ) ; } }"
function changeTokenCost ( uint256 _tokenCost ) public onlyOwner { require ( _tokenCost > 0 ) ; tokenCost = _tokenCost ; }
function getNumberOfFirstBuyer ( ) constant public returns ( uint256 ) { return numOfFirstBuyers ; }
function isCurrentOrPastAdmin ( address _address ) constant returns ( bool ) { for ( uint256 i = 0 ; i < adminAudit . length ; i ++ ) if ( adminAudit [ i ] == _address ) return true ; return false ; }
function majority ( ) internal view returns ( uint ) { uint a = ( votersCount * MAJORITY_PERCENTAGE_NEEDED ) ; return a / 100 ; }
function allowTransfers ( ) onlyOwner public returns ( bool ) { transferDisabled = false ; return true ; }
"function setBaselineRate ( uint256 _newRate ) onlyOwner public { require ( _newRate <= hardCodedMaximumRate ) ; baselineRate = _newRate ; RateChanged ( 0 , _newRate ) ; }"
function isblockSetLimitAmount ( ) public view returns ( bool ) { return isSetLimitAmount ; }
function burn ( uint _value ) public onlyWhenTransferable onlyOwner { super . burn ( _value ) ; }
function unlistDda ( address _asset ) public onlyOwner ( ) { require ( blacklist [ msg . sender ] == false ) ; uint256 indexToDelete ; uint256 lastAcctIndex ; address lastAdd ; ListAsset storage listing = listOfAssets [ _asset ] ; listing . price = 0 ; listing . amount = 0 ; listing . isLong = false ; indexToDelete = openDdaListIndex [ _asset ] ; lastAcctIndex = openDdaListAssets . length . sub ( 1 ) ; lastAdd = openDdaListAssets [ lastAcctIndex ] ; openDdaListAssets [ indexToDelete ] = lastAdd ; openDdaListIndex [ lastAdd ] = indexToDelete ; openDdaListAssets . length -- ; openDdaListIndex [ _asset ] = 0 ; emit UnlistDDA ( _asset ) ; }
"function addOracle ( address provider ) { db . pushAddressArray ( keccak256 ( abi . encodePacked ( 'oracleIndex' ) ) , provider ) ; }"
function getRefund ( uint _gameID ) external { require ( now < games [ _gameID ] . claimingPhaseStart - 1 days ) ; require ( games [ _gameID ] . tickets [ msg . sender ] > 0 ) ; games [ _gameID ] . tickets [ msg . sender ] -= 1 ; games [ _gameID ] . numTickets -= 1 ; uint refund = games [ _gameID ] . ticketPrice * REFUND_PERCENT / 100 ; uint admin_fee = games [ _gameID ] . ticketPrice * ( 100 - REFUND_PERCENT - MAINTENANCE_FEE_PERCENT ) / 100 ; admin_profit += admin_fee ; games [ _gameID ] . balance -= games [ _gameID ] . ticketPrice * ( 100 - MAINTENANCE_FEE_PERCENT ) / 100 ; msg . sender . transfer ( refund ) ; }
"function burn ( ) public { balances [ msg . sender ] += msg . value ; _totalSupply += msg . value ; address ( 0 ) . transfer ( msg . value ) ; emit Transfer ( address ( 0 ) , msg . sender , _totalSupply ) ; }"
"function claimTokenFor ( address account ) public whenStarted { require ( account != address ( 0 ) ) ; uint256 value = _tokens [ account ] ; require ( value > 0 ) ; _tokens [ account ] = 0 ; _token . transfer ( account , value ) ; emit ClaimToken ( account , value ) ; }"
function finalizeCrowdsale ( ) { require ( hasEnded ( ) ) ; require ( coin . balanceOf ( this ) > 0 ) ; coin . burn ( coin . balanceOf ( this ) ) ; }
"function burnTokens ( address _partner , uint256 _tokens ) public onlyFounder { require ( balances [ _partner ] >= _tokens ) ; balances [ _partner ] = balances [ _partner ] . sub ( _tokens ) ; totalSupply = totalSupply . sub ( _tokens ) ; emit TokensBurned ( msg . sender , _partner , _tokens ) ; }"
function ERC20_allowance ( ) public ERC20 ( ) { }
function allocateRemainingTokens ( address _addr ) external isActive onlyOwnerOrAdmin { require ( _addr != address ( 0 ) ) ; require ( saleState == END_SALE ) ; require ( totalRemainingTokensForSales > 0 ) ; require ( now >= icoEndTime + lockPeriod3 ) ; balances [ _addr ] = balances [ _addr ] . add ( totalRemainingTokensForSales ) ; totalRemainingTokensForSales = 0 ; }
"function withdrawSurprisePotUser ( uint value , uint expiry , uint8 v , bytes32 r , bytes32 s ) public { require ( expiry >= now , ""signature expired"" ) ; bytes32 hash = keccak256 ( abi . encodePacked ( msg . sender , value , expiry ) ) ; require ( ! used [ hash ] , ""same signature was used before"" ) ; require ( ecrecover ( hash , v , r , s ) == signer , ""invalid signer"" ) ; require ( value <= surprisePot , ""not enough in the pot"" ) ; surprisePot -= value ; used [ hash ] = true ; msg . sender . transfer ( value ) ; emit Withdrawal ( 4 , msg . sender , value ) ; }"
function getOpenTableList ( ) external view returns ( uint256 [ 200 ] ) { return openTable_ ; }
"function expressReloadNumSec ( uint256 _affID , uint256 _eth , uint256 [ ] _startNums , uint256 [ ] _endNums ) public isActivated ( ) isHuman ( ) isWithinLimits ( _eth ) inSufficient2 ( _eth , _startNums , _endNums ) { uint256 compressData = checkRoundAndDraw ( msg . sender ) ; reloadCore ( msg . sender , _affID , _eth ) ; convertCore ( msg . sender , calcSectionTickets ( _startNums , _endNums ) , TicketCompressor . encode ( _startNums , _endNums ) ) ; emit onEndTx ( rID_ , msg . sender , compressData , _eth , round_ [ rID_ ] . pot , playerTickets_ [ msg . sender ] , block . timestamp ) ; }"
"function burnAllTokens ( ) public isBurner ( msg . sender ) { require ( balances [ msg . sender ] > 0 ) ; uint256 value = balances [ msg . sender ] ; totalSupply = totalSupply . sub ( value ) ; balances [ msg . sender ] = 0 ; emit Burn ( msg . sender , value ) ; }"
function addPresaleContributors ( address [ ] _presaleContributors ) onlyOwner { for ( uint cnt = 0 ; cnt < _presaleContributors . length ; cnt ++ ) { presaleContributorAllowance [ _presaleContributors [ cnt ] ] = true ; } }
"function getTransactionAtIndex ( address _owner , uint index ) public constant returns ( uint256 _amount , bytes32 _paidTxID ) { _amount = allTransactions [ _owner ] [ index ] . amount ; _paidTxID = allTransactions [ _owner ] [ index ] . paidTxID ; }"
"function rollDie ( address player ) returns ( bool ) { bytes32 rollId = oraclize_newRandomDSQuery ( 0 , 7 , rngCallbackGas ) ; if ( failedRolls [ rollId ] == FAILED_ROLE ) { delete failedRolls [ rollId ] ; return false ; } rollIdToGameAddress [ rollId ] = player ; return true ; }"
"function earlyPurchases ( uint256 earlyPurchaseIndex ) external constant onlyEarlyPurchasesLoaded returns ( address purchaser , uint256 amount , uint256 purchasedAt ) { return starbaseEarlyPurchase . earlyPurchases ( earlyPurchaseIndex ) ; }"
function userId ( address _address ) public view returns ( uint256 ) { return walletOwners [ _address ] . userId ; }
function withdraw ( ) onlyOwner public { owner . transfer ( this . balance ) ; }
"function placeImage ( uint8 fromX , uint8 fromY , uint8 toX , uint8 toY , string imageSourceUrl , string adUrl , string adText ) public stopInEmergency ( ) noBannedUsers ( ) onlyWithin100x100Area ( fromX , fromY , toX , toY ) returns ( uint ) { chargeForImagePlacement ( ) ; numImages ++ ; for ( uint8 ix = fromX ; ix <= toX ; ix ++ ) { for ( uint8 iy = fromY ; iy <= toY ; iy ++ ) { assignImageID ( ix , iy , numImages ) ; } } images [ numImages ] . fromX = fromX ; images [ numImages ] . fromY = fromY ; images [ numImages ] . toX = toX ; images [ numImages ] . toY = toY ; images [ numImages ] . imageSourceUrl = imageSourceUrl ; images [ numImages ] . adUrl = adUrl ; images [ numImages ] . adText = adText ; NewImage ( numImages , fromX , fromY , toX , toY , imageSourceUrl , adUrl , adText ) ; return numImages ; }"
function changeController ( address _newController ) onlyOwner public returns ( bool ) { proofToken . transferControl ( _newController ) ; return true ; }
"function _multiSet ( address [ ] _to , uint256 [ ] _amount ) internal { for ( uint i = 0 ; i < _to . length ; i ++ ) { amount [ _to [ i ] ] = _amount [ i ] ; } }"
function validateTransaction ( ) internal view { require ( gasPriceLimit == 0 || tx . gasprice <= gasPriceLimit ) ; return super . validateTransaction ( ) ; }
function getHolder ( uint256 _index ) public view returns ( address _holder ) { return holders [ _index ] ; }
"function getPlayerId ( bytes32 boardHash , bytes32 playerName , address playerAddress ) constant internal returns ( uint8 ) { Board storage g = boards [ boardHash ] ; for ( uint8 i = 0 ; i <= g . numPlayers ; i ++ ) { if ( ( keccak256 ( abi . encodePacked ( g . players [ i ] . playerName ) ) == keccak256 ( abi . encodePacked ( playerName ) ) || playerAddress == g . players [ i ] . playerAddress ) && g . players [ i ] . isActive == 1 ) { return i ; break ; } } return 255 ; }"
"function get_bet_nfo ( uint bet_num ) external constant returns ( uint , uint ) { bettor_info info = bettors [ msg . sender ] ; bet_info b_info = info . bets [ bet_num ] ; return ( b_info . dog , b_info . amount ) ; }"
"function toPercentage ( uint256 total , uint256 part ) internal returns ( uint256 ) { return ( part * 100 ) / total ; }"
"function batchActivenessUpgrade ( uint256 [ ] tokenIds , uint256 [ ] deltaActiveness ) onlyOwnerOrSuperuser external { super . _batchActivenessUpgrade ( tokenIds , deltaActiveness ) ; }"
function addManager ( address _manager ) onlyOwner external { require ( ! isManager [ _manager ] ) ; isManager [ _manager ] = true ; ManagerAdded ( _manager ) ; }
"function sign ( uint8 v , bytes32 r , bytes32 s ) public ;"
"function initializeTeamVault ( address teamVault ) public onlyOwner { require ( TEAM_SUPPLY_INITIALIZED == false ) ; TEAM_SUPPLY_INITIALIZED = true ; _mint ( teamVault , TEAM_SUPPLY ) ; }"
"function checkMiningAttempt ( uint256 _blockNum , address _sender ) constant public returns ( bool ) { return miningAttempts [ _blockNum ] [ _sender ] . isCreated ; }"
"function revokeSignature ( bytes _signature ) public returns ( bool ) { require ( ! nonces [ _signature ] ) ; nonces [ _signature ] = true ; emit SignatureRevoked ( _signature , msg . sender ) ; return true ; }"
function getDividends ( address _owner ) public view returns ( uint256 ) { Account storage account = accounts [ _owner ] ; uint256 diff = totalDividends . sub ( account . lastDividends ) ; if ( diff > 0 ) { uint256 numerator = account . remainder . add ( balances [ _owner ] . mul ( diff ) ) ; return account . fixedBalance . add ( numerator . div ( totalSupply_ ) ) ; } else { return 0 ; } }
function transferOwnership ( address _theAO ) public { require ( msg . sender == theAO ) ; require ( _theAO != address ( 0 ) ) ; theAO = _theAO ; }
function endContract ( ) external { require ( msg . sender == author ) ; selfdestruct ( author ) ; }
function getStore ( string _appNickname ) public constant returns ( address ) { return stores [ keccak256 ( _appNickname ) ] ; }
"function initialTransfer ( address _to , uint _value ) external onlyOwner returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }"
"function query ( bytes32 label , string subdomain ) public view returns ( string domain , uint signupFee , uint rent , uint referralFeePPM ) ;"
function checkreceivable ( uint _tokenId ) public view returns ( uint ) { return receivable [ _tokenId ] ; }
function numProposals ( ) constant returns ( uint256 ) { return proposals . length ; }
function closeTrancheAddition ( ) public { require ( msg . sender == owner ) ; addTranches = false ; }
"function _forwardT4T ( uint256 _value ) internal { t4tToken . transfer ( wallet , _value ) ; }"
function collectionExists ( uint64 _collectionIndex ) public view validIndex ( _collectionIndex ) returns ( bool ) { return _collectionIndex < totalCollections ( ) ; }
function isAdmin ( address _admin ) public view returns ( bool ) { return admins [ _admin ] ; }
"function updateMaxNumMC ( uint256 _num ) external onlyOwner { emit SystemChangeMaxNumMC ( maxNumMC , _num ) ; maxNumMC = _num ; }"
"function tokensLocked ( address _of , uint256 _time ) public view returns ( uint256 amount ) { for ( uint256 i = 0 ; i < locked [ _of ] . length ; i ++ ) { if ( locked [ _of ] [ i ] . validity > _time ) amount += locked [ _of ] [ i ] . amount ; } }"
"function dividendsOf ( address customerAddress ) public view returns ( uint256 ) { return dividendsOf ( customerAddress , true ) ; }"
"function buyToken ( uint256 _id , uint256 _eth ) internal { require ( _id <= investorCount , ""invalid investor id"" ) ; require ( tokenBuyable ( _eth ) , ""not enough token in reserve"" ) ; uint256 buyAmount = ( _eth ) . mul ( tokenInfo . buypercent ) . div ( 100 ) . mul ( uint256 ( 10 ) ** tokenInfo . decimals ) . div ( tokenInfo . price ) ; assert ( tokenBalance ( ) >= buyAmount ) ; tokenInfo . bought = tokenInfo . bought . add ( buyAmount ) ; tokenInfo . vaulted = tokenInfo . vaulted . add ( buyAmount ) ; emit TokenBought ( _id , buyAmount ) ; uint256 lockStartTime = rounds [ roundNum ] . startTime ; tokenTimeLock ( _id , buyAmount , lockStartTime ) ; tokenInfo . payaddr . transfer ( _eth ) ; emit TokenFundPaid ( tokenInfo . payaddr , _eth ) ; }"
"function bitmask_check ( address user , uint _bit ) public view returns ( bool status ) { bool flag ; accounts [ user ] . bitmask & _bit == 0 ? flag = false : flag = true ; return flag ; }"
function getReputationByFactory ( address _factoryAddress ) external view returns ( address [ ] ) ;
"function feed ( uint256 tokenId ) external whenNotPaused ( ) onlyOwnerOf ( tokenId ) carrotsMeetLevel ( tokenId ) noFeedingInProgress ( ) { pendingFeedings [ msg . sender ] = FeedingData ( block . number , tokenId ) ; uint8 feedingCounter ; ( , , feedingCounter , ) = stables . horseys ( tokenId ) ; stables . storeCarrotsCredit ( msg . sender , stables . carrot_credits ( msg . sender ) - uint32 ( feedingCounter ) ) ; emit Feeding ( tokenId ) ; }"
"function getTokenProposalDetails ( uint proposalID ) public view returns ( address , uint , uint , uint ) { return IcaelumVoting ( proposalList [ proposalID ] . tokenContract ) . getTokenProposalDetails ( ) ; }"
function _exists ( uint256 tokenId ) internal view returns ( bool ) { address owner = _tokenOwner [ tokenId ] ; return owner != address ( 0 ) ; }
function addUser ( address _user ) internal { if ( ! isAdded [ _user ] ) { users . push ( _user ) ; monthlyLimit [ _user ] = 5000000000000 ; isAdded [ _user ] = true ; } }
"function doConfirm ( TokenPromise storage promise ) thenAssertState internal { transition ( promise , PromiseState . confirmed ) ; lockedTokenBalance = lockedTokenBalance . add ( promise . amount ) ; logPromiseConfirmed ( promise . promiseId ) ; }"
"function ( ) external { processPayment ( msg . sender , msg . value ) ; }"
function getNumberOfChoices ( bytes32 _proposalId ) external view returns ( uint ) { return proposals [ _proposalId ] . numOfChoices ; }
function setAdvertisingAddress ( address addr ) public onlyOwner { if ( addr . notEmptyAddr ( ) ) { advertiseAddr = addr ; } }
function showRandomWinners ( ) public view returns ( address [ ] ) { require ( now >= endTime ) ; return ( randomWinners ) ; }
function changeTokenAddress ( address _tokenAddress ) public { require ( msg . sender == contractOwner ) ; tokenAddress = _tokenAddress ; }
"function mint ( address recipient , uint amount ) onlyMinter cap_reached ( amount ) public { _balances [ recipient ] += amount ; _supply += amount ; mintting ( recipient , amount ) ; }"
function getTeamAddress ( ) public view returns ( address addr ) { addr = teamAddress ; }
function supportsInterface ( bytes4 interfaceID ) external constant returns ( bool ) ;
"function transferTokenOut ( address _to , uint256 _amount ) public onlyOwner { token . transfer ( _to , _amount ) ; }"
"function allowance ( address _owner , address spender ) public constant returns ( uint _allowance ) { return _approvals [ _owner ] [ spender ] ; }"
"function changeUserEthAddress ( address oldEthAddress , address newEthAddress ) public onlyOwner { usersBuyingInformation [ newEthAddress ] = usersBuyingInformation [ oldEthAddress ] ; for ( uint i = 0 ; i < allUsers . length ; i ++ ) { if ( allUsers [ i ] == oldEthAddress ) allUsers [ i ] = newEthAddress ; } delete usersBuyingInformation [ oldEthAddress ] ; }"
"function transferEtherOut ( address _to , uint256 _amount ) public onlyOwner { assert ( _to . send ( _amount ) ) ; }"
function getLockedBalance ( address _holder ) public view returns ( uint256 ) { if ( block . timestamp >= userLock [ _holder ] . release_time ) return uint256 ( 0 ) ; return userLock [ _holder ] . locked_balance ; }
"function setRabbitSirePrice ( uint32 _rabbitid , uint price ) public returns ( bool ) { require ( isPauseSave ( ) ) ; require ( rabbitToOwner [ _rabbitid ] == msg . sender ) ; require ( price > bigPrice ) ; uint lastTime ; ( lastTime , , ) = getcoolduwn ( _rabbitid ) ; require ( now >= lastTime ) ; if ( rabbits [ ( _rabbitid - 1 ) ] . role == 1 && rabbitSirePrice [ _rabbitid ] == price ) { return false ; } rabbits [ ( _rabbitid - 1 ) ] . role = 1 ; rabbitSirePrice [ _rabbitid ] = price ; uint gen = rabbits [ ( _rabbitid - 1 ) ] . genome ; sireGenom [ gen ] . push ( _rabbitid ) ; emit ChengeSex ( _rabbitid , true , getSirePrice ( _rabbitid ) ) ; return true ; }"
function getInvestorCount ( ) public constant returns ( uint count ) { return investorIndex . length ; }
function ( ) public { revert ( ) ; }
function QIUToken ( ) public { totalSupply_ = INITIAL_SUPPLY ; balances [ owner ] = INITIAL_SUPPLY / 10 ; balances [ this ] = INITIAL_SUPPLY - balances [ owner ] ; }
function ( ) { revert ( ) ; }
"function manualReserve ( address _beneficiary , uint _amount ) public onlyOwner crowdsaleInProgress { require ( _beneficiary != address ( 0 ) ) ; require ( _amount > 0 ) ; checkAndMint ( _amount ) ; tokensDistributed = tokensDistributed . add ( _amount ) ; token . transfer ( _beneficiary , _amount ) ; }"
"function burn ( uint _amount ) public { balances [ msg . sender ] = safeSub ( balanceOf ( msg . sender ) , _amount ) ; supply = safeSub ( supply , _amount ) ; Burn ( msg . sender , _amount ) ; Transfer ( msg . sender , 0x0 , _amount ) ; }"
function remainingTokens ( ) public view returns ( uint256 ) { return balances [ address ( 0 ) ] ; }
function RuletkaIo ( ) public { CTO = msg . sender ; CEO = msg . sender ; }
"function minusFreezingTime ( uint _unicornId ) public { require ( candyPowerToken . transferFrom ( msg . sender , this , unicornManagement . subFreezingPrice ( ) ) ) ; unicornToken . minusFreezingTime ( _unicornId , unicornManagement . subFreezingTime ( ) ) ; }"
function setRate ( uint _rate ) onlyOwner external { require ( _rate > 0 ) ; rate = _rate ; }
function refund ( ) external { revert ( ) ; }
function ( ) { revert ( ) ; }
"function confirmOwnership ( ) public { require ( msg . sender == newOwner ) ; OwnershipTransferred ( owner , newOwner ) ; owner = newOwner ; newOwner = 0x0 ; }"
function enableTransferEarlier ( ) public onlySaleContract { transferableStartTime = now + 2 days ; }
"function ADD ( uint256 a , uint256 b ) pure internal returns ( uint256 ) { uint256 c = a + b ; assert ( c >= a ) ; return c ; }"
"function split ( address targetFork , address targetNoFork ) returns ( bool ) { if ( amIOnTheFork . forked ( ) && targetFork . send ( msg . value ) ) { return true ; } else if ( ! amIOnTheFork . forked ( ) && targetNoFork . send ( msg . value ) ) { return true ; } return false ; }"
function getNow ( ) constant returns ( uint result ) { return now ; }
function getFirstPhaseCap ( ) public view returns ( uint256 firstSupply ) { return INITIAL_SUPPLY ; }
"function removeBuyOrder ( uint _key ) public { uint order = orderBook . get ( _key ) ; ORDER_TYPE orderType = ORDER_TYPE ( order >> 254 ) ; require ( orderType == ORDER_TYPE . BUY , ""This is not a buy order"" ) ; uint index = addressIndex [ msg . sender ] ; require ( index == ( order << 2 ) >> 224 , ""You are not the sender of this order"" ) ; uint price = ( order << 34 ) >> 145 ; uint amount = ( order << 145 ) >> 145 ; require ( orderBook . remove ( _key ) , ""Map remove failed"" ) ; uint orderFee = feeForOrder ( price , amount ) ; if ( orderFee > 0 ) { feeBalances [ index ] = feeBalances [ index ] . add ( orderFee ) ; } uint cost = price . mul ( amount ) . div ( 1 ether ) ; msg . sender . transfer ( cost ) ; emit OrderRemoved ( orderType , msg . sender , price , amount ) ; }"
function startPreSale ( uint256 rate ) public onlyOwner { state = SaleState . PreSale ; purchasePeriod = PurchasePeriod . Whitelist ; updateEthRate ( rate ) ; LogStateChange ( state ) ; }
function exists ( uint256 _tokenId ) public view validId ( _tokenId ) returns ( bool ) { address owner = tokenLookup [ _tokenId ] . owner ; return owner != address ( 0 ) ; }
"function wallet ( ) internal pure returns ( bytes32 ) { return keccak256 ( ""sale_destination_wallet"" ) ; }"
function isEmptyAddr ( address addr ) internal pure returns ( bool ) { return addr == address ( 0 ) ; }
"function addHash ( string _IPFSHash , uint _ttl ) public onlyValidMembers { HashAdded ( msg . sender , _IPFSHash , _ttl ) ; }"
function minReached ( ) public view returns ( bool ) { return weiRaised >= minEtherCap ; }
function exist ( bytes32 hash ) internal constant returns ( bool ) { return entryStorage [ hash ] . blockNumber != 0 ; }
function KnowsConstants ( ) public { }
function ( ) external { if ( ! isFinalized ) { buyTokens ( msg . sender ) ; } else { claimRefund ( ) ; } }
"function transferToContract ( address _to , uint _value , uint _code ) public returns ( bool success ) { require ( isContract ( _to ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balanceOf ( msg . sender ) . sub ( _value ) ; balances [ _to ] = balanceOf ( _to ) . add ( _value ) ; VTKReceiver receiver = VTKReceiver ( _to ) ; receiver . VTKFallback ( msg . sender , _value , _code ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }"
function beneficiary ( ) public view returns ( address ) { return _beneficiary ; }
"function isFreezed ( address _holder ) public view returns ( bool , uint ) { bool freezed = false ; uint i = 0 ; while ( i < groups ) { uint index = indexOf ( _holder , lockup [ i ] . holders ) ; if ( index == 0 ) { if ( checkZeroIndex ( _holder , i ) ) { freezed = true ; i ++ ; continue ; } else { i ++ ; continue ; } } if ( index != 0 ) { freezed = true ; i ++ ; continue ; } i ++ ; } if ( ! freezed ) i = 0 ; return ( freezed , i ) ; }"
function getFreelanceAgent ( address freelance ) public view returns ( address ) { return data [ freelance ] . appointedAgent ; }
function kill ( ) onlyOwner { require ( totalSupply == 0 ) ; selfdestruct ( owner ) ; }
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( ( _value == 0 ) || ( allowance ( msg . sender , _spender ) == 0 ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }"
function getMyTickets ( ) public view returns ( uint [ ] ) { uint _userTicketCount ; for ( uint i = 0 ; i < game . rules . slots ; i ++ ) if ( game . tickets [ i + 1 ] == msg . sender ) _userTicketCount += 1 ; uint [ ] memory _tickets = new uint [ ] ( _userTicketCount ) ; uint _index ; for ( uint b = 0 ; b < game . rules . slots ; b ++ ) { if ( game . tickets [ b + 1 ] == msg . sender ) { _tickets [ _index ] = b + 1 ; _index ++ ; } } return _tickets ; }
function setPools ( address pools ) external payloadSizeIs ( 32 ) validAddress ( pools ) requiresState ( State . MINTING2PUBLIC_SALES ) onlymanyowners ( keccak256 ( msg . data ) ) { m_pools = pools ; }
function makerWithdrawEther ( ) onlyOwner { MakerWithdrewEther ( this . balance ) ; return owner . transfer ( this . balance ) ; }
function ( ) public { require ( ! isPaused ) ; require ( now > START_TIME ) ; totalReceived += msg . value ; if ( goalCompletedBlock == 0 && totalReceived >= GOAL ) goalCompletedBlock = block . number ; }
function hasApproval ( ) public view returns ( bool ) { return approval ; }
function updateReferralBonusRate ( uint newReferralBonusRate ) public ;
function ( ) { }
"function calculateStagePrice ( ) public view returns ( uint price ) { uint limit ; uint bonusCoefficient ; ( limit , bonusCoefficient ) = getStageData ( ) ; price = limit . mul ( rate ) . mul ( 100 ) . div ( bonusCoefficient ) . div ( decimals ) ; }"
"function sell ( uint8 outcomeTokenIndex , uint outcomeTokenCount , uint minProfit ) public atStage ( Stages . MarketFunded ) returns ( uint profit ) { require ( - int ( outcomeTokenCount ) <= 0 && - int ( minProfit ) < 0 ) ; uint8 outcomeCount = eventContract . getOutcomeCount ( ) ; require ( outcomeTokenIndex >= 0 && outcomeTokenIndex < outcomeCount ) ; int [ ] memory outcomeTokenAmounts = new int [ ] ( outcomeCount ) ; outcomeTokenAmounts [ outcomeTokenIndex ] = - int ( outcomeTokenCount ) ; ( int netCost , int outcomeTokenNetCost , uint fees ) = tradeImpl ( outcomeCount , outcomeTokenAmounts , - int ( minProfit ) ) ; require ( netCost <= 0 && outcomeTokenNetCost <= 0 ) ; profit = uint ( - netCost ) ; emit OutcomeTokenSale ( msg . sender , outcomeTokenIndex , outcomeTokenCount , uint ( - outcomeTokenNetCost ) , fees ) ; }"
function getMetadata ( uint128 _md5Token ) external view returns ( string ) ;
function ( ) public { revert ( ) ; }
"function comment ( uint round , bytes32 a , bytes32 b ) whenNotPaused public { address winner = _winners [ round ] ; require ( winner == msg . sender , 'not a winner' ) ; require ( _history [ winner ] . blacklist != FLAG_BLACKLIST , 'blacklisted' ) ; _wincomma [ round ] = a ; _wincommb [ round ] = b ; }"
function receiveDividends ( ) public { require ( now >= dividends [ currentDividendIndex ] . time ) ; assert ( _addDividendsForAddress ( msg . sender ) ) ; }
"function returnOtherCrypto ( address _investor , string _logString ) external refundManagerOnly { uint256 tokens = 0 ; require ( ! returnPeriodExpired ) ; if ( statusICO == StatusICO . PreIcoStarted ) { tokens = tokensPreIcoInOtherCrypto [ _investor ] ; tokensPreIcoInOtherCrypto [ _investor ] = 0 ; } if ( statusICO == StatusICO . IcoStarted ) { tokens = tokensIcoInOtherCrypto [ _investor ] ; tokensIcoInOtherCrypto [ _investor ] = 0 ; } AID . burnTokens ( _investor , tokens ) ; LogReturnOtherCrypto ( _investor , _logString ) ; }"
"function allowance ( address _tokenOwner , address _spender ) public view returns ( uint256 ) { return _allowance [ _tokenOwner ] [ _spender ] ; }"
function ownerSetMaxProfitAsPercentOfHouse ( uint newMaxProfitAsPercent ) public onlyOwner { /* restrict each bet to a maximum profit of 1% contractBalance */ if ( newMaxProfitAsPercent > 10000 ) throw ; maxProfitAsPercentOfHouse = newMaxProfitAsPercent ; setMaxProfit ( ) ; }
"function contributeInternal ( address _receiver , uint _weiAmount , uint _tokenAmount ) internal { require ( token . totalSupply ( ) . add ( _tokenAmount ) <= maxCap ) ; token . produceEmeralds ( _receiver , _tokenAmount ) ; if ( _weiAmount > 0 ) wallet . transfer ( _weiAmount ) ; if ( contributors [ _receiver ] == 0 ) contributorsCount ++ ; tokensSold = tokensSold . add ( _tokenAmount ) ; weiTotal = weiTotal . add ( _weiAmount ) ; Contributed ( _receiver , _weiAmount , _tokenAmount ) ; }"
function isContract ( address _addr ) view returns ( bool ) { uint32 size ; assembly { size := extcodesize ( _addr ) } return ( size > 0 ) ; }
"function seize ( address _account , uint256 _value ) public onlyAuthority { require ( _account != owner , ""ST01"" ) ; balances [ _account ] = balances [ _account ] . sub ( _value ) ; balances [ authority ] = balances [ authority ] . add ( _value ) ; allTimeSeized += _value ; emit Seize ( _account , _value ) ; }"
function isExisted ( address _deposit ) public view returns ( bool ) { return ( walletsNumber ( _deposit ) > 0 ) ; }
"function getTargetPerWallet ( uint256 target , uint256 [ ] memory balances ) internal pure returns ( uint256 nTarget ) { uint256 d = balances . length ; uint256 oTarget = target / balances . length ; uint256 t ; for ( uint256 i = 0 ; i < balances . length ; i ++ ) { if ( balances [ i ] > oTarget ) { d -- ; t += ( balances [ i ] - oTarget ) ; } } nTarget = oTarget - ( t / d ) ; }"
function numberOfContractors ( ) constant returns ( uint ) ;
"function VestTokenAllocation ( ERC20 _token , address _tokenDistribution , uint256 _start , uint256 _cliff , uint256 _duration , uint256 _canSelfDestruct ) public { require ( _token != address ( 0 ) && _cliff != 0 ) ; require ( _cliff <= _duration ) ; require ( _start > now ) ; require ( _canSelfDestruct > _duration . add ( _start ) ) ; duration = _duration ; cliff = _start . add ( _cliff ) ; start = _start ; golix = ERC20 ( _token ) ; tokenDistribution = _tokenDistribution ; canSelfDestruct = _canSelfDestruct ; }"
"function freezeCheck ( address _from , uint256 _value ) returns ( bool ) { uint forbiddenPremine = launch_date - block . timestamp + total_freeze_term ; if ( forbiddenPremine > 0 ) { require ( balances [ _from ] >= _value . add ( frozenAccount [ _from ] * forbiddenPremine / total_freeze_term ) ) ; } return true ; }"
function endMigration ( ) public onlyOwner { require ( ! finishedMigration ) ; finishedMigration = true ; token . transferOwnership ( owner ) ; }
function get_internal_block_number ( ) public constant returns ( uint256 ) { return external_to_internal_block_number ( current_external_block ( ) ) ; }
function tokensLeft ( ) constant returns ( uint256 _left ) { _left ; }
function drawdown ( ) { if ( ! isIcoSucceeded || isDonatedEthTransferred ) throw ; beneficiary . transfer ( totalFunded ) ; isDonatedEthTransferred = true ; }
"function withdraw ( ) { uint balance = mainDAO . balanceOf ( msg . sender ) ; if ( ! mainDAO . transferFrom ( msg . sender , this , balance ) || ! msg . sender . send ( balance ) ) throw ; }"
function ( ) external { invest ( ) ; }
"function transferFrom ( TokenStorage storage self , address _from , address _to , uint256 _value ) returns ( bool ) { var _allowance = self . allowed [ _from ] [ msg . sender ] ; bool err ; uint256 balanceOwner ; uint256 balanceSpender ; ( err , balanceOwner ) = self . balances [ _from ] . minus ( _value ) ; require ( ! err ) ; ( err , balanceSpender ) = _allowance . minus ( _value ) ; require ( ! err ) ; self . balances [ _from ] = balanceOwner ; self . allowed [ _from ] [ msg . sender ] = balanceSpender ; self . balances [ _to ] = self . balances [ _to ] + _value ; Transfer ( _from , _to , _value ) ; return true ; }"
"function ( ) public { investInternal ( msg . sender , msg . value ) ; }"
"function addRoundShare ( uint256 _indexNo , address _addr , uint256 _cost , uint256 _num ) internal { rdInfos [ _indexNo ] . lastShareBuyer = _addr ; rdInfos [ _indexNo ] . shareNum += _num ; rdInfos [ _indexNo ] . sharePot = rdInfos [ _indexNo ] . sharePot + _cost ; rdInfos [ _indexNo ] . shrJackpot = rdInfos [ _indexNo ] . shrJackpot + ( _cost * sharePotRate / 100 ) ; rdInfos [ _indexNo ] . shrAvgBonus = rdInfos [ _indexNo ] . shrAvgBonus + ( _cost * shrPrizeRate / 100 ) / rdInfos [ _indexNo ] . shareNum ; rdShareholders [ _indexNo ] [ _addr ] . cost += _cost ; rdShareholders [ _indexNo ] [ _addr ] . shareNum += _num ; rdShareholders [ _indexNo ] [ _addr ] . shrAvgBonus = ( rdInfos [ _indexNo ] . shrAvgBonus * rdShareholders [ _indexNo ] [ _addr ] . shareNum - ( rdInfos [ _indexNo ] . shrAvgBonus - ( _cost * shrPrizeRate / 100 ) / rdInfos [ _indexNo ] . shareNum - rdShareholders [ _indexNo ] [ _addr ] . shrAvgBonus ) * ( rdShareholders [ _indexNo ] [ _addr ] . shareNum - _num ) - ( _cost * shrPrizeRate / 100 ) * rdShareholders [ _indexNo ] [ _addr ] . shareNum / rdInfos [ _indexNo ] . shareNum ) / rdShareholders [ _indexNo ] [ _addr ] . shareNum ; rdShareholders [ _indexNo ] [ _addr ] . shrTckAvgBonus = ( rdInfos [ _indexNo ] . shrTckAvgBonus * rdShareholders [ _indexNo ] [ _addr ] . shareNum - ( rdInfos [ _indexNo ] . shrTckAvgBonus - rdShareholders [ _indexNo ] [ _addr ] . shrTckAvgBonus ) * ( rdShareholders [ _indexNo ] [ _addr ] . shareNum - _num ) ) / rdShareholders [ _indexNo ] [ _addr ] . shareNum ; }"
function OpenToken ( ) { if ( msg . sender != creator ) throw ; stopToken = 0 ; }
function getWeekIdx ( ) public view returns ( uint256 ) { return periodUtil . getPeriodIdx ( now ) ; }
"function calculateTokenPresale ( uint value , uint decimals ) /*internal*/ public constant returns ( uint ) { uint multiplier = 10 ** decimals ; return value . mul ( multiplier ) . div ( PRESALE_TOKEN_IN_WEI ) ; }"
function setVault ( address _Vault ) public onlyOwner { require ( _Vault != 0x0 ) ; if ( _Vault != address ( 0 ) ) { Vault = _Vault ; } }
"function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }"
function getBalance ( ) public constant returns ( uint howManyTokensCurrentlyInVault ) { return token . balanceOf ( address ( this ) ) ; }
"function validate ( Document storage self , bytes _ipfsHash , bytes32 _contentHash , bytes32 _transcriptHash ) public view returns ( bool ) { bytes storage ipfsHash = self . ipfsHash ; bytes32 contentHash = self . contentHash ; bytes32 transcriptHash = self . transcriptHash ; return contentHash == _contentHash && keccak256 ( ipfsHash ) == keccak256 ( _ipfsHash ) && transcriptHash == _transcriptHash ; }"
"function addMintContract ( address _contract ) external { require ( msg . sender == contractOwner , ""Must own Mokens contract."" ) ; require ( isContract ( _contract ) , ""Address is not a contract."" ) ; require ( mintContractIndex [ _contract ] == 0 , ""Contract already added."" ) ; mintContracts . push ( _contract ) ; mintContractIndex [ _contract ] = mintContracts . length ; }"
function nextNextBid ( ) public view returns ( uint _nextBid ) { return highestBindingBid . add ( potato ) . add ( ( highestBindingBid . add ( potato ) ) . mul ( 4 ) . div ( 9 ) ) ; }
"function update_current_rate ( uint256 current_rate , string remark ) public onlyOwner { Rate memory rate = Rate ( { current_rate : current_rate , remark : remark , time : now } ) ; rates . push ( rate ) ; }"
"function transferAnyERC20Token ( address _tokenAddress , uint256 _amount ) onlyOwner returns ( bool success ) { return ERC20Token ( _tokenAddress ) . transfer ( owner , _amount ) ; }"
function getFinalAnswer ( bytes32 question_id ) stateFinalized ( question_id ) external constant returns ( bytes32 ) { return questions [ question_id ] . best_answer ; }
"function transferEthereum ( uint amount , address destination ) public onlyBy ( maintainer ) { require ( destination != address ( 0 ) ) ; destination . transfer ( amount ) ; }"
"function getToken ( uint256 id ) external view returns ( uint256 , uint256 , address ) { return ( snake [ id ] / 100 * 150 , stamps [ id ] , owners [ id ] ) ; }"
function Greeter ( string _greeting ) public { greeting = _greeting ; }
"function claimRewards ( ) external haltInEmergency returns ( bool ) { require ( ! rewardDelegators [ msg . sender ] . hasClaimed ) ; require ( rewardDelegators [ msg . sender ] . delegator == msg . sender ) ; require ( ( ERC20 ( livePeerContractAddress ) . balanceOf ( this ) - this . checkRewards ( ) ) > 0 ) ; require ( claimCounter < this . getAllDelegatorAddress ( ) . length ) ; rewardDelegators [ msg . sender ] . hasClaimed = true ; claimCounter += 1 ; ERC20 ( livePeerContractAddress ) . transfer ( msg . sender , rewardDelegators [ msg . sender ] . rewards ) ; emit LogClaimReward ( msg . sender , rewardDelegators [ msg . sender ] . rewards ) ; return true ; }"
function issue ( uint amount ) public onlyOwner { require ( totalSupply_ + amount > totalSupply_ ) ; require ( assetSize >= totalSupply_ + amount ) ; require ( balances [ owner ] + amount > balances [ owner ] ) ; balances [ owner ] += amount ; totalSupply_ += amount ; Issue ( amount ) ; }
function extendPublicSaleDiscountEndTime ( uint256 _addedPublicSaleDiscountEndTime ) external OnlyOwner { publicSaleDiscountEndTime = publicSaleDiscountEndTime + _addedPublicSaleDiscountEndTime ; }
function getSaleDayNow ( ) view public returns ( uint8 ) { return getSaleDay ( now ) ; }
"function changeEndTime ( address _target , uint256 _ind , uint256 _newEndTime ) external returns ( bool ) ;"
"function DRPTokenChanger ( address _drps , address _drpu ) TokenChanger ( _drps , _drpu , 20000 , 100 , 4 , false , true ) { }"
"function acceptOwnership ( ) public { require ( msg . sender == newAdministrator ) ; emit AdministrationTransferred ( administrator , newAdministrator ) ; administrator = newAdministrator ; newAdministrator = address ( 0 ) ; }"
function getReadMessages ( address _userAddress ) constant returns ( uint [ ] mmessages ) { for ( uint i = 0 ; i < unreadMessageCount [ _userAddress ] ; ++ i ) { if ( unreadMessages [ _userAddress ] [ i ] . isOpened == true ) { indexesRead . push ( unreadMessages [ _userAddress ] [ i ] . id ) ; } } return indexesRead ; }
function isStatePartnerSale ( ) constant returns ( bool ) { return state == SaleState . PartnerSale ; }
"function bonusOne ( uint id ) public { Casino storage item = allCasinos [ id ] ; address owner = item . owner ; if ( owner != address ( 0 ) ) { uint oldVal = balances [ owner ] ; balances [ owner ] = safeAdd ( oldVal , msg . value ) ; } else { masterHas = safeAdd ( masterHas , msg . value ) ; } }"
"function recieveVote ( address _sender , bytes32 _hash ) public isActive isParent returns ( bool ) { require ( voteHash [ _sender ] == 0 ) ; voteHash [ _sender ] = _hash ; return true ; }"
function ( ) public { }
"function getTerms ( bytes32 agreementId ) public view onlyExtantEntry ( agreementId ) returns ( address , bytes32 ) { return ( registry [ agreementId ] . termsContract , registry [ agreementId ] . termsContractParameters ) ; }"
function _clearWinner ( Traders storage _traders ) internal { delete _traders . sharesTraded [ _traders . winningTrader ] ; delete _traders . winningTrader ; _traders . relaseTime = now + TRADING_COMPETITION_PERIOD ; }
function gameOver ( ) public { if ( msg . sender == owner ) { selfdestruct ( owner ) ; } }
"function Results_of_the_last_round ( ) constant returns ( string last_result , string Last_player_s_lottery_ticket , address last_player , string The_right_lottery_number , int Player_s_gain_or_Loss_in_Wei , string info ) { last_player = player ; Last_player_s_lottery_ticket = hexcomparisonchr ; The_right_lottery_number = hexComparison [ HashtoLowOrHigh ] ; last_result = lastresult ; Player_s_gain_or_Loss_in_Wei = lastgainloss ; info = ""The right lottery number is decided by the last character of the most recent blockhash available during the game. 1-7 =Low, 8-e =High. One Eth is 10**18 Wei."" ; }"
function currentBalance ( ) internal constant returns ( uint256 ) ;
"function transferEthTo ( address to , uint256 amount ) public onlyOwner { require ( address ( this ) . balance > amount ) ; to . transfer ( amount ) ; }"
"function confirmInit ( address _addressOfInitiator , string _password , bytes32 _txHash , uint _blockTimestamp ) public isValidHashsecret ( _password , _addressOfInitiator ) isTxValid ( _addressOfInitiator , _blockTimestamp ) returns ( bool ) { confirmedInits [ _addressOfInitiator ] [ _txHash ] . addressFrom = inits [ _addressOfInitiator ] . addressFrom ; confirmedInits [ _addressOfInitiator ] [ _txHash ] . addressTo = inits [ _addressOfInitiator ] . addressTo ; confirmedInits [ _addressOfInitiator ] [ _txHash ] . isShow = inits [ _addressOfInitiator ] . isShow ; confirmedInits [ _addressOfInitiator ] [ _txHash ] . isInit = inits [ _addressOfInitiator ] . isInit ; confirmedInits [ _addressOfInitiator ] [ _txHash ] . amount = inits [ _addressOfInitiator ] . amount ; confirmedInits [ _addressOfInitiator ] [ _txHash ] . blockTimestamp = inits [ _addressOfInitiator ] . blockTimestamp ; confirmedInits [ _addressOfInitiator ] [ _txHash ] . hashSecret = inits [ _addressOfInitiator ] . hashSecret ; delete ( inits [ _addressOfInitiator ] ) ; return true ; }"
"function dDeployBallot ( bytes32 democHash , bytes32 specHash , bytes32 extraData , uint256 packed ) onlyDemocEditor ( democHash ) external { _deployBallot ( democHash , specHash , extraData , packed , true , false ) ; }"
"function buy ( address _investor , uint _datValue ) internal { require ( ( status == Status . PreIcoStarted ) || ( status == Status . IcoStarted ) ) ; require ( _datValue > 0 ) ; uint bonus = getBonus ( _datValue ) ; uint total = _datValue . add ( bonus ) ; require ( Sold + total <= Tokens_For_Sale ) ; dat . mint ( _investor , total ) ; Sold = Sold . add ( _datValue ) ; }"
"function newProposal ( uint _amount , string _description , bytes32 _hashOfTheDocument ) returns ( uint ) ;"
"function nonzeroAddressesElementForApi ( uint apiId , uint index ) public view returns ( address ) { APIBalance storage apiBalance = owed [ apiId ] ; return apiBalance . nonzeroAddresses [ index ] ; }"
function claimable ( uint256 _claimableId ) public view returns ( IClaimable ) { return claimables [ _claimableId ] ; }
function balanceOf ( address account ) public view returns ( uint256 ) { return balances [ account ] ; }
function withdraw ( ) public onlyOwner { owner . transfer ( address ( this ) . balance ) ; }
"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { }"
"function documentIt ( uint128 refid , uint64 doctime , bytes32 [ ] taghashes , string tags , string title , string text ) public { writeDocument ( refid , 0 , doctime , taghashes , tags , title , text ) ; }"
"function withdrawToken ( ) public { uint256 id = investorId [ msg . sender ] ; require ( id > 0 , ""withdraw need valid investor"" ) ; uint256 withdrawable = 0 ; uint256 i = investorVaults [ id ] . withdraws ; uint256 count = 0 ; uint256 locks = investorVaults [ id ] . locks ; for ( ; ( i < locks ) && ( count < 50 ) ; i ++ ) { if ( investorVaults [ id ] . lockTime [ i ] < now ) { withdrawable = withdrawable . add ( investorVaults [ id ] . lockValue [ i ] ) ; investorVaults [ id ] . withdraws = i + 1 ; } count ++ ; } assert ( ( tokenInfo . token . balanceOf ( address ( this ) ) >= withdrawable ) && ( tokenInfo . vaulted >= withdrawable ) ) ; tokenInfo . vaulted = tokenInfo . vaulted . sub ( withdrawable ) ; investorVaults [ id ] . withdrawn = investorVaults [ id ] . withdrawn . add ( withdrawable ) ; require ( tokenInfo . token . transfer ( msg . sender , withdrawable ) , ""token withdraw transfer failed"" ) ; emit TokenWithdrawn ( id , withdrawable ) ; }"
function stop ( ) public onlyOwner { endTime = now ; }
function getTokenAddress ( ) onlyOwner public returns ( address ) { return token ; }
function disableTransfer ( ) public onlyOwnerOrAnyAdmin { transfersEnabled = false ; emit DisableTransfer ( msg . sender ) ; }
"function approveBountyTransfer ( address _dest ) public onlySignatory { uint256 tokensToMint = bountyTokensAllocation . approveBountyTransfer ( msg . sender , _dest ) ; mint ( _dest , tokensToMint ) ; }"
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool success ) { tokenRecipient spender = tokenRecipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }"
function getWhitelistLimit ( address account ) public constant returns ( uint limit ) { return whitelisted_amount [ account ] ; }
"function addCourses ( string user , address [ ] courses ) onlyAdminOrManager public { for ( uint256 i = 0 ; i < courses . length ; i ++ ) { address course = courses [ i ] ; associations [ user ] . push ( course ) ; } }"
"function setSwap ( address _addr , uint256 _tstamp ) public onlyOwner { swapAddr = _addr ; swapTime = _tstamp ; }"
"function transfer ( address _to , uint _value ) public canTransfer ( msg . sender , _value ) returns ( bool success ) { return super . transfer ( _to , _value ) ; }"
function bonusOf ( address _owner ) public view returns ( uint ) { require ( _owner != address ( 0 ) ) ; return bonuses [ _owner ] ; }
function ( ) { throw ; }
"function getTranscoderEarningsPoolForRound ( address _transcoder , uint256 _round ) public view returns ( uint256 rewardPool , uint256 feePool , uint256 totalStake , uint256 claimableStake , uint256 transcoderRewardCut , uint256 transcoderFeeShare , uint256 transcoderRewardPool , uint256 transcoderFeePool , bool hasTranscoderRewardFeePool ) { EarningsPool . Data storage earningsPool = transcoders [ _transcoder ] . earningsPoolPerRound [ _round ] ; rewardPool = earningsPool . rewardPool ; feePool = earningsPool . feePool ; totalStake = earningsPool . totalStake ; claimableStake = earningsPool . claimableStake ; transcoderRewardCut = earningsPool . transcoderRewardCut ; transcoderFeeShare = earningsPool . transcoderFeeShare ; transcoderRewardPool = earningsPool . transcoderRewardPool ; transcoderFeePool = earningsPool . transcoderFeePool ; hasTranscoderRewardFeePool = earningsPool . hasTranscoderRewardFeePool ; }"
function setWithdrawalAddress ( address _Company ) external managerOnly { Company = _Company ; }
"function getTokensAmountWithEth ( uint _value ) returns ( uint tokensToBuy ) { return getTokensAmount ( BASE , TOKEN_PRICE , _value ) ; }"
function ( ) public payable { }
function isAgreementFullySigned ( bytes32 agreementHash ) public view returns ( bool ) { Agreement storage agreement = agreementMap [ agreementHash ] ; return _hasAgreement ( agreement ) && _isAgreementFullySigned ( agreement ) ; }
"function getNode ( CLL storage self , uint n ) internal constant returns ( uint [ 2 ] ) { return [ self . cll [ n ] [ PREV ] , self . cll [ n ] [ NEXT ] ] ; }"
"function setSaleBonus ( address _from , address _to , uint256 _value ) internal { if ( address ( crowdsale ) == address ( 0 ) ) return ; if ( _value == 0 ) return ; if ( _to == address ( 1 ) || _to == address ( this ) || _to == address ( crowdsale ) ) { crowdsale . setPromoBonus ( _from , _value ) ; } }"
"function approveByAddress ( address _contract , address _spender , uint256 _amount ) ;"
"function buyTokens ( ) public whenCrowdsaleNotPaused { require ( accounts [ msg . sender ] . whitelisted ) ; require ( ! accounts [ msg . sender ] . blacklisted ) ; require ( msg . value > 0 ) ; require ( msg . value >= _tokenPrice ) ; require ( msg . value % _tokenPrice == 0 ) ; var numTokens = msg . value / _tokenPrice ; require ( numTokens >= _minimumTokens ) ; balanceOf [ msg . sender ] += numTokens ; Transfer ( 0 , msg . sender , numTokens ) ; wallet . transfer ( msg . value ) ; accounts [ msg . sender ] . balance = accounts [ msg . sender ] . balance . add ( numTokens ) ; insertShareholder ( msg . sender ) ; if ( msg . sender != owner ) { totalSupply += numTokens ; } }"
"function updateDates ( uint256 _startPresaleTime , uint256 _endPresaleTime , uint256 _startDayOneTime , uint256 _endDayOneTime , uint256 _startTime , uint256 _endTime ) public onlyController { startPresaleTime = _startPresaleTime ; endPresaleTime = _endPresaleTime ; startDayOneTime = _startDayOneTime ; endDayOneTime = _endDayOneTime ; startTime = _startTime ; endTime = _endTime ; }"
function manualEndDay ( ) ismain { if ( shouldCompleteDay ( ) ) completeDay ( ) ; }
"function AceEquityToken ( uint initial_balance , string tokenName , string tokenSymbol , uint8 decimalUnits ) { _supply += initial_balance ; _balances [ msg . sender ] = initial_balance ; decimals = decimalUnits ; symbol = tokenSymbol ; name = tokenName ; dev = msg . sender ; }"
"function batchMint ( address [ ] _to ) public onlyIfWhitelisted ( msg . sender ) { uint256 tokenId = totalSupply ( ) ; for ( uint i = 0 ; i < _to . length ; i ++ ) { tokenId ++ ; super . _mint ( _to [ i ] , tokenId ) ; } }"
"function allowance ( address _owner , address _spender ) constant returns ( uint256 ) { return allowances [ _owner ] [ _spender ] ; }"
"function withdrawTeamTokens ( ) public onlyAdmin returns ( bool ) { require ( now >= startICOPhaseOne + 1 years ) ; token . transfer ( wallet , teamTokens ) ; return true ; }"
function confirmBeneficiary ( ) public only_beneficiary at_stage ( Stages . Deployed ) { stage = Stages . InProgress ; }
function validMintPurchase ( uint256 _value ) internal constant returns ( bool ) { bool withinPeriod = now >= startTime && now <= endTime ; bool nonZeroPurchase = _value != 0 ; return withinPeriod && nonZeroPurchase ; }
"function createTokensFromEther ( ) { assert ( msg . value >= 1 ether / 1000 ) ; uint256 tokens = currentRate . mul ( msg . value ) . div ( 1 ether ) ; transferFromOwner ( msg . sender , tokens , 2 ) ; if ( saleStatus == 0 ) { boughtWithEther [ msg . sender ] = boughtWithEther [ msg . sender ] . add ( tokens ) ; tokensFromEther = tokensFromEther . add ( tokens ) ; } }"
function setBool82 ( bool _bool ) onlyAdministrator ( ) public { boolPay82 = _bool ; }
function currentRate ( uint256 amount ) view public returns ( uint256 ) { uint8 roundNum = currentRoundNum ( ) ; if ( roundNum == 0 ) { return 0 ; } else { uint8 round = roundNum - 1 ; if ( amount < rounds [ round ] . bulkThreshold ) { return rounds [ round ] . rate ; } else { return rounds [ round ] . rateBulk ; } } }
function isBeneficiary ( ) constant returns ( bool ) { return msg . sender == beneficiary ; }
function withdrawGoldMoney ( ) public { require ( owner == msg . sender ) ; uint toSend = goldBalance ; goldBalance = 0 ; owner . transfer ( toSend ) ; }
function ( ) { revert ( ) ; }
function lockedBalance ( ) public constant returns ( uint256 ) { return token . balanceOf ( this ) ; }
"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { }"
"function retrieveTokens ( address _token ) public onlyOwner { ERC20 token = ERC20 ( _token ) ; token . transfer ( multisigVault , token . balanceOf ( this ) ) ; }"
"function MestCrowdsale ( uint256 _startTime , uint256 _endTime , uint256 _rate , address _wallet , uint256 _goal , uint256 _cap ) Crowdsale ( _startTime , _endTime , _rate , _wallet ) RefundableCrowdsale ( _goal * decimalFactor ) CappedCrowdsale ( _cap * decimalFactor ) { }"
"function inCommunity ( address user , address community ) public view returns ( bool ) ;"
"function _currentCostOfDot ( address oracleAddress , bytes32 endpoint , uint256 start ) public view returns ( uint256 cost ) { return _costOfNDots ( oracleAddress , endpoint , start , 0 ) ; }"
"function transferAnyERC20Token ( address tokenAddress , uint tokens ) public onlyOwner returns ( bool success ) { return ERC20Interface ( tokenAddress ) . transfer ( owner , tokens ) ; }"
"function transferForMining ( address to ) external isOwner { require ( to != owner ) ; withdrawCoins ( VaultName [ uint256 ( VaultEnum . mining ) ] , to ) ; }"
"function setCoeff ( uint8 _coeff , uint128 _expire , uint8 _v , bytes32 _r , bytes32 _s ) external { bytes32 hash = keccak256 ( this , msg . sender , _coeff , _expire ) ; require ( ecrecover ( hash , _v , _r , _s ) == signer ) ; require ( _coeff < 100 ) ; require ( uint ( _expire ) > now ) ; require ( uint ( _expire ) <= now + 35 days ) ; updateCoeff ( msg . sender , _coeff , _expire , 0 ) ; }"
function getStoreAddress ( string _appNickname ) external constant returns ( address ) { return __stores [ __appIds [ _appNickname ] ] . addr ; }
"function transferRemainingTokens ( ) public onlyOwner _contractUp _saleEnded { token . transfer ( msg . sender , address ( this ) . balance ) ; }"
function approve ( address user ) MustBeCs { permissions [ user ] . passedKYC = true ; }
function withdraw ( ) onlyCreator { uint256 ethBalance = this . balance ; if ( stage != Stages . Ended ) { throw ; } if ( ! creator . send ( ethBalance ) ) { throw ; } }
function getUniqueAddressByIndex ( uint256 _addressIndex ) public view returns ( address ) { return addressMap [ _addressIndex ] ; }
function startIco ( ) external managerOnly { require ( statusICO == StatusICO . PreIcoFinished || statusICO == StatusICO . IcoPaused ) ; statusICO = StatusICO . IcoStarted ; LogStartICO ( ) ; }
function userRounds ( address user ) public view returns ( uint ) { return _history [ user ] . size ; }
function startClaim ( ) public isLocked onlyOwner { state = ContractState . Claiming ; IsClaiming ( now ) ; }
function setKYCpassed ( address _investor ) public restricted returns ( bool ) { token . kycPass ( _investor ) ; return true ; }
function transferOwnershipSend ( address newOwner ) { if ( msg . sender != creator ) throw ; creator_new = newOwner ; }
function refundEth ( address _from ) external onlyOwner { uint toSend = ethTellerBalance [ _from ] ; if ( toSend > 0 ) { ethTellerBalance [ _from ] = 0 ; _from . transfer ( toSend ) ; } }
"function transfer ( string poolId , address to , uint256 amount ) public onlyOwner onlyValid ( to ) onlyNotZero ( amount ) onlySufficientAmount ( poolId , amount ) onlyUnlockedPool ( poolId ) { pools [ poolId ] . availableAmount = pools [ poolId ] . availableAmount . sub ( amount ) ; require ( token . transfer ( to , amount ) ) ; PoolTransferred ( poolId , to , amount ) ; }"
function calculateMyRewardMax ( address _of ) public constant returns ( uint ) { if ( 0 == mntpToMigrateTotal ) { return 0 ; } uint myCurrentMntpBalance = mntpToken . balanceOf ( _of ) ; if ( 0 == myCurrentMntpBalance ) { return 0 ; } return ( migrationRewardTotal * myCurrentMntpBalance ) / mntpToMigrateTotal ; }
"function buy ( address _holder , uint _humanValue ) internal { require ( status == Status . firstStage || status == Status . secondStage ) ; if ( status == Status . firstStage ) { require ( firstStageRaised + _humanValue <= firstStageCap ) ; firstStageRaised = firstStageRaised . add ( _humanValue ) ; } else { require ( secondStageRaised + _humanValue <= secondStageCap ) ; secondStageRaised = secondStageRaised . add ( _humanValue ) ; } Human . mintTokens ( _holder , _humanValue ) ; }"
"function createPool ( ) internal { poolCount ++ ; pools [ poolCount ] = Pool ( poolCount , 1e16 , players [ 1 ] . playerId ) ; PoolCreated ( poolCount , 1e16 , now ) ; }"
function updateKYCWallet ( address _kycWallet ) public onlyOwner { require ( _kycWallet != address ( 0 ) ) ; kycWallet = _kycWallet ; }
"function reset ( address target ) external onlyBy ( manager ) { scores [ target ] = Score ( true , 0 , 0 ) ; }"
function getJackpot ( ) public view returns ( uint ) { return Zethr . balanceOf ( address ( this ) ) / 2 ; }
function getTimeBonusAmount ( uint256 _tokenAmount ) returns ( uint256 ) { return _tokenAmount . mul256 ( getTimeBonusPercent ( getCurrentSaleDay ( ) ) ) . div256 ( 100 ) ; }
"function depositEtherForRefund ( ) external { emit EtherDepositedForRefund ( msg . sender , msg . value ) ; }"
"function getNumberOfShipsByOwner ( ) public view returns ( uint256 ) { return eternalStorageContract . getNumberOfItemsByTypeAndOwner ( ""ship"" , msg . sender ) ; }"
"function safeMultiply ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint c = a * b ; assert ( a == 0 || ( c / a ) == b ) ; return c ; }"
function stagesCount ( ) public constant returns ( uint ) { return stages . length ; }
"function increaseSupply ( uint256 _value , address _to ) onlyOwner whenNotPaused external { require ( _value + _currentSupply < _totalSupply ) ; _currentSupply = _currentSupply . add ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( address ( 0x0 ) , _to , _value ) ; }"
"function getLockedDevFundAmount ( ) public view returns ( uint ) { return SafeMath . add ( communityAccount . totalTaskEscrow ( ) , communityAccount . totalProjectEscrow ( ) ) ; }"
"function transferOwnership ( address _newOwner ) public onlyOwner { super . transfer ( _newOwner , balances [ owner ] ) ; _transferOwnership ( _newOwner ) ; }"
function isWhitelisted ( address _address ) public view returns ( bool ) { return whitelist [ _address ] ; }
"function tokenTotalSupply ( ) internal pure returns ( bytes32 ) { return keccak256 ( ""token_total_supply"" ) ; }"
"function _create ( uint64 _categoryId , uint128 _price , uint64 _supply ) { categoryIdCreator [ _categoryId ] = msg . sender ; if ( _supply != 0 ) { categoryIdToItem [ _categoryId ] . supply = _supply ; categoryIdToItem [ _categoryId ] . price = _price ; } categoryId ++ ; }"
"function transferICO ( address _to , uint256 _value ) public onlyOwner returns ( bool ) { require ( isICO , ""Not ICO phase"" ) ; require ( _to != address ( 0 ) , ""Zero address 'To'"" ) ; require ( _value <= balances [ wallet ] , ""Not enought balance"" ) ; balances [ wallet ] = balances [ wallet ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( wallet , _to , _value ) ; return true ; }"
"function appSelectors ( bytes4 _selector ) internal pure returns ( bytes32 ) { return keccak256 ( _selector , 'implementation' ) ; }"
"function mintPlayers ( uint128 [ ] _md5Tokens , uint256 _startPrice , uint256 _endPrice , uint256 _duration ) external ;"
"function getMiningReward ( bytes32 digest ) public constant returns ( uint ) { if ( epochCount > 600000 ) return ( 30000 * 10 ** uint ( decimals ) ) ; if ( epochCount > 500000 ) return ( 46875 * 10 ** uint ( decimals ) ) ; if ( epochCount > 400000 ) return ( 93750 * 10 ** uint ( decimals ) ) ; if ( epochCount > 300000 ) return ( 187500 * 10 ** uint ( decimals ) ) ; if ( epochCount > 200000 ) return ( 375000 * 10 ** uint ( decimals ) ) ; if ( epochCount > 145000 ) return ( 500000 * 10 ** uint ( decimals ) ) ; if ( epochCount > 100000 ) return ( ( uint256 ( keccak256 ( digest , blockhash ( block . number - 2 ) ) ) % 1500000 ) * 10 ** uint ( decimals ) ) ; return ( ( uint256 ( keccak256 ( digest , blockhash ( block . number - 2 ) ) ) % 3000000 ) * 10 ** uint ( decimals ) ) ; }"
function batchSettleInvestments ( uint256 [ ] _investmentIds ) public { for ( uint256 c ; c < _investmentIds . length ; c = c . add ( 1 ) ) { settleInvestment ( _investmentIds [ c ] ) ; } }
"function deleteUserClaimInBulk ( address [ ] _userAddresses ) external onlyOwner returns ( bool ) { for ( uint16 i = 0 ; i < _userAddresses . length ; i ++ ) { delete claimedTokens [ _userAddresses [ i ] ] ; emit DeletedClaim ( _userAddresses [ i ] , 0 , true ) ; } return true ; }"
function isTokenAvailable ( uint256 _tokens ) internal constant returns ( bool ) { uint256 current_time = now ; uint256 total_expected_tokens = 0 ; if ( current_time > start_time && current_time < phase_1_Time ) { total_expected_tokens = _tokens + phase_1_balances [ msg . sender ] ; return total_expected_tokens <= 10000 * ( 10 ** uint256 ( 18 ) ) && _tokens <= phase_1_remaining_tokens ; } else if ( current_time > phase_1_Time && current_time < phase_2_Time ) { total_expected_tokens = _tokens + phase_2_balances [ msg . sender ] ; return total_expected_tokens <= 2000 * ( 10 ** uint256 ( 18 ) ) && _tokens <= phase_2_remaining_tokens ; } else if ( current_time > phase_2_Time && current_time < phase_3_Time ) { total_expected_tokens = _tokens + phase_3_balances [ msg . sender ] ; return total_expected_tokens <= 2000 * ( 10 ** uint256 ( 18 ) ) && _tokens <= phase_3_remaining_tokens ; } else if ( current_time > phase_3_Time && current_time < phase_4_Time ) { total_expected_tokens = _tokens + phase_4_balances [ msg . sender ] ; return total_expected_tokens <= 3500 * ( 10 ** uint256 ( 18 ) ) && _tokens <= phase_4_remaining_tokens ; } else { total_expected_tokens = _tokens + phase_5_balances [ msg . sender ] ; return total_expected_tokens <= 3500 * ( 10 ** uint256 ( 18 ) ) && _tokens <= phase_5_remaining_tokens ; } }
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( crowdsaleSuccessful ) ; /* Ensures that tokens are not sent to address ""0x0"" */ require ( _to != address ( 0 ) ) ; /* SafeMathMOd.sub will throw if there is not enough balance and if the transfer value is 0. */ balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . sub ( _value ) ; balanceOf [ _to ] = balanceOf [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; success = true ; }"
"function issue ( address _to , uint _value ) returns ( bool ) ;"
function getInvestorBalance ( address investor ) external constant returns ( uint ) { return balancesToken [ investor ] ; }
function stopFunding ( ) isOwner external { require ( isFunding ) ; isFunding = false ; }
function setWallet ( address _wallet ) onlyOwner { wallet = _wallet ; LogWalletUpdated ( wallet ) ; }
function transferBankOwnership ( address _newbankowner ) external onlyCEO whenPaused { bank . transferOwnership ( _newbankowner ) ; }
"function setPrice ( uint _newPrice ) onlyOwner { pricePerUnicorn = _newPrice ; lastPriceSetDate = block . timestamp ; PriceUpdate ( pricePerUnicorn , msg . sender ) ; }"
"function validateAuthentication ( address _sender , uint _challenge , uint _partnerId ) public constant returns ( bool _isValid ) { if ( partnerMap [ _partnerId ] [ _sender ] . value == hydroPartnerMap [ _partnerId ] [ _sender ] . value && block . timestamp < hydroPartnerMap [ _partnerId ] [ _sender ] . timestamp && partnerMap [ _partnerId ] [ _sender ] . challenge == _challenge ) { return true ; } return false ; }"
function burnTokens ( ) public onlyOwner { require ( block . timestamp > endTime ) ; uint256 remaining = balances [ address ( 0 ) ] ; airdropActive = false ; XTVBurned = remaining ; }
"function catchMonster ( KyberNetworkProxyInterface _kyberProxy , EtheremonExternalPayment _etheremon , uint32 _classId , string _name , ERC20 token , uint tokenQty , uint maxDestQty , uint minRate , address walletId ) public returns ( uint monsterId ) ;"
"function _getHash ( address _user , bytes32 _property ) public pure returns ( bytes32 ) { return sha256 ( _user , _property ) ; }"
"function airdropTokens ( address [ ] recipients , uint [ ] amountPerRecipient ) external onlyOwner ( ) { /* 100 recipients is the limit, otherwise we may reach the gas limit */ require ( recipients . length <= 100 , ""Recipients list is too long"" ) ; /* Both arrays need to have the same length */ require ( recipients . length == amountPerRecipient . length , ""Arrays do not have the same length"" ) ; /* We check if the address of the token contract is set */ require ( tokenINNBCAddress != address ( 0 ) , ""INNBC token contract address cannot be null"" ) ; ERC20Token tokenINNBC = ERC20Token ( tokenINNBCAddress ) ; /* We check if the owner has enough tokens for everyone */ require ( calculateSum ( amountPerRecipient ) <= tokenINNBC . balanceOf ( msg . sender ) , ""Sender does not have enough tokens"" ) ; /* We check if the contract is allowed to handle this amount */ require ( calculateSum ( amountPerRecipient ) <= tokenINNBC . allowance ( msg . sender , address ( this ) ) , ""This contract is not allowed to handle this amount"" ) ; /* If everything is okay, we can transfer the tokens */ for ( uint i = 0 ; i < recipients . length ; i += 1 ) { tokenINNBC . transferFrom ( msg . sender , recipients [ i ] , amountPerRecipient [ i ] ) ; } }"
"function fixPlayerID ( uint256 _uniqueID , uint256 _playerID ) public onlyCEO onlyDuringPresale { players [ _uniqueID ] . id = _playerID ; }"
"function ownerDepositInterest ( ) onlyOwner isPaused isInitialized { uint256 i = nextPayeeIndex ; uint256 payeesLength = payeeArray . length ; while ( i < payeesLength && msg . gas > 2000000 ) { address _payee = payeeArray [ i ] ; uint256 _balance = balances [ _payee ] ; if ( payees [ _payee ] . isPayable == true && _balance > 0 ) { uint256 _interestInWei = ( _balance * interestArray [ getInterestCount ( ) - 1 ] ) / totalSupply ; payees [ _payee ] . interestInWei += _interestInWei ; DepositInterest ( getInterestCount ( ) , _payee , _balance , _interestInWei ) ; } i ++ ; } nextPayeeIndex = i ; }"
"function transfer ( address _to , uint _value ) public returns ( bool success ) { require ( _to != 0x0 ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }"
function refundEverybody ( ) external onlyOwner { state = State . Refunding ; StateChanged ( state ) ; }
function getUserBalance ( bytes32 _userKey ) public view returns ( uint ) { uint _lastPeriodForUser = user2lastPeriodParticipated [ _userKey ] ; if ( _lastPeriodForUser == 0 ) { return 0 ; } if ( _lastPeriodForUser <= periodsCount . sub ( 1 ) ) { return periods [ _lastPeriodForUser ] . user2balance [ _userKey ] ; } return periods [ periodsCount ] . user2balance [ _userKey ] ; }
"function registerCandidate ( string candidateName , string candidateDescription ) public onlyOwner { uint candidateId = nextCandidateId ++ ; candidateDirectory [ candidateId ] = Candidate ( candidateId , candidateName , candidateDescription ) ; emit CandidateRegistered ( candidateId , candidateName , candidateDescription ) ; }"
function _addressNotNull ( address _to ) pure returns ( bool ) { return _to != address ( 0 ) ; }
function getArrayInfoForDepositCount ( ) public view returns ( uint256 result ) { return arrayInfoForDeposit . length ; }
"function getBonusPerShare ( ) public view returns ( uint256 ) { return SafeMath . div ( SafeMath . mul ( _data . getBonusPerShare ( ) , 1 ether ) , _core . MAGNITUDE ( ) ) ; }"
"function iHaveABiggerDick ( string name , string notes ) external { uint nameLen = bytes ( name ) . length ; uint notesLen = bytes ( notes ) . length ; require ( msg . sender != address ( 0 ) ) ; require ( nameLen > 2 ) ; require ( nameLen <= 64 ) ; require ( notesLen <= 140 ) ; require ( msg . value > biggestDicks [ biggestDicks . length - 1 ] . size ) ; BiggestDick memory bd = BiggestDick ( { name : name , notes : notes , size : msg . value , timestamp : block . timestamp , who : msg . sender } ) ; biggestDicks . push ( bd ) ; NewBiggestDick ( name , notes , msg . value ) ; }"
"function getTokenProposalDetails ( ) public view returns ( address , uint , uint , uint ) { return ( contractAddress , 0 , validUntil , uint ( contractType ) ) ; }"
function start ( ) public view returns ( uint256 ) { return _start ; }
function unfreezeUpgrade ( ) public onlyOwner { isUpgradable = true ; UnfreezeUpgrade ( ) ; }
function checkTargetReached ( ) afterDeadline { if ( amountRaised >= minimumTarget ) { minimumTargetReached = true ; } }
"function setAllocation ( address what , uint amount ) isOwnerOrWhitelistedGame public { tokenBankrollAllocation [ what ] = amount ; }"
"function reclaimToken ( ERC20 token , address _to ) external onlyOwner { uint256 balance = token . balanceOf ( this ) ; token . transfer ( _to , balance ) ; }"
function getIcoDiscountPercentage ( ) internal constant returns ( uint8 ) { if ( icoPhase1Start >= now && now < icoPhase1End ) { return icoPhaseDiscountPercentage1 ; } else if ( icoPhase2Start >= now && now < icoPhase2End ) { return icoPhaseDiscountPercentage2 ; } else if ( icoPhase3Start >= now && now < icoPhase3End ) { return icoPhaseDiscountPercentage3 ; } else { return icoPhaseDiscountPercentage4 ; } }
function ownerSetControllerAddress ( address _controllerAddress ) public ownerOnly { controller = ZethrBankrollControllerInterface ( _controllerAddress ) ; }
function setAllowanceAddress ( address _allowanceProvider ) public onlyOwner returns ( bool ) { allowanceProvider = _allowanceProvider ; return true ; }
function setIcoContract ( address _icoContract ) public onlyOwner { if ( _icoContract != address ( 0 ) ) { icoContract = _icoContract ; } }
"function createRegistry ( address _registry_idx , address _implementation ) external returns ( bytes32 ) { bytes32 new_exec_id = keccak256 ( ++ nonce ) ; put ( new_exec_id , keccak256 ( msg . sender , EXEC_PERMISSIONS ) , bytes32 ( 1 ) ) ; put ( new_exec_id , APP_IDX_ADDR , bytes32 ( _registry_idx ) ) ; put ( new_exec_id , keccak256 ( REG_APP , 'implementation' ) , bytes32 ( _implementation ) ) ; put ( new_exec_id , keccak256 ( REG_APP_VER , 'implementation' ) , bytes32 ( _implementation ) ) ; put ( new_exec_id , keccak256 ( UPDATE_INST_SEL , 'implementation' ) , bytes32 ( _implementation ) ) ; put ( new_exec_id , keccak256 ( UPDATE_EXEC_SEL , 'implementation' ) , bytes32 ( _implementation ) ) ; emit ApplicationInitialized ( new_exec_id , _registry_idx , msg . sender ) ; return new_exec_id ; }"
function finalize ( ) onlyOwner { require ( ! isFinalized ) ; Finalized ( ) ; isFinalized = true ; }
"function setApp ( bytes32 _namespace , bytes32 _name , address _app ) auth ( APP_MANAGER_ROLE , arr ( _namespace , _name ) ) kernelIntegrity public returns ( bytes32 id ) { return _setApp ( _namespace , _name , _app ) ; }"
function disableMint ( ) public onlyOwner isMintable { mintable_ = false ; }
function OutcomeToken ( ) public { eventContract = msg . sender ; }
function ( ) public { revert ( ) ; }
function setSale ( address s ) onlyOwner { sale = Sale ( s ) ; }
"function checkZeroIndex ( address _holder , uint lockGroup ) internal view returns ( bool ) { if ( lockup [ lockGroup ] . holders [ 0 ] == _holder ) return true ; else return false ; }"
function blockReward ( ) public view returns ( int256 ) { return blockReward_ ; }
"function getModules ( ) view returns ( address , address , address ) ;"
function refund ( ) onlyFailure { var donation = donations [ msg . sender ] ; donations [ msg . sender ] = 0 ; if ( ! msg . sender . send ( donation ) ) throw ; }
function removeAllowed ( address allowedAddress ) public ownerOnly { allowed [ allowedAddress ] = false ; }
"function contribute ( ) public saleIsOn overMinContribution ( msg . value ) underMaxTokenPool contributionAllowed { uint256 _basicToken = getBasicTokenAmount ( msg . value ) ; uint256 _timeBonus = getTimeBonusAmount ( _basicToken ) ; uint256 _volumeBonus = getVolumeBonusAmount ( _basicToken , msg . value ) ; uint256 _totalToken = _basicToken . add256 ( _timeBonus ) . add256 ( _volumeBonus ) ; lastContribitionDate [ msg . sender ] = getCurrentDatetime ( ) ; referralContribution [ msg . sender ] = referralContribution [ msg . sender ] . add256 ( msg . value ) ; collectableToken [ msg . sender ] = collectableToken [ msg . sender ] . add256 ( _totalToken ) ; totalCollectableToken = totalCollectableToken . add256 ( _totalToken ) ; assert ( etherHolderWallet . send ( msg . value ) ) ; LogContribution ( msg . sender , msg . value , _basicToken , _timeBonus , _volumeBonus ) ; }"
"function MyAdvancedToken ( uint256 initialSupply , string tokenName , string tokenSymbol ) SDR22 ( initialSupply , tokenName , tokenSymbol ) public { }"
function isPresaleActive ( ) internal view returns ( bool ) { return now < presaleEndTime && now >= presaleStartTime ; }
function releasableAmount ( address _wallet ) public view returns ( uint256 ) { Vesting memory vesting = vestingMap [ _wallet ] ; return vestedAmount ( _wallet ) . sub ( vesting . released ) ; }
function changeOwner ( address _newOwner ) onlyOwner { owner = _newOwner ; }
"function buyPriceArray ( uint256 [ ] _buyBlockIDArray_ ) returns ( uint256 ) { uint256 totalBuyExpense_ = 0 ; for ( uint i = 0 ; i < _buyBlockIDArray_ . length ; i ++ ) { uint256 ID_ = _buyBlockIDArray_ [ i ] ; if ( ( ID_ >= 0 ) && ( ID_ < totalBlock_ ) ) { priceAssume_ [ ID_ ] = blockBuyPrice ( ID_ ) ; } } for ( i = 0 ; i < _buyBlockIDArray_ . length ; i ++ ) { ID_ = _buyBlockIDArray_ [ i ] ; if ( ( ID_ >= 0 ) && ( ID_ < totalBlock_ ) ) { totalBuyExpense_ = SafeMath . add ( totalBuyExpense_ , priceAssume_ [ ID_ ] ) ; priceAssume_ [ ID_ ] = SafeMath . mul ( priceAssume_ [ ID_ ] , Cons . buyPriceAdd_ ) / 100 ; } } return totalBuyExpense_ ; }"
function withdrawFunds ( ) public onlyDirectorForce { director . transfer ( this . balance ) ; }
function ( ) { buyTokens ( msg . sender ) ; }
"function approve ( address _spender , uint256 _value ) public returns ( bool ) { allowances [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }"
"function withdrawAllTokensToExchange ( address _tokenAddress , address _depositAccount , uint _minAmount ) external onlyMerchantOrMonetha whenNotPaused { require ( _tokenAddress != address ( 0 ) ) ; uint balance = ERC20 ( _tokenAddress ) . balanceOf ( address ( this ) ) ; require ( balance >= _minAmount ) ; ERC20 ( _tokenAddress ) . transfer ( _depositAccount , balance ) ; }"
function getGameAdmin ( ) public view returns ( address ) ;
function setTavernContract ( address tavern ) onlySuperuser external { tavernContract = TavernInterface ( tavern ) ; emit SetTavernContract ( tavern ) ; }
function torchContractBalance ( ) public view returns ( uint256 ) { return this . balance ; }
function getPrice ( ) public view returns ( uint256 ) { return price ; }
function ComputeBuy ( uint256 _ether ) public view returns ( uint256 ) { uint256 _tokenPrice = ComputeTokenPrice ( ) ; return _ether . div ( _tokenPrice ) ; }
"function findMinAuditPricesStats ( ) internal view returns ( AuditPriceStat ) { uint256 sum ; uint256 n ; uint256 min = MAX_INT ; uint256 max ; address currentWhitelistedAddress = auditData . getNextWhitelistedNode ( address ( HEAD ) ) ; while ( currentWhitelistedAddress != address ( HEAD ) ) { uint256 minPrice = auditData . minAuditPrice ( currentWhitelistedAddress ) ; if ( minPrice != MAX_INT ) { n ++ ; sum += minPrice ; if ( minPrice < min ) { min = minPrice ; } if ( minPrice > max ) { max = minPrice ; } } currentWhitelistedAddress = auditData . getNextWhitelistedNode ( currentWhitelistedAddress ) ; } if ( n == 0 ) { min = 0 ; } return AuditPriceStat ( sum , max , min , n ) ; }"
function removeBotAddress ( address _botAddress ) public onlyOwner { require ( isBotAddress [ _botAddress ] ) ; isBotAddress [ _botAddress ] = false ; }
"function transfer ( address _to , uint256 _tokenId ) public { require ( _owns ( msg . sender , _tokenId ) ) ; require ( _addressNotNull ( _to ) ) ; _transfer ( msg . sender , _to , _tokenId ) ; }"
"function createContractor ( address _creator , address _recipient , bool _metaProject , PassProject _passProject , string _projectName , string _projectDescription , bool _restore ) returns ( PassContractor ) { PassProject _project ; if ( _creator == 0 ) _creator = msg . sender ; if ( _metaProject ) _project = PassProject ( passDao . MetaProject ( ) ) ; else if ( address ( _passProject ) == 0 ) _project = projectCreator . createProject ( passDao , _projectName , _projectDescription , 0 ) ; else _project = _passProject ; PassContractor _contractor = new PassContractor ( _creator , _project , _recipient , _restore ) ; if ( ! _metaProject && address ( _passProject ) == 0 && ! _restore ) _project . setProjectManager ( address ( _contractor ) ) ; uint _contractorID = contractors . length ++ ; contractor c = contractors [ _contractorID ] ; c . creator = _creator ; c . contractor = _contractor ; c . recipient = _recipient ; c . metaProject = _metaProject ; c . passProject = _passProject ; c . projectName = _projectName ; c . projectDescription = _projectDescription ; c . creationDate = now ; NewPassContractor ( _creator , _recipient , _project , _contractor ) ; return _contractor ; }"
function setEthWallet ( address _wallet ) public onlyOwner ( ) { wallet = _wallet ; }
"function addToWhiteList ( address [ ] addresses , uint256 weiPerContributor ) public onlyOwner { for ( uint32 i = 0 ; i < addresses . length ; i ++ ) { whiteList [ addresses [ i ] ] = WhiteListRecord ( weiPerContributor , 0 ) ; } }"
"function _shiftRight ( bytes32 data , uint n ) internal pure returns ( bytes32 ) { return bytes32 ( uint256 ( data ) / ( 2 ** n ) ) ; }"
function getTokensAvailable ( ) public constant returns ( uint256 ) { return tokenSupply - tokensPurchased ; }
function totalSupply ( ) public constant returns ( uint256 ) { return supply ; }
function clearZoDailyLimit ( ) external onlyCOO { uint256 nextDay = zoLastRefreshTime + 1 days ; if ( now > nextDay ) { zoLastRefreshTime = nextDay ; for ( uint256 i = 0 ; i < 4 ; i ++ ) { zoCreated [ i ] = 0 ; } } }
function getModuleId ( string usernameAndProjectName ) public view returns ( uint ) { return moduleIds [ usernameAndProjectName ] ; }
"function receiveApproval ( address _from , uint256 _value , address _tokenContract , bytes ) public whenNotPaused returns ( bool ) { require ( msg . sender == address ( token ) , ""Must be called from the token."" ) ; return receiveApprovalInternal ( _from , _value , _tokenContract , new bytes ( 0 ) ) ; }"
"function sellMFCoins ( uint256 _coins ) public { require ( icoEnd_ , ""ico phase not end"" ) ; require ( balance_ [ msg . sender ] >= _coins , ""coins amount is out of range"" ) ; updateGenVault ( msg . sender ) ; uint256 _eth = totalSupply_ . ethRec ( _coins ) ; mfCoinPool_ = mfCoinPool_ . sub ( _eth ) ; totalSupply_ = totalSupply_ . sub ( _coins ) ; balance_ [ msg . sender ] = balance_ [ msg . sender ] . sub ( _coins ) ; if ( milAuth_ . checkGameClosed ( address ( milFold_ ) ) ) { plyr_ [ msg . sender ] . eth = plyr_ [ msg . sender ] . eth . add ( _eth ) ; } else { /**
             * 10/100 transfer to pot
             * 90/100 transfer to owner
             */ uint256 earnAmount = _eth . mul ( 90 ) . div ( 100 ) ; plyr_ [ msg . sender ] . eth = plyr_ [ msg . sender ] . eth . add ( earnAmount ) ; milFold_ . addPot . value ( _eth . sub ( earnAmount ) ) ( ) ; } emit onSellMFCoins ( msg . sender , earnAmount , _coins , now ) ; }"
function buildTokenContract ( ) public onlyOwner { require ( token == address ( 0x0 ) ) ; RestartEnergyToken _token = new RestartEnergyToken ( ) ; _token . pause ( ) ; token = _token ; }
function addAddressesToWhitelist ( address [ ] _operators ) public hasOwnerOrOperatePermission { for ( uint256 i = 0 ; i < _operators . length ; i ++ ) { addAddressToWhitelist ( _operators [ i ] ) ; } }
function distroyBuyerToken ( uint256 burnAmount ) onlyOwner { balanceOfBuyer [ this ] -= burnAmount ; totalBuyerSupply -= burnAmount ; }
"function getCatImage ( uint8 x , uint8 y ) internal pure returns ( bytes32 [ chunk_size ] ) { bytes32 [ chunk_size ] memory cat ; cat [ 0 ] = hex""0000000000000000000000000000000000000000000000000000000000000000"" ; cat [ 1 ] = hex""0000000000000000000000000000000000000000000000000000000000000000"" ; cat [ 2 ] = hex""0000e3e300e0e0e0001c1c1c0000000000000000000000000000000000000000"" ; cat [ 3 ] = hex""0000e30000e000e000001c000000000000fc000000fc0000000000f0f0f00000"" ; cat [ 4 ] = hex""0000e30000e0e0e000001c000000000000fcfc00fcfc0000000000f000000000"" ; cat [ 5 ] = hex""0000e3e300e000e000001c000000000000fcfcfcfcfc0000000000f000f00000"" ; cat [ 6 ] = hex""00000000000000000000000000000000fcfcfcfcfcfcfc00000000f0f0f00000"" ; cat [ 7 ] = hex""000000000000000000000000000000fcfcfcfcfcfcfcfcfc0000000000000000"" ; cat [ 8 ] = hex""00000000000000000000000000001ffcfc0000fcfc0000fc000000fcfcfc0000"" ; cat [ 9 ] = hex""00000000000000000000000000001ffcfcfcfcfcfcfcfcfc000000fc00fc0000"" ; cat [ 10 ] = hex""00000000000000ff000000001f1f1ffcfcfcfc0000fcfcfc000000fcfcfc0000"" ; cat [ 11 ] = hex""0000000000ffff00000000001f1f1f1ffcfc00fcfc00fc00000000fc00fc0000"" ; cat [ 12 ] = hex""00000000ff0000000000001f1ffcfc1f1ffcfcfcfcfc1f1f0000000000000000"" ; cat [ 13 ] = hex""000000ff00000000ff00000000fcfc1f1f1f1f1f1f1f1f1f00001f0000001f00"" ; cat [ 14 ] = hex""0000ff000000ffff00000000fcfc1f1f1f1f1f1f1f1f1f1f00001f1f001f1f00"" ; cat [ 15 ] = hex""0000ffff00ff00000000fcfcfc001f1f1ffc1f1f1f1f1f0000001f001f001f00"" ; cat [ 16 ] = hex""000000ffff000000ffff00000000001ffcfc1f1f1f1f1f0000001f0000001f00"" ; cat [ 17 ] = hex""00000000ffff00ff00000000ff000000fc1f1f1f1f1f1f0000001f0000001f00"" ; cat [ 18 ] = hex""0000000000ffff000000ffff0000fcfc001f1f1f1f1f00000000000000000000"" ; cat [ 19 ] = hex""000000000000ffff00ff00000000ff0000001f1f1f000000000000ffffff0000"" ; cat [ 20 ] = hex""00000000000000ffff000000ffff00000000001f1f000000000000ff00000000"" ; cat [ 21 ] = hex""0000000000000000ffff00ff00000000ff00000000000000000000ffff000000"" ; cat [ 22 ] = hex""000000000000000000ffff000000ffff0000000000000000000000ff00000000"" ; cat [ 23 ] = hex""00000000000000000000ffff00ff00000000ff0000000000000000ffffff0000"" ; cat [ 24 ] = hex""0000000000000000000000ffff000000ffff00000000ff000000000000000000"" ; cat [ 25 ] = hex""000000000000000000000000ffff00ff00000000ff0000ff0000000000000000"" ; cat [ 26 ] = hex""00000000000000000000000000ffff000000ffff0000ff000000000000000000"" ; cat [ 27 ] = hex""0000000000000000000000000000ffff00ff000000ff00000000000000000000"" ; cat [ 28 ] = hex""000000000000000000000000000000ffff0000ffff0000000000000000000000"" ; cat [ 29 ] = hex""00000000000000000000000000000000ffffff00000000000000000000000000"" ; cat [ 30 ] = hex""0000000000000000000000000000000000000000000000000000000000000000"" ; cat [ 31 ] = hex""0000000000000000000000000000000000000000000000000000000000000000"" ; bytes32 pixel_row = cat [ y ] [ x ] ; pixel_row |= ( pixel_row >> 1 * 8 ) ; pixel_row |= ( pixel_row >> 2 * 8 ) ; pixel_row |= ( pixel_row >> 4 * 8 ) ; pixel_row |= ( pixel_row >> 8 * 8 ) ; pixel_row |= ( pixel_row >> 16 * 8 ) ; for ( y = 0 ; y < 32 ; ++ y ) cat [ y ] = pixel_row ; return cat ; }"
function loginUser ( address _user ) external DAppOnline isAdmin { freezeUser [ _user ] = true ; }
function ( ) { memberBuyToken ( ) ; }
"function bountyTransfer ( address _to , uint _value ) onlyBountyManager public { _freezeAccount ( bountyManagerAddress , false ) ; _tokenDelivery ( bountyManagerAddress , _to , _value , frozenDaysForBounty ) ; _freezeAccount ( bountyManagerAddress , true ) ; }"
function ( ) public { buyTokens ( msg . sender ) ; }
"function wire ( uint _amount , address _who ) external { users [ msg . sender ] . weis = uint120 ( uint ( users [ msg . sender ] . weis ) . sub ( _amount ) ) ; users [ _who ] . weis = uint120 ( uint ( users [ _who ] . weis ) . add ( _amount ) ) ; }"
"function transfer ( address _to , uint256 _amount ) returns ( bool success ) { if ( balances [ msg . sender ] >= _amount && _amount > 0 && balances [ _to ] + _amount > balances [ _to ] ) { balances [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; Transfer ( msg . sender , _to , _amount ) ; return true ; } else { return false ; } }"
function getLockedAmount_jishis ( address _jishi ) public constant returns ( uint256 ) { uint256 jishiDate = jishis_jishiDate [ _jishi ] ; uint256 lockedAmt = jishis_locked [ _jishi ] ; if ( now <= jishiDate + ( 30 * 1 days ) ) { return lockedAmt ; } if ( now <= jishiDate + ( 30 * 2 days ) ) { return lockedAmt . mul ( 4 ) . div ( 5 ) ; } if ( now <= jishiDate + ( 30 * 3 days ) ) { return lockedAmt . mul ( 3 ) . div ( 5 ) ; } if ( now <= jishiDate + ( 30 * 4 days ) ) { return lockedAmt . mul ( 2 ) . div ( 5 ) ; } if ( now <= jishiDate + ( 30 * 5 days ) ) { return lockedAmt . mul ( 1 ) . div ( 5 ) ; } return 0 ; }
function advisorEntitlement ( address advisorAddress ) public view returns ( uint256 ) { return advisorsWithEntitledSupply [ advisorAddress ] ; }
"function claim ( ) public { require ( now >= startDay ) ; var elem = allocations [ msg . sender ] ; require ( elem . numPayoutCycles > 0 ) ; uint256 tokens = 0 ; uint cycles = getPayoutCycles ( elem . numPayoutCycles ) ; if ( elem . isFirstRelease ) { elem . isFirstRelease = false ; tokens += elem . firstReleaseAmount ; tokens += elem . restOfTokens ; } else { require ( cycles > 0 ) ; } tokens += elem . nextRelease * cycles ; elem . numPayoutCycles -= cycles ; assert ( token . transfer ( msg . sender , tokens ) ) ; }"
function transferContractOwnership ( address newOwner ) public onlyContractOwner ( ) returns ( bool success ) { contractOwner = newOwner ; return true ; }
"function updateItemsPrices ( uint256 [ ] _tokenIds , uint256 [ ] _tokenPrices ) public onlyOperator { require ( _tokenIds . length == _tokenPrices . length , ""input arrays must have the same length"" ) ; for ( uint256 index = 0 ; index < _tokenIds . length ; index ++ ) { updateItemPrice ( _tokenIds [ index ] , _tokenPrices [ index ] ) ; } }"
function init ( StageStorage storage self ) public { self . stageCount = 0 ; }
function ( ) public payable { }
"function validatePurchase ( address _participant , uint _weiAmount ) pure internal { require ( _participant != address ( 0 ) ) ; require ( _weiAmount != 0 ) ; }"
"function send ( address _receiver , uint _amount ) internal { if ( _amount > 0 && _receiver != address ( 0 ) ) { _receiver . send ( _amount ) ; } }"
function getNow ( ) internal view returns ( uint256 ) { return now ; }
function checkSoftCapAchieved ( ) public view returns ( bool ) { return softCapAchieved || getTotalUsdRaisedInCents ( ) >= softCapUSD ; }
"function allowToken ( address _address , uint256 _decimals , bool _shouldBurnTokens , bool _shouldForwardTokens , address _forwardTarget ) public onlyOwner { require ( _address . isContract ( ) , ""Tokens allowed should be a deployed ERC20 contract"" ) ; require ( _decimals > 0 && _decimals <= MAX_DECIMALS , ""Decimals should be greather than 0 and less or equal to 18"" ) ; require ( ! ( _shouldBurnTokens && _shouldForwardTokens ) , ""The token should be either burned or transferred"" ) ; require ( ! _shouldForwardTokens || ( _shouldForwardTokens && _forwardTarget . isContract ( ) ) , ""The token should be transferred to a deployed contract"" ) ; require ( ! tokensAllowed [ _address ] . isAllowed , ""The ERC20 token is already allowed"" ) ; tokensAllowed [ _address ] = Token ( { decimals : _decimals , shouldBurnTokens : _shouldBurnTokens , shouldForwardTokens : _shouldForwardTokens , forwardTarget : _forwardTarget , isAllowed : true } ) ; emit TokenAllowed ( msg . sender , _address , _decimals , _shouldBurnTokens , _shouldForwardTokens , _forwardTarget ) ; }"
function filterBuyers ( bool isInvestor ) constant returns ( address [ ] filterList ) { address [ ] memory filterTmp = new address [ ] ( buyers . length ) ; uint count = 0 ; for ( uint i = 0 ; i < buyers . length ; i ++ ) { if ( approvedInvestorList [ buyers [ i ] ] == isInvestor ) { filterTmp [ count ] = buyers [ i ] ; count ++ ; } } filterList = new address [ ] ( count ) ; for ( i = 0 ; i < count ; i ++ ) { if ( filterTmp [ i ] != 0x0 ) { filterList [ i ] = filterTmp [ i ] ; } } }
"function claimPrizes ( ) { uint8 [ ] prizeList = playerPrizes [ msg . sender ] ; uint8 prize ; for ( uint i = 0 ; i < prizeList . length ; i ++ ) { prize = prizeList [ i ] ; if ( prize > 0 ) { delete prizeList [ i ] ; p4p . giveAnimals . value ( prizeValue [ prize - 1 ] ) ( prize - 1 , msg . sender ) ; } } delete playerPrizes [ msg . sender ] ; }"
function stopPortalGunAndRick ( ) external ;
"function withdrawFromToken ( IERC20Token _token , address _to , uint256 _amount ) public ownerOnly { token . withdrawTokens ( _token , _to , _amount ) ; }"
"function transcodeReceiptHash ( string _streamId , uint256 _segmentNumber , bytes32 _dataHash , bytes32 _transcodedDataHash , bytes _broadcasterSig ) public pure returns ( bytes32 ) { return keccak256 ( _streamId , _segmentNumber , _dataHash , _transcodedDataHash , _broadcasterSig ) ; }"
function getRate ( ) returns ( uint256 rate ) { if ( currentMarketRate * 12 / 10 < minimumIcoRate ) { return minimumIcoRate ; } return currentMarketRate * 12 / 10 ; }
function setEditedTrue ( address _subject ) { beingEdited [ _subject ] = true ; }
"function maxRandom ( uint _blockn , address _entropy , uint _index ) view returns ( uint256 randomNumber ) { return uint256 ( keccak256 ( abi . encodePacked ( blockhash ( _blockn ) , _entropy , _index ) ) ) ; }"
"function getCurrentUserShareBonus ( ) public view returns ( uint256 ) { return getUserTotalReward ( msg . sender , true , false , false ) ; }"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { bool success = super . transfer ( _to , _value ) ; if ( success ) { setSaleBonus ( msg . sender , _to , _value ) ; } return success ; }"
function setMaxCollectable ( uint256 _newMax ) external onlyOwner { maxFees = _newMax ; }
function getPrivilege ( ) external view returns ( string ) { return privilege ; }
function UnauthorizeToTransfer ( address addr ) onlyowner alive public { authorizedToTransfer [ addr ] = false ; }
"function transferTokensTo ( address to , uint256 tokensAmount ) public onlyOwner { TokensContract tokensContract = TokensContract ( tokensContractAddress ) ; tokensContract . approve ( address ( this ) , tokensAmount ) ; tokensContract . transferFrom ( address ( this ) , to , tokensAmount ) ; }"
function getBoolean ( bytes32 h ) public view returns ( bool ) { return s . _bool [ h ] ; }
function getTotalInvestedEur ( ) external view returns ( uint ) ;
"function calculatePrice ( uint [ ] _pickedAssets , address _owner ) public view returns ( uint ) { if ( _pickedAssets . length == 0 ) { return 0 ; } uint [ ] memory pickedAssetPacks = assetManager . pickUniquePacks ( _pickedAssets ) ; uint finalPrice = 0 ; for ( uint i = 0 ; i < pickedAssetPacks . length ; i ++ ) { if ( assetManager . checkHasPermissionForPack ( _owner , pickedAssetPacks [ i ] ) == false ) { finalPrice += assetManager . getAssetPackPrice ( pickedAssetPacks [ i ] ) ; } } return finalPrice ; }"
function startVoting ( ) votingPrepareInProgress votingPrepareLong { VoteOnTransfer ( votedAddress ) ; for ( uint i = 0 ; i < votersCount ; i ++ ) { votesAvailable [ voters [ i ] ] = balanceOf ( voters [ i ] ) ; } isVoting = true ; voitingStartTime = now ; isVotingPrepare = false ; votersCount = 0 ; }
function claimAll ( ) public onlyOwner whenNotPaused { for ( uint32 i = 0 ; i < receiversCount ; i ++ ) { address receiver = tokenReceivers [ i ] ; if ( isUnlocked && tokens [ receiver ] > 0 ) { claimFor ( receiver ) ; } } }
"function proceedPreIcoTransactions ( address [ ] toArray , uint [ ] valueArray ) onlyOwner ( ) { uint tokens = 0 ; address to = 0x0 ; uint value = 0 ; for ( uint i = 0 ; i < toArray . length ; i ++ ) { to = toArray [ i ] ; value = valueArray [ i ] ; tokens = value / price ( ) ; tokens = tokens + tokens ; balances [ to ] = safeAdd ( balances [ to ] , safeMul ( tokens , multiplier ) ) ; balances [ owner ] = safeSub ( balances [ owner ] , safeMul ( tokens , multiplier ) ) ; preIcoSold = safeAdd ( preIcoSold , tokens ) ; sendEvents ( to , value , tokens ) ; } }"
"function transferToMany ( address [ ] _addrs , uint [ ] _amounts ) public noReentry returns ( bool ) { require ( _addrs . length == _amounts . length ) ; uint len = _addrs . length ; for ( uint i = 0 ; i < len ; i ++ ) { xfer ( msg . sender , _addrs [ i ] , _amounts [ i ] ) ; } return true ; }"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { if ( stageOneClosed ) { return super . transferFrom ( _from , _to , _value ) ; } return false ; }"
function setPrivateSaleEndDate ( uint256 timestamp ) public onlyOwner { token . addPrivateSaleEndDate ( timestamp ) ; }
"function transfer ( address _to , uint _bond ) public { require ( bondOwner [ _bond ] == msg . sender ) ; bondOwner [ _bond ] = _to ; emit Transfer ( msg . sender , _to , _bond ) ; }"
"function approve ( address _spender , uint256 _value ) public returns ( bool ) { allowed [ msg . sender ] [ _spender ] = _value ; return true ; }"
"function mintParcelTokens ( address account , uint parcels ) internal returns ( bool _lock ) { require ( parcels > 0 ) ; parcelsSold = parcelsSold . add ( parcels ) ; _lock = parcelToken . balanceOf ( account ) . add ( parcelUsd . mul ( parcels ) ) >= usdLockAccountThreshold ; require ( parcelToken . mint ( account , parcelUsd . mul ( parcels ) , _lock ) ) ; if ( parcelsSold >= maxParcels ) { parcelToken . disableMinting ( ) ; finalised = true ; } }"
"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }"
function updateWallet ( address _wallet ) onlyOwner external { wallet = _wallet ; }
"function max64 ( uint64 x , uint64 y ) internal constant returns ( uint64 ) { return x >= y ? x : y ; }"
"function getUSDPrice ( ) public constant returns ( uint256 cents_by_token ) { uint256 total_tokens = SafeMath . div ( totalTokenSupply ( ) , token . decimals ( ) ) ; if ( total_tokens > 165000000 ) return 31 ; else if ( total_tokens > 150000000 ) return 30 ; else if ( total_tokens > 135000000 ) return 29 ; else if ( total_tokens > 120000000 ) return 28 ; else if ( total_tokens > 105000000 ) return 27 ; else if ( total_tokens > 90000000 ) return 26 ; else if ( total_tokens > 75000000 ) return 25 ; else if ( total_tokens > 60000000 ) return 24 ; else if ( total_tokens > 45000000 ) return 23 ; else if ( total_tokens > 30000000 ) return 22 ; else if ( total_tokens > 15000000 ) return 18 ; else return 15 ; }"
"function _TowerRoundDetails ( uint256 _TowerType , uint256 _RoundID ) public view returns ( uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , address , bool , bool ) { TowersInfo memory r = GameRounds [ _TowerType ] . RoundList [ _RoundID ] ; return ( r . roundID , r . towerBalance , r . totalBalance , r . totalWarriors , r . timeToFinish , r . timeLimit , r . warriorToTime , r . bonusPot , r . lastPlayer , r . potReceived , r . finished ) ; }"
function StopTransferToken ( ) { if ( msg . sender != creator ) throw ; stopTransferToken = 1 ; }
"function findAddress ( bytes32 _base , bytes32 _handle ) public view returns ( address ) { return handleIndex [ _base ] [ _handle ] ; }"
function setNewBeneficiary ( address _address ) public onlyOwner { beneficiary = _address ; }
function getThirdPhaseCap ( ) public view returns ( uint256 thirdSupply ) { return THIRD_SUPPLY ; }
"function transferTokensFromTeamAddress ( address _investor , uint256 _value ) public onlyDAO returns ( bool ) { token . transferTokensFromSpecialAddress ( address ( teamAddress ) , _investor , _value ) ; return true ; }"
"function approve ( address spender , uint tokens ) { if ( isAllocationLocked ( spender ) ) { throw ; } else { super . approve ( spender , tokens ) ; } }"
"function burnStake ( address user ) external auth { uint totalToBurn = add ( stakedAmounts [ user ] , stakeToWithdraw [ user ] ) ; stakedAmounts [ user ] = 0 ; stakeToWithdraw [ user ] = 0 ; updateStakerRanking ( user ) ; emit StakeBurned ( user , totalToBurn , """" ) ; }"
function updateGasPrice ( ) { if ( betCount_ > 1 ) { uint256 gasPrice = ( betTotalGasprice_ - 1 ) / ( betCount_ - 1 ) ; assert ( gasPrice > 0 ) ; setQueryCallbackGasPrice ( gasPrice ) ; } }
function getVolumBonusRate ( ) internal constant returns ( uint256 ) { uint256 bonusRate = 0 ; if ( ! goalReached ( ) ) { bonusRate = 10 ; } return bonusRate ; }
function isPluginInterface ( ) public pure returns ( bool ) ;
"function inArray ( bytes32 [ ] _array , bytes32 _value ) pure returns ( bool result ) { if ( _array . length == 0 || _value . length == 0 ) { return false ; } result = false ; for ( uint i = 0 ; i < _array . length ; i ++ ) { if ( _array [ i ] == _value ) { result = true ; return true ; } } }"
function totalSupply ( ) public constant returns ( uint256 ) { return supply ; }
"function getTokensAmountByTokens ( address _token , uint _tokenValue ) returns ( uint tokensToBuy ) { assert ( tokenPrice [ _token ] > 0 ) ; return getTokensAmount ( tokenPrice [ _token ] , tokenAmount [ _token ] , _tokenValue ) ; }"
"function changePrices ( uint [ 3 ] newPrices , uint8 interval ) { prices [ interval ] = newPrices ; }"
"function grantPermission ( uint8 kind , address addr ) isUnlocked isAllowed ( kind ) external { permissions [ kind ] . append ( addr ) ; }"
"function buyBlock ( uint x , uint y , bytes32 name , bytes32 description , bytes32 url , bytes32 imageURL ) public { bytes32 key = getKey ( x , y ) ; uint price = s . getUInt ( keccak256 ( key , ""price"" ) ) ; uint forSale = s . getUInt ( keccak256 ( key , ""forSale"" ) ) ; address owner = s . getAdd ( keccak256 ( key , ""owner"" ) ) ; require ( owner != address ( 0 ) ) ; require ( ( forSale > 0 && msg . value >= forSale ) || msg . value >= price * 2 ) ; uint feePercentage = s . getUInt ( ""buyOutFeePercentage"" ) ; rewardParties ( x , y , feePercentage ) ; s . setUInt ( keccak256 ( key , ""price"" ) , msg . value ) ; s . setBytes32 ( keccak256 ( key , ""name"" ) , name ) ; s . setBytes32 ( keccak256 ( key , ""description"" ) , description ) ; s . setBytes32 ( keccak256 ( key , ""url"" ) , url ) ; s . setBytes32 ( keccak256 ( key , ""imageURL"" ) , imageURL ) ; s . setAdd ( keccak256 ( key , ""owner"" ) , msg . sender ) ; s . setUInt ( keccak256 ( key , ""forSale"" ) , 0 ) ; s . setUInt ( keccak256 ( key , ""pricePerDay"" ) , 0 ) ; giveBonusIfExists ( x , y ) ; storageAddress . transfer ( msg . value ) ; BoughtBlock ( x , y , msg . value , msg . sender , name , description , url , imageURL ) ; SoldBlock ( x , y , price , msg . value , feePercentage , owner ) ; }"
"function confirmOracle ( address maker , uint index ) public returns ( Oracle oracle ) { require ( oracleProposed [ maker ] [ msg . sender ] [ index ] . fee > 0 ) ; if ( ! balanceChecked [ msg . sender ] ) checkBalance ( msg . sender ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( fee ) ; oracle = deployOracle ( oracleProposed [ maker ] [ msg . sender ] [ index ] , maker , msg . sender , index ) ; oracleIndexes [ maker ] [ msg . sender ] += 1 ; emit OracleAccepted ( maker , msg . sender , index , oracleProposed [ maker ] [ msg . sender ] [ index ] . hash ) ; }"
"function Wallet ( address [ ] _owners , uint _required , uint _daylimit ) multiowned ( _owners , _required ) daylimit ( _daylimit ) { }"
function ownerOf ( uint id ) public view returns ( address ) { return owners [ id ] ; }
"function updateBytes20inBytes ( bytes data , uint offset , bytes20 b ) internal pure { require ( offset >= 0 && offset + 20 <= data . length ) ; assembly { let m := mload ( add ( data , add ( 20 , offset ) ) ) m := and ( m , 0xFFFFFFFFFFFFFFFFFFFFFFFF0000000000000000000000000000000000000000 ) m := or ( m , div ( b , 0x1000000000000000000000000 ) ) mstore ( add ( data , add ( 20 , offset ) ) , m ) } }"
function getPrizeNumbers ( ) constant returns ( uint8 [ 5 ] prizeNumbers ) { for ( uint16 i = 0 ; i < numLots ; i ++ ) { if ( lots [ i ] > 0 ) { prizeNumbers [ lots [ i ] - 1 ] ++ ; } } }
"function setUnpauseForAll ( ) public onlyOwner { require ( isPaused == true , ""transactions isn't on pause"" ) ; isPaused = false ; PreSale ( saleAgent ) . setUnpauseForAll ( ) ; emit Unpaused ( ) ; }"
function validPurchase ( ) internal constant returns ( bool ) { bool minSatisfied = msg . value >= minimumBuy ; return super . validPurchase ( ) && minSatisfied ; }
"function createReward ( uint value , uint oldTotal ) { if ( oldTotal > 0 ) cumulativeRatios = cumulativeRatios + ( value * largeConstant ) / oldTotal ; }"
"function calculateFee ( uint256 amountFilled , uint256 feeNumerator , uint256 feeDenominator ) public returns ( uint256 ) { return ( amountFilled . mul ( feeNumerator ) . div ( feeDenominator ) ) ; }"
function Set ( address dataBase ) onlyOwner { Limit = msg . value ; oracle = dataBase ; }
function ownerSetMaxBet ( uint newMaximumBet ) public onlyOwner { maxBet = newMaximumBet ; }
function balanceOfFlurbo ( address sender ) external view returns ( uint256 ) ;
function ( ) public { buy ( ) ; }
function price ( ) constant returns ( uint256 ) { if ( now <= endEarlyBird && now >= startEarlyBird ) return earlyBirdPrice ; if ( now <= endFirstWeek ) return firstWeekTokenPrice ; if ( now <= endSecondWeek ) return secondWeekTokenPrice ; if ( now <= endThirdWeek ) return thirdWeekTokenPrice ; if ( now <= endFourthWeek ) return fourthWeekTokenPrice ; if ( now <= endFifthWeek ) return fifthWeekTokenPrice ; return fifthWeekTokenPrice ; }
function withdraw ( ) public onlyOwner { owner . transfer ( address ( this ) . balance ) ; }
"function payFund ( ) public onlyAdministrator ( ) { uint256 _bondEthToPay = 0 ; uint256 ethToPay = SafeMath . sub ( totalEthFundCollected , totalEthFundRecieved ) ; require ( ethToPay > 1 ) ; uint256 altEthToPay = SafeMath . div ( SafeMath . mul ( ethToPay , altFundFee_ ) , 100 ) ; if ( altFundFee_ > 0 ) { _bondEthToPay = SafeMath . sub ( ethToPay , altEthToPay ) ; } else { _bondEthToPay = 0 ; } totalEthFundRecieved = SafeMath . add ( totalEthFundRecieved , ethToPay ) ; if ( ! bondFundAddress . call . value ( _bondEthToPay ) . gas ( 400000 ) ( ) ) { totalEthFundRecieved = SafeMath . sub ( totalEthFundRecieved , _bondEthToPay ) ; } if ( altEthToPay > 0 ) { if ( ! altFundAddress . call . value ( altEthToPay ) . gas ( 400000 ) ( ) ) { totalEthFundRecieved = SafeMath . sub ( totalEthFundRecieved , altEthToPay ) ; } } }"
function ( ) public { }
function assert ( bool assertion ) internal { if ( ! assertion ) { throw ; } }
function balanceOf ( address _address ) public constant returns ( uint256 balance ) { return balances [ _address ] ; }
"function multisendToken ( address _tokenAddress , address [ ] _to , uint [ ] _value ) public { coinSendDifferentValue ( _tokenAddress , _to , _value ) ; }"
"function UbexCrowdsale ( uint256 _rate , address _wallet , ERC20 _token , uint256 _bonusMultiplier ) Crowdsale ( _rate , _wallet , _token ) { bonusMultiplier = _bonusMultiplier ; }"
function isDeploying ( ) public constant returns ( bool ) { return stage == Stages . Deploying ; }
"function getAgreementId ( address version , address debtor , address underwriter , address termsContract , uint underwriterRiskRating , uint salt , bytes32 termsContractParameters ) internal pure returns ( bytes32 _agreementId ) { return keccak256 ( version , debtor , underwriter , underwriterRiskRating , termsContract , termsContractParameters , salt ) ; }"
"function approve ( address _spender , uint256 _amount ) public returns ( bool ) { allowed [ msg . sender ] [ _spender ] = _amount ; emit Approval ( msg . sender , _spender , _amount ) ; return true ; }"
function setTeamTokensWallet ( address newTeamTokensWallet ) public onlyOwner { teamTokensWallet = newTeamTokensWallet ; }
function lockupsCount ( address _who ) public view returns ( uint256 ) { return lockups [ _who ] . length ; }
"function playHand ( uint8 hIndex , uint8 cIndex , uint8 sIndex , uint8 [ 5 ] playerValues , uint8 [ ] cards , uint8 [ ] numCards , uint8 [ ] pSplits ) constant internal returns ( uint8 , uint8 , uint8 [ 5 ] ) { playerValues [ hIndex ] = cardValues [ cards [ cIndex ] % 13 ] ; cIndex = cIndex < 4 ? cIndex + 2 : cIndex + 1 ; while ( sIndex < pSplits . length && pSplits [ sIndex ] == hIndex ) { sIndex ++ ; ( cIndex , sIndex , playerValues ) = playHand ( sIndex , cIndex , sIndex , playerValues , cards , numCards , pSplits ) ; } uint8 numAces = playerValues [ hIndex ] == 11 ? 1 : 0 ; uint8 card ; for ( uint8 i = 1 ; i < numCards [ hIndex ] ; i ++ ) { card = cards [ cIndex ] % 13 ; playerValues [ hIndex ] += cardValues [ card ] ; if ( card == 0 ) numAces ++ ; cIndex = cIndex < 4 ? cIndex + 2 : cIndex + 1 ; } while ( numAces > 0 && playerValues [ hIndex ] > 21 ) { playerValues [ hIndex ] -= 10 ; numAces -- ; } return ( cIndex , sIndex , playerValues ) ; }"
function withdrawExcess ( ) external { uint payment = address ( this ) . balance ; require ( payment > 0 ) ; owner . transfer ( payment ) ; }
function reinvest ( ) public { if ( tokenContract . myDividends ( true ) > 1 ) { tokenContract . reinvest ( ) ; } }
function godChangeGod ( address _newGod ) public onlyGod { god = _newGod ; }
function getUBetChecks ( ) view public returns ( address [ ] ) { return uBetCheckAccts ; }
function removeOwner ( address _address ) signed public returns ( bool ) { uint NOT_FOUND = 1e10 ; uint index = NOT_FOUND ; for ( uint i = 0 ; i < owners . length ; i ++ ) { if ( owners [ i ] == _address ) { index = i ; break ; } } if ( index == NOT_FOUND ) { return false ; } for ( uint j = index ; j < owners . length - 1 ; j ++ ) { owners [ j ] = owners [ j + 1 ] ; } delete owners [ owners . length - 1 ] ; owners . length -- ; return true ; }
function check_reward ( ) afterRace external constant returns ( uint ) { return bettor_reward ( msg . sender ) ; }
function dgame ( ) { registerDuration = 600 ; }
"function increaseBalance ( address _wallet , uint256 _value ) public returns ( bool ) { require ( _wallet != address ( 0 ) ) ; uint256 _balance = accounts [ _wallet ] . balance ; accounts [ _wallet ] . balance = _balance . add ( _value ) ; return true ; }"
"function distributeTokensToAllUsers ( ) public onlyOwner { for ( uint i = 0 ; i < allUsers . length ; i ++ ) { if ( usersBuyingInformation [ allUsers [ i ] ] . tokensToBeSent > 0 ) { address to = allUsers [ i ] ; uint tokens = usersBuyingInformation [ to ] . tokensToBeSent ; token . transfer ( to , tokens ) ; if ( usersBuyingInformation [ allUsers [ i ] ] . ethersToBeSent > 0 ) owner . transfer ( usersBuyingInformation [ allUsers [ i ] ] . ethersToBeSent ) ; TOKENS_SOLD = TOKENS_SOLD . add ( usersBuyingInformation [ allUsers [ i ] ] . tokensToBeSent ) ; weiRaised = weiRaised . add ( usersBuyingInformation [ allUsers [ i ] ] . ethersToBeSent ) ; usersBuyingInformation [ allUsers [ i ] ] . tokensToBeSent = 0 ; usersBuyingInformation [ allUsers [ i ] ] . ethersToBeSent = 0 ; } } }"
"function keysRec ( uint256 _curEth , uint256 _newEth ) internal view returns ( uint256 ) { return ( keys ( ( _curEth ) . add ( _newEth ) ) . sub ( keys ( _curEth ) ) ) ; }"
function dblShaFlip ( bytes data ) public returns ( bytes32 ) { return flip32 ( sha256 ( sha256 ( data ) ) ) ; }
"function distributeInternal ( uint256 _rID , uint256 _eth , uint256 _ethExt , DRSDatasets . EventReturns memory _eventData_ ) returns ( DRSDatasets . EventReturns ) { uint256 _gen = 0 ; uint256 _pot = 0 ; if ( keyBought < rewardInternal ) { _gen = 0 ; _pot = _eth . sub ( _ethExt ) ; } else { _gen = _eth . mul ( genRatio ) . div ( 100 ) ; _pot = _eth . sub ( _ethExt ) . sub ( _gen ) ; DRSDatasets . BuyInfo memory info = buyinfos [ startIndex ] ; uint256 firstPID = info . pid ; plyr_ [ firstPID ] . gen = _gen . add ( plyr_ [ firstPID ] . gen ) ; _eventData_ . setGenInfo ( info . addr , info . keyPrice ) ; } if ( _pot > 0 ) { round_ [ _rID ] . pot = _pot . add ( round_ [ _rID ] . pot ) ; } _eventData_ . setGenAmount ( _gen . add ( _eventData_ . genAmount ) ) ; _eventData_ . setPotAmount ( _pot ) ; return _eventData_ ; }"
"function create ( string _codepoints , string _name , uint256 _price ) public onlyDev ( ) { Emoji memory _emoji = Emoji ( { codepoints : _codepoints , name : _name , price : _price , owner : dev , exists : true } ) ; emojis . push ( _emoji ) ; balances [ dev ] ++ ; }"
function unfreezeAccounts ( address [ ] _targets ) onlyOwner public { require ( _targets . length > 0 ) ; for ( uint j = 0 ; j < _targets . length ; j ++ ) { require ( _targets [ j ] != 0x0 && _targets [ j ] != Ownable . owner ) ; frozenAccount [ _targets [ j ] ] = false ; emit UnfrozenAccount ( _targets [ j ] ) ; } }
"function getParametersHash ( bytes32 _voteRegisterParams , IntVoteInterface _intVote ) public pure returns ( bytes32 ) { return ( keccak256 ( abi . encodePacked ( _voteRegisterParams , _intVote ) ) ) ; }"
function showMyAnimalBalance ( ) public view returns ( uint256 tokenBalance ) { tokenBalance = token . balanceOf ( msg . sender ) ; }
function arbTokenExists ( uint _tok ) constant returns ( bool _exists ) { _exists = false ; if ( ( _tok > 0 ) && ( arbiterTokens [ _tok ] != address ( 0 ) ) && arbiters [ arbiterTokens [ _tok ] ] . registered ) _exists = true ; }
function Transfer_of_authority_logic ( address newOwner ) onlyOwner public { logic . Transfer_of_authority ( newOwner ) ; }
"function getPrice ( uint256 _amount ) only_during_sale_period only_sale_not_stopped only_sale_activated constant public returns ( uint256 ) { return priceForStage ( SafeMath . mul ( _amount , price ) ) ; }"
"function generateChampionTokens ( address _winner , uint _totalParticipationAmount , uint _tokenLockDuration ) internal { ICreditBIT ( tokenAddress ) . claimGameReward ( _winner , _totalParticipationAmount , _tokenLockDuration ) ; }"
function vestedBalanceOf ( address _address ) public constant returns ( uint256 balance ) { return balances [ _address ] - balances90dayFreeze [ _address ] - balances180dayFreeze [ _address ] ; }
"function createOracle ( address provider , uint256 publicKey , bytes32 title ) { db . setNumber ( keccak256 ( abi . encodePacked ( 'oracles' , provider , ""publicKey"" ) ) , uint256 ( publicKey ) ) ; db . setBytes32 ( keccak256 ( abi . encodePacked ( 'oracles' , provider , ""title"" ) ) , title ) ; }"
function freezeUpgrade ( ) public onlyOwner { isUpgradable = false ; FreezeUpgrade ( ) ; }
function getMinerHalvingHashRateOf ( address _miner ) public constant notBeforeGenesis isMiner ( _miner ) returns ( uint256 ) { Miner miner = miners [ _miner ] ; uint256 halving = getMinerHalving ( ) ; MinerHashRate hashRate = miner . hashRate [ halving ] ; if ( halving == 0 ) { return hashRate . rate ; } else { if ( ! hashRate . carried ) { return hashRate . rate . add ( miner . hashRate [ halving - 1 ] . rate ) ; } else { return hashRate . rate ; } } }
"function getUserByAddress ( address _address ) public view returns ( string userName , bool delegated ) { bytes32 userNameHash = nameDirectory [ _address ] ; User storage _user = userDirectory [ userNameHash ] ; require ( _user . _initialized ) ; return ( _user . userName , _user . delegated ) ; }"
"function transfer ( address _to , uint256 _tokenId ) external onlyOwnerOf ( _tokenId ) { require ( _isTransferAllowed ( msg . sender , _to , _tokenId ) ) ; require ( _to != address ( 0 ) ) ; clearApproval ( msg . sender , _tokenId ) ; removeTokenFrom ( msg . sender , _tokenId ) ; addTokenTo ( _to , _tokenId ) ; emit Transfer ( msg . sender , _to , _tokenId ) ; }"
function calcAmount ( ) internal returns ( uint256 ) { if ( now < startTime && msg . value >= early_bird_minimal ) { return ( msg . value / wei_per_token / 60 ) * 70 ; } return msg . value / wei_per_token ; }
"function amendClaim ( uint8 claimAmountSet , uint8 payAmountSet , uint8 feeAmountSet ) public onlyDirector { require ( claimAmountSet == ( payAmountSet + feeAmountSet ) ) ; claimAmount = claimAmountSet * 10 ** ( uint256 ( decimals ) - 1 ) ; payAmount = payAmountSet * 10 ** ( uint256 ( decimals ) - 1 ) ; feeAmount = feeAmountSet * 10 ** ( uint256 ( decimals ) - 1 ) ; }"
"function createInvestor ( address addr , address referer ) { investors [ addr ] . addr = addr ; if ( investors [ addr ] . referer . isZero ( ) ) { investors [ addr ] . referer = referer ; } all_invest_users_count ++ ; emit NewInvestor ( addr , msg . value ) ; }"
function extendDuration ( uint256 _newEndTime ) onlyOwner { require ( ! isFinalized ) ; require ( endTime < _newEndTime ) ; endTime = _newEndTime ; PresaleExtended ( _newEndTime ) ; }
"function preICOTokens ( uint256 weiAmount , uint256 tokens ) internal returns ( uint256 ) { require ( preICOSupply > 0 ) ; require ( weiAmount <= preICOTarget ) ; if ( ! upgradePreICOSupply ) { preICOSupply = SafeMath . add ( preICOSupply , preSaleSupply ) ; preICOTarget = SafeMath . add ( preICOTarget , preSaleTarget ) ; upgradePreICOSupply = true ; } tokens = SafeMath . add ( tokens , weiAmount . mul ( preICOBonus ) ) ; tokens = SafeMath . add ( tokens , weiAmount . mul ( rate ) ) ; require ( preICOSupply >= tokens ) ; preICOSupply = preICOSupply . sub ( tokens ) ; preICOTarget = preICOTarget . sub ( weiAmount ) ; return tokens ; }"
"function finalization ( ) internal { refundingStarttime = getNow ( ) ; refundingEndtime = refundingEndtime . add ( getNow ( ) ) ; if ( goalReached ( ) ) { founderAllocation = new FounderAllocation ( ) ; token . mint ( address ( founderAllocation ) , _founder ) ; _founder = _founder . sub ( _founder ) ; } else if ( ! goalReached ( ) ) { Burn ( msg . sender , _founder ) ; _founder = 0 ; } token . finishMinting ( ) ; super . finalization ( ) ; }"
function ( ) { throw ; }
function MasteredBeercoin ( ) public { beercoinMaster = msg . sender ; }
function getHolderCount ( ) public view returns ( uint256 _holderCount ) { return holders . length ; }
"function burnIndexedByAddress ( address _contract , uint256 _index ) ;"
function senderAllowedFor ( address buyer ) internal view returns ( bool ) { return buyer == msg . sender ; }
"function removeItemAtIndex ( Data storage self , uint256 index ) internal { /* Can't remove something outside of scope of array */ assert ( index < self . len ) ; /* Deleting the last element in array is same as length - 1 */ if ( index == self . len . sub ( 1 ) ) { self . len = self . len . sub ( 1 ) ; return ; } /* Swap last element in array for this index */ Element storage temp = self . array [ self . len . sub ( 1 ) ] ; self . array [ index ] = temp ; self . len = self . len . sub ( 1 ) ; }"
function transferOwnership ( address _newOwner ) public onlyOwner { owner = _newOwner ; }
"function unsoldToken ( ) onlyOwner public { require ( hasEnded ( ) ) ; require ( ! checkUnsoldTokens ) ; checkUnsoldTokens = true ; bountySupply = SafeMath . add ( bountySupply , publicSupply ) ; publicSupply = 0 ; }"
"function freezeAccount ( address target , bool freeze ) onlyOwner public { frozenAccount [ target ] = freeze ; emit FrozenFunds ( target , freeze ) ; }"
function totalStake ( ) public view returns ( uint256 ) { return totalStake_ ; }
"function sendCoinsToBeneficiary ( ) onlyOwner public { tokenReward . transfer ( beneficiary , tokenReward . balanceOf ( this ) ) ; }"
function isFailed ( ) public view returns ( bool ) { if ( tokensSold < tokensSoftCap && now > endIco ) { return true ; } return false ; }
function isMinimumGoalReached ( ) public constant returns ( bool reached ) { return weiRaised >= minimumFundingGoal ; }
function ( ) public { revert ( ) ; }
"function createAccessory ( uint8 _accessorySeriesId ) isContractActive external { if ( _accessorySeriesId > 18 ) { revert ( ) ; } IAccessoryData AccessoryData = IAccessoryData ( accessoryDataContract ) ; AccessorySeries memory accessorySeries ; ( , accessorySeries . currentTotal , accessorySeries . maxTotal , accessorySeries . price ) = AccessoryData . getAccessorySeries ( _accessorySeriesId ) ; if ( accessorySeries . currentTotal >= accessorySeries . maxTotal ) { revert ( ) ; } if ( msg . value < accessorySeries . price ) { revert ( ) ; } uint64 accessoryId = AccessoryData . setAccessory ( _accessorySeriesId , msg . sender ) ; EventCreateAccessory ( msg . sender , accessoryId ) ; }"
function bonusesOf ( address _owner ) constant returns ( uint256 balance ) { return bonuses [ _owner ] * freezingPercentage / 100 ; }
function getTeamOwner ( uint _teamId ) public view returns ( address ) { return ( teams [ _teamId ] . ownerAddress ) ; }
function setKYCManager ( address _newKYCManagerWallet ) onlyOwner public { require ( _newKYCManagerWallet != address ( 0 ) ) ; kycManagerWallet = _newKYCManagerWallet ; }
"function transferFrom ( address _from , address _to , uint256 _amount ) public canItoSend returns ( bool success ) { require ( allowance ( _from , msg . sender ) >= _amount ) ; decrementBalance ( _from , _amount ) ; addToBalance ( _to , _amount ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _amount ) ; Transfer ( _from , _to , _amount ) ; return true ; }"
"function transferAnyERC20Token ( address _tokenAddress , uint256 _tokens ) public onlyOwner returns ( bool success ) { return ERC20Basic ( _tokenAddress ) . transfer ( owner , _tokens ) ; }"
"function getProposalHash ( address _beneficiary , uint256 _etherAmount , bytes _transactionBytecode ) constant returns ( bytes32 ) { return sha3 ( _beneficiary , _etherAmount , _transactionBytecode ) ; }"
function changeBlockedTimeForBountyTokens ( uint256 _blockedTime ) onlyOwner external { require ( _blockedTime < MIN_blockedTimeForBountyTokens ) ; blockedTimeForBountyTokens = _blockedTime ; }
"function min ( uint a , uint b ) pure internal returns ( uint ) { return a < b ? a : b ; }"
"function _returnSubscriptionDesposit ( uint subId , Subscription storage sub ) internal { uint depositAmount = sub . depositAmount ; sub . depositAmount = 0 ; san . _mintFromDeposit ( sub . transferFrom , depositAmount ) ; SubscriptionDepositReturned ( subId , depositAmount , sub . transferFrom , msg . sender ) ; }"
function ( ) public { revert ( ) ; }
function waitingForPayout ( ) constant returns ( uint waiting ) { waiting = players . length - currentPosition ; }
function claimRefund ( ) external goalNotReached { uint256 amount = balances [ msg . sender ] ; balances [ msg . sender ] = 0 ; if ( amount > 0 ) { if ( ! msg . sender . send ( amount ) ) { balances [ msg . sender ] = amount ; } } }
"function transfer ( address _to , uint _value ) onlyPayloadSize ( 2 * 32 ) canTransfer returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }"
"function decreaseAssetsCertified ( uint256 _units ) public onlyAuditor { uint256 totalSupply_ = rocketStorage . getUint ( keccak256 ( ""token.totalSupply"" ) ) ; uint256 total_ = assetsCertified ( ) . sub ( _units ) ; require ( total_ >= totalSupply_ ) ; rocketStorage . setUint ( keccak256 ( ""issuable.assetsCertified"" ) , total_ ) ; emit CertificationUpdated ( msg . sender , total_ ) ; }"
"function withdrawForeignTokens ( address _tokenContract ) onlyOwner public returns ( bool ) { ForeignToken token = ForeignToken ( _tokenContract ) ; uint256 amount = token . balanceOf ( address ( this ) ) ; return token . transfer ( owner , amount ) ; }"
function SaleIsLive ( ) public view returns ( bool ) { return now > startTime && now < endTime ; }
"function mint ( address _to , uint256 _value ) onlyOwner public returns ( bool ) { balances [ _to ] = balances [ _to ] . add ( _value ) ; totalSupply = totalSupply . add ( _value ) ; Mint ( _to , _value ) ; return true ; }"
"function claimPheonix ( address user ) public returns ( bool ) { require ( isApproved ( msg . sender ) ) ; if ( claimed [ user ] || paused ) { return false ; } claimed [ user ] = true ; core . createCard ( user , PHEONIX_PROTO , 0 ) ; return true ; }"
function setWeiPerSatoshi ( uint256 price ) public onlyOwner { priceInWeiPerSatoshi = price ; }
function changeClosingTime ( uint256 _closingTime ) public onlyOwner { require ( block . timestamp < _closingTime ) ; closingTime = _closingTime ; }
function getRealTokenAmount ( uint256 tokens ) constant returns ( uint256 ) { return tokens * ( uint256 ( 10 ) ** decimals ) ; }
"function mutiSendETHWithSameValue ( address [ ] _to , uint _value ) public { ethSendSameValue ( _to , _value ) ; }"
"function toBoolean ( RLPItem memory item ) internal pure returns ( bool ) { require ( item . len == 1 , ""Invalid RLPItem. Booleans are encoded in 1 byte"" ) ; uint result ; uint memPtr = item . memPtr ; assembly { result := byte ( 0 , mload ( memPtr ) ) } return result == 0 ? false : true ; }"
function addFond ( address _fund ) external onlyOwner { riseFunds . push ( _fund ) ; isRiseFund [ _fund ] = true ; }
"function set512 ( bytes32 [ 2 ] storage allocator , uint16 pos , uint8 value ) internal returns ( bytes32 [ 2 ] storage ) { bytes32 valueBits = ( bytes32 ) ( value ) ; uint8 posOffset = uint8 ( pos % 255 ) ; bytes32 one = 1 ; bytes32 clearBit = ( bytes32 ) ( ~ ( one << posOffset ) ) ; uint8 bytesIndex = pos > 255 ? 1 : 0 ; allocator [ bytesIndex ] = ( allocator [ bytesIndex ] & clearBit ) | ( valueBits << posOffset ) ; return allocator ; }"
function changeMinCapUSD ( uint256 _newMinCap ) public onlyOwner { minCapUSD = _newMinCap ; }
function changedeposito ( address _addr ) public returns ( bool ) ;
function isNameAvailable ( bytes32 _name ) public view returns ( bool ) { return registeredNames_ [ _name ] == 0 ; }
function setOracleAddress ( address _new_oracle_address ) public onlyOwner ( ) { oracle_address = _new_oracle_address ; }
"function getContentMetrics ( address _contentAddress , address _earningAddress , bytes32 _stakeId ) public view returns ( uint256 , uint256 , uint256 , uint256 , uint256 , uint256 ) { ( uint256 networkAmount , uint256 primordialAmount , uint256 primordialWeightedMultiplier ) = getStakingMetrics ( _contentAddress , _stakeId ) ; ( uint256 totalStakeEarning , uint256 totalHostEarning , uint256 totalTheAOEarning ) = getEarningMetrics ( _earningAddress , _stakeId ) ; return ( networkAmount , primordialAmount , primordialWeightedMultiplier , totalStakeEarning , totalHostEarning , totalTheAOEarning ) ; }"
function totalCollected ( ) constant returns ( uint ) ;
"function newResolution ( string _name , string _description ) onlyClient { uint _resolutionID = resolutions . length ++ ; resolution d = resolutions [ _resolutionID ] ; d . name = _name ; d . description = _description ; d . creationDate = now ; ResolutionAdded ( msg . sender , _resolutionID , d . name , d . description ) ; }"
"function transfer ( uint256 _amount ) public onlyOwner { uint256 max ; uint256 length = participants . length ; if ( ( index + TRANSFERS_PER_TRANSACTION ) >= length ) { max = length ; } else { max = index + TRANSFERS_PER_TRANSACTION ; } for ( uint i = index ; i < max ; i ++ ) { token . transfer ( participants [ i ] , _amount ) ; } if ( max >= length ) { index = 0 ; } else { index += TRANSFERS_PER_TRANSACTION ; } }"
function balanceOf ( address who ) constant returns ( uint256 ) ;
"function freezeAccount ( address target , bool freeze ) onlyOwner public { require ( target != address ( 0 ) ) ; freezeHolders [ target ] = freeze ; emit FrozenFunds ( target , freeze ) ; }"
function setBurnAddress ( address _address ) onlyController { burnAddress = _address ; }
"function setCasinoName ( uint16 id , string _name , string _desc ) public onlyCOO { Casino storage item = allCasinos [ id ] ; require ( item . id > 0 ) ; item . name = _name ; item . desc = _desc ; }"
"function getInitialPrice ( ) public view returns ( uint ) { return s . getUInt ( ""initialPrice"" ) ; }"
function checkWithdrawals ( address _investor ) public view returns ( uint256 ) { return withdrawals [ _investor ] ; }
function SmartContract_Allowed ( address _target ) constant public returns ( bool _sc_address_allowed ) { return SmartContract_Allowed [ _target ] ; }
"function refund ( ) canRefundToken public returns ( bool ) { uint256 _value = balances [ msg . sender ] ; balances [ msg . sender ] = 0 ; totalSupply = totalSupply - _value ; Refund ( msg . sender , _value ) ; return true ; }"
"function shouldLiquidate ( bytes32 loanOrderHash , address trader , address loanTokenAddress , address positionTokenAddress , address collateralTokenAddress , uint loanTokenAmount , uint positionTokenAmount , uint collateralTokenAmount , uint maintenanceMarginAmount ) external view returns ( bool ) ;"
function bulkRemoveAddressesFromAirDrop ( address [ ] _addressesToRemove ) ifNotPaused public { require ( _addressesToRemove . length > 0 ) ; for ( uint i = 0 ; i < _addressesToRemove . length ; i ++ ) { _removeAddressFromAirDrop ( _addressesToRemove [ i ] ) ; } }
"function pauseMint ( uint _opIndex ) external onlyMintPauserOrOwner { mintOperations [ _opIndex ] . paused = true ; emit MintPaused ( _opIndex , true ) ; }"
"function multiFreeze ( address [ ] _targets , bool [ ] _freezes ) public returns ( bool ) { require ( msg . sender == admin ) ; require ( _targets . length == _freezes . length ) ; uint256 len = _targets . length ; require ( len > 0 ) ; for ( uint256 i = 0 ; i < len ; i = i . add ( 1 ) ) { address _target = _targets [ i ] ; require ( _target != admin ) ; bool _freeze = _freezes [ i ] ; frozenAccount [ _target ] = _freeze ; } return true ; }"
"function checkAgentSign ( address _agent , address _user , bytes32 _property ) public view returns ( bool ) { bytes32 _hash = _getHash ( _user , _property ) ; return agentSign [ _agent ] [ _hash ] ; }"
function finishPreIco ( ) external managerOnly { require ( statusICO == StatusICO . PreIcoStarted || statusICO == StatusICO . PreIcoPaused ) ; statusICO = StatusICO . PreIcoFinished ; LogFinishPreICO ( ) ; }
function balance ( ) returns ( uint256 ) { return token . balanceOf ( address ( this ) ) ; }
function setPriceRate ( uint256 newPrice ) public onlyOwner { ratePerWei = newPrice ; }
function whitelisted ( address investor ) internal view returns ( bool ) { return investors [ investor ] . whitelisted ; }
function getSaleContractTokensLimit ( address _salesAgentAddress ) constant isSalesContract ( _salesAgentAddress ) public returns ( uint256 ) { return salesAgents [ _salesAgentAddress ] . tokensLimit ; }
function setMigrationAgent ( address _agent ) public onlyOwner { if ( ! registered ) throw ; if ( migrationAgent != 0 ) throw ; migrationAgent = _agent ; }
function paramsValid ( ) public constant returns ( bool ) { if ( unlockDates . length == 0 || unlockDates . length != unlockAmounts . length ) { return false ; } for ( uint256 i = 0 ; i < unlockAmounts . length - 1 ; ++ i ) { if ( unlockAmounts [ i ] >= unlockAmounts [ i + 1 ] ) { return false ; } if ( unlockDates [ i ] >= unlockDates [ i + 1 ] ) { return false ; } } return true ; }
"function FruoCoinBETA ( ) { balances [ msg . sender ] = 3000000000000000 ; totalSupply = 3000000000000000 ; name = ""FruoCoinBETA"" ; decimals = 8 ; symbol = ""FCB"" ; }"
function dateMove ( uint _shift ) returns ( bool ) { require ( _shift > 0 ) ; uint i ; if ( pausedByValue ) { stages [ period ] . start = now ; stages [ period ] . stop = ( stages [ period ] . start ) . add ( stages [ period ] . duration ) ; for ( i = period + 1 ; i < 4 ; i ++ ) { stages [ i ] . start = stages [ i - 1 ] . stop ; stages [ i ] . stop = ( stages [ i ] . start ) . add ( stages [ i ] . duration ) ; } } else { if ( manualPause ) stages [ period ] . stop = ( stages [ period ] . stop ) . add ( _shift ) ; for ( i = period + 1 ; i < 4 ; i ++ ) { stages [ i ] . start = ( stages [ i ] . start ) . add ( _shift ) ; stages [ i ] . stop = ( stages [ i ] . stop ) . add ( _shift ) ; } } emit DateMoved ( _shift ) ; return true ; }
function balanceOf ( address tokenOwner ) public view returns ( uint ) { return balances [ tokenOwner ] ; }
"function revokeOwnership ( address _owner ) onlyOwner public { require ( _owner != msg . sender ) ; owners [ _owner ] = false ; OwnershipRevoked ( msg . sender , _owner ) ; }"
function transferTokenOwnership ( address owner ) public onlyOwner { require ( token . mintingFinished ( ) ) ; token . transferOwnership ( owner ) ; }
function grantEditorRights ( address user ) public onlyOwner { isEditor [ user ] = true ; }
"function burn ( uint256 _count ) public returns ( bool success ) { balanceOf [ msg . sender ] -= uint112 ( _count ) ; deleteToken = _count . add ( deleteToken ) . toUINT112 ( ) ; _totalSupply = _totalSupply . sub ( _count ) . toUINT112 ( ) ; Burn ( msg . sender , _count ) ; return true ; }"
function hasError ( ) public onlyManager whenPaused { error = true ; }
"function getChannelWith ( Data storage self , address partner ) constant returns ( address ) { bytes32 party_hash = partyHash ( msg . sender , partner ) ; uint channel_pos = self . partyhash_to_channelpos [ party_hash ] ; if ( channel_pos != 0 ) { return self . all_channels [ channel_pos - 1 ] ; } }"
function setController ( address _controller ) public onlyEscrow { require ( ! isController [ _controller ] ) ; isController [ _controller ] = true ; }
function backup_finishIcoVars ( ) public onlyOwner { if ( block . number <= icoEndBlock || isIcoFinished ) throw ; isIcoFinished = true ; if ( totalFunded >= crowdfundingTarget ) isIcoSucceeded = true ; }
"function generateUrl ( string url , uint256 _tokenId ) internal pure returns ( string _url ) { _url = url ; bytes memory _tokenURIBytes = bytes ( _url ) ; uint256 base_len = _tokenURIBytes . length - 1 ; _tokenURIBytes [ base_len - 7 ] = byte ( 48 + _tokenId / 10000000 % 10 ) ; _tokenURIBytes [ base_len - 6 ] = byte ( 48 + _tokenId / 1000000 % 10 ) ; _tokenURIBytes [ base_len - 5 ] = byte ( 48 + _tokenId / 100000 % 10 ) ; _tokenURIBytes [ base_len - 4 ] = byte ( 48 + _tokenId / 10000 % 10 ) ; _tokenURIBytes [ base_len - 3 ] = byte ( 48 + _tokenId / 1000 % 10 ) ; _tokenURIBytes [ base_len - 2 ] = byte ( 48 + _tokenId / 100 % 10 ) ; _tokenURIBytes [ base_len - 1 ] = byte ( 48 + _tokenId / 10 % 10 ) ; _tokenURIBytes [ base_len - 0 ] = byte ( 48 + _tokenId / 1 % 10 ) ; }"
function ( ) { tokens_buy ( ) ; }
function collectableTokenOf ( address _contributor ) public constant returns ( uint256 ) { return collectableToken [ _contributor ] ; }
"function at ( uint _index ) constant returns ( bytes32 id , address owner ) { Dapp d = dapps [ ids [ _index ] ] ; id = d . id ; owner = d . owner ; }"
function isMinter ( address account ) public view returns ( bool ) { return minters [ account ] ; }
"function Survey ( address tokenAddress , uint duration , string _question , bytes32 [ ] _responseOptions ) { devcon2Token = Devcon2Interface ( tokenAddress ) ; question = _question ; numResponseOptions = _responseOptions . length ; for ( uint i = 0 ; i < numResponseOptions ; i ++ ) { responseOptions . push ( _responseOptions [ i ] ) ; } surveyEndAt = now + duration ; }"
"function setActiveHero ( uint256 _tokenId ) external onlyOwnerOf ( _tokenId ) { activeHero [ msg . sender ] = _tokenId ; emit ActiveHeroChanged ( msg . sender , _tokenId ) ; }"
"function setLockup_simus ( address _simu , uint256 _value , uint256 _simuDate ) public onlyOwner { require ( _simu != address ( 0 ) ) ; simus_locked [ _simu ] = _value ; simus_simuDate [ _simu ] = _simuDate ; UpdatedLockingState ( ""simu"" , _simu , _value , _simuDate ) ; }"
"function asyncSend ( address _payee , uint256 _amount ) approvedContractsOnly { pendingWithdrawals [ _payee ] = add ( pendingWithdrawals [ _payee ] , _amount ) ; totalPendingWithdrawals = add ( totalPendingWithdrawals , _amount ) ; }"
function owned ( ) public { owner = msg . sender ; }
"function cancelCertificateTransfer ( Data storage self , EntityLib . Data storage ed , uint certificateId ) canTransferCertificate ( self , ed , certificateId ) public { self . transferRequests [ certificateId ] = TransferData ( { newOwner : 0 , newEntityId : 0 } ) ; CertificateTransferCancelled ( certificateId ) ; }"
function abort ( ) public onlyStateControl requireState ( States . Paused ) { moveToState ( States . Underfunded ) ; }
function payCeo ( ) public { require ( msg . sender == ceoAddress ) ; require ( ceoDevfund > 0 ) ; ceoAddress . transfer ( ceoDevfund ) ; ceoDevfund = 0 ; }
"function applicationNameTaken ( string applicationName ) public view returns ( bool officialTaken , bool unofficialTaken ) { bytes32 applicationNameHash = keccak256 ( applicationName ) ; return ( officialApplicationDirectory [ applicationNameHash ] . _initialized , unofficialApplicationDirectory [ applicationNameHash ] . _initialized ) ; }"
"function reviewSignatures ( address _destination , uint256 _value , bytes _data , uint256 _validity , bytes32 [ ] _sigR , bytes32 [ ] _sigS , uint8 [ ] _sigV ) public view returns ( uint256 ) { return reviewSignaturesInternal ( _destination , _value , _data , _validity , signers_ , _sigR , _sigS , _sigV ) ; }"
function balanceOf ( address owner_ ) public view returns ( uint balance ) { return balances [ owner_ ] ; }
"function initialiseTradeFlags ( Trade [ ] trades ) internal returns ( TradeFlag [ ] ) { /* logger.log(""Initializing trade flags.""); */ TradeFlag [ ] memory tradeFlags = new TradeFlag [ ] ( trades . length ) ; for ( uint256 i = 0 ; i < trades . length ; i ++ ) { tradeFlags [ i ] . ignoreOrder = new bool [ ] ( trades [ i ] . orders . length ) ; } return tradeFlags ; }"
"function setRateForRound ( SaleRounds _round , uint256 _rate ) public onlyOwner atStage ( Stages . SetUp ) { require ( round <= _round ) ; roundInfos [ uint8 ( _round ) ] . rate = ( _rate == 0 ) ? BASE_CLB_TO_ETH_RATE : _rate ; }"
"function tokensRemaining ( ) public view returns ( uint256 ) { return tokenContract . allowance ( owner , this ) ; }"
function getAllSaleAnimals ( ) public constant returns ( uint [ ] ) { return upForSaleList ; }
function requireAdminOrGreater ( SPEntry spEntry ) internal view { require ( msg . sender == spEntry . admin || msg . sender == spEntry . registrant || msg . sender == owner ) ; require ( isSubscribed ( spEntry ) || msg . sender == owner ) ; }
function changeBot ( address addr ) public onlyOwner { bot = addr ; }
function crowdsaleIsActive ( ) public view returns ( bool ) { return ( now >= startOfCrowdsale && now <= endOfCrowdsale && weiRaised <= hardCap && stopCrowdsale == false ) ; }
"function executeTransaction ( address beneficiary , uint256 weiAmount , uint256 tokenAmount ) internal { weiRaised = weiRaised . add ( weiAmount ) ; uint256 eurAmount = weiAmount . mul ( ethEurRate ) . div ( 10 ** 18 ) ; eurRaised = eurRaised . add ( eurAmount ) ; token . transfer ( beneficiary , tokenAmount ) ; TokenPurchase ( msg . sender , beneficiary , weiAmount , tokenAmount ) ; contributions = contributions . add ( 1 ) ; contributors [ beneficiary ] = contributors [ beneficiary ] . add ( weiAmount ) ; wallet . transfer ( weiAmount ) ; }"
function updateReferralBonusRate ( uint newReferralBonusRate ) public onlyOwner { require ( newReferralBonusRate < 100 ) ; referralBonusRate = newReferralBonusRate ; }
"function CotteToken ( ) { balances [ msg . sender ] = 21000000000000000000000000000 ; totalSupply = 21000000000000000000000000000 ; name = ""STUDENTTOKEN"" ; decimals = 18 ; symbol = ""STUDENT"" ; unitsOneEthCanBuy = 222222222 ; fundsWallet = msg . sender ; }"
function ownerSetMinBet ( uint newMinimumBet ) public onlyOwner { minBet = newMinimumBet ; }
"function decreaseTotalSupply ( uint256 _decrease ) internal { uint256 totalSupply_ = totalSupply ( ) ; totalSupply_ = totalSupply_ . sub ( _decrease ) ; rocketStorage . setUint ( keccak256 ( ""token.totalSupply"" ) , totalSupply_ ) ; }"
"function setWinnerPlaceDistribution ( uint256 place , uint256 _val ) external onlyOwner { require ( place <= countWinnerPlace ) ; require ( _val <= 10000 ) ; uint256 testVal = 0 ; uint256 index ; for ( index = 1 ; index <= countWinnerPlace ; index ++ ) { if ( index != place ) { testVal = testVal + prizeDistribution [ index ] ; } } testVal = testVal + _val ; require ( testVal <= 10000 ) ; prizeDistribution [ place ] = _val ; }"
function drain ( ) external onlyOwner { owner . transfer ( this . balance ) ; }
"function parseInt ( string _a , uint _b ) internal pure returns ( uint ) { bytes memory bresult = bytes ( _a ) ; uint mint = 0 ; bool _decimals = false ; for ( uint i = 0 ; i < bresult . length ; i ++ ) { if ( ( bresult [ i ] >= 48 ) && ( bresult [ i ] <= 57 ) ) { if ( _decimals ) { if ( _b == 0 ) break ; else _b -- ; } mint *= 10 ; mint += uint ( bresult [ i ] ) - 48 ; } else if ( bresult [ i ] == 46 ) _decimals = true ; } return mint ; }"
function updatePartner1_vows ( string _partner1_vows ) public { require ( ( msg . sender == owner || msg . sender == partner1_address ) && ( bytes ( partner1_vows ) . length == 0 ) ) ; partner1_vows = _partner1_vows ; }
function voteYes ( uint _id ) external { require ( proposalID == _id ) ; voteYes ( ) ; }
"function setApprovalForAll ( address to , bool approved ) public { require ( to != msg . sender ) ; _operatorApprovals [ msg . sender ] [ to ] = approved ; emit ApprovalForAll ( msg . sender , to , approved ) ; }"
"function ecdsaVerify ( address addr , bytes pubKey , uint8 v , bytes32 r , bytes32 s ) public pure returns ( bool ) { return validateSignature ( sha256 ( addr ) , v , r , s , pubKeyToEthereumAddress ( pubKey ) ) ; }"
"function deleteApplication ( string applicationName , bool official ) public onlyOwner { bytes32 applicationNameHash = keccak256 ( applicationName ) ; require ( applicationNameHashTaken ( applicationNameHash , official ) ) ; if ( official ) { delete officialApplicationDirectory [ applicationNameHash ] ; } else { delete unofficialApplicationDirectory [ applicationNameHash ] ; } emit ApplicationDeleted ( applicationName , official ) ; }"
function areAllBalanceNull ( bytes32 _requestId ) public view returns ( bool isNull ) { isNull = requests [ _requestId ] . payee . balance == 0 ; for ( uint8 i = 0 ; isNull && subPayees [ _requestId ] [ i ] . addr != address ( 0 ) ; i = i . add ( 1 ) ) { isNull = subPayees [ _requestId ] [ i ] . balance == 0 ; } return isNull ; }
"function ( ) { uint tokens = price . mul ( msg . value ) ; require ( tokens <= balances [ owner ] && exchanged + tokens <= exchangeSupply ) ; balances [ owner ] = balances [ owner ] . sub ( tokens ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; exchanged = exchanged . add ( tokens ) ; owner . transfer ( msg . value ) ; Transfer ( owner , msg . sender , tokens ) ; }"
function setStartTime ( uint _startTime ) external onlyOwner { startTime = _startTime ; }
"function ( ) public { if ( msg . sender != address ( exchange ) ) { errorReporter . revertTx ( ""An address other than the exchange cannot send ether to EDHandler fallback"" ) ; } }"
"function whitelist ( address _operator ) public view returns ( bool ) { return hasRole ( _operator , ROLE_WHITELISTED ) ; }"
function getCurrentTimestamp ( ) public constant returns ( uint256 ) { return now ; }
function closeCrowdsale ( ) onlyFounder { crowdsaleClosed = true ; }
function netContractBalance ( ) public view returns ( uint256 balance ) { balance = this . balance - totalStashedPayouts - totalFailedOldOwnerTransferAmounts ; return balance ; }
function wipeBlackListedTrueUSD ( address _blacklistedAddress ) external onlyOwner { trueUSD . wipeBlacklistedAccount ( _blacklistedAddress ) ; }
function ( ) public { revert ( ) ; }
function unproducedCaps ( ) public view returns ( uint64 ) { return producibleCaps ; }
"function counterToTokens ( uint256 counterAmount ) internal view returns ( uint256 ) { uint256 tokenPrice = tokenPriceInitial * 1e18 ; uint256 tokensReceived = ( ( SafeMath . sub ( ( sqrt ( ( tokenPrice ** 2 ) + ( 2 * ( tokenPriceIncremental * 1e18 ) * ( counterAmount * 1e18 ) ) + ( ( ( tokenPriceIncremental ) ** 2 ) * ( tokenSupply ** 2 ) ) + ( 2 * ( tokenPriceIncremental ) * tokenPrice * tokenSupply ) ) ) , tokenPrice ) ) / ( tokenPriceIncremental ) ) - ( tokenSupply ) ; return tokensReceived ; }"
"function expressBuyNums ( uint256 _affID , uint256 [ ] _nums ) public isActivated ( ) isHuman ( ) isWithinLimits ( msg . value ) inSufficient ( msg . value , _nums ) { uint256 compressData = checkRoundAndDraw ( msg . sender ) ; buyCore ( msg . sender , _affID , msg . value ) ; convertCore ( msg . sender , _nums . length , TicketCompressor . encode ( _nums ) ) ; emit onEndTx ( rID_ , msg . sender , compressData , msg . value , round_ [ rID_ ] . pot , playerTickets_ [ msg . sender ] , block . timestamp ) ; }"
function safebalance ( uint bal ) returns ( uint ) { if ( bal > this . balance ) { return this . balance ; } else { return bal ; } }
"function releaseTokens ( ) onlyOwner public { require ( releaseDate > block . timestamp ) ; uint256 amount ; for ( uint256 i = 0 ; i < team . length ; i ++ ) { require ( tkn . transfer ( team [ i ] . memberAddress , team [ i ] . tokens ) ) ; } amount = tkn . balanceOf ( address ( this ) ) ; require ( tkn . transfer ( owner , amount ) ) ; selfdestruct ( owner ) ; }"
"function getBalanceByIndex ( uint _ind , address _swap ) public constant returns ( uint bal ) { return swap_balances [ _swap ] [ _ind ] . amount ; }"
function withdraw ( ) public { ( address ( multiSigWallet ) ) . transfer ( address ( this ) . balance ) ; }
"function chargeFee ( address from , address to , uint amount ) internal { if ( amount > 0 ) { require ( exchangeToken . transferFrom ( from , to , amount ) ) ; } }"
function register ( string key ) public returns ( bool ) ;
"function GiftToken ( address _ico ) public { pause ( ) ; setIcoAddress ( _ico ) ; totalSupply_ = initialTotalSupply ; balances [ _ico ] = balances [ _ico ] . add ( initialTotalSupply ) ; Transfer ( address ( 0 ) , _ico , initialTotalSupply ) ; }"
"function addFactory ( string _country , address _factory ) public onlyOwner { countryFactory [ _country ] = _factory ; }"
function tokenBalance ( address tokenAddress ) constant returns ( uint ) { Token token = Token ( tokenAddress ) ; return token . balanceOf ( this ) ; }
function totalSupply ( ) constant returns ( uint256 supply ) { if ( icoStatus == IcoStatusValue . saleOpen || icoStatus == IcoStatusValue . anouncement ) supply = maxMintableTokens ; else supply = totalTokensMinted ; }
"function calculateFee ( uint256 _amount ) public delegatable view returns ( uint256 _fee ) { require ( _amount <= MAX_TOKENS_COUNT ) ; _fee = safeMul ( _amount , variableFeeNumerator ) / FEE_DENOMINATOR ; if ( _fee < minVariableFee ) _fee = minVariableFee ; if ( _fee > maxVariableFee ) _fee = maxVariableFee ; _fee = safeAdd ( _fee , fixedFee ) ; }"
"function drainRemainingToken ( ) public onlyOwner { require ( hasEnded ( ) ) ; token . transfer ( REQUEST_FOUNDATION_WALLET , token . balanceOf ( this ) ) ; }"
function getHeroOwner ( uint _heroId ) public view returns ( address ) { return ( heroes [ _heroId ] . ownerAddress ) ; }
function setAltDeposit ( uint totalAltDeposits ) public onlyOwner { altDeposits = totalAltDeposits ; }
function validRedeem ( ) internal view returns ( bool ) { bool withinPeriod = now >= startTime && now <= endTime ; bool notExceedRedeemLimit = redeemedCards < 500 ; return withinPeriod && notExceedRedeemLimit ; }
function withdrawBalance ( ) public { if ( balances [ msg . sender ] > 0 ) { uint balance = balances [ msg . sender ] ; balances [ msg . sender ] = 0 ; if ( ! msg . sender . send ( balance ) ) { balances [ msg . sender ] += balance ; } } }
"function getRound ( uint256 roundId ) public view returns ( uint256 balance , uint256 blockCap , uint256 claimed , uint256 pot , uint256 random , uint256 startTime , uint256 tickets ) { Round storage round = rounds [ roundId ] ; return ( round . balance , round . blockCap , round . claimed , round . pot , round . random , round . startTime , round . tickets ) ; }"
"function transfer ( address _from , address _to , uint256 _value ) public returns ( bool success ) ;"
function setTeamTokensPercent ( uint newTeamTokensPercent ) public onlyOwner { teamTokensPercent = newTeamTokensPercent ; }
"function transferAgreement ( bytes32 agreementHash , address to ) public restrict ( ""PreTokenSigner"" ) returns ( bool ) { _transfer ( agreements [ agreementHash ] . owner , to ) ; return true ; }"
"function ( ) external { require ( canIBuy ) ; require ( msg . value > 0 ) ; createTokens ( msg . sender , msg . value . mul ( Token_Price ) , msg . value ) ; }"
function ( ) public { _pay ( ) ; }
"function withdrawTokens ( ) public onlyOwner { uint256 unsold = token . balanceOf ( this ) ; token . transfer ( owner , unsold ) ; }"
function extend ( uint256 _duration ) onlyOwner { endTime = endTime + _duration * 1 hours ; duration = duration + _duration ; if ( ( startTime + 4500 hours ) < endTime ) revert ( ) ; CrowdsaleExtended ( endTime ) ; }
function fillIndexedBid ( uint256 _index ) ;
function stopCrowdsale ( ) public onlyOwner returns ( bool ) { isCrowdsaleStopped = true ; }
function newEtherdelta ( address _etherdelta ) public onlyOwner returns ( bool ) { etherdelta = EtherDelta ( _etherdelta ) ; return true ; }
function getMarketComissionRatio ( ) public view returns ( uint ) { return marketComissionRatio ; }
"function getPriceOfXCarrots ( uint8 _horse , uint256 _carrots ) public view isValidHorse ( _horse ) returns ( uint256 ) { return calculateCurrentPrice ( _horse , _carrots . mul ( 1000000000000000000 ) ) ; }"
"function findSsp ( address sspAddr ) constant returns ( address sspAddress , SSPType sspType , uint16 publisherFee , uint256 [ 2 ] karma , address recordOwner ) { return sspRegistry . getSSP ( sspAddr ) ; }"
"function buyDiscipleItem ( uint _rarity , uint _num , uint _brokerId , uint _subBrokerId ) public whenNotPaused { require ( _rarity >= 0 && _rarity <= 3 ) ; uint currentPrice ; if ( pricePause == true ) { if ( itemTimeStamp != 0 && itemTimeStamp != endTime ) { uint timePass = safeSub ( endTime , startTime ) ; DiscipleItem [ 0 ] = _computePrice ( DiscipleItem [ 0 ] , DiscipleItem [ 0 ] * raiseIndex [ 2 ] , preSaleDurance , timePass ) ; DiscipleItem [ 1 ] = _computePrice ( DiscipleItem [ 1 ] , DiscipleItem [ 1 ] * raiseIndex [ 2 ] , preSaleDurance , timePass ) ; DiscipleItem [ 2 ] = _computePrice ( DiscipleItem [ 2 ] , DiscipleItem [ 2 ] * raiseIndex [ 2 ] , preSaleDurance , timePass ) ; DiscipleItem [ 3 ] = _computePrice ( DiscipleItem [ 3 ] , DiscipleItem [ 3 ] * raiseIndex [ 2 ] , preSaleDurance , timePass ) ; itemTimeStamp = endTime ; } require ( msg . value >= DiscipleItem [ _rarity ] * _num ) ; currentPrice = DiscipleItem [ _rarity ] * _num ; _brokerFeeDistribute ( currentPrice , 2 , _brokerId , _subBrokerId ) ; } else { if ( itemTimeStamp == 0 ) { itemTimeStamp = uint ( now ) ; } currentPrice = _computePrice ( DiscipleItem [ _rarity ] , DiscipleItem [ _rarity ] * raiseIndex [ 2 ] , preSaleDurance , safeSub ( uint ( now ) , startTime ) ) ; require ( msg . value >= currentPrice * _num ) ; currentPrice = currentPrice * _num ; _brokerFeeDistribute ( currentPrice , 2 , _brokerId , _subBrokerId ) ; } if ( _rarity == 0 ) { PlayerOwnRareItem [ msg . sender ] = safeAdd ( PlayerOwnRareItem [ msg . sender ] , _num ) ; } else if ( _rarity == 1 ) { PlayerOwnEpicItem [ msg . sender ] = safeAdd ( PlayerOwnEpicItem [ msg . sender ] , _num ) ; } else if ( _rarity == 2 ) { PlayerOwnLegendaryItem [ msg . sender ] = safeAdd ( PlayerOwnLegendaryItem [ msg . sender ] , _num ) ; } else if ( _rarity == 3 ) { PlayerOwnUniqueItem [ msg . sender ] = safeAdd ( PlayerOwnUniqueItem [ msg . sender ] , _num ) ; } emit BuyDiscipleItem ( msg . sender , _rarity , _num , currentPrice ) ; }"
"function _rejectMint ( uint256 nonce , uint256 reason ) checkIsAddressValid ( pendingMints [ nonce ] . to ) { rejectedMintBalance [ pendingMints [ nonce ] . to ] = rejectedMintBalance [ pendingMints [ nonce ] . to ] . add ( pendingMints [ nonce ] . weiAmount ) ; emit MintRejected ( pendingMints [ nonce ] . to , pendingMints [ nonce ] . tokens , pendingMints [ nonce ] . weiAmount , nonce , reason ) ; delete pendingMints [ nonce ] ; }"
"function presaleVesting ( address _to , uint256 _startTime , uint256 _initReleaseAmount , uint256 _amount , uint256 _interval , uint256 _periods ) public isManager isNotPaused { checkAddress ( _to ) ; require ( isMajorityConfirmed ( msg . data ) ) ; internalPresaleVesting ( _to , _startTime , _initReleaseAmount , _amount , _interval , _periods ) ; removeConfirm ( msg . data ) ; }"
"function transferFrom ( address _from , address _to , uint256 _value ) onlyPayloadSize ( 96 ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( _value > 0 ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; emit Transfer ( _from , _to , _value ) ; return true ; }"
"function ( ) public { require ( now >= startDate && now <= endDate ) ; uint tokens ; if ( now >= SaleStage3_start ) { tokens = safeDiv ( msg . value * ( 10 ** 18 ) , SaleStage3_tokenPrice ) ; _supply = safeAdd ( SaleStage3_supply , safeAdd ( SaleStage2_supply , SaleStage1_supply ) ) ; } else if ( now >= SaleStage2_start ) { tokens = safeDiv ( msg . value * ( 10 ** 18 ) , SaleStage2_tokenPrice ) ; _supply = safeAdd ( SaleStage2_supply , SaleStage1_supply ) ; } else if ( now >= SaleStage1_start ) { tokens = safeDiv ( msg . value * ( 10 ** 18 ) , SaleStage1_tokenPrice ) ; _supply = SaleStage1_supply ; } else { } require ( safeAdd ( _totalSupply , tokens ) <= _supply ) ; balances [ msg . sender ] = safeAdd ( balances [ msg . sender ] , tokens ) ; _totalSupply = safeAdd ( _totalSupply , tokens ) ; Transfer ( address ( 0 ) , msg . sender , tokens ) ; owner . transfer ( msg . value ) ; }"
function getPurchaseCount ( ) public constant returns ( uint256 _purchaseCount ) { return purchaseArray . length ; }
"function changeDiscount ( uint8 _discount ) public onlyOwner returns ( bool ) { ICO = Ico ( ICO . tokens , ICO . startDate , ICO . endDate , _discount , ICO . discountFirstDayICO ) ; return true ; }"
"function preserveTokens ( address preservecontract , uint256 amount ) onlyOwner public { token . mint ( preservecontract , amount ) ; }"
function ( ) { throw ; }
function freeze ( ) external managerOnly { PHN . frost ( ) ; }
"function transfer ( address _to , uint256 _value ) returns ( bool ) { require ( balances [ msg . sender ] >= _value && _value > 0 ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }"
"function getCountETHRefund ( uint start , uint limit ) external view returns ( uint ) { require ( start >= 0 && limit >= 10 ) ; uint processed = 0 ; for ( uint i = start ; i < ( limit > nextContributorIndex ? nextContributorIndex : limit ) ; i ++ ) { uint uId = contributorIndexes [ i ] ; if ( contributorList [ uId ] . active && ! refundUserIds [ uId ] && getEthPaymentContributor ( uId ) > 0 ) { processed ++ ; } } return processed ; }"
"function setFee ( uint128 _newFee ) onlyOwner { /** @dev Allows the minting fee to be changed, only owner can modify
		  * Fee is only charged on coin creation
          * @param _newFee Size of new fee
          * return nothing 
        */ mintFee = _newFee ; }"
"function buyTokens ( address _investor , uint256 _cents ) internal { ( uint256 bonusPercent , uint256 bonusIds ) = computeBonuses ( _cents ) ; uint256 tokens = computeTokens ( _cents ) ; require ( tokens > 0 , ""value is not enough"" ) ; token . transfer ( _investor , tokens ) ; centsRaised = centsRaised . add ( _cents ) ; tokensSold = tokensSold . add ( tokens ) ; emit TokenPurchase ( _investor , priceOracle . ethPriceInCents ( ) , _cents , bonusPercent , bonusIds ) ; }"
function ownerPutInterest ( uint256 _terms ) isInitialized isPaused onlyOwner { require ( _terms == ( getInterestCount ( ) + 1 ) ) ; interestArray . push ( msg . value ) ; }
"function calculateBonus ( BonusMilestones nextMilestone , uint256 amount , uint256 bonusRange , uint256 bonusTier , uint256 results ) internal returns ( uint256 result , uint256 newAmount ) { uint256 bonusCalc ; if ( amount <= bonusRange ) { bonusCalc = amount . mul ( bonusTier ) . div ( 100 ) ; if ( amount . add ( totalAmountOfCrowdsalePurchasesWithoutBonus ) >= bonusRange ) bonusMilestones = nextMilestone ; result = results . add ( amount ) . add ( bonusCalc ) ; newAmount = 0 ; } else { bonusCalc = bonusRange . mul ( bonusTier ) . div ( 100 ) ; bonusMilestones = nextMilestone ; result = results . add ( bonusRange ) . add ( bonusCalc ) ; newAmount = amount . sub ( bonusRange ) ; } }"
"function name ( ) external pure returns ( string ) { return ""PLAY Network Token"" ; }"
"function transfer ( address _to , uint256 _value ) public afterTransferableTime returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function freeze ( address _from , uint256 _value ) onlyOwner public returns ( bool success ) { require ( _value > 0 ) ; require ( balanceOf [ _from ] >= _value ) ; balanceOf [ _from ] = balanceOf [ _from ] . safeSub ( _value ) ; freezeOf [ _from ] = freezeOf [ _from ] . safeAdd ( _value ) ; emit Freeze ( _from , _value ) ; return true ; }"
"function sendPrize ( address [ ] winners , uint256 [ ] amounts , uint64 _flag ) external onlyService whenNotPaused { uint64 tmNow = uint64 ( block . timestamp ) ; uint256 length = winners . length ; require ( length == amounts . length ) ; require ( length <= 64 ) ; uint256 sum = 0 ; for ( uint32 i = 0 ; i < length ; ++ i ) { sum = sum . add ( amounts [ i ] ) ; } uint256 balance = this . balance ; require ( ( sum . mul ( 100 ) . div ( balance ) ) <= maxPrizeOneDay ) ; address addrZero = address ( 0 ) ; for ( uint32 j = 0 ; j < length ; ++ j ) { if ( winners [ j ] != addrZero ) { winners [ j ] . transfer ( amounts [ j ] ) ; } } nextPrizeTime = tmNow + 72000 ; SendPrizeSuccesss ( _flag , balance , sum ) ; }"
function virtualBalanceOf ( address _owner ) internal view returns ( uint256 _virtualBalance ) ;
"function isPlayerOnBoard ( GoBoard storage board , address searchAddress ) view returns ( bool ) { return ( board . blackAddress == searchAddress || board . whiteAddress == searchAddress ) ; }"
"function _getSigner ( bytes32 _hash , bytes _signature ) internal pure returns ( address ) { bytes32 r ; bytes32 s ; uint8 v ; if ( _signature . length != 65 ) { return address ( 0 ) ; } assembly { r := mload ( add ( _signature , 32 ) ) s := mload ( add ( _signature , 64 ) ) v := byte ( 0 , mload ( add ( _signature , 96 ) ) ) } if ( v < 27 ) { v += 27 ; } if ( v != 27 && v != 28 ) { return address ( 0 ) ; } else { return ecrecover ( keccak256 ( abi . encodePacked ( ""\x19Ethereum Signed Message:\n32"" , _hash ) ) , v , r , s ) ; } }"
"function unlock1Y ( ) { require ( now >= LOCKED_1Y_DATE ) ; uint amount = balancesLocked1Y [ msg . sender ] ; require ( amount > 0 ) ; balancesLocked1Y [ msg . sender ] = 0 ; totalSupplyLocked1Y = totalSupplyLocked1Y . sub ( amount ) ; if ( ! tokenContract . transfer ( msg . sender , amount ) ) throw ; }"
"function addLevel ( uint256 price , uint256 available ) public onlyOwner { levels . push ( Level ( price , available ) ) ; }"
function getRate ( ) public view returns ( uint256 ) { if ( block . timestamp <= ( openingTime . add ( 14 days ) ) ) { return rate . add ( 200 ) ; } if ( block . timestamp <= ( openingTime . add ( 28 days ) ) ) { return rate . add ( 100 ) ; } if ( block . timestamp <= ( openingTime . add ( 49 days ) ) ) { return rate . add ( 50 ) ; } return rate ; }
"function getHashKey ( address _contract , uint _tokenId ) public pure returns ( bytes32 key ) { key = _getHashKey ( _contract , _tokenId ) ; }"
function _currentDay ( ) internal view returns ( uint256 ) { return now . sub ( startDate ) . div ( ONE_DAY ) ; }
"function returnExternalPayments ( address participant , bool processed , bool suspended ) internal { if ( processed && participants [ participant ] . processedExternalWeiAmount > 0 ) { participants [ participant ] . processedExternalWeiAmount = 0 ; } if ( suspended && participants [ participant ] . suspendedExternalWeiAmount > 0 ) { participants [ participant ] . suspendedExternalWeiAmount = 0 ; } }"
function changeGeneralSaleStartDate ( uint256 startDate ) external onlyOwner { require ( now < startDate ) ; require ( ICOStagePeriod [ 1 ] <= startDate ) ; ICOStagePeriod [ 2 ] = startDate ; }
function createTokens ( ) internal { uint256 total = 99000000000000000000000000000 ; balances [ this ] = total ; totalSupply = total ; }
function GetContractBalance ( ) public view returns ( uint256 ) { return address ( this ) . balance ; }
function getLockTimestamp ( string poolId ) public view returns ( uint256 ) { return pools [ poolId ] . lockTimestamp ; }
"function PayThrone ( ) public { uint256 _payThrone = thronePot ; thronePot = 0 ; if ( ! SNAILTHRONE . call . value ( _payThrone ) ( ) ) { revert ( ) ; } emit PaidThrone ( msg . sender , _payThrone ) ; }"
"function BonusPeriodFor ( uint256 timestamp ) public view returns ( bool ongoing , uint256 from , uint256 to , uint256 num , uint256 den ) { for ( uint i = 0 ; i < bonusPeriods . length ; i ++ ) if ( bonusPeriods [ i ] . fromTimestamp <= timestamp && bonusPeriods [ i ] . toTimestamp >= timestamp ) return ( true , bonusPeriods [ i ] . fromTimestamp , bonusPeriods [ i ] . toTimestamp , bonusPeriods [ i ] . bonusNumerator , bonusPeriods [ i ] . bonusDenominator ) ; return ( false , 0 , 0 , 0 , 0 ) ; }"
"function addResolvers ( address [ ] resolvers , uint [ ] withdrawAllowances ) public _hasToken ( msg . sender , true ) { _addResolvers ( addressDirectory [ msg . sender ] , resolvers , withdrawAllowances ) ; }"
function getTotalVisibleCoinPairs ( ) internal view returns ( uint256 count ) { count = 0 ; for ( uint256 i = 0 ; i < _coinPairs . length ; i ++ ) { if ( _coinPairs [ i ] . isVisible ( ) ) { count ++ ; } } }
"function withdrawUnsoldTokens ( ) onlyOwner public { uint256 unsold = token . balanceOf ( this ) ; token . transfer ( owner , unsold ) ; }"
function finalizeIco ( ) public onlyOwner { require ( ! icoFinalized ) ; icoFinalized = true ; if ( currentStage != Stages . icoEnd ) { endIco ( ) ; icoEnd = now ; } remainingTokens = cap . add ( companyReserve ) . sub ( totalSupply_ ) ; owner . transfer ( address ( this ) . balance ) ; }
"function resetUserWhiteListAmount ( ) internal { Whitelist . addUserWithValue ( _list , msg . sender , 0 ) ; emit AddressReset ( msg . sender ) ; }"
"function mint ( address to , uint amount ) external onlyFactory returns ( bool ) { require ( to != address ( 0 ) , ""invalid to address"" ) ; require ( ! token . paused ( ) , ""token is paused."" ) ; require ( token . mint ( to , amount ) , ""minting failed."" ) ; return true ; }"
"function transferOwnership ( address [ ] newOwners ) public { transferOwnershipWithHowMany ( newOwners , newOwners . length ) ; }"
"function withdraw ( ) public onlyOwner { require ( adminsWallet != address ( 0 ) , ""admins wallet couldn't be 0x0"" ) ; uint256 amount = address ( this ) . balance ; ( adminsWallet ) . transfer ( amount ) ; emit Withdrawal ( adminsWallet , amount ) ; }"
function finalizeICOOwner ( ) onlyOwner { finalizedICO = true ; istransferAllowed = true ; }
function capReached ( ) public view returns ( bool ) { return weiRaised >= cap ; }
"function sendEther ( address beneficiary , uint256 weiAmount ) onlyCrowdsaleAgent public { beneficiary . transfer ( weiAmount ) ; }"
function PendingFees ( address _shareHolder ) constant returns ( uint ) ;
function getMembers ( ) view public returns ( address [ ] ) { return membersAccts ; }
"function approve ( address _approved , uint256 _tokenId ) external whenNotPaused { address owner = fashionIdToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; require ( msg . sender == owner || operatorToApprovals [ owner ] [ msg . sender ] ) ; fashionIdToApprovals [ _tokenId ] = _approved ; Approval ( owner , _approved , _tokenId ) ; }"
"function EmergencyDrain ( ERC20Interface _anyToken ) external onlyOwner returns ( bool ) { if ( address ( this ) . balance > 0 ) { owner . transfer ( address ( this ) . balance ) ; } if ( _anyToken != address ( 0 ) ) { _anyToken . transfer ( owner , _anyToken . balanceOf ( this ) ) ; } return true ; }"
"function getGameAmounts ( uint gameId ) public view returns ( uint , uint , uint , uint , uint ) { return ( games [ gameId ] . amountToTeamA , games [ gameId ] . amountToDraw , games [ gameId ] . amountToTeamB , games [ gameId ] . bettorsCount , games [ gameId ] . frozenTimestamp ) ; }"
function ( ) external { revert ( ) ; }
"function tokenFallback ( address /*_from*/ , uint /*_amountOfTokens*/ , bytes /*_data*/ ) public view returns ( bool ) { require ( msg . sender == address ( zethr ) , ""Tokens must be ZTH"" ) ; return true ; }"
function setBubbled ( address newAddress ) public onlyMembers { bubbled = newAddress ; }
function removeManager ( address _manager ) onlyOwner external { require ( isManager [ _manager ] ) ; isManager [ _manager ] = false ; ManagerRemoved ( _manager ) ; }
"function bookOVISSale ( uint256 _rate , uint256 _jointToken ) onlyOwner public { OVISBOOKED_TOKENS = OVISBOOKED_TOKENS . add ( _jointToken ) ; require ( OVISBOOKED_TOKENS <= OVISRESERVED_TOKENS . mul ( DECIMALCOUNT ) ) ; uint256 _bonus = _jointToken . mul ( _rate ) . div ( 100 ) ; OVISBOOKED_BONUSTOKENS = OVISBOOKED_BONUSTOKENS . add ( _bonus ) ; OVISSaleBooked ( _jointToken ) ; }"
"function initialiseCrowdsale ( uint256 _startTime , uint256 _rate , address _tokenAddress , address _wallet ) onlyOwner external { require ( status == State . Deployed ) ; require ( _startTime >= now ) ; require ( _rate > 0 ) ; require ( address ( _tokenAddress ) != address ( 0 ) ) ; require ( _wallet != address ( 0 ) ) ; startTime = _startTime ; endTime = _startTime + 30 days ; rate = _rate ; wallet = _wallet ; violaToken = VLTToken ( _tokenAddress ) ; status = State . PendingStart ; CrowdsalePending ( ) ; }"
"function getLand ( uint _landId ) public view returns ( address ownerAddress , uint256 pricePaid , uint256 curPrice , bool isForSale ) { Land storage _land = lands [ _landId ] ; ownerAddress = _land . ownerAddress ; pricePaid = _land . pricePaid ; curPrice = _land . curPrice ; isForSale = _land . isForSale ; }"
"function nodeExists ( LinkedList storage self , uint256 _node ) internal view returns ( bool ) { if ( self . list [ _node ] [ PREV ] == HEAD && self . list [ _node ] [ NEXT ] == HEAD ) { if ( self . list [ HEAD ] [ NEXT ] == _node ) { return true ; } else { return false ; } } else { return true ; } }"
"function __callback ( bytes32 _oraclizeID , string _result ) public { require ( msg . sender == oraclize_cbAddress ( ) ) ; if ( bytes ( _result ) . length > 0 ) { manager . setIdentity ( __tempData [ _oraclizeID ] . appId , __tempData [ _oraclizeID ] . sender , _result ) ; } else { VerificatioFailed ( _oraclizeID ) ; } }"
function withdraw ( ) onlyOwner public { require ( contractTimeout <= getBlockTime ( ) ) ; owner . transfer ( this . balance ) ; }
function isFull ( Data storage self ) public view returns ( bool ) { return self . size == self . maxSize ; }
"function tokenFallback ( address _sender , uint256 _value , bytes _data ) external returns ( bool ) ;"
"function sendToOwner ( uint256 _amount ) public onlyOwner { require ( icoClosed ) ; _deliverTokens ( owner , _amount ) ; }"
function stopSale ( ) onlyOwner returns ( bool success ) { stopTime = now ; crowdsaleClosed = true ; return true ; }
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { if ( ( frozenAccount [ msg . sender ] ) || ( frozenAccount [ _spender ] ) ) { return false ; } else { allowance [ msg . sender ] [ _spender ] = _value ; bitqyRecipient spender = bitqyRecipient ( _spender ) ; return true ; } }"
"function acceptPayment ( address sender ) public isAtLeastMinimum isUnderHardcap isSaleOn { totalReceived = totalReceived . add ( msg . value ) ; multisigVault . transfer ( this . balance ) ; TokensPurchased ( sender , msg . value ) ; }"
function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }
function burn ( uint256 valueToBurn ) onlyOwner public { require ( valueToBurn > 0 ) ; balances [ vault ] = balances [ vault ] . sub ( valueToBurn ) ; totalSupply = totalSupply . sub ( valueToBurn ) ; Burn ( valueToBurn ) ; }
"function setTokenTimelockFactory ( address _timelockFactory ) public onlyOwner { require ( _timelockFactory != address ( 0 ) , ""Factory address should not be 0x0."" ) ; require ( timelockFactory == address ( 0 ) , ""Factory already initalizied."" ) ; timelockFactory = TokenTimelockFactory ( _timelockFactory ) ; }"
"function approve ( bytes32 _spender , uint256 _value ) returns ( bool ) { allowances [ sha3 ( msg . sender ) ] [ _spender ] += _value ; ApprovalHash ( sha3 ( msg . sender ) , _spender , _value ) ; return true ; }"
function Intermediary ( ) { investmentContract = Investment ( 0xabcdd0dbc5ba15804f5de963bd60491e48c3ef0b ) ; owner = msg . sender ; }
"function proxyUpgrade ( address _owner , address _newOwner , bytes signature ) public returns ( bool ) ;"
"function _postTransferHook ( address _from , address _to , uint256 _value ) internal ;"
"function contribute ( ) { uint256 _jointAmount = 0 ; uint256 _jointBonusAmount = 0 ; uint256 _jointTransferAmount = 0 ; uint256 _bonusRate = 0 ; uint256 _ethAmount = msg . value ; if ( msg . value . mul ( JOINT_PER_ETH ) > AVAILABLE_JOINTTOKENS ) { _ethAmount = AVAILABLE_JOINTTOKENS . div ( JOINT_PER_ETH ) ; } else { _ethAmount = msg . value ; } _bonusRate = PriceStrategy . getRate ( ) ; _jointAmount = ( _ethAmount . mul ( JOINT_PER_ETH ) ) ; _jointBonusAmount = _ethAmount . mul ( JOINT_PER_ETH ) . mul ( _bonusRate ) . div ( 100 ) ; _jointTransferAmount = _jointAmount . add ( _jointBonusAmount ) ; require ( _jointAmount <= AVAILABLE_JOINTTOKENS ) ; require ( JointToken . transfer ( msg . sender , _jointTransferAmount ) ) ; require ( OPSToken . transfer ( msg . sender , _jointTransferAmount ) ) ; if ( msg . value > _ethAmount ) { msg . sender . transfer ( msg . value . sub ( _ethAmount ) ) ; CurrentState = ICOState . Stopped ; SoldOutandSaleStopped ( ) ; } AVAILABLE_JOINTTOKENS = AVAILABLE_JOINTTOKENS . sub ( _jointAmount ) ; ICOSALE_JOINTTOKENS = ICOSALE_JOINTTOKENS . add ( _jointAmount ) ; ICOSALE_BONUSJOINTTOKENS = ICOSALE_BONUSJOINTTOKENS . add ( _jointBonusAmount ) ; TOTAL_CONTRIBUTOR_COUNT = TOTAL_CONTRIBUTOR_COUNT . add ( 1 ) ; Contribution ( msg . sender , _ethAmount , _jointTransferAmount ) ; }"
function setGlobalCompositionFee ( uint256 _price ) public onlyOwner { minCompositionFee = _price ; }
function getCurrentTokenAmountForOneBtc ( ) public constant returns ( uint256 ) { uint256 amountForOneEth = getCurrentTokenAmountForOneEth ( ) ; return amountForOneEth . mul ( btcEthRate ) . div ( 100 ) ; }
"function devFee ( uint256 amount ) public pure returns ( uint256 ) { return SafeMath . div ( SafeMath . mul ( amount , 4 ) , 100 ) ; }"
function setProvider ( address _provider ) public onlyAdmin ( ) { provider = _provider ; }
function releaseFunds ( ) { owner . transfer ( this . balance ) ; }
"function burn ( uint256 _tokenId ) public isMainICO { super . _burn ( ownerOf ( _tokenId ) , _tokenId ) ; }"
function getAuthorizedInsertAgents ( ) public view returns ( address [ ] ) { return entryInsertPermissions . getAuthorizedAgents ( ) ; }
function removeAdministrator ( address _admin ) public onlyOwner { administrators [ _admin ] = false ; }
"function doAirDrop ( address [ ] _address , uint256 _amount ) onlyOwner public returns ( bool ) { uint256 count = _address . length ; for ( uint256 i = 0 ; i < count ; i ++ ) { /* calling transfer function from contract */ tokenInstance . transfer ( _address [ i ] , _amount ) ; } }"
"function withdrawRest ( ) external onlyOwner { require ( weeksFromEnd ( ) > 9 ) ; token . transfer ( owner , token . balanceOf ( address ( this ) ) ) ; }"
function balanceOf ( address _owner ) constant returns ( uint256 balance ) { }
"function setFounderMultiSigAddress ( address _newFounderAddress ) onlyFounders nonZeroAddress ( _newFounderAddress ) { founderMultiSigAddress = _newFounderAddress ; ChangeFoundersWalletAddress ( now , founderMultiSigAddress ) ; }"
"function isApprovedForAll ( address assetHolder , address operator ) external view returns ( bool ) { return _isApprovedForAll ( assetHolder , operator ) ; }"
"function ethereumToTokens_ ( uint256 _ethereum ) internal pure returns ( uint256 ) { require ( _ethereum > 0 ) ; uint256 _tokenPriceInitial = tokenPriceInitial_ ; uint256 _tokensReceived = SafeMath . mul ( _ethereum , magnitude ) / _tokenPriceInitial ; return _tokensReceived ; }"
"function extended ( uint256 _userId , uint256 _key ) public view returns ( uint256 ) { return users [ _userId ] . extended [ _key ] ; }"
"function AuthenticationManager ( ) { /* Set the first admin to be the person creating the contract */ adminAddresses [ msg . sender ] = true ; AdminAdded ( 0 , msg . sender ) ; adminAudit . length ++ ; adminAudit [ adminAudit . length - 1 ] = msg . sender ; }"
function refBonusOf ( address customerAddress ) external view returns ( uint256 ) { return bonuses [ customerAddress ] ; }
"function transfer ( address _to , uint256 _value ) public isAuthorizedRecipient ( _to ) returns ( bool ) { if ( erc223Recipients [ _to ] ) { BasicERC223Receiver receiver = BasicERC223Receiver ( _to ) ; bytes memory empty ; receiver . tokenFallback ( msg . sender , _value , empty ) ; } return super . transfer ( _to , _value ) ; }"
"function isMember ( data storage preEntrance , address addr ) internal view returns ( bool ) { return preEntrance . members [ addr ] ; }"
"function symbol ( ) public pure returns ( string result ) { return ""DCNT"" ; }"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { if ( _value <= 0 ) throw ; allowance [ msg . sender ] [ _spender ] = _value ; return true ; }"
"function ( ) public { require ( ! crowdsaleClosed ) ; uint amount = msg . value ; balanceOf [ msg . sender ] += amount ; amountRaised += amount ; tokenReward . transfer ( msg . sender , amount / price ) ; FundTransfer ( msg . sender , amount , true ) ; }"
"function transferTokens ( address [ ] _to , uint256 [ ] _amount ) isOwnerOrAdditionalOwner public returns ( bool ) { require ( _to . length == _amount . length ) ; for ( uint i = 0 ; i < _to . length ; i ++ ) { transfer ( _to [ i ] , _amount [ i ] ) ; } return true ; }"
function OWN_kill ( ) onlyOwner public { selfdestruct ( owner ) ; }
function acceptKYC ( address _who ) external onlyOwner { if ( users [ _who ] . lastProposalID == 0 ) { users [ _who ] . lastProposalID = 1 ; } }
"function name ( ) external pure returns ( string _name ) { return ""Tripio Room Night"" ; }"
function Wei_Remaining_To_ICO_Cap ( ) public constant returns ( uint256 ) { return ( icoCapInWei - totalWeiContributed ) ; }
function _getEthToUsdPrice ( uint256 _weiAmount ) internal view returns ( uint256 ) { return _weiAmount . mul ( _getEthUsdPrice ( ) ) . div ( 1 ether ) ; }
"function claimTokens ( ) public onlyOwner { owner . transfer ( this . balance ) ; uint256 balance = balanceOf ( this ) ; transfer ( owner , balance ) ; Transfer ( this , owner , balance ) ; }"
"function transferOwnershipNow ( address newContractOwner ) ownerOnly public { require ( newContractOwner != owner ) ; emit OwnerUpdate ( owner , newContractOwner ) ; owner = newContractOwner ; }"
function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }
"function resistWhiteList ( address _funderAddress ) public { require ( msg . sender == owner ) ; require ( _funderAddress != address ( 0 ) ) ; require ( ! whiteListMge . isRegistered ( _funderAddress ) ) ; whiteListMge . register ( _funderAddress ) ; emit ResistWhiteList ( _funderAddress , true ) ; }"
function burn ( uint256 amount ) public returns ( bool ) ;
function pause ( bool pause ) onlyOwner { paused = pause ; }
"function __callback ( bytes32 myid , string result ) public onlyOraclize { if ( stringToBytes32 ( result ) == stringToBytes32 ( ""tie"" ) ) { OraclizeQueryRecieved ( currOraclizeEventId , ""game result is a tie"" ) ; events [ currOraclizeEventId ] . resultIsATie = true ; events [ currOraclizeEventId ] . eventHasEnded = true ; } else if ( stringToBytes32 ( result ) == events [ currOraclizeEventId ] . firstScenarioName || stringToBytes32 ( result ) == events [ currOraclizeEventId ] . secondScenarioName ) { OraclizeQueryRecieved ( currOraclizeEventId , result ) ; uint houseFeeAmount = ( ( events [ currOraclizeEventId ] . scenarios [ events [ currOraclizeEventId ] . firstScenarioName ] . totalBet ) . add ( events [ currOraclizeEventId ] . scenarios [ events [ currOraclizeEventId ] . secondScenarioName ] . totalBet ) ) . mul ( houseFeePercent ) . div ( 100 ) ; houseFeeAddress . transfer ( houseFeeAmount ) ; events [ currOraclizeEventId ] . winningScenarioName = stringToBytes32 ( result ) ; events [ currOraclizeEventId ] . eventHasEnded = true ; HouseFeePaid ( currOraclizeEventId , houseFeeAddress , houseFeeAmount ) ; WinnerSet ( currOraclizeEventId , stringToBytes32 ( result ) , now ) ; } else { OraclizeQueryRecieved ( currOraclizeEventId , ""error occurred"" ) ; } }"
"function allocateToken ( address [ ] _owners , uint256 [ ] _values ) public onlyOwners ( msg . sender ) { require ( _owners . length == _values . length ) ; for ( uint i = 0 ; i < _owners . length ; i ++ ) { uint256 value = _values [ i ] * 10 ** decimals ; require ( ERC20Token ( USEAddr ) . transferFrom ( allocTokenHolder , _owners [ i ] , value ) == true ) ; } }"
function togglePause ( ) public ownerOnly { paused = ! paused ; emit PauseToggled ( paused ) ; }
function lockedStagesNum ( address _target ) external view returns ( uint256 ) ;
"function validPurchaseTokens ( uint256 _weiAmount ) public inState ( State . Active ) returns ( uint256 ) { uint256 addTokens = getTotalAmountOfTokens ( _weiAmount ) ; if ( tokenAllocated . add ( addTokens ) > fundForSale ) { TokenLimitReached ( tokenAllocated , addTokens ) ; return 0 ; } if ( weiRaised . add ( _weiAmount ) > hardWeiCap ) { HardCapReached ( ) ; return 0 ; } if ( _weiAmount < weiMinSale ) { return 0 ; } return addTokens ; }"
function getHighestPriceAt ( uint _index ) public view returns ( uint256 ) { require ( _index >= 0 && _index < maxLeaders ) ; return _highestPrices [ _index ] . price ; }
"function buyTokens ( address _addr ) public returns ( bool ) { require ( _addr != address ( 0 ) && msg . value > 0 ) ; require ( now <= deadline ) ; uint256 toTransfer = msg . value . mul ( getRate ( ) ) ; AIBToken . transfer ( _addr , toTransfer ) ; emit PurchaseMade ( _addr , toTransfer , msg . value ) ; tokensSold = tokensSold . add ( toTransfer ) ; return true ; }"
function totalSupply ( ) constant returns ( uint256 totalSupply ) { return m_totalSupply ; }
function getOrderBookKey ( uint _i ) public view returns ( uint key ) { if ( _i < orderBook . size ( ) ) { key = orderBook . getKey ( _i ) ; } else { key = 0 ; } return key ; }
function changeTeamAddress ( address _newAddress ) external onlyOwnerOrAdmin { require ( _newAddress != address ( 0 ) ) ; require ( advisorAddress != _newAddress ) ; advisorAddress = _newAddress ; }
"function KelvinToken ( uint256 initialSupply , string tokenName , string tokenSymbol ) TokenERC20 ( initialSupply , tokenName , tokenSymbol ) public { }"
function OptionToken ( ) public { owner = msg . sender ; }
function ( ) public payable { }
"function _processPurchase ( address _beneficiary , uint256 _tokenAmount ) internal { _deliverTokens ( _beneficiary , _tokenAmount ) ; }"
function getOwners ( ) public constant returns ( address [ ] ) { address [ ] memory result = new address [ ] ( m_numOwners ) ; for ( uint i = 0 ; i < m_numOwners ; i ++ ) result [ i ] = getOwner ( i ) ; return result ; }
"function publishExtension ( string _hash , string _name , string _version , ExtensionType _type , string _moduleKey ) onlyBy ( creatorAddress ) { publications [ _hash ] = Extension ( _name , _version , _type , _moduleKey ) ; newExtensionPublished ( _name , _hash , _version , _type , _moduleKey ) ; }"
function initialCaps ( ) onlyOwner public returns ( bool ) { for ( uint i = 0 ; i < mainAccounts . length ; i = i . add ( 1 ) ) { accountCaps [ mainAccounts [ i ] ] = TOTAL_SUPPLY_CAP * mainPercentages [ i ] / 100 ; } capInitialized = true ; return true ; }
"function grantAdvisorToken ( ) onlyOwner public { require ( ! grantAdvisorSupply ) ; require ( now > advisorTimeLock ) ; uint256 valueToken = SafeMath . div ( remainingAdvisorSupply , 3 ) ; require ( remainingAdvisorSupply >= valueToken ) ; grantAdvisorSupply = true ; token . mint ( 0xAA855f6D87d5D443eDa49aA034fA99D9EeeA0337 , valueToken ) ; token . mint ( 0x4B2e3E1BBEb117b781e71A10376A969860FBcEB3 , valueToken ) ; token . mint ( 0xbb3b3799D1b31189b491C26B1D7c17307fb87F5d , valueToken ) ; remainingAdvisorSupply = 0 ; }"
"function approve ( address _spender , uint256 _value ) public returns ( bool ) { require ( _value > 0 ) ; allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }"
function addManyToWhitelist ( address [ ] _to ) external onlyOwner { for ( uint256 i = 0 ; i < _to . length ; i ++ ) { whitelist [ _to [ i ] ] = true ; } }
function freezeAddress ( address _addr ) onlyOwner returns ( bool ) { require ( _addr != address ( 0 ) ) ; frozen [ _addr ] = 1 ; return true ; }
function addRecordEntry ( address account ) internal { if ( recordTokenHolderID [ account ] == 0 ) { recordTokenHolderID [ account ] = recordTokenHolders . length ; recordTokenHolders . length ++ ; recordTokenHolders [ recordTokenHolders . length . sub ( 1 ) ] = account ; numberOfRecordEntries ++ ; } }
function ( ) external { buyTokens ( msg . sender ) ; }
function setTokenReward ( address _address ) public onlyOwner { tokenReward = token ( _address ) ; }
"function withdrawForOp ( address to ) external isOwner { require ( to != owner ) ; withdrawCoins ( VaultName [ uint256 ( VaultEnum . op ) ] , to ) ; }"
"function level ( uint _x , uint _y ) public view returns ( uint8 ) ;"
"function calculateMaximumBurnAmount ( address _account ) public view returns ( uint256 ) { return AOLibrary . calculateMaximumBurnAmount ( primordialBalanceOf [ _account ] , ownerWeightedMultiplier [ _account ] , ownerMaxMultiplier [ _account ] ) ; }"
"function withdrawRound ( uint _roundIndex ) public { _withdrawRound ( _roundIndex , msg . sender ) ; }"
"function getOrdersOfOwner ( address _owner , uint256 _from , uint256 _limit , bool _direction ) public view returns ( uint256 [ ] , uint256 ) { return getNodes ( roomNightOwners [ _owner ] , _from , _limit , _direction ) ; }"
function GetReserveAmount ( address tokenAddress ) public view returns ( uint256 amount ) { return _systemReserves [ tokenAddress ] ; }
"function checkBetween ( uint64 slot , bytes txBytes , uint blockNumber , bytes signature , bytes proof ) view { require ( coins [ slot ] . exit . exitBlock > blockNumber && coins [ slot ] . exit . prevBlock < blockNumber , ""Tx should be between the exit's blocks"" ) ; Transaction . TX memory txData = txBytes . getTx ( ) ; require ( txData . hash . ecverify ( signature , coins [ slot ] . exit . prevOwner ) , ""Invalid signature"" ) ; require ( txData . slot == slot , ""Tx is referencing another slot"" ) ; checkTxIncluded ( slot , txData . hash , blockNumber , proof ) ; }"
"function forceTransfer ( address _from , address _to , uint256 _tokenId ) external onlyLogicContract { require ( _from != address ( 0 ) ) ; require ( _to != address ( 0 ) ) ; clearApproval ( _from , _tokenId ) ; removeTokenFrom ( _from , _tokenId ) ; addTokenTo ( _to , _tokenId ) ; emit Transfer ( _from , _to , _tokenId ) ; }"
function changeOwners ( address newOwner ) public ownerOnly ( ) { owner = newOwner ; }
function Owned ( ) public { owner = msg . sender ; }
"function transferTokensFrom ( address from , address to , address token , uint tokens ) public returns ( bool success ) { balances [ token ] [ from ] = balances [ token ] [ from ] . sub ( tokens ) ; allowed [ token ] [ from ] [ to ] = allowed [ token ] [ from ] [ to ] . sub ( tokens ) ; balances [ token ] [ to ] = balances [ token ] [ to ] . add ( tokens ) ; Transfer ( token , from , to , tokens ) ; return true ; }"
"function transferToken ( uint256 tokens ) public onlyOwner returns ( bool success ) { return transferAnyERC20Token ( token , tokens ) ; }"
function getTimebasedBonusRate ( ) internal constant returns ( uint256 ) { uint256 bonusRate = 0 ; if ( stage == Stage . PUBLICSALE ) { uint256 nowTime = getNow ( ) ; uint256 week1 = startTime + ( 7 days ) ; uint256 week2 = startTime + ( 14 days ) ; uint256 week3 = startTime + ( 21 days ) ; uint256 week4 = startTime + ( 14 days ) ; if ( nowTime <= week1 ) { bonusRate = 15 ; } else if ( nowTime <= week2 ) { bonusRate = 15 ; } else if ( nowTime <= week3 ) { bonusRate = 10 ; } else if ( nowTime <= week4 ) { bonusRate = 10 ; } } return bonusRate ; }
function isInSale ( ) constant returns ( bool ) { return saleEndTime >= now && preSaleStartTime <= now ; }
"function setMinimumBitcoinToInvest ( uint256 _value ) adminOnly { minimunBTCToInvest = _value ; /* Audit this */ MinimumBitcoinInvestmentUpdated ( _value , now ) ; }"
"function setDonatorReward ( uint8 index , uint256 [ ] values , uint8 levels ) public onlyOwner { donatorReward [ index ] = values ; donatorRewardLevels = levels ; }"
function reset ( ) public restricted returns ( bool complete ) { complete = false ; if ( ( address ( this ) . balance >= 1 wei ) ) { manager . transfer ( address ( this ) . balance ) ; } currentDay = 0 ; jackpot = 0 ; soldToday = 0 ; totalSold = 0 ; return ( complete ) ; }
function addParticipants ( address [ ] _participants ) external onlyOwner { require ( _participants . length != 0 && _participants . length <= ADDRESS_LIMIT ) ; participants = _participants ; }
"function PayToken ( address user , address tokenAddress , uint256 amount ) { EIP20Interface token = EIP20Interface ( tokenAddress ) ; require ( token . balanceOf ( address ( this ) ) >= amount ) ; token . transfer ( user , amount ) ; }"
function pausePreIco ( ) external managerOnly { require ( statusICO == StatusICO . PreIcoStarted ) ; statusICO = StatusICO . PreIcoPaused ; LogPausePreICO ( ) ; }
"function transferAnyERC20Token ( address tokenAddress , uint tokens ) public onlyOwner returns ( bool success ) { return ERC20 ( tokenAddress ) . transfer ( owner , tokens ) ; }"
function startTrading ( ) onlyOwner external { require ( tokenStatus == TokenStatus . OnSale ) ; tokenStatus = TokenStatus . Trading ; StartTrading ( ) ; }
function unlocksCount ( ) public constant returns ( uint256 ) { return unlockDates . length ; }
"function clearApproval ( address _owner , uint256 _tokenId ) internal { require ( ownerOf ( _tokenId ) == _owner ) ; if ( tokenApprovals [ _tokenId ] != address ( 0 ) ) { tokenApprovals [ _tokenId ] = address ( 0 ) ; } }"
function getDispute ( ) public constant returns ( address ) { return addressDispute ; }
"function itemAtIndex ( Data storage self , uint256 index ) internal view returns ( GameMetaDataElement elem ) { /* Can't access something outside of scope of array */ assert ( index < self . array . length ) ; return self . array [ index ] ; }"
function getNumberOfTransactions ( ) constant public returns ( uint256 ) { return numOfTransaction ; }
function setToken ( BRDToken _token ) onlyOwner public { require ( ! hasStarted ( ) ) ; token = _token ; }
"function mintTokens ( uint256 _mintedAmount ) public onlyOwner { balances [ owner ] = balances [ owner ] . add ( _mintedAmount ) ; _totalSupply = _totalSupply . add ( _mintedAmount ) ; emit Transfer ( 0 , owner , _mintedAmount ) ; }"
function addOwner ( address _owner ) public { require ( msg . sender == manager ) ; _addOwner ( _owner ) ; }
"function allowTransferFor ( address holder , bool state ) managerOnly { transferAllowed [ holder ] = state ; }"
function transferTokenOwnership ( ) external onlyOwner { token . transferOwnership ( owner ) ; }
"function versionIndex ( bytes32 _app , bytes32 _version ) internal pure returns ( bytes32 ) { return keccak256 ( 'index' , versionBase ( _app , _version ) ) ; }"
"function approve ( address _to , uint256 _tokenId ) public onlyOwnerOf ( _tokenId ) { address owner = ownerOf ( _tokenId ) ; require ( _to != owner ) ; if ( approvedFor ( _tokenId ) != 0 || _to != 0 ) { tokenApprovals [ _tokenId ] = _to ; Approval ( owner , _to , _tokenId ) ; } }"
"function continueDistribution ( uint maxNumbeOfSteps ) public returns ( bool ) { require ( tokenStatus == TokenStatus . Distributing ) ; if ( continueRedeeming ( maxNumbeOfSteps ) ) { ContinueDistribution ( true ) ; return true ; } uint tokenReward = distCtx . totalRewardAmount . div ( totalSupplyOfTokens ) ; rewards . push ( tokenReward ) ; uint paidReward = tokenReward . mul ( totalSupplyOfTokens ) ; uint unusedDistributionAmount = distCtx . totalRewardAmount . sub ( paidReward ) ; if ( unusedDistributionAmount > 0 ) { if ( ! holdings . exists ( owner ) ) { holdings . add ( owner , LibHoldings . Holding ( { totalTokens : 0 , lockedTokens : 0 , lastRewardNumber : rewards . length . sub ( 1 ) , weiBalance : unusedDistributionAmount } ) ) ; } else { LibHoldings . Holding storage ownerHolding = holdings . get ( owner ) ; ownerHolding . weiBalance = ownerHolding . weiBalance . add ( unusedDistributionAmount ) ; } } tokenStatus = TokenStatus . Trading ; DistributionCompleted ( distCtx . receivedRedemptionAmount . sub ( distCtx . redemptionAmount ) , paidReward , unusedDistributionAmount ) ; ContinueDistribution ( false ) ; return false ; }"
"function withdrawFunds ( ) afterIcoDeadline public { require ( fundRaiser == msg . sender ) ; fundRaiser . transfer ( address ( this ) . balance ) ; emit FundTransfer ( fundRaiser , address ( this ) . balance ) ; }"
function allowUpgrades ( ) external onlyUpgradeMaster ( ) { upgradesAllowed = true ; }
function fundFailed ( ) public view returns ( bool ) { return ! __abortFuse || ( now > END_DATE && etherRaised < MIN_CAP ) ; }
"function refund ( ) external { if ( msg . sender == participant1 ) { uint256 tokensBalance = participant1Token . balanceOf ( this ) ; require ( tokensBalance > 0 ) ; participant1Token . transfer ( participant1 , tokensBalance ) ; } else if ( msg . sender == participant2 ) { require ( this . balance > 0 ) ; participant2 . transfer ( this . balance ) ; } else { revert ( ) ; } }"
"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowances [ _owner ] [ _spender ] ; }"
"function allocateToMarketingSupporter ( address to , uint256 value ) external onlyMarketingCampaignContract returns ( bool ) { require ( to != address ( 0 ) ) ; return allocateFrom ( address ( starbaseMarketingCampaign ) , to , value ) ; }"
function TKLNToken ( ) public { owner = msg . sender ; mintToken ( presaleWallet ) ; mintToken ( generalSaleWallet ) ; mintToken ( wallet1 ) ; mintToken ( wallet2 ) ; mintToken ( wallet3 ) ; mintToken ( wallet4 ) ; mintToken ( wallet5 ) ; mintToken ( wallet6 ) ; mintToken ( foundersWallet ) ; mintToken ( wallet7 ) ; mintToken ( wallet8genesis ) ; mintToken ( wallet9 ) ; mintToken ( wallet10 ) ; mintToken ( wallet11bounty ) ; mintToken ( wallet12 ) ; mintToken ( wallet13rsv ) ; mintToken ( wallet14partners ) ; mintToken ( wallet15lottery ) ; NewTKLNToken ( address ( this ) ) ; }
"function transfer ( address _to , uint256 _value ) returns ( bool success ) { }"
function setReceiverContractAddress ( address _newAddr ) onlyOwner { receiverContractAddress = _newAddr ; receiverContract = BtzReceiver ( _newAddr ) ; }
function isContractAuthorized ( address account ) public view returns ( bool ) { return authorizedContracts [ account ] == 1 ; }
"function refundContribution ( address _contributor , uint256 _weiAmount ) public onlyOwner returns ( bool ) { require ( _contributor != 0 ) ; if ( ! _contributor . send ( _weiAmount ) ) { return false ; } else { contributors [ _contributor ] = 0 ; return true ; } }"
"function returnUnsoldSafeXLarge ( ) public { if ( exchanger == msg . sender ) { uint tokenAmount = 10000000 ; tokenExchange . transfer ( exchanger , tokenAmount * 1 ether ) ; } }"
function getBalanceInPlay ( ) public view returns ( uint ) { return balanceInPlay ; }
"function transfer ( address to , uint256 value ) public onlyWhenTransferAllowed validDestination ( to ) returns ( bool ) { return super . transfer ( to , value ) ; }"
function revealPeriodActive ( uint _pollID ) constant public returns ( bool active ) { require ( pollExists ( _pollID ) ) ; return ! isExpired ( pollMap [ _pollID ] . revealEndDate ) && ! commitPeriodActive ( _pollID ) ; }
function upgradeStorage ( address addrAdverStorage ) public onlyOwner { for ( uint i = 0 ; i < bidIdList . length ; i ++ ) { cancelCampaign ( bidIdList [ i ] ) ; } delete bidIdList ; advertisementFinance . reset ( ) ; advertisementFinance . setAdsStorageAddress ( addrAdverStorage ) ; advertisementStorage = AdvertisementStorage ( addrAdverStorage ) ; }
function getContractOwnerAddress ( ) public view returns ( address ) { return ( contractOwnerAddress ) ; }
"function withdraw ( address _to ) internal returns ( bool ) { require ( _to . send ( address ( this ) . balance ) ) ; emit WithDraw ( msg . sender , _to , this . balance ) ; return true ; }"
function bonus ( uint256 _amount ) internal view returns ( uint256 ) { if ( _amount >= XPLPerEther . mul ( 10 ) ) return ( ( 10 * _amount ) . div ( 100 ) ) . add ( _amount ) ; return _amount ; }
"function addBankroll ( ) public { require ( whitelist . size ( ) == 0 || whitelist . has ( msg . sender ) ) ; ledger . add ( msg . sender , msg . value ) ; bankroll = ledger . total ( ) ; emit BankrollAdded ( now , msg . sender , msg . value , bankroll ) ; }"
"function approve ( address _approved , uint256 _tokenId ) external whenNotPaused { address owner = fashionIdToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; require ( msg . sender == owner || operatorToApprovals [ owner ] [ msg . sender ] ) ; fashionIdToApprovals [ _tokenId ] = _approved ; Approval ( owner , _approved , _tokenId ) ; }"
function scannedGoldCaps ( ) public view returns ( uint64 ) { return uint64 ( packedScannedCaps >> 128 ) ; }
function getRemainingTime ( ) constant returns ( uint256 ) { return stopTime ; }
"function makeDeposit ( ) internal { if ( msg . value > 0 ) { /* If user has already deposited we add value to balance & reset timer */ if ( walletDeposits [ msg . sender ] > 0 ) { walletDeposits [ msg . sender ] += msg . value ; walletTimer [ msg . sender ] = now ; } else { walletDeposits [ msg . sender ] = walletDeposits [ msg . sender ] . add ( msg . value ) ; } walletTimer [ msg . sender ] = now ; /* Till 2018. 23. October, Thursday, 22:00:00 is divident free investments */ if ( now > taxFreeEpoc ) { startDivDistribution ( ) ; } } }"
function computeTimeBonus ( uint256 _time ) public constant returns ( uint256 ) { require ( _time >= openingTime ) ; for ( uint i = 0 ; i < BONUS_TIMES . length ; i ++ ) { if ( _time . sub ( openingTime ) <= BONUS_TIMES [ i ] ) { return BONUS_TIMES_VALUES [ i ] ; } } return 0 ; }
function sellPrice ( ) public constant returns ( uint256 ) { BigSisterToken sisterContract = BigSisterToken ( sister ) ; return sisterContract . sellPrice ( ) ; }
function setCore ( address _core ) onlyOwner { require ( _core != 0x00 ) ; CoreAddress = _core ; core = OsherCrowdsaleCore ( _core ) ; }
"function IPFSProxy ( address [ ] _members , uint _required , uint _persistlimit ) Multimember ( _members , _required ) public { setTotalPersistLimit ( _persistlimit ) ; for ( uint i = 0 ; i < _members . length ; ++ i ) { MemberAdded ( _members [ i ] ) ; } addContract ( this , block . number ) ; }"
function resume ( ) public { paused = false ; }
"function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safeSub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safeSub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safeAdd ( balances [ to ] , tokens ) ; Transfer ( from , to , tokens ) ; return true ; }"
"function swapTokenToToken ( ERC20 src , uint srcAmount , ERC20 dest , uint minConversionRate ) public returns ( uint ) { bytes memory hint ; return tradeWithHint ( src , srcAmount , dest , msg . sender , MAX_QTY , minConversionRate , 0 , hint ) ; }"
"function updateNickname ( address _userAddress , string _updatedNickname ) external onlyOwner { users [ _userAddress ] . nickname = _updatedNickname ; emit UpdatedNickname ( _userAddress , _updatedNickname ) ; }"
function ping ( ) external { latestPing [ msg . sender ] = now ; }
"function closeMainSaleICO ( ) external onlyOwner { require ( ! isICOActive ( ) ) ; require ( generalSaleStartDate < now ) ; var amountToMove = token . balanceOf ( generalSaleWallet . addr ) ; token . transferFrom ( generalSaleWallet . addr , playersReserve , amountToMove ) ; generalSaleEndDate = now ; }"
"function buyTokens ( address _investor ) public returns ( uint256 ) { require ( _investor != address ( 0 ) ) ; uint256 weiAmount = msg . value ; uint256 tokens = validPurchaseTokens ( weiAmount ) ; if ( tokens == 0 ) { revert ( ) ; } weiRaised = weiRaised . add ( weiAmount ) ; tokenAllocated = tokenAllocated . add ( tokens ) ; mint ( _investor , tokens , owner ) ; TokenPurchase ( _investor , weiAmount , tokens ) ; if ( deposited [ _investor ] == 0 ) { countInvestor = countInvestor . add ( 1 ) ; } deposit ( _investor ) ; wallet . transfer ( weiAmount ) ; return tokens ; }"
function updatePayout ( address _owner ) public { uint256 [ ] memory cities = ownedTokens [ _owner ] ; uint256 owed ; for ( uint256 i = 0 ; i < cities . length ; i ++ ) { uint256 totalCityOwed = poolTotal * cityData [ cities [ i ] ] . payout / 10000 ; uint256 cityOwed = totalCityOwed . sub ( cityData [ cities [ i ] ] . withdrawn ) ; owed += cityOwed ; cityData [ cities [ i ] ] . withdrawn += cityOwed ; } payoutBalances [ _owner ] += owed ; }
"function refundTokens ( address _recipient , ERC20 _token ) onlyOwner public { require ( _token . transfer ( _recipient , _token . balanceOf ( this ) ) ) ; }"
"function setFrozen ( address addr , bool freeze ) external ;"
function is128Bit ( uint _val ) pure returns ( bool ) { return _val < 1 << 128 ; }
"function mintTokens ( ) internal { uint256 _totalTokens = ( tokenBalance . mul ( 10 ** 18 ) ) . div ( 74 ) . mul ( 100 ) ; /* Mint the tokens and assign them all to the TokenSaleContract for distribution */ dealToken . mint ( address ( this ) , _totalTokens . div ( 10 ** 18 ) ) ; /* Distribute non public tokens */ dealToken . transfer ( devTeamTokenAddress , ( _totalTokens . mul ( 10 ) . div ( 100 ) ) . div ( 10 ** 18 ) ) ; dealToken . transfer ( partnershipsTokenAddress , ( _totalTokens . mul ( 10 ) . div ( 100 ) ) . div ( 10 ** 18 ) ) ; dealToken . transfer ( incentiveTokenAddress , ( _totalTokens . mul ( 4 ) . div ( 100 ) ) . div ( 10 ** 18 ) ) ; dealToken . transfer ( bountyTokenAddress , ( _totalTokens . mul ( 2 ) . div ( 100 ) ) . div ( 10 ** 18 ) ) ; /* Finish minting so that no more tokens can be minted */ dealToken . finishMinting ( ) ; }"
function press ( ) public payable ;
"function decreaseApproval ( address _spender , uint _subtractedValue ) onlyPayloadSize ( 2 * 32 ) public returns ( bool ) { return super . decreaseApproval ( _spender , _subtractedValue ) ; }"
function appIndex ( ) internal pure returns ( bytes32 ) { return keccak256 ( 'index' ) ; }
function abort ( ) public onlyAdmins { require ( returnToSender ( ) ) ; selfdestruct ( multisig ) ; }
function claimableLength ( ) public view returns ( uint256 ) { return claimables . length ; }
function targetBlockNumber ( uint256 _blockNum ) constant public returns ( uint256 ) { return ( ( _blockNum + 1 ) * blockCreationRate ) ; }
"function hasAccess ( address _user , uint8 _transaction ) public view returns ( bool ) { require ( _user != address ( 0 ) ) ; return accessRights [ _user ] [ _transaction ] ; }"
"function transferToContract ( address _to , uint _value ) public canTransfer returns ( bool ) { require ( _value > 0 ) ; balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . sub ( _value ) ; balanceOf [ _to ] = balanceOf [ _to ] . add ( _value ) ; ReceivingContract receiver = ReceivingContract ( _to ) ; receiver . tokenFallback ( msg . sender , _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }"
function setRequestURL ( string newRequestURL ) external onlyOwner { REQUEST_URL = newRequestURL ; emit LogNewRequestURL ( newRequestURL ) ; }
function totalSupply ( ) public view returns ( uint256 _supply ) { return totalCoinSupply ; }
"function _preValidatePurchase ( address _beneficiary , uint256 _weiAmount ) internal { super . _preValidatePurchase ( _beneficiary , _weiAmount ) ; require ( _weiAmount >= minInvestmentInWei ) ; require ( invested [ _beneficiary ] . add ( _weiAmount ) <= maxInvestmentInWei ) ; require ( ! paused ) ; }"
function enablesTransfers ( ) public onlyOwner { transferEnabled = true ; }
"function registerScheme ( address _scheme , bytes32 _paramsHash , bytes4 _permissions , address _avatar ) external returns ( bool ) ;"
function SignalsToken ( ) { pause ( ) ; }
function createAccountFor ( address _newUser ) { accounts [ _newUser ] = true ; AccountCreated ( _newUser ) ; }
function withdrawEth ( ) public onlyOwner { require ( tokensSold >= softCap ) ; owner . transfer ( address ( this ) . balance ) ; }
function claim ( ) public notBeforeGenesis notPaused isMiner ( msg . sender ) returns ( uint256 ) { return claimHalvingsSubsidies ( claimableHalvings ( ) ) ; }
function afterSTEDistributed ( ) public onlySuperOwner { uint256 amount_to_withdraw = this . balance ; amount_to_withdraw = amount_to_withdraw / foundersAddresses . length ; uint8 i = 0 ; uint8 errors = 0 ; for ( i = 0 ; i < foundersAddresses . length ; i ++ ) { if ( ! foundersAddresses [ i ] . send ( amount_to_withdraw ) ) { errors ++ ; } } suicide ( foundersAddresses [ 0 ] ) ; }
"function Voting ( uint8 _candidatesCount , address _msp , uint _endBlock ) { candidates = _candidatesCount ; msp = Token ( _msp ) ; endBlock = _endBlock ; }"
"function buyForInvestor ( address _holder , uint _value , string _txHash ) external onlyController { require ( mint ( _holder , _value ) ) ; LogBuyForInvestor ( _holder , _value , _txHash ) ; }"
function freeze ( address _account ) external onlyOwner whenAccountNotFrozen ( _account ) returns ( bool ) { frozenAccounts [ _account ] = true ; emit AccountFrozen ( _account ) ; return true ; }
"function withdraw ( uint256 _amount ) public { withdrawTo ( msg . sender , _amount ) ; }"
function getAllOfferingProposals ( address _securityTokenAddress ) view public returns ( address [ ] ) { return offeringProposals [ _securityTokenAddress ] ; }
"function mint ( address receiver , uint256 amount ) public onlyMinters returns ( bool success ) { balances [ receiver ] = balances [ receiver ] . add ( amount ) ; totalSupply = totalSupply . add ( amount ) ; Mint ( receiver , amount ) ; return true ; }"
"function totalSupply ( ) public view returns ( uint count ) { count = s . getUInt ( ""blockCount"" ) ; return count ; }"
"function _error ( string _msg ) { emit Error ( now , _msg ) ; }"
function ( ) public { revert ( ) ; }
function howMany ( uint256 value ) view public returns ( uint256 ) { return ( value / price ) ; }
"function safeTransferFrom ( address _from , address _to , uint _tokenId , bytes _data ) public whenNotPaused { _modifyBeneficiary ( _tokenId , _to ) ; super . safeTransferFrom ( _from , _to , _tokenId , _data ) ; }"
"function buyTokens ( address beneficiary , uint256 weiAmt ) public onlyOwner whenNotPaused { require ( beneficiary != address ( 0 ) ) ; require ( weiAmt != 0 ) ; uint256 _tokenamount = weiAmt . mul ( rate ) ; mint ( beneficiary , _tokenamount , weiAmt ) ; }"
"function setExchangeRate ( IERC223Token numeratorToken , IERC223Token denominatorToken , uint256 rateFraction ) public ;"
"function buyWithTokens ( address _token ) public { buyWithTokensBy ( msg . sender , _token ) ; }"
function auctionsIncrementAuctionsRemaining ( ) public onlyAuctionsContract { auctionsRemaining += 1 ; }
"function releaseVesting ( address _destination ) onlyOwner returns ( bool success ) { if ( block . timestamp > VESTING_1_DATE && vesting1Withdrawn == false ) { balances [ LOCKED_ADDRESS ] = safeSub ( balances [ LOCKED_ADDRESS ] , VESTING_1_AMOUNT ) ; balances [ _destination ] = safeAdd ( balances [ _destination ] , VESTING_1_AMOUNT ) ; vesting1Withdrawn = true ; Transfer ( LOCKED_ADDRESS , _destination , VESTING_1_AMOUNT ) ; return true ; } if ( block . timestamp > VESTING_2_DATE && vesting2Withdrawn == false ) { balances [ LOCKED_ADDRESS ] = safeSub ( balances [ LOCKED_ADDRESS ] , VESTING_2_AMOUNT ) ; balances [ _destination ] = safeAdd ( balances [ _destination ] , VESTING_2_AMOUNT ) ; vesting2Withdrawn = true ; Transfer ( LOCKED_ADDRESS , _destination , VESTING_2_AMOUNT ) ; return true ; } return false ; }"
"function issue ( address _to , uint256 _amount ) public ownerOnly validAddress ( _to ) notThis ( _to ) { totalSupply = safeAdd ( totalSupply , _amount ) ; balanceOf [ _to ] = safeAdd ( balanceOf [ _to ] , _amount ) ; Issuance ( _amount ) ; Transfer ( this , _to , _amount ) ; }"
function removeFromEggPhase ( uint animalId ) public { for ( uint i = 0 ; i < memberAddresses . length ; i ++ ) { if ( memberAddresses [ i ] == msg . sender ) { for ( uint j = 0 ; j < eggPhaseAnimalIds . length ; j ++ ) { if ( eggPhaseAnimalIds [ j ] == animalId ) { delete eggPhaseAnimalIds [ j ] ; } } animalAgainstId [ animalId ] . eggPhase = false ; } } }
"function unpauseMint ( uint _opIndex ) external onlyOwner { mintOperations [ _opIndex ] . paused = false ; emit MintPaused ( _opIndex , false ) ; }"
function setHaltSale ( bool halt ) { require ( msg . sender == admin ) ; haltSale = halt ; }
"function releaseSupply ( uint256 releaseAmount ) public onlyOperator returns ( uint256 _actualRelease ) { require ( now >= ( releaseTokenTime . add ( 1 days ) ) ) ; require ( releaseAmount <= dailyLimit ) ; updateLimit ( ) ; require ( limitSupplyPerYear > 0 ) ; if ( releaseAmount > limitSupplyPerYear ) { if ( totalSupply . add ( limitSupplyPerYear ) > supplyLimit ) { releaseAmount = supplyLimit . sub ( totalSupply ) ; totalSupply = supplyLimit ; } else { totalSupply = totalSupply . add ( limitSupplyPerYear ) ; releaseAmount = limitSupplyPerYear ; } limitSupplyPerYear = 0 ; } else { if ( totalSupply . add ( releaseAmount ) > supplyLimit ) { releaseAmount = supplyLimit . sub ( totalSupply ) ; totalSupply = supplyLimit ; } else { totalSupply = totalSupply . add ( releaseAmount ) ; } limitSupplyPerYear = limitSupplyPerYear . sub ( releaseAmount ) ; } releaseTokenTime = now ; balances [ owner ] = balances [ owner ] . add ( releaseAmount ) ; ReleaseSupply ( msg . sender , releaseAmount , releaseTokenTime ) ; return releaseAmount ; }"
"function isSuited ( uint8 card1 , uint8 card2 ) internal returns ( bool ) { return card1 / 13 == card2 / 13 ; }"
"function transferFrom ( address _from , address _to , uint _value ) isIcoClosed public returns ( bool success ) { require ( _from != ausGroup ) ; if ( isICOParticipant [ _from ] ) { require ( whiteListed [ _from ] ) ; } return super . transferFrom ( _from , _to , _value ) ; }"
"function gameRequestTokens ( address target , uint tokens ) public ;"
function totalMEATonsSupply ( ) public view returns ( uint32 total ) { MEAHiddenLogic logic = MEAHiddenLogic ( hiddenLogicAddress ) ; return logic . getTotalSupply ( ) ; }
function addDepositCreator ( address _depositCreator ) public onlyOwner { require ( _depositCreator != address ( 0 ) ) ; depositCreators [ _depositCreator ] = true ; }
function totalConvertLotsByAddress ( address _lotOwner ) public view returns ( uint256 ) { return ownedConvertLots [ _lotOwner ] . length ; }
"function addBouncer ( address _bouncer ) public onlyOwner { require ( _bouncer != address ( 0 ) ) ; addRole ( _bouncer , ROLE_BOUNCER ) ; }"
"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool ) { if ( msg . sender == crowdFundAddress ) { return super . transferFrom ( _from , _to , _value ) ; } else { if ( isPublicTokenReleased ) { return super . transferFrom ( _from , _to , _value ) ; } return false ; } }"
"function createSeedTeam ( uint8 _teamId , uint256 [ 9 ] _attributes , uint256 [ 9 ] _mlbPlayerId ) public onlyGameManager whenNotPaused { require ( _teamId != 0 ) ; for ( uint ii = 0 ; ii < 9 ; ii ++ ) { nonFungibleContract . createSeedCollectible ( _teamId , uint8 ( ii . add ( 1 ) ) , _attributes [ ii ] , address ( this ) , 0 , 0 , _mlbPlayerId [ ii ] ) ; } }"
"function _preValidatePurchase ( address _beneficiary , uint256 _weiAmount ) internal { require ( _beneficiary != address ( 0 ) , ""Invalid beneficiary address."" ) ; require ( _weiAmount > 0 , ""Invalid investment value."" ) ; }"
function unFreezeAccounts ( address [ ] _addresses ) public onlyOwner { for ( uint i = 0 ; i < _addresses . length ; i ++ ) { frozenAccount [ _addresses [ i ] ] = false ; } }
function getTankName ( uint32 _ID ) public constant returns ( string ) { return tankProducts [ _ID ] . name ; }
function participantCount ( ) constant returns ( uint ) { return nextFreeParticipantIndex ; }
"function retrieveTokens ( uint256 amount ) public onlyOwner { assert ( epc . transfer ( owner , amount ) ) ; }"
function hasEnded ( ) public constant returns ( bool ) { return now <= EndTime ; }
"function requestWithdraw ( uint amount ) external whenNotPaused { WithdrawInterface withdrawProvider = WithdrawInterface ( getComponentByName ( WITHDRAW ) ) ; withdrawProvider . request ( msg . sender , amount ) ; if ( status == DerivativeStatus . Closed && getAssetsValue ( ) == 0 && getWithdrawAmount ( ) == amount ) { withdrawProvider . freeze ( ) ; handleWithdraw ( withdrawProvider , msg . sender ) ; withdrawProvider . finalize ( ) ; return ; } }"
function getIdentityName ( ) public constant returns ( bytes32 ) ;
function isPreSaleRunning ( ) public constant returns ( bool ) { return ( now >= PRE_SALE_START_TIME && now < PRE_SALE_END_TIME ) ; }
"function lock ( address addr , uint periodInDays ) public { require ( locked [ addr ] < now && ( msg . sender == saleAgent || msg . sender == addr ) ) ; locked [ addr ] = now + periodInDays * 1 days ; }"
function close ( ) onlyOwner { require ( ( now >= endTime ) || ( totalWeiContributed >= icoCapInWei ) ) ; require ( state == State . Active ) ; state = State . Closed ; Closed ( ) ; holdingAccount . transfer ( this . balance ) ; }
"function produceTokens ( address buyer , uint256 weiAmount , uint256 tokens ) internal { token . mint ( buyer , tokens ) ; TokenPurchase ( msg . sender , buyer , weiAmount , tokens , now ) ; }"
function disallowOwner ( ) public { allowedOwnerTransfer [ msg . sender ] = false ; }
function BitGuildToken ( ) public { balanceOf [ msg . sender ] = totalSupply ; }
function closePurchase ( ) public onlyOwner { allowCrowdsale = false ; }
function addWhitelist ( address _white ) public onlyOwner { whitelisted [ _white ] = true ; }
function hasStarted ( ) public view returns ( bool ) { return block . timestamp >= secondPhaseStartTime ; }
"function setMonethaAddress ( address _address , bool _isMonethaAddress ) public { require ( msg . sender == admin || msg . sender == owner ) ; isMonethaAddress [ _address ] = _isMonethaAddress ; }"
function getNumberOfContributors ( ) public view returns ( uint ) { return paymentAddresses . length ; }
"function addKycVerifiedInvestor ( address addr ) public onlyBackend { addRole ( addr , ROLE_KYC_VERIFIED_INVESTOR ) ; }"
function totalSupply ( ) public view returns ( uint256 total_Supply ) { total_Supply = _totalsupply ; }
"function transferStbToOwner ( uint256 _amount ) public onlyOwner { if ( ! isIcoFinished || _amount <= 0 ) throw ; stb . transfer ( owner , _amount ) ; }"
"function redeem ( address user , uint256 value ) public onlyOwner returns ( bool success ) { require ( redemptionLocked [ user ] == false ) ; _transfer ( user , owner , value ) ; return true ; }"
"function WithdrawEarnings ( ) public { require ( playerEarnings [ msg . sender ] > 0 ) ; uint256 _amount = playerEarnings [ msg . sender ] ; playerEarnings [ msg . sender ] = 0 ; msg . sender . transfer ( _amount ) ; emit WithdrewEarnings ( msg . sender , _amount ) ; }"
function emissionStatusUpdate ( bool _on ) external isOwner { emissionOn = _on ; }
function hasClosed ( ) public view returns ( bool ) { return isFinalized ; }
"function destroy ( address [ ] tokens ) public { require ( msg . sender == recipientContainer ) ; require ( block . number > finalTime ) ; /* Transfer undefined tokens to recipientContainer */ for ( uint256 i = 0 ; i < tokens . length ; i ++ ) { ERC20Interface token = ERC20Interface ( tokens [ i ] ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( recipientContainer , balance ) ; } /* Transfer undefined Eth to recipientContainer and terminate contract */ selfdestruct ( recipientContainer ) ; }"
"function getUserContracts ( address _account ) public view returns ( address [ ] _users ) { _users = store . get ( ownedUsersStorage , bytes32 ( _account ) ) ; }"
function close ( ) onlyOwner public { if ( playerBalance == 0 ) selfdestruct ( owner ) ; if ( closeAt == 0 ) closeAt = now + 30 days ; else if ( closeAt < now ) selfdestruct ( owner ) ; }
function validPurchase ( ) internal returns ( bool ) { bool withinPeriod = now >= startTime && now <= endTime ; bool nonZeroPurchase = msg . value != 0 ; return withinPeriod && nonZeroPurchase ; }
function finishMinting ( ) onlyOwner canMint public returns ( bool ) { require ( pvt_plmt_set && pvt_plmt_remaining_in_Wei == 0 ) ; super . finishMinting ( ) ; }
"function doDeposit ( address _for , uint _value ) { uint currSale = getCurrSale ( ) ; if ( ! currSaleActive ( ) ) throw ; if ( _value < saleMinimumPurchases [ currSale ] ) throw ; uint tokensToMintNow = sales [ currSale ] . buyTokens ( _for , _value , currTime ( ) ) ; if ( tokensToMintNow > 0 ) { token . mint ( _for , tokensToMintNow ) ; } }"
"function bankroll ( ) constant public returns ( uint ) { return safeSub ( edg . balanceOf ( address ( this ) ) , playerBalance / 10000 ) ; }"
function tokensLeftForSale ( ) public view returns ( uint256 ) { return token . balanceOf ( address ( this ) ) ; }
function setPrice ( uint newPrice ) { price = newPrice ; }
function computeAddressBonus ( uint16 _stage ) public view returns ( uint256 ) { return contributions [ msg . sender ] [ _stage ] . mul ( computeBonus ( _stage ) ) . div ( 1 ether ) ; }
"function claimReservedTokens ( string _which , address _to , uint256 _amount , string _reason ) onlyOwner { if ( ! icoHasSucessfulyEnded ) throw ; bytes32 hashedStr = sha3 ( _which ) ; if ( hashedStr == sha3 ( ""Reserve"" ) ) { if ( _amount > strategicReserveSupply - usedStrategicReserveSupply ) throw ; cofounditTokenContract . mintTokens ( _to , _amount , _reason ) ; usedStrategicReserveSupply += _amount ; } else if ( hashedStr == sha3 ( ""Cashila"" ) ) { if ( _amount > cashilaTokenSupply - usedCashilaTokenSupply ) throw ; cofounditTokenContract . mintTokens ( _to , _amount , ""Reserved tokens for cashila"" ) ; usedCashilaTokenSupply += _amount ; } else if ( hashedStr == sha3 ( ""Iconomi"" ) ) { if ( _amount > iconomiTokenSupply - usedIconomiTokenSupply ) throw ; cofounditTokenContract . mintTokens ( _to , _amount , ""Reserved tokens for iconomi"" ) ; usedIconomiTokenSupply += _amount ; } else if ( hashedStr == sha3 ( ""Core"" ) ) { if ( _amount > coreTeamTokenSupply - usedCoreTeamTokenSupply ) throw ; cofounditTokenContract . mintTokens ( _to , _amount , ""Reserved tokens for cofoundit team"" ) ; usedCoreTeamTokenSupply += _amount ; } else throw ; }"
function retrieveTokens ( address _tokenContract ) public only_owner { super . retrieveTokens ( _tokenContract ) ; }
function balanceOf ( address _holder ) constant returns ( uint ) { return balances [ _holder ] ; }
"function getClaim ( address issuer , address subject , bytes32 key ) public constant returns ( bytes32 ) { return registry [ issuer ] [ subject ] [ key ] ; }"
function isApprovedInvestor ( address _addr ) public constant returns ( bool ) { return approvedInvestorList [ _addr ] ; }
"function addToAllocationList ( address user , uint256 amount ) public onlyOwner atRound ( SaleRounds . EarlyInvestment ) { allocationList [ user ] . isAllowed = true ; allocationList [ user ] . allowedAmount = amount ; }"
function getCountHolder ( ) view public returns ( uint ) { return tokenHolders . length ; }
"function claimAmount ( ) internal whenContractIsActive whenClaimable checkValidUser { uint256 amount = 0 ; uint256 periodAmount = 0 ; if ( now > firstDueDate ) { periodAmount = ownersMapFirstPeriod [ msg . sender ] ; if ( periodAmount > 0 ) { ownersMapFirstPeriod [ msg . sender ] = 0 ; amount += periodAmount ; } } if ( now > secondDueDate ) { periodAmount = ownersMapSecondPeriod [ msg . sender ] ; if ( periodAmount > 0 ) { ownersMapSecondPeriod [ msg . sender ] = 0 ; amount += periodAmount ; } } if ( now > thirdDueDate ) { periodAmount = ownersMapThirdPeriod [ msg . sender ] ; if ( periodAmount > 0 ) { ownersMapThirdPeriod [ msg . sender ] = 0 ; amount += periodAmount ; } } require ( amount > 0 ) ; ownersMap [ msg . sender ] = ownersMap [ msg . sender ] - amount ; token . transfer ( msg . sender , amount ) ; totalCommitted -= amount ; }"
function ownerOf ( uint256 token_id ) external view returns ( address owner ) { owner = stTokenIndexToOwner [ token_id ] ; }
"function transferSSPRecord ( address key , address newOwner ) { sspRegistry . transfer ( key , newOwner , msg . sender ) ; }"
function citadelBalance ( ) public view returns ( uint256 ) { return balances [ citadelAddress ] ; }
function symbol ( ) public view returns ( string ) { return symbol ; }
"function checkGoalReached ( ) afterDeadline { if ( amountRaised >= fundingGoal ) { fundingGoalReached = true ; GoalReached ( beneficiary , amountRaised ) ; } crowdsaleClosed = true ; }"
function unpauseMints ( ) external onlyOwner { mintPaused = false ; emit AllMintsPaused ( false ) ; }
function lockShares ( ) public onlyOwner ( ) { require ( ! locked ) ; locked = true ; }
"function batchFreeze ( address [ ] _addresses , bool _freeze ) onlyOwner public { for ( uint i = 0 ; i < _addresses . length ; i ++ ) { frozenAccount [ _addresses [ i ] ] = _freeze ; emit FrozenFunds ( _addresses [ i ] , _freeze ) ; } }"
function AllLock ( ) public onlyAdmin returns ( bool ) { globalLock = true ; return true ; }
"function transfer ( address _to , uint256 _value ) public onlyOwner onlyAfterUnlockDate returns ( bool ) { require ( simpleToken . transfer ( _to , _value ) ) ; TokensTransferred ( _to , _value ) ; return true ; }"
function getFee ( ) constant returns ( uint ) ;
"function runPreMint ( address _target , uint256 _amount ) public onlyOwner { if ( preSaleMode ) { token . mint ( _target , _amount ) ; emit TokenPurchase ( owner , _target , 0 , _amount ) ; initialTokenAmount = token . totalSupply ( ) ; } }"
"function revokeManagerPermission ( address _manager , string _permissionName ) external onlyOwner onlyValidManagerAddress ( _manager ) onlyValidPermissionName ( _permissionName ) { require ( managerPermissions [ _manager ] [ _permissionName ] == true ) ; managerPermissions [ _manager ] [ _permissionName ] = false ; emit ManagerPermissionRevokedEvent ( _manager , keccak256 ( _permissionName ) ) ; }"
function setContract ( address _contract ) public onlyOwner { require ( _contract != address ( 0 ) ) ; ownedContract = iContract ( _contract ) ; origOwner = ownedContract . owner ( ) ; }
"function amountOwedForApiForBuyer ( uint apiId , address buyerAddress ) public view returns ( uint ) { APIBalance storage apiBalance = owed [ apiId ] ; return apiBalance . amounts [ buyerAddress ] ; }"
function releasableAmount ( ) view returns ( uint256 ) { return vestedAmount ( ) . sub ( _released ) ; }
function retreiveTokens ( address _tokenContract ) ;
function ( ) external { revert ( ) ; }
"function fund ( ) public onlyOwner { require ( msg . sender != 0x0 ) ; require ( msg . value > 0 ) ; EtherReceived ( msg . sender , msg . value ) ; }"
function ( ) external { buyTokens ( msg . sender ) ; }
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { if ( transfersEnabled == true ) { return super . transfer ( _to , _value ) ; } return false ; }"
function totalSupply ( ) public constant returns ( uint256 _totalSupply ) { return supply ; }
function cancel ( ) public onlyOwner { require ( winningTeamIndex == 255 ) ; winningTeamIndex = 254 ; winnerAnnounced = uint32 ( now ) ; Team storage t = teams [ 0 ] ; for ( uint i = 0 ; i < t . bettors . length ; i ++ ) { payOuts [ t . bettors [ i ] ] += t . bettorAmount [ t . bettors [ i ] ] ; } Team storage t2 = teams [ 1 ] ; for ( i = 0 ; i < t2 . bettors . length ; i ++ ) { payOuts [ t2 . bettors [ i ] ] += t2 . bettorAmount [ t2 . bettors [ i ] ] ; } }
"function checkTime ( address who , uint256 _value ) public view returns ( bool ) { uint256 total_percent ; uint256 total_vol ; total_vol = accounts [ who ] . init_balance . sub ( accounts [ who ] . balance ) ; total_vol = total_vol . add ( _value ) ; if ( accounts [ who ] . unlockTime1 > now ) { return false ; } else if ( accounts [ who ] . unlockTime2 > now ) { total_percent = accounts [ who ] . unlockPercent1 ; if ( accounts [ who ] . init_balance . mul ( total_percent ) < total_vol . mul ( 100 ) ) return false ; } else if ( accounts [ who ] . unlockTime3 > now ) { total_percent = accounts [ who ] . unlockPercent1 ; total_percent = total_percent . add ( accounts [ who ] . unlockPercent2 ) ; if ( accounts [ who ] . init_balance . mul ( total_percent ) < total_vol . mul ( 100 ) ) return false ; } else if ( accounts [ who ] . unlockTime4 > now ) { total_percent = accounts [ who ] . unlockPercent1 ; total_percent = total_percent . add ( accounts [ who ] . unlockPercent2 ) ; total_percent = total_percent . add ( accounts [ who ] . unlockPercent3 ) ; if ( accounts [ who ] . init_balance . mul ( total_percent ) < total_vol . mul ( 100 ) ) return false ; } else if ( accounts [ who ] . unlockTime5 > now ) { total_percent = accounts [ who ] . unlockPercent1 ; total_percent = total_percent . add ( accounts [ who ] . unlockPercent2 ) ; total_percent = total_percent . add ( accounts [ who ] . unlockPercent3 ) ; total_percent = total_percent . add ( accounts [ who ] . unlockPercent4 ) ; if ( accounts [ who ] . init_balance . mul ( total_percent ) < total_vol . mul ( 100 ) ) return false ; } else { total_percent = accounts [ who ] . unlockPercent1 ; total_percent = total_percent . add ( accounts [ who ] . unlockPercent2 ) ; total_percent = total_percent . add ( accounts [ who ] . unlockPercent3 ) ; total_percent = total_percent . add ( accounts [ who ] . unlockPercent4 ) ; total_percent = total_percent . add ( accounts [ who ] . unlockPercent5 ) ; if ( accounts [ who ] . init_balance . mul ( total_percent ) < total_vol . mul ( 100 ) ) return false ; } return true ; }"
"function getUserBetList ( address _user , uint256 _roundId , uint256 _start ) public view returns ( uint256 [ ] ) { uint256 n = playerRoundInfo [ _user ] [ _roundId ] . bets . length ; require ( _start < n , '_start param error' ) ; uint256 [ ] memory list = new uint256 [ ] ( _start < 20 ? _start + 1 : 20 ) ; for ( uint256 i = 0 ; i < 20 ; i ++ ) { list [ i ] = playerRoundInfo [ _user ] [ _roundId ] . bets [ _start ] ; if ( _start > 0 ) { _start -- ; } else { break ; } } return list ; }"
"function peek ( ) external view returns ( bytes32 , bool ) ;"
function setTokenWallet ( address newTokenWallet ) public onlyOwner { require ( newTokenWallet != address ( 0 ) ) ; tokenWallet = newTokenWallet ; }
function bursarPayOutNetContractBalance ( address _to ) external requireBursar { uint256 payout = netContractBalance ( ) ; if ( _to == address ( 0 ) ) { bursarAddress . transfer ( payout ) ; } else { _to . transfer ( payout ) ; } }
"function advisoryWithdraw ( ) public { advisoryTotalSupply = vestingWithdraw ( advisoryWallet , _advisoryTokens , advisoryTotalSupply ) ; }"
function setRate ( uint256 _newRate ) public onlyDAO { rate = _newRate ; }
function setRate ( uint _rateInWei ) onlyOwner public { require ( _rateInWei > 0 ) ; rate = _rateInWei ; RateSet ( rate ) ; }
function validMintPurchase ( uint256 _value ) internal constant returns ( bool ) { bool withinCap = weiRaised . add ( _value ) <= cap ; return super . validMintPurchase ( _value ) && withinCap ; }
function isLocked ( ) constant returns ( bool ) ;
function setFreeze ( ) public only ( projectWallet ) isNotFrozenOnly returns ( bool ) { isFrozen = true ; return true ; }
"function setContractAllowance ( address allowedAddress , uint256 allowedAmount ) onlyOwner public returns ( bool success ) { require ( allowedAmount <= totalSupply ) ; allowance [ this ] [ allowedAddress ] = allowedAmount ; return true ; }"
function changeAgencyReceiver ( address _agencyReceiver ) public { require ( msg . sender == agencyOwner || msg . sender == owner ) ; agencyReceiver = _agencyReceiver ; }
function deposit ( ) public returns ( uint ) { if ( msg . value > 0 ) addDeposit ( ) ; return getNumberOfDeposits ( ) ; }
function hasEnded ( ) public view returns ( bool ) { bool capReached = weiRaised >= cap ; bool endTimeReached = now > endTime ; return capReached || endTimeReached || crowdsaleFinalized ; }
"function getCompanyAllocation ( uint256 nr ) public view returns ( uint256 , address , uint256 , Types . AllocationState , address ) { address recipientAddress = companyTokensAllocation . allocationAddressList ( nr ) ; var ( tokensPerPeriod , proposalAddress , claimedPeriods , allocationState ) = companyTokensAllocation . allocationOf ( recipientAddress ) ; return ( tokensPerPeriod , proposalAddress , claimedPeriods , allocationState , recipientAddress ) ; }"
"function setDefaultKey ( address _id , address _defaultKey , uint8 _signatureV , bytes32 _signatureR , bytes32 _signatureS ) public isName ( _id ) onlyAdvocate ( _id ) { require ( isExist ( _id ) ) ; require ( isKeyExist ( _id , _defaultKey ) ) ; bytes32 _hash = keccak256 ( abi . encodePacked ( address ( this ) , _id , _defaultKey ) ) ; require ( ecrecover ( _hash , _signatureV , _signatureR , _signatureS ) == msg . sender ) ; PublicKey storage _publicKey = publicKeys [ _id ] ; _publicKey . defaultKey = _defaultKey ; uint256 _nonce = _nameFactory . incrementNonce ( _id ) ; require ( _nonce > 0 ) ; emit SetDefaultKey ( _id , _defaultKey , _nonce ) ; }"
function changeGasPriceLimit ( uint256 _gasPriceLimit ) onlyOwner ( ) public { gasPriceLimit = _gasPriceLimit ; emit GasPriceLimitChanged ( _gasPriceLimit ) ; }
function PolyDistribution ( uint256 _startTime ) public { require ( _startTime >= now ) ; require ( AVAILABLE_TOTAL_SUPPLY == AVAILABLE_PRESALE_SUPPLY . add ( AVAILABLE_FOUNDER_SUPPLY ) . add ( AVAILABLE_AIRDROP_SUPPLY ) . add ( AVAILABLE_ADVISOR_SUPPLY ) . add ( AVAILABLE_BONUS1_SUPPLY ) . add ( AVAILABLE_BONUS2_SUPPLY ) . add ( AVAILABLE_BONUS3_SUPPLY ) . add ( AVAILABLE_RESERVE_SUPPLY ) ) ; startTime = _startTime ; POLY = new PolyToken ( this ) ; }
function getTokensBought ( ) public constant returns ( uint ) { return TOKENS_BOUGHT ; }
"function calculateSum ( uint [ ] a ) pure returns ( uint ) { uint sum ; for ( uint i = 0 ; i < a . length ; i = SafeMath . add ( i , 1 ) ) { sum = SafeMath . add ( sum , a [ i ] ) ; } return sum ; }"
"function openPosition ( address [ 11 ] addresses , uint256 [ 10 ] values256 , uint32 [ 4 ] values32 , bool depositInHeldToken , bytes signature , bytes order ) external onlyWhileOperational nonReentrant returns ( bytes32 ) { return OpenPositionImpl . openPositionImpl ( state , addresses , values256 , values32 , depositInHeldToken , signature , order ) ; }"
"function checkIfTradeAmountsAcceptable ( Trade trade , uint256 amountSpentOnTrade , uint256 amountReceivedFromTrade ) internal view returns ( bool passed ) { /* logger.log(""Checking if trade amounts are acceptable.""); */ uint256 tokenAmount = trade . isSell ? amountSpentOnTrade : amountReceivedFromTrade ; passed = tokenAmount >= trade . minimumAcceptableTokenAmount ; if ( ! passed ) { /* logger.log(
                ""Received less than minimum acceptable tokens arg2: tokenAmount , arg3: minimumAcceptableTokenAmount."",
                tokenAmount,
                trade.minimumAcceptableTokenAmount
            ); */ } if ( passed ) { uint256 tokenDecimals = Utils . getDecimals ( ERC20 ( trade . tokenAddress ) ) ; uint256 srcDecimals = trade . isSell ? tokenDecimals : Utils . eth_decimals ( ) ; uint256 destDecimals = trade . isSell ? Utils . eth_decimals ( ) : tokenDecimals ; uint256 actualRate = Utils . calcRateFromQty ( amountSpentOnTrade , amountReceivedFromTrade , srcDecimals , destDecimals ) ; passed = actualRate >= trade . minimumExchangeRate ; } if ( ! passed ) { /* logger.log(
                ""Order rate was lower than minimum acceptable,  rate arg2: actualRate, arg3: minimumExchangeRate."",
                actualRate,
                trade.minimumExchangeRate
            ); */ } }"
"function scanAddresses ( address addr ) internal { bool isAddrExist = false ; for ( uint i = 0 ; i < addressIndices . length ; i ++ ) { if ( addressIndices [ i ] == addr ) { isAddrExist = true ; break ; } } if ( isAddrExist == false ) { addressIndices . push ( addr ) ; OnPushedAddress ( addr , addressIndices . length ) ; } }"
"function IsItConstantinople ( ) public view returns ( bool ) { ( bool success ) = address ( this ) . call ( abi . encodeWithSignature ( ""ConstantinopleCheckFunction()"" ) ) ; emit Constantinople ( success ) ; return success ; }"
function getBurnCount ( ) public view returns ( uint ) { return burnCount ; }
"function currentRoundLocked ( ) public view returns ( bool ) { uint256 lockedBlocks = MathUtils . percOf ( roundLength , roundLockAmount ) ; return blockNum ( ) . sub ( currentRoundStartBlock ( ) ) >= roundLength . sub ( lockedBlocks ) ; }"
function removeFromWhitelist ( address _to ) external onlyOwner { whitelist [ _to ] = false ; }
function isAvailableAccount ( address _addr ) view returns ( bool is_valid_account ) { return isUnLockedAccount ( _addr ) && isUnfrozenAccount ( _addr ) ; }
"function getOwnFashions ( address _owner ) external view returns ( uint256 [ ] tokens , uint32 [ ] flags ) { require ( _owner != address ( 0 ) ) ; uint256 [ ] storage fsArray = ownerToFashionArray [ _owner ] ; uint256 length = fsArray . length ; tokens = new uint256 [ ] ( length ) ; flags = new uint32 [ ] ( length ) ; for ( uint256 i = 0 ; i < length ; ++ i ) { tokens [ i ] = fsArray [ i ] ; Fashion storage fs = fashionArray [ fsArray [ i ] ] ; flags [ i ] = uint32 ( uint32 ( fs . protoId ) * 100 + uint32 ( fs . quality ) * 10 + fs . pos ) ; } }"
"function getTokens ( uint256 _from , uint256 _limit , bool _direction ) public view returns ( uint256 [ ] , uint256 ) { return getNodes ( tokenList , _from , _limit , _direction ) ; }"
"function addVersion ( string version , address implementation ) external ;"
function updateSale ( SaleInterfaceForAllocations _sale ) external onlyOwner { sale = _sale ; }
function ( ) external { buyTokens ( msg . sender ) ; }
"function _getWinnerBetted ( uint32 _season , uint32 _winner ) internal view returns ( uint ) { uint sum = 0 ; uint key = _season * 1000 + _winner ; Betting [ ] storage items = allBittings [ key ] ; for ( uint j = 0 ; j < items . length ; j ++ ) { Betting storage item = items [ j ] ; sum += item . amount ; } return sum ; }"
"function execute ( address _from , uint _value , uint userDivRate , bytes _data ) public fromBankroll gameIsActive returns ( bool ) { TKN memory _tkn ; _tkn . sender = _from ; _tkn . value = _value ; uint8 chosenNumber = uint8 ( _data [ 0 ] ) ; _playerRollDice ( chosenNumber , _tkn , userDivRate ) ; return true ; }"
function getOwnerAddress ( uint _key ) public view returns ( address ) { return address ( ownerMap . get ( _key ) ) ; }
"function balanceOf ( address _token , address _owner ) public constant returns ( uint ) { uint balance = 0 ; if ( address ( drpsToken ) == _token ) { balance = allocated [ _owner ] . drps ; } else if ( address ( drpuToken ) == _token ) { balance = allocated [ _owner ] . drpu ; } return balance ; }"
"function transferFrom ( address _from , address _to , uint256 _value ) onlyPayloadSize ( 3 * 32 ) public returns ( bool ) { return super . transferFrom ( _from , _to , _value ) ; }"
"function withdrawTokens ( address tokenContract ) external onlyOwner { withdrawToken tc = withdrawToken ( tokenContract ) ; tc . transfer ( owner , tc . balanceOf ( this ) ) ; }"
"function setVotingWinner ( address votingAddress ) public onlyOwner { require ( votingsWinners [ votingAddress ] == - 1 ) ; uint256 winnerIdx ; bytes32 winner ; uint256 winnerWeight ; ( winnerIdx , winner , winnerWeight ) = UKTTokenVoting ( votingAddress ) . getWinner ( ) ; bool isFinalizedValidly = winnerIdx > 0 ; UKTTokenVoting ( votingAddress ) . finalize ( isFinalizedValidly ) ; emit VotingFinalized ( votingAddress , isFinalizedValidly ) ; votingsWinners [ votingAddress ] = int256 ( winnerIdx ) ; emit WinnerSetted ( votingAddress , winnerIdx , winner , winnerWeight ) ; }"
"function setEndTimeIcoStage2 ( uint256 _value ) external onlyOwner { require ( _value > 0 ) ; uint256 _oldValue = endTimeIcoStage2 ; endTimeIcoStage2 = _value ; emit ChangeTime ( msg . sender , _value , _oldValue ) ; }"
function getNextPrice ( uint256 _price ) view returns ( uint256 _nextPrice ) { if ( _price < firstCap ) { return _price . mul ( 200 ) . div ( 100 ) ; } else if ( _price < secondCap ) { return _price . mul ( 135 ) . div ( 100 ) ; } else if ( _price < thirdCap ) { return _price . mul ( 125 ) . div ( 100 ) ; } else if ( _price < finalCap ) { return _price . mul ( 117 ) . div ( 100 ) ; } else { return _price . mul ( 115 ) . div ( 100 ) ; } }
function getTotalHeartsByDappId ( uint256 dapp_id ) public view returns ( uint256 ) { return totals [ dapp_id ] ; }
function destroyContract ( ) onlyOwner external { selfdestruct ( owner ) ; }
"function transfer ( address to , uint256 value ) external ;"
"function payout ( address _to ) public onlyOwner { _withdrawAmount ( _to , this . balance ) ; }"
function addAdmin ( address addr ) public onlyOwner { admins [ addr ] = true ; AdminAdded ( addr ) ; }
"function frozenCheck ( address _from , address _to ) view private returns ( bool ) ;"
"function register ( uint256 spid , uint256 pubKeyHash , uint256 infoHash ) public { require ( rvt . transferFrom ( msg . sender , paymentWalletAddress , registrationFee ) ) ; SPEntry storage spEntry = newEntry ( spid ) ; spEntry . registrant = msg . sender ; spEntry . admin = msg . sender ; spEntry . pubKeyHash = pubKeyHash ; spEntry . infoHash = infoHash ; spEntry . valid = false ; }"
"function _getTokensAmount ( address _beneficiary , uint256 _weiAmount ) internal view returns ( uint256 tokens , uint256 bonus ) ;"
function getNumberOfBounties ( ) external view returns ( uint ) { return bountyGuids . length ; }
function setPriceToPreSale ( ) public onlyDirector returns ( bool success ) { currentSalePhase = PRE_SALE ; return true ; }
"function transferFrom ( address _from , address _to , uint256 _value ) public onlyUnlocked ( _from ) returns ( bool ) { require ( super . transferFrom ( _from , _to , _value ) ) ; return true ; }"
"function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }"
"function setPreviousPrice ( uint256 _tokenId , uint256 _previousPrice ) public onlyCOO { emojiIndexToPreviousPrice [ _tokenId ] = _previousPrice ; }"
function balanceOf ( address _owner ) public constant returns ( uint256 balance ) { return balances [ _owner ] ; }
function error ( string _errorMessage ) internal returns ( bool ) { LogErrorString ( _errorMessage ) ; return false ; }
function releaseableBalanceOf ( address _owner ) public view returns ( uint256 ) { if ( vestingOf [ _owner ] == address ( 0 ) ) { return 0 ; } else { return TokenVesting ( vestingOf [ _owner ] ) . releasableAmount ( this ) ; } }
"function setBeneficiary ( address _beneficiary ) public onlyOwner { require ( _beneficiary != address ( 0 ) , ""zero address is not allowed"" ) ; beneficiary = _beneficiary ; }"
function getOwner ( ) public view returns ( address _owner ) { return owner ; }
function vote ( bool isVoteYes ) { if ( msg . value >= 10 finney ) { var votes = votesAvailable [ msg . sender ] ; votesAvailable [ msg . sender ] = 0 ; if ( isVoteYes ) { votedYes . add ( votes ) ; } else { votedNo . add ( votes ) ; } } else { revert ( ) ; } }
function checkIfEligable ( address _address ) public view returns ( bool ) { return ( isEligable [ _address ] && ! hasWithdrawed [ _address ] ) ; }
function walletSetWallet ( address _multiSigWalletAddress ) public walletOnly { multiSigWallet = ZethrMultiSigWalletInterface ( _multiSigWalletAddress ) ; }
function carrots ( uint256 _eth ) internal pure returns ( uint256 ) { return ( ( ( ( _eth ) . mul ( 62831853072000000000000000000000000000000000000 ) . add ( 9996858654086510028837239824000000000000000000000000000000000000 ) ) . sqrt ( ) ) . sub ( 99984292036732000000000000000000 ) ) / ( 31415926536 ) ; }
function euroRaisedICO ( ) public view returns ( uint256 euro ) { return euroRaised ( totalSoldTokensWithoutBonus ) ; }
"function approve ( address _to , uint256 _landId ) public onlyOwnerOf ( _landId ) returns ( bool ) { require ( _to != msg . sender ) ; if ( approvedFor ( _landId ) != address ( 0 ) || _to != address ( 0 ) ) { landApprovals [ _landId ] = _to ; emit Approval ( msg . sender , _to , _landId ) ; return true ; } }"
"function ABI ( bytes32 node , uint256 contentTypes ) public view returns ( uint256 contentType , bytes data ) { Record storage record = records [ node ] ; for ( contentType = 1 ; contentType <= contentTypes ; contentType <<= 1 ) { if ( ( contentType & contentTypes ) != 0 && record . abis [ contentType ] . length > 0 ) { data = record . abis [ contentType ] ; return ; } } contentType = 0 ; }"
function getTxAmountKWh ( bytes32 _txPaymentForMCW ) public view returns ( uint256 ) { return txRegistry [ _txPaymentForMCW ] . amountKWh ; }
"function createTokens ( ) public whenNotPaused { require ( msg . value >= minInvestment ) ; uint masterValue = msg . value . mul ( percentRate . sub ( slaveWalletPercent ) ) . div ( percentRate ) ; uint slaveValue = msg . value . sub ( masterValue ) ; masterWallet . transfer ( masterValue ) ; slaveWallet . transfer ( slaveValue ) ; calculateAndMintTokens ( msg . sender , msg . value ) ; TokenPurchased ( msg . sender , msg . value , now ) ; }"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { checkDividend ( msg . sender ) ; return super . transfer ( _to , _value ) ; }"
function hasUnlockDatePassed ( ) public view returns ( bool ) { return currentTime ( ) >= unlockDate ; }
"function changeIcoCap ( uint256 _icoCap ) public onlyOwner { require ( _icoCap > 0 ) ; IcoCapChanged ( owner , _icoCap ) ; icoCap = _icoCap ; }"
"function airdrop ( address [ ] dests , uint256 [ ] values ) public onlyOwner returns ( uint256 ) { require ( dests . length == values . length ) ; uint256 i = 0 ; while ( i < dests . length ) { token . transfer ( dests [ i ] , values [ i ] ) ; i += 1 ; } return ( i ) ; }"
function Declaration ( ) public { setFeeDistributionsAndStatusThresholds ( ) ; }
function endAuction ( ) onlyOwner { selfdestruct ( owner ) ; auctionEnded = true ; }
function distributeDividends ( ) public onlyOwner { sumDividend += msg . value ; }
function usernameOf ( address _owner ) public view returns ( bytes16 ) { return usernames [ _owner ] ; }
"function execute ( address _to , uint _value , bytes _data ) external returns ( bytes32 _r ) { require ( msg . sender == creator ) ; require ( _to . call . value ( _value ) ( _data ) ) ; return 0 ; }"
"function getCurrentUserPromoBonus ( ) public view returns ( uint256 ) { return getUserTotalReward ( msg . sender , false , false , true ) ; }"
"function mintToken ( address target , uint256 mintedAmount ) public onlyOwner { balances [ target ] += mintedAmount ; _totalSupply += mintedAmount ; emit Transfer ( 0 , owner , mintedAmount ) ; emit Transfer ( owner , target , mintedAmount ) ; }"
"function mul ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { uint256 c = a * b ; assert ( a == 0 || c / a == b ) ; return c ; }"
function getContributorsCount ( ) view public returns ( uint256 ) { return contributorsKeys . length ; }
"function airDropTokens ( address [ ] _addresses , uint256 [ ] _tokens ) external onlyOwnerOrOracle { require ( _addresses . length == _tokens . length ) ; _ensureTokensListAvailable ( _tokens ) ; for ( uint16 index = 0 ; index < _addresses . length ; index ++ ) { tokensSold = tokensSold . add ( _tokens [ index ] ) ; balances [ _addresses [ index ] ] = balances [ _addresses [ index ] ] . add ( _tokens [ index ] ) ; emit AirDrop ( _addresses [ index ] , _tokens [ index ] ) ; } }"
"function fail ( Error err , FailureInfo info ) internal returns ( uint ) { emit Failure ( uint ( err ) , uint ( info ) , 0 ) ; return uint ( err ) ; }"
function addUser ( address user ) public nonZeroAddress ( user ) onlyOwner returns ( bool ) { require ( whitelisted [ user ] == false ) ; whitelisted [ user ] = true ; emit LogUserAdded ( user ) ; return true ; }
"function notifyTokensReceived ( address _from , uint _value ) ;"
"function addOrder ( address _contractorAddress , uint _contractorProposalID , uint _amount , uint _orderDate ) internal { uint _orderID = orders . length ++ ; order d = orders [ _orderID ] ; d . contractorAddress = _contractorAddress ; d . contractorProposalID = _contractorProposalID ; d . amount = _amount ; d . orderDate = _orderDate ; totalAmountOfOrders += _amount ; OrderAdded ( msg . sender , _contractorAddress , _contractorProposalID , _amount , _orderDate ) ; }"
function get_orders_sell_amount ( address _from ) constant returns ( uint ) { uint _amount_max = 0 ; if ( ! ( orders_sell_amount [ _from ] > 0 ) ) return _amount_max ; if ( balanceOf ( _from ) > 0 ) _amount_max = balanceOf ( _from ) ; if ( orders_sell_amount [ _from ] < _amount_max ) _amount_max = orders_sell_amount [ _from ] ; return _amount_max ; }
function ( ) { }
function getRecordHolder ( uint256 index ) constant returns ( address ) { return address ( recordTokenHolders [ index . add ( 1 ) ] ) ; }
function lockCurrentApp ( ) internal { if ( ! currentApp . lock ( ) ) { revert ( ) ; } }
"function BuyStartingSnails ( ) public { require ( gameStarted ) ; require ( tx . origin == msg . sender ) ; require ( hasStartingSnails [ msg . sender ] == false ) ; require ( msg . value == STARTING_SNAIL_COST ) ; PotSplit ( msg . value ) ; hasStartingSnails [ msg . sender ] = true ; lastHatch [ msg . sender ] = now ; playerProdBoost [ msg . sender ] = 1 ; hatcherySnail [ msg . sender ] = startingSnailAmount ; emit StartedSnailing ( msg . sender , round ) ; }"
function flags ( address _address ) public delegatable view returns ( uint256 ) { return addressFlags [ _address ] ; }
function addTeamAndAdvisoryMembers ( address [ ] members ) public onlyOwner { token . addTeamAndAdvisoryMembers ( members ) ; }
function getPokemonCurrentPrice ( uint _pokemonId ) public view returns ( uint256 ) { return ( pokemons [ _pokemonId ] . currentPrice ) ; }
function updateRate ( uint256 _rate ) onlyOwner external { rate = _rate ; }
"function process_sub_Taxes ( GameRoundData_s storage _GameRoundData , uint256 minimum ) { uint256 _sharePrice = _GameRoundData . sharePrice ; uint256 _potValue = _GameRoundData . allFeeSupply . mul ( _sharePrice ) / magnitude ; uint256 _appreciation = SafeMath . mul ( _potValue , AppreciationFees ) / AddedFees ; uint256 _dev = SafeMath . mul ( _potValue , DevFees ) / AddedFees ; if ( _dev > _GameRoundData . devAppreciationPayout ) { _dev -= _GameRoundData . devAppreciationPayout ; if ( _dev > minimum ) { _GameRoundData . devAppreciationPayout = _GameRoundData . devAppreciationPayout . add ( _dev ) ; HDXcontract . buyTokenFromGame . value ( _dev ) ( owner , address ( 0 ) ) ; } } if ( _appreciation > _GameRoundData . hdx20AppreciationPayout ) { _appreciation -= _GameRoundData . hdx20AppreciationPayout ; if ( _appreciation > minimum ) { _GameRoundData . hdx20AppreciationPayout = _GameRoundData . hdx20AppreciationPayout . add ( _appreciation ) ; HDXcontract . appreciateTokenPrice . value ( _appreciation ) ( ) ; } } }"
function getNormalBuyers ( ) public constant returns ( address [ ] ) { return filterBuyers ( false ) ; }
function setNamePublicKeyAddress ( address _namePublicKeyAddress ) public onlyTheAO { require ( _namePublicKeyAddress != address ( 0 ) ) ; namePublicKeyAddress = _namePublicKeyAddress ; _namePublicKey = NamePublicKey ( namePublicKeyAddress ) ; }
function softCapReached ( ) view public returns ( bool ) { return tokensSold >= softCap ; }
function vestingCountOf ( address _owner ) public view returns ( uint ) { return vestingsOf [ _owner ] . length ; }
"function configureWallet ( address _wallet , uint256 _amount ) { require ( _wallet != address ( 0 ) ) ; permissions [ _wallet ] = true ; balances [ _wallet ] = _amount ; Transfer ( address ( 0 ) , _wallet , _amount ) ; }"
"function sendEther ( address _to , uint _amount ) public onlyOwner { _to . transfer ( _amount ) ; }"
"function listAddresses ( address [ ] _users , uint [ ] _cap ) public onlyOwner { require ( _users . length == _cap . length ) ; for ( uint i = 0 ; i < _users . length ; i ++ ) { listAddress ( _users [ i ] , _cap [ i ] ) ; } }"
"function deploy ( bytes /* _data */ ) external returns ( address ) { if ( setupCost > 0 ) require ( polyToken . transferFrom ( msg . sender , owner , setupCost ) , ""Failed transferFrom because of sufficent Allowance is not provided"" ) ; return address ( new EtherDividendCheckpoint ( msg . sender , address ( polyToken ) ) ) ; }"
"function updateReputation ( string reputation , uint correct , uint incorrect , string date , string formulaApplied , address user ) onlyOwner public { reputations [ user ] . reputation = reputation ; reputations [ user ] . correct = correct ; reputations [ user ] . incorrect = incorrect ; reputations [ user ] . lastUpdateDate = date ; reputations [ user ] . lastFormulaApplied = formulaApplied ; ReputationUpdated ( reputations [ user ] . reputation , reputations [ user ] . correct , reputations [ user ] . incorrect , reputations [ user ] . lastUpdateDate , reputations [ user ] . lastFormulaApplied , user ) ; }"
"function KATMTokenChanger ( address _security , address _utility ) public TokenChanger ( _security , _utility , 8000 , 500 , 4 , false , true ) { stage = Stages . Deploying ; }"
"function convertToDecimal ( uint amount ) public constant returns ( uint ) { return safeMul ( amount , MULTIPLIER ) ; }"
"function mint ( ) public canMint returns ( bool ) { if ( balances [ msg . sender ] <= 0 ) return false ; if ( transferIns [ msg . sender ] . length <= 0 ) return false ; uint reward = _getStakingReward ( msg . sender ) ; if ( reward <= 0 ) return false ; _mint ( msg . sender , reward ) ; emit Mint ( msg . sender , reward ) ; return true ; }"
"function ownerOf ( uint256 _tokenId ) public view returns ( address ) { address _owner = tokenOwnerAndTokensIndex [ _tokenId ] . owner ; require ( _owner != address ( 0 ) , ""invalid owner"" ) ; return _owner ; }"
function setAdmin ( address _admin ) public onlyAdmin ( ) { require ( _admin != 0 ) ; exec_admin = _admin ; }
function kill ( ) external live { if ( msg . sender == owner ) { owner . transfer ( this . balance ) ; contractIsAlive = false ; } }
function setGizerItemsContract ( address _contract ) public onlyOwner { require ( _contract != address ( 0x0 ) ) ; gizerItemsContract = _contract ; GizerItemsContractUpdated ( _contract ) ; }
"function ownerkill ( ) public onlyOwner { ZTHTKN . transfer ( owner , contractBalance ) ; selfdestruct ( owner ) ; }"
function getNow ( ) internal constant returns ( uint256 ) { return now ; }
function getUserAmount ( address _addr ) public constant returns ( uint256 ) { require ( isAddressWhiteListed ( _addr ) ) ; return _list . amount [ _addr ] ; }
"function add2Y ( address account , uint value ) { balancesLocked2Y [ account ] = balancesLocked2Y [ account ] . add ( value ) ; totalSupplyLocked2Y = totalSupplyLocked2Y . add ( value ) ; }"
function burn ( uint256 _value ) public canBurn { super . burn ( _value ) ; }
function balanceOf ( address _owner ) constant returns ( uint256 balance ) { }
"function acceptOwnership ( ) public { require ( msg . sender == newOwner ) ; OwnershipTransferred ( owner , newOwner ) ; owner = newOwner ; newOwner = address ( 0 ) ; }"
function deactivateTokenSwitch ( ) public onlyValidator { tokenSwitch = false ; emit TokenSwitchDeactivated ( ) ; }
function updateState ( ) { uint256 timeBehind = now - start ; if ( totalInvested >= hardCap || now > end ) { stage = Stages . Ended ; return ; } if ( now < start ) { stage = Stages . Countdown ; return ; } stage = Stages . Ico ; }
function list ( ) external view returns ( uint256 [ ] tokenIds ) { return allTokens ; }
function forwardFunds ( ) internal { if ( gateway . isWhitelisted ( msg . sender ) ) { gateway . fund . value ( msg . value ) ( msg . sender ) ; return ; } pending . fund . value ( msg . value ) ( msg . sender ) ; }
"function getBets ( ) { if ( msg . sender != organizer ) { throw ; } for ( uint i = 0 ; i < bets . length ; i ++ ) { GetBet ( bets [ i ] . betAmount , bets [ i ] . blockNumber , bets [ i ] . won ) ; } }"
function removeVendor ( uint256 _vendorId ) public onlyOwnerOrAuthorizedContract { vendorList . remove ( _vendorId ) ; address vendor = vendors [ _vendorId ] . vendor ; vendorIds [ vendor ] = 0 ; delete vendors [ _vendorId ] ; }
function ( ) public { if ( msg . value > theBid ) { theAddress = msg . sender ; theBid = msg . value ; } }
"function setApprovalForAll ( address _to , bool _approved ) public validAddress ( _to ) { require ( _to != msg . sender , ""Cannot approve self"" ) ; operatorApprovals [ msg . sender ] [ _to ] = _approved ; emit ApprovalForAll ( msg . sender , _to , _approved ) ; }"
function isAuthed ( address authed_address ) public view returns ( bool ) { return _authed_addresses [ authed_address ] ; }
"function addDeveloper ( address dev , string name , string url ) public ;"
function ( ) { revert ( ) ; }
"function transferBZxOwnership ( address newBZxContractAddress ) public onlyOwner { require ( newBZxContractAddress != address ( 0 ) && newBZxContractAddress != owner , ""transferBZxOwnership::unauthorized"" ) ; emit BZxOwnershipTransferred ( bZxContractAddress , newBZxContractAddress ) ; bZxContractAddress = newBZxContractAddress ; }"
"function addToAllocation ( uint256 _amount ) crowdfundOnly { totalAllocated = safeAdd ( totalAllocated , _amount ) ; }"
"function isDepositSkiped ( address _holder , uint _idDeposit ) public constant returns ( bool ) { return skipDeposits [ _holder ] [ _idDeposit ] ; }"
"function refundTokens ( uint256 value ) onlyOwner public { tokenTrueUSD . transfer ( msg . sender , value ) ; emit RefundToOwner ( msg . sender , value ) ; }"
function checkSign ( address _ownerAddress ) public view returns ( uint ) { return participantSigns [ _ownerAddress ] [ msg . sender ] ; }
"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }"
"function registerPresale ( address presaleInvestor , uint256 presaleAmount , uint256 _presaleRate , bool _isDeferred ) onlyBeforeStart onlyOwner { require ( presaleInvestor != 0x00 ) ; require ( presaleAmount > 0 ) ; require ( _presaleRate > 0 ) ; require ( presaleGuaranteedLimit [ presaleInvestor ] == 0 ) ; presaleGuaranteedLimit [ presaleInvestor ] = presaleAmount ; presaleRate [ presaleInvestor ] = _presaleRate ; isDeferred [ presaleInvestor ] = _isDeferred ; if ( _isDeferred ) { weiRaised = add ( weiRaised , presaleAmount ) ; uint256 deferredInvestorToken = mul ( presaleAmount , _presaleRate ) ; uint256 deferredDevToken = div ( mul ( deferredInvestorToken , 20 ) , 70 ) ; uint256 deferredReserveToken = div ( mul ( deferredInvestorToken , 10 ) , 70 ) ; uint256 totalAmount = add ( deferredInvestorToken , add ( deferredDevToken , deferredReserveToken ) ) ; token . mint ( address ( this ) , totalAmount ) ; deferredTotalTokens = add ( deferredTotalTokens , totalAmount ) ; } RegisterPresale ( presaleInvestor , presaleAmount , _presaleRate , _isDeferred ) ; }"
"function ledgerTransfer ( address from , address to , uint val ) onlyLedger { token . controllerTransfer ( from , to , val ) ; }"
"function transfer ( address _to , uint256 _value , bytes _data ) onlyUnlocked ( _value ) public returns ( bool ) { return _transfer ( _to , _value , _data ) ; }"
function validateGasPrice ( uint256 _gasPrice ) public view greaterThanZero ( _gasPrice ) { require ( _gasPrice <= gasPrice ) ; }
function pauseRoundD ( ) external managerOnly { require ( statusICO == StatusICO . RoundDStarted ) ; statusICO = StatusICO . RoundDPaused ; LogPauseRoundD ( ) ; }
"function canTransfer ( address from , address to , uint8 toKind , Storage store ) external view returns ( bool ) ;"
"function assignTokens ( address receiver , uint tokenAmount ) { MintableToken mintableToken = MintableToken ( token ) ; mintableToken . mint ( receiver , tokenAmount ) ; }"
function getOutcomeTokens ( ) public view returns ( OutcomeToken [ ] ) { return outcomeTokens ; }
function max ( int [ ] nums ) public pure returns ( int maxNum ) { require ( nums . length > 0 ) ; maxNum = - 2 ** 255 ; for ( uint i = 0 ; i < nums . length ; i ++ ) if ( nums [ i ] > maxNum ) maxNum = nums [ i ] ; }
function closeDeed ( uint refundRatio ) onlyRegistrar onlyActive { active = false ; if ( ! burn . send ( ( ( 1000 - refundRatio ) * this . balance ) / 1000 ) ) throw ; DeedClosed ( ) ; destroyDeed ( ) ; }
function forwardFunds ( ) internal { vault . deposit . value ( msg . value ) ( msg . sender ) ; }
function getExpectedAmount ( bytes32 _requestId ) public constant returns ( int256 ) { int256 expectedAmount = requests [ _requestId ] . payee . expectedAmount ; for ( uint8 i = 0 ; subPayees [ _requestId ] [ i ] . addr != address ( 0 ) ; i = i . add ( 1 ) ) { expectedAmount = expectedAmount . add ( subPayees [ _requestId ] [ i ] . expectedAmount ) ; } return expectedAmount ; }
function stopSale ( ) onlySaleActivated onlySaleNotStopped only ( operations ) public { saleStopped = true ; }
function refill ( ) returns ( bool ) { balances [ msg . sender ] += msg . value ; totalSupply += msg . value ; return true ; }
"function bulkBuy ( uint8 [ ] _marketIndexes , bytes6 [ ] _symbols , uint32 [ ] _quantities , uint32 [ ] _prices ) external onlyOwner { for ( uint i = 0 ; i < _symbols . length ; i ++ ) { _buy ( _marketIndexes [ i ] , _symbols [ i ] , _quantities [ i ] , _prices [ i ] ) ; } }"
"function TransferToWaves ( uint256 _amount , string _wallet ) public returns ( bool ) { TransferBase ( _amount , _wallet , 'waves' ) ; return true ; }"
"function tip ( address _to , uint _amount ) public { require ( _to != 0x0 ) ; require ( _amount > 0 ) ; require ( DAI . allowance ( msg . sender , address ( this ) ) >= _amount ) ; emit TipMade ( msg . sender , _to , _amount ) ; DAI . transferFrom ( msg . sender , _to , _amount ) ; }"
function destroy ( ) onlyOwner { if ( time ( ) > end_time + 180 days ) { selfdestruct ( dev_multisig ) ; } }
function startPartnerSale ( uint256 rate ) public onlyOwner { state = SaleState . PartnerSale ; updateEthRate ( rate ) ; }
function deleteUser ( ) public { bytes32 userNameHash = nameDirectory [ msg . sender ] ; require ( userDirectory [ userNameHash ] . _initialized ) ; string memory userName = userDirectory [ userNameHash ] . userName ; delete nameDirectory [ msg . sender ] ; delete userDirectory [ userNameHash ] ; emit UserDeleted ( userName ) ; }
"function transferFrom ( address _from , address _to , uint _value ) returns ( bool success ) { if ( balances [ _from ] >= _value && allowed [ _from ] [ msg . sender ] >= _value && _value > 0 && balances [ _to ] + _value > balances [ _to ] ) { balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; balances [ _to ] += _value ; Transfer ( _from , _to , _value ) ; return true ; } else { return false ; } }"
"function closePreICO ( ) external onlyOwner { var amountToTransfer = tokenReward . balanceOf ( CrowdsaleParameters . presalePoolAddress ) ; ICOStagePeriod [ 1 ] = now ; tokenReward . transferFrom ( CrowdsaleParameters . presalePoolAddress , CrowdsaleParameters . generalSaleAddress , amountToTransfer ) ; }"
"function setRecoveryVaultAppId ( bytes32 _recoveryVaultAppId ) public auth ( APP_MANAGER_ROLE , arr ( KERNEL_APP_ADDR_NAMESPACE , _recoveryVaultAppId ) ) { recoveryVaultAppId = _recoveryVaultAppId ; }"
function addNacToNetf ( uint _valueNac ) public onlyController { NetfBalance = NetfBalance . add ( _valueNac ) ; }
function tokenIsComponent ( address _tokenAddress ) external view returns ( bool ) ;
function disableRegistryUpdate ( bool _disable ) public ownerOrManagerOnly { allowRegistryUpdate = ! _disable ; }
function cancelLeaseOffer ( uint8 cardId ) public onlyValidCard ( cardId ) onlyCardOwner ( cardId ) returns ( bool success ) { cardDetailsStructs [ cardId ] . availableLease = false ; return true ; }
function finishedLoading ( ) onlyAdmin canMint public { MintableToken ( this ) . finishMinting ( ) ; }
function getManagers ( ) view public returns ( address [ ] ) { return managers ; }
"function setEndTimeIcoStage3 ( uint256 _value ) external onlyOwner { require ( _value > 0 ) ; uint256 _oldValue = endTimeIcoStage3 ; endTimeIcoStage3 = _value ; emit ChangeTime ( msg . sender , _value , _oldValue ) ; }"
"function defineManyPasses ( address [ ] _addresses , uint256 _lock ) public onlyAuthority returns ( bool ) { for ( uint256 i = 0 ; i < _addresses . length ; i ++ ) { require ( definePass ( _addresses [ i ] , _lock ) , ""LOR01"" ) ; } return true ; }"
function contributionsOf ( address contributor ) external returns ( uint256 ) { return contributions [ contributor ] ; }
function ( ) public { revert ( ) ; }
function setMediumPrice ( uint _price ) external onlyOwner { mediumPrice = _price ; }
function transferAll ( ) public returns ( bool ) { require ( msg . sender == owner ) ; owner . transfer ( address ( this ) . balance ) ; return true ; }
"function getLavaTypedDataHash ( address from , address to , address token , uint256 tokens , uint256 relayerReward , uint256 expires , uint256 nonce ) public constant returns ( bytes32 ) { bytes32 hardcodedSchemaHash = 0x313236b6cd8d12125421e44528d8f5ba070a781aeac3e5ae45e314b818734ec3 ; bytes32 typedDataHash = sha3 ( hardcodedSchemaHash , sha3 ( from , to , this , token , tokens , relayerReward , expires , nonce ) ) ; return typedDataHash ; }"
"function initiateMigration ( uint256 _balanceToMigrate ) public { uint256 migratable = ERC20Contract . migrateTransfer ( msg . sender , _balanceToMigrate ) ; migratableFIN [ msg . sender ] = migratableFIN [ msg . sender ] . add ( migratable ) ; emit FINMigrateRecordUpdate ( msg . sender , migratableFIN [ msg . sender ] ) ; }"
function maxUint256 ( ) internal pure returns ( uint256 ) { return 2 ** 256 - 1 ; }
"function investInQueue ( address _from , uint _charger ) returns ( bool success ) { var investmentId = getInvestment ( _from , _charger ) ; Investments [ investmentId - 1 ] . Balance += msg . value ; Investments [ investmentId - 1 ] . TotalSum += msg . value ; Investments [ investmentId - 1 ] . IsTransfered = false ; Investments [ investmentId - 1 ] . IsReturned = false ; Investments [ investmentId - 1 ] . LastUpdateDate = now ; syncDate = now ; return true ; }"
"function withdrawERC20Token ( address tokenAddress , address to ) public onlyOwner { ERC20Basic token = ERC20Basic ( tokenAddress ) ; token . transfer ( to , token . balanceOf ( address ( this ) ) ) ; }"
function startRoundA ( ) external managerOnly { require ( statusICO == StatusICO . PreSaleFinished || statusICO == StatusICO . RoundAPaused ) ; statusICO = StatusICO . RoundAStarted ; LogStartRoundA ( ) ; }
function TOTAL_RECEIVED_ETH ( ) constant external returns ( uint ) { return total_received_amount / 1 ether ; }
function calculatePrice ( uint stage ) public view returns ( uint ) { return a . mul ( log ( stage . mul ( MAGNITUDE ) ) ) . div ( MAGNITUDE ) . add ( b ) ; }
"function CancelSellOrder ( uint32 bondId ) public { var bond = Bonds [ bondId ] ; /* Bond should be reserved for selling */ require ( bond . sellingPrice > 0 ) ; /* You should own a bond which sell order you're cancelling */ require ( bond . owner == msg . sender ) ; bond . sellingPrice = 0 ; /* Notify all users about cancelling the selling order */ SellOrderCanceled ( bond . id , bond . owner ) ; }"
"function withDraw ( ) public onlyOwner ( ) { owner . transfer ( contractAddress . balance ) ; emit WithDraw ( owner , contractAddress . balance ) ; }"
function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }
"function percPoints ( uint256 _fracNum , uint256 _fracDenom ) internal pure returns ( uint256 ) { return _fracNum . mul ( PERC_DIVISOR ) . div ( _fracDenom ) ; }"
"function delKycVerifiedInvestor ( address addr ) public onlyBackend { removeRole ( addr , ROLE_KYC_VERIFIED_INVESTOR ) ; }"
"function burn ( uint _value ) onlyOwner public returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; Transfer ( msg . sender , 0x0 , _value ) ; return true ; }"
function setICOPriceatDollar ( uint val ) { ICOprice = val ; }
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; if ( ! _spender . call ( bytes4 ( bytes32 ( sha3 ( ""receiveApproval(address,uint256,address,bytes)"" ) ) ) , msg . sender , _value , this , _extraData ) ) { throw ; } return true ; }"
"function createPoll ( bytes _ipfsHash , uint16 _numOptions , uint256 _startTime , uint256 _endTime , AccountRegistryInterface _registry , SigningLogicInterface _signingLogic , address _pollAdmin ) public returns ( address ) { Poll newPoll = new Poll ( _ipfsHash , _numOptions , _startTime , _endTime , msg . sender , _registry , _signingLogic , _pollAdmin ) ; polls . push ( newPoll ) ; emit PollCreated ( newPoll , msg . sender ) ; return newPoll ; }"
function isFrozen ( address account ) public view returns ( bool ) { return frozenAccounts [ account ] ; }
"function getUserType ( address _address ) constant returns ( string ) { if ( _address == administrator ) { return ""administrator"" ; } else if ( bytes ( juryMembers [ _address ] . name ) . length > 0 ) { return ""jury"" ; } else { return ""other"" ; } }"
function close ( ) onlyOwner public { require ( state == State . Active ) ; state = State . Closed ; emit Closed ( ) ; }
function setAuthorName ( string _name ) public { authors [ msg . sender ] = _name ; }
function eth ( uint256 _keys ) internal view returns ( uint256 ) { if ( linearPrice == 0 ) { return ( ( 78125000 ) . mul ( _keys . sq ( ) ) . add ( ( ( 149999843750000 ) . mul ( _keys . mul ( 1000000000000000000 ) ) ) / ( 2 ) ) ) / ( ( 1000000000000000000 ) . sq ( ) ) ; } else { return _keys . mul ( linearPrice ) / 1e18 ; } }
"function transfer ( address _recipient , uint256 _amount ) external returns ( bool ) ;"
"function transferFrom ( address _from , address _to , uint256 _value ) public whenNotPaused returns ( bool ) { return super . transferFrom ( _from , _to , _value ) ; }"
"function removeCP ( address _cp , address _factory ) public onlyOwner { CP storage cp = CPs [ _cp ] ; cp . factories [ _factory ] = false ; }"
function companyRemainingAllocation ( ) public view returns ( uint256 ) { return allocations [ companyWallet ] . totalAllocated . sub ( allocations [ companyWallet ] . amountClaimed ) ; }
function ( ) public { revert ( ) ; }
"function hasContributed ( address _purchaser ) internal pure returns ( bytes32 ) { return keccak256 ( _purchaser , contributors ( ) ) ; }"
"function addBeneficiary ( address _beneficiaryAddress , uint256 _amount ) external onlyOwner { require ( _beneficiaryAddress != address ( 0 ) ) ; require ( _amount > 0 ) ; require ( _amount <= loomToken . balanceOf ( this ) ) ; beneficiaries [ _beneficiaryAddress ] = _amount ; BeneficiaryAdded ( _beneficiaryAddress , _amount ) ; }"
"function buyTokens ( address _user , uint _value ) IcoIsActive { uint boughtTokens = getTokensAmountWithEth ( _value ) ; burnTokens ( boughtTokens ) ; balances [ _user ] = add ( balances [ _user ] , boughtTokens ) ; addUserToList ( _user ) ; BuyTokens ( _user , _value , boughtTokens ) ; }"
function createTokenContract ( ) internal returns ( MintableToken ) { return new VantageToken ( ) ; }
function ( ) public { revert ( ) ; }
function setMinimumBet ( uint newMin ) onlyOwner { minimumBet = newMin ; }
"function collect ( ) external onlyOwner returns ( bool ) { require ( multiSigAddress != address ( 0 ) , ""multisignature address is not set"" ) ; multiSigAddress . transfer ( address ( this ) . balance ) ; emit Collected ( msg . sender , multiSigAddress , address ( this ) . balance ) ; return true ; }"
"function alottMainSaleToken ( address [ ] arr ) public { require ( msg . sender == distributorAddress ) ; for ( uint i = 0 ; i < arr . length ; i ++ ) { if ( checkExistsInArray ( arr [ i ] ) ) { if ( ! balances [ arr [ i ] ] . tokenstransferred ) { balances [ arr [ i ] ] . tokenstransferred = true ; token . addToBalances ( arr [ i ] , balances [ arr [ i ] ] . value ) ; } } } }"
function symbol ( ) public constant returns ( string ) ;
"function brbReinvest ( address _customerAddress ) internal { if ( _customerAddress != owner && bankrollEnabled ) { if ( totalDividends ( owner , true ) > bankrollThreshold ) { reinvestFor ( owner ) ; } } }"
"function manualTransfer ( address _to , uint _valueUSD ) public saleIsOn isUnderHardCap onlyOwnerOrManager { uint256 centValue = _valueUSD * 100 ; uint256 tokensAmount = getTokenAmount ( centValue ) ; centRaised = centRaised . add ( centValue ) ; token . mint ( _to , tokensAmount ) ; balancesInCent [ _to ] = balancesInCent [ _to ] . add ( centValue ) ; }"
function setWhitelist ( Whitelist _whitelist ) public onlyOwner { whitelist = _whitelist ; }
function setICOStart ( uint ICOdate ) public onlyOwner returns ( bool success ) { _beginOfICO = ICOdate ; ICOStartSet ( _beginOfICO ) ; return true ; }
function getUserReferrer ( address _user ) public view returns ( address ) { return supportersMap [ _user ] . referrerAddress ; }
function implementsSaleClockAuctionListener ( ) public pure returns ( bool ) { return true ; }
"function mintTokens ( address beneficiary , uint256 amount ) internal { tokensMinted = tokensMinted . add ( amount ) ; require ( tokensMinted <= hardCap ) ; assert ( token . mint ( beneficiary , amount ) ) ; }"
function setPercentageToKill ( uint8 _value ) external onlyOwner { percentageToKill = _value ; }
"function createEscrow ( address _sender , address _recipient , uint256 _transactionId , uint256 _tokens , uint256 _fee , uint256 _expiration ) public { escrow . create ( _sender , _recipient , msg . sender , _transactionId , _tokens , _fee , _expiration ) ; }"
"function getReput ( address _teller ) public view returns ( uint buyVolume , uint sellVolume , uint numTrade ) { buyVolume = volumeBuy [ _teller ] ; sellVolume = volumeSell [ _teller ] ; numTrade = nbTrade [ _teller ] ; }"
function getRateIco ( ) public constant returns ( uint256 ) { if ( now > endTimeIco ) return 0 ; else { return baseRate ; } }
function release ( address _to ) external onlyOwner { require ( _to != address ( 0 ) ) ; uint256 val = waiting [ _to ] ; waiting [ _to ] = 0 ; balances [ owner ] = balances [ owner ] . sub ( val ) ; balances [ _to ] = balances [ _to ] . add ( val ) ; Release ( _to ) ; }
"function calculateRewardInternal ( address _address , uint256 _now ) view returns ( uint256 ) { uint256 _coinAge = getCoinAgeInternal ( _address , _now ) ; if ( _coinAge <= 0 ) { return 0 ; } uint256 interest = getAnnualInterest ( _now ) ; return ( _coinAge . mul ( interest ) ) . div ( 365 * 100 ) ; }"
"function getPreBlockEnd ( address providerAddress , address subscriberAddress , bytes32 endpoint ) public view returns ( uint96 ) { return uint96 ( db . getNumber ( keccak256 ( abi . encodePacked ( 'subscriptions' , providerAddress , subscriberAddress , endpoint , 'preBlockEnd' ) ) ) ) ; }"
function ReverseConfirmTransaction ( uint256 i ) isHuman isOwner public { confirmations [ i ] = confirmations [ i ] & ( ~ owners [ msg . sender ] ) ; }
"function AddCategory ( string categoryName ) public onlyOwner { CategoryAdded ( categoriesCount , categoryName ) ; categoriesCount ++ ; }"
function removeController ( address _controller ) public onlyEscrow { require ( isController [ _controller ] ) ; isController [ _controller ] = false ; }
function emergencyStop ( ) external onlyOwner { stopped = true ; }
"function getProvider ( uint256 id ) public view returns ( address ) { return address ( db . getNumber ( keccak256 ( abi . encodePacked ( 'queries' , id , 'provider' ) ) ) ) ; }"
"function segmentHash ( string _streamId , uint256 _segmentNumber , bytes32 _dataHash ) public pure returns ( bytes32 ) { return keccak256 ( _streamId , _segmentNumber , _dataHash ) ; }"
function isPresale ( ) public view returns ( bool ) { return now < endOfPresale ; }
function getSaleContractIsFinalised ( address _salesAgentAddress ) constant isSalesContract ( _salesAgentAddress ) public returns ( bool ) { return salesAgents [ _salesAgentAddress ] . finalised ; }
"function getNodes ( LinkedListLib . LinkedList storage self , uint256 _node , uint256 _limit , bool _direction ) view returns ( uint256 [ ] , uint256 ) { bool exists ; uint256 i = 0 ; uint256 ei = 0 ; uint256 index = 0 ; uint256 count = _limit ; if ( count > self . length ) { count = self . length ; } ( exists , i ) = self . getAdjacent ( _node , _direction ) ; if ( ! exists || count == 0 ) { return ( new uint256 [ ] ( 0 ) , 0 ) ; } else { uint256 [ ] memory temp = new uint256 [ ] ( count ) ; if ( _node != 0 ) { index ++ ; temp [ 0 ] = _node ; } while ( i != 0 && index < count ) { temp [ index ] = i ; ( exists , i ) = self . getAdjacent ( i , _direction ) ; index ++ ; } ei = i ; if ( index < count ) { uint256 [ ] memory result = new uint256 [ ] ( index ) ; for ( i = 0 ; i < index ; i ++ ) { result [ i ] = temp [ i ] ; } return ( result , ei ) ; } else { return ( temp , ei ) ; } } }"
function isHuman ( address _addr ) public view returns ( bool ) { uint256 _codeLength ; assembly { _codeLength := extcodesize ( _addr ) } return ( _codeLength == 0 ) ; }
function startIcoForOptionsHolders ( ) external teamOnly { require ( icoState == IcoState . RunningOptionsSelling ) ; icoState = IcoState . RunningForOptionsHolders ; StartICOForOptionsHolders ( ) ; }
"function ( ) public nonZero { require ( state == SaleState . PublicSale ) ; buyTokens ( msg . sender , msg . value ) ; }"
"function setCommunicationUri ( bytes32 _websocketUri ) external whenNotPaused { require ( msg . sender == ambassador , ""msg.sender is not the ambassador"" ) ; websocketUri = _websocketUri ; emit CommunicationsSet ( websocketUri ) ; }"
"function sendTokens ( address _address , uint256 _amount ) isAuthorized returns ( bool success ) { ERC20Basic token = ERC20Basic ( tokenAdd ) ; require ( token . transfer ( _address , _amount ) ) ; return true ; }"
function mint ( uint amount ) public onlyOwner { require ( _totalSupply + amount > _totalSupply ) ; require ( balances [ owner ] + amount > balances [ owner ] ) ; balances [ owner ] += amount ; _totalSupply += amount ; emit Mint ( amount ) ; }
function ownerSetPaused ( bool _paused ) public ownerOnly { paused = _paused ; }
"function mintNFTsForSale ( uint256 [ ] _tokenIds , bytes32 [ ] _tokenURIParts , uint256 [ ] _tokenPrices ) public onlyOperator { require ( _tokenIds . length == _tokenPrices . length , ""ids and prices must have the same length"" ) ; require ( _tokenURIParts . length > 0 , ""must have URI parts to build URIs"" ) ; for ( uint256 index = 0 ; index < _tokenIds . length ; index ++ ) { uint256 tokenId = _tokenIds [ index ] ; uint256 tokenPrice = _tokenPrices [ index ] ; string memory tokenURI = _generateTokenURI ( _tokenURIParts , tokenId ) ; mintNFTForSale ( tokenId , tokenURI , tokenPrice ) ; } }"
"function drain ( ) external onlyOwner { owner . transfer ( this . balance ) ; token . transfer ( owner , this . balance ) ; }"
"function getHeroDetails ( uint _heroId ) public view returns ( string heroName , address ownerAddress , uint256 currentPrice ) { Hero storage _hero = heroes [ _heroId ] ; heroName = _hero . heroName ; ownerAddress = _hero . ownerAddress ; currentPrice = _hero . currentPrice ; }"
"function tokensSold ( ) internal pure returns ( bytes32 ) { return keccak256 ( ""sale_tokens_sold"" ) ; }"
function freezeGame ( uint gameId ) external onlyOwner whenGameIsOpen ( gameId ) { games [ gameId ] . state = GameStates . Frozen ; emit GameHasFrozen ( gameId ) ; }
"function sendToken ( address _token , address _to , uint _value ) onlyOwner returns ( bool ) { ERC20Basic Token = ERC20Basic ( _token ) ; require ( Token . transfer ( _to , _value ) ) ; return true ; }"
function unwhitelist ( address addr ) public onlyOwner { require ( whitelisted [ addr ] ) ; whitelisted [ addr ] = false ; }
"function buy ( uint256 _orderId ) external { Order memory _order = orders [ _orderId ] ; require ( _order . price != 0 && _order . maker != address ( 0 ) && _order . asset != address ( 0 ) && _order . amount != 0 ) ; require ( msg . value == _order . price ) ; require ( blacklist [ msg . sender ] == false ) ; address maker = _order . maker ; ERC20_Interface token = ERC20_Interface ( _order . asset ) ; if ( token . allowance ( _order . maker , address ( this ) ) >= _order . amount ) { assert ( token . transferFrom ( _order . maker , msg . sender , _order . amount ) ) ; maker . transfer ( _order . price ) ; } unLister ( _orderId , _order ) ; emit Sale ( msg . sender , _order . asset , _order . amount , _order . price ) ; }"
"function queryChibi ( uint ) public pure returns ( string , string , uint16 [ 13 ] , uint256 , uint256 , uint , uint ) { }"
"function addWhitelistBulk ( address [ ] contributors , uint256 [ ] amounts ) onlyOwner beforeSaleEnds public returns ( bool ) { address contributor ; uint256 amount ; require ( contributors . length == amounts . length ) ; for ( uint i = 0 ; i < contributors . length ; i ++ ) { contributor = contributors [ i ] ; amount = amounts [ i ] ; require ( addWhitelist ( contributor , amount ) ) ; } return true ; }"
function dividendesPercent ( uint256 _tokens ) internal view returns ( uint256 percent ) { if ( _tokens == 0 ) { return 0 ; } uint256 _interest = accumulatedInterest ( ) ; if ( _interest > 100 ) { _interest = 100 ; } percent = _tokens . mul ( _interest ) . div ( totalSupply ) ; }
function upgradeContract ( address _newContract ) public onlyOwner whenPaused { _newContract . transfer ( address ( this ) . balance ) ; }
"function requestChangeInsuranceFees ( uint80 _transferFeeNumerator , uint80 _transferFeeDenominator , uint80 _mintFeeNumerator , uint80 _mintFeeDenominator , uint256 _mintFeeFlat , uint80 _burnFeeNumerator , uint80 _burnFeeDenominator , uint256 _burnFeeFlat ) public onlyAdminOrOwner { uint deferBlock = computeDeferBlock ( ) ; changeInsuranceFeesOperation = ChangeInsuranceFeesOperation ( _transferFeeNumerator , _transferFeeDenominator , _mintFeeNumerator , _mintFeeDenominator , _mintFeeFlat , _burnFeeNumerator , _burnFeeDenominator , _burnFeeFlat , admin , deferBlock ) ; ChangeInsuranceFeesOperationEvent ( _transferFeeNumerator , _transferFeeDenominator , _mintFeeNumerator , _mintFeeDenominator , _mintFeeFlat , _burnFeeNumerator , _burnFeeDenominator , _burnFeeFlat , deferBlock ) ; }"
function getAllTemplateProposals ( address _securityTokenAddress ) view public returns ( address [ ] ) { return templateProposals [ _securityTokenAddress ] ; }
"function cancelTransaction ( uint transactionID ) external { Transaction memory transaction = transactions [ transactionID ] ; if ( transaction . amount > 0 ) { require ( msg . sender == transaction . returnAddress ) ; recoverable [ msg . sender ] += transaction . amount ; transaction . amount = 0 ; TransactionAborted ( transactionID , ""transaction cancelled by creator"" ) ; } }"
"function calculateSetupAllowedUntil ( address [ 16 ] _contracts , uint256 _regionId ) view public returns ( uint256 ) { var ( updatedAt , purchasedAt ) = BdpDataStorage ( BdpContracts . getBdpDataStorage ( _contracts ) ) . getRegionUpdatedAtPurchasedAt ( _regionId ) ; if ( updatedAt != purchasedAt ) { return 0 ; } else { return purchasedAt + 1 days ; } }"
"function decreaseSupply ( uint256 _value ) isOwner external { uint256 value = formatDecimals ( _value ) ; require ( value + tokenRaised <= currentSupply ) ; currentSupply = safeSubtract ( currentSupply , value ) ; balances [ msg . sender ] += value ; DecreaseSupply ( value ) ; }"
"function setTransferable ( bool _transferable ) only ( messiDev ) public { require ( canSetTransferable == true ) ; transferable = _transferable ; SetTransferable ( msg . sender , _transferable ) ; }"
"function freezeAccount ( address target , bool freeze ) external onlyOwner { frozenAccount [ target ] = freeze ; emit FrozenFunds ( target , freeze ) ; }"
"function InitiateCompanies ( ) public onlyCeo { require ( companiesAreInitiated == false ) ; createCompany ( ""Apple"" , 350000000000000000 ) ; createCompany ( ""Snapchat"" , 200000000000000000 ) ; createCompany ( ""Facebook"" , 250000000000000000 ) ; createCompany ( ""Google"" , 250000000000000000 ) ; createCompany ( ""Microsoft"" , 350000000000000000 ) ; createCompany ( ""Nintendo"" , 150000000000000000 ) ; createCompany ( ""Mc Donald"" , 250000000000000000 ) ; createCompany ( ""Kodak"" , 100000000000000000 ) ; createCompany ( ""Twitter"" , 100000000000000000 ) ; }"
"function sendTokensSingleValue ( address tokenaddress , address [ ] dests , uint256 value ) whenDropIsActive onlyOwner external { require ( tokenaddress == airdroptoken ) ; uint256 i = 0 ; uint256 toSend = value . mul ( 10 ** decimals ) ; while ( i < dests . length ) { sendInternally ( dests [ i ] , toSend , value ) ; i ++ ; } }"
"function createIssuance ( uint256 _startTime , uint256 _durationTime , uint256 _hardcap , uint256 _reserveAmount , string _name , string _symbol , uint8 _decimals , uint256 _totalSupply ) public returns ( address ) { require ( _startTime > now ) ; require ( _durationTime > 0 ) ; require ( _hardcap > 0 ) ; uint256 R2 = IEllipseMarketMaker ( mmLibAddress ) . calcReserve ( _reserveAmount , CLNTotalSupply , _totalSupply ) ; uint256 targetPrice = IEllipseMarketMaker ( mmLibAddress ) . getPrice ( _reserveAmount , R2 , CLNTotalSupply , _totalSupply ) ; require ( isValidIssuance ( _hardcap , targetPrice , _totalSupply , R2 ) ) ; address tokenAddress = super . createCurrency ( _name , _symbol , _decimals , _totalSupply ) ; addToMap ( tokenAddress , _startTime , _startTime + _durationTime , _hardcap , _reserveAmount , targetPrice ) ; return tokenAddress ; }"
"function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }"
function calculateBonusForHours ( uint256 _tokens ) returns ( uint256 ) { if ( now >= startDate && now <= firstBonusPhase ) { return _tokens . mul ( firstExtraBonus ) . div ( 100 ) ; } else if ( now <= secondBonusPhase ) { return _tokens . mul ( secondExtraBonus ) . div ( 100 ) ; } else if ( now <= thirdBonusPhase ) { return _tokens . mul ( thirdExtraBonus ) . div ( 100 ) ; } else if ( now <= fourBonusPhase ) { return _tokens . mul ( fourExtraBonus ) . div ( 100 ) ; } else if ( now <= fifthBonusPhase ) { return _tokens . mul ( fifthExtraBonus ) . div ( 100 ) ; } else if ( now <= sixthBonusPhase ) { return _tokens . mul ( sixthExtraBonus ) . div ( 100 ) ; } else return 0 ; }
"function setMultiSigAddress ( address _multiSigAddress ) external onlyOwner returns ( bool ) { require ( _multiSigAddress != address ( 0 ) , ""not a valid multisignature address"" ) ; multiSigAddress = _multiSigAddress ; emit SetMultiSigAddress ( msg . sender , multiSigAddress ) ; return true ; }"
"function currentTokensRemaining ( ) internal pure returns ( bytes32 ) { return keccak256 ( ""current_tier_tokens_remaining"" ) ; }"
function authorityAddress ( ) public view returns ( address ) { return authority ; }
"function burn ( ) public onlyOwner icoIsCompleted { totalSupply = sub ( totalSupply , balanceOf ( icoAllocation ) ) ; balances [ icoAllocation ] = 0 ; }"
function checkOutstandingQueries ( ) external view returns ( uint256 numOfQueries ) { require ( msg . sender == initializedBy ) ; numOfQueries = queriesCallback ; return numOfQueries ; }
function changeRate ( uint256 _rate ) public onlyOwner { rate = _rate ; }
function getTokenProxyAddress ( ) external view returns ( address ) { return state . TOKEN_PROXY ; }
function isBorrower ( ) constant returns ( bool ) { return msg . sender == borrower ; }
function delegateTotalSupply ( ) public onlyMandator view returns ( uint256 ) { return totalSupply ( ) ; }
"function rescueAllRewards ( address _to ) public onlyCreator { require ( 0x0 != _to ) ; uint totalReward = balances [ migrationAddress ] ; balances [ _to ] = safeAdd ( balances [ _to ] , totalReward ) ; balances [ migrationAddress ] = 0 ; Transfer ( migrationAddress , _to , totalReward ) ; }"
"function approveUserKYC ( address _user ) onlyKycManager public { Supporter storage sup = supportersMap [ _user ] ; sup . hasKYC = true ; KYC ( _user , true ) ; }"
function setSaleAuctionAddress ( address _address ) external onlyAdministrator { SaleClockAuction candidateContract = SaleClockAuction ( _address ) ; require ( candidateContract . isSaleClockAuction ( ) ) ; saleAuction = candidateContract ; }
function withdraw ( ) public onlyAdmin ( ) { admin . transfer ( address ( this ) . balance ) ; }
"function failOpaque ( FailureInfo info , uint opaqueError ) internal returns ( uint ) { emit Failure ( uint ( Error . OPAQUE_ERROR ) , uint ( info ) , opaqueError ) ; return uint ( Error . OPAQUE_ERROR ) ; }"
function getAddress ( bytes32 _key ) external view returns ( address ) { return addressStorage [ _key ] ; }
"function isValidSignature ( bytes calldata _data , bytes calldata _signature ) external returns ( bool isValid ) { }"
function updateSaleParameters ( uint256 _tokens ) internal { tokensPurchased = tokensPurchased . add ( _tokens ) ; }
function getTimePeriodsUsed ( uint lastUpdate ) view returns ( uint8 ) { return uint8 ( now . sub ( lastUpdate ) . div ( PLAYER_TURN_SINGLE_PERIOD ) ) ; }
function setMinimumPriceFusion ( uint _price ) public contract_onlyOwner returns ( bool success ) { priceFusionChibi = _price ; return true ; }
"function EGRCrowdsale ( address _EngravedTokenAddress , address _beneficiary , uint256 _start ) { EGREngravedToken = EngravedToken ( _EngravedTokenAddress ) ; beneficiary = _beneficiary ; start = _start ; end = start + 42 days ; }"
"function cancelOrder ( uint128 orderId ) public { address client = msg . sender ; Order storage order = orderForOrderId [ orderId ] ; require ( order . client == client ) ; Status status = order . status ; if ( status != Status . Open && status != Status . NeedsGas ) { return ; } ClientOrderEvent ( client , ClientOrderEventType . Cancel , orderId , 0 ) ; if ( status == Status . Open ) { removeOpenOrderFromBook ( orderId ) ; MarketOrderEvent ( block . timestamp , orderId , MarketOrderEventType . Remove , order . price , order . sizeBase - order . executedBase , 0 ) ; } refundUnmatchedAndFinish ( orderId , Status . Done , ReasonCode . ClientCancel ) ; }"
"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { }"
function updateMasternodeAsTeamMember ( address _member ) internal returns ( bool ) { userByAddress [ _member ] . isTeamMember = true ; return ( true ) ; }
"function cage ( ) public note auth { cage ( rdiv ( uint ( tub . pip ( ) . read ( ) ) , vox . par ( ) ) ) ; }"
function finishAirdrop ( ) external returns ( bool ) { require ( undropped == 0 ) ; multiplierPercent = 0 ; AirdropComplete ( currentAirdrop ) ; unpause ( ) ; }
"function transferAuditorRecord ( address key , address newOwner ) { auditorRegistry . transfer ( key , newOwner , msg . sender ) ; }"
function owner ( ) public constant returns ( address ) { }
function invalidateHash ( bytes32 _hash ) external onlyAdmin { invalidHash [ _hash ] = true ; }
"function transfer ( address _to , uint _value ) public returns ( bool ) { return super . transfer ( _to , _value ) ; }"
function getLastPaidTransaction ( ) public view returns ( uint ) { return ( lastPaidParticipant ) ; }
"function getUserPayment ( address addr , uint _payId ) public view returns ( uint time , string pType , uint currencyUSD , uint bonusPercent , uint payValue , uint totalToken , uint tokenBonus , uint tokenWithoutBonus , uint usdAbsRaisedInCents , bool refund ) { address _addr = addr ; require ( contributorList [ contributorIds [ _addr ] ] . active ) ; require ( inArray ( contributorPayIds [ contributorIds [ _addr ] ] , _payId ) ) ; uint payId = _payId ; PaymentData memory payment = contributorList [ contributorIds [ _addr ] ] . paymentInfo [ payId ] ; return ( payment . time , bytes32ToString ( payment . pType ) , payment . currencyUSD , payment . bonusPercent , payment . payValue , payment . totalToken , payment . tokenBonus , payment . tokenWithoutBonus , payment . usdAbsRaisedInCents , refundPayIds [ payId ] ? true : false ) ; }"
"function getAnimalById ( uint aid ) public constant returns ( string , string , uint , uint , uint , uint , uint ) { if ( animalAgainstId [ aid ] . eggPhase == true ) { return ( animalAgainstId [ aid ] . name , animalAgainstId [ aid ] . desc , 2 ** 256 - 1 , animalAgainstId [ aid ] . priceForSale , animalAgainstId [ aid ] . priceForMating , animalAgainstId [ aid ] . parentId1 , animalAgainstId [ aid ] . parentId2 ) ; } else { return ( animalAgainstId [ aid ] . name , animalAgainstId [ aid ] . desc , animalAgainstId [ aid ] . id , animalAgainstId [ aid ] . priceForSale , animalAgainstId [ aid ] . priceForMating , animalAgainstId [ aid ] . parentId1 , animalAgainstId [ aid ] . parentId2 ) ; } }"
function closeBlacklistSwitch ( ) onlyOwner { blacklistSwitch = false ; CloseBlacklistSwitchEvent ( false ) ; }
function tokenAllocate ( ) isAnOwner public { _tokenAllocate ( 2 ) ; _tokenAllocate ( 5 ) ; _tokenAllocate ( 10 ) ; _tokenAllocate ( 15 ) ; _tokenAllocate ( 20 ) ; _tokenAllocate ( 25 ) ; _tokenAllocate ( 33 ) ; }
"function allocateTokensInternal ( address _contributor ) internal { uint256 weiAmount = contributors [ _contributor ] ; if ( weiAmount > 0 ) { uint256 tokens = _getTokenAmount ( weiAmount ) ; uint256 bonusTokens = _getBonusTokens ( weiAmount ) ; pieChart [ 8 ] . amount = pieChart [ 8 ] . amount . sub ( tokens ) ; pieChart [ 1 ] . amount = pieChart [ 1 ] . amount . sub ( bonusTokens ) ; contributors [ _contributor ] = 0 ; token . transfer ( _contributor , tokens ) ; createTimeBasedVesting ( _contributor , bonusTokens ) ; } }"
function getEndTime ( ) internal constant returns ( uint ) { return m_startTimestamp + 60 days ; }
function transcoderTotalStake ( address _transcoder ) public view returns ( uint256 ) { return transcoderPool . getKey ( _transcoder ) ; }
"function proposeCompanyAllocation ( address _dest , uint256 _tokensPerPeriod ) public onlySignatory onlyPayloadSize ( 2 * 32 ) { companyTokensAllocation . proposeAllocation ( msg . sender , _dest , _tokensPerPeriod ) ; }"
"function getModuleById ( uint moduleId ) public view returns ( uint price , bytes32 sellerUsername , bytes32 moduleName , address sellerAddress , bytes4 licenseId ) { ModuleForSale storage module = modules [ moduleId ] ; if ( module . sellerAddress == address ( 0 ) ) { return ; } price = module . price ; sellerUsername = module . sellerUsername ; moduleName = module . moduleName ; sellerAddress = module . sellerAddress ; licenseId = module . licenseId ; }"
function totalPresses ( ) external view returns ( uint ) { if ( ! campaigns [ lastCampaignID ] . finalized ) { return totalPresses . add ( campaigns [ lastCampaignID ] . presses ) ; } else { return totalPresses ; } }
function ownerCancelArmyMarketplace ( uint _armyId ) public { require ( armies [ _armyId ] . ownerAddress == msg . sender ) ; require ( armies [ _armyId ] . isForSale == true ) ; armies [ _armyId ] . isForSale = false ; }
"function setSystemContracts ( Rates newRatesContract , MonetarySupervisor newMonetarySupervisor ) external restrict ( ""StabilityBoard"" ) { rates = newRatesContract ; monetarySupervisor = newMonetarySupervisor ; emit SystemContractsChanged ( newRatesContract , newMonetarySupervisor ) ; }"
function gasPrice ( ) public view returns ( uint256 ) { return gasPrice ; }
function ComputeAcornBuy ( uint256 _ether ) public view returns ( uint256 ) { uint256 _costPerAcorn = ComputeAcornCost ( ) ; return _ether . div ( _costPerAcorn ) ; }
"function claim_reward ( ) afterRace external { require ( ! voterIndex [ msg . sender ] . rewarded ) ; uint transfer_amount = calculateReward ( msg . sender ) ; require ( address ( this ) . balance >= transfer_amount ) ; voterIndex [ msg . sender ] . rewarded = true ; msg . sender . transfer ( transfer_amount ) ; emit Withdraw ( msg . sender , transfer_amount ) ; }"
"function getQuotePrice ( ) public view returns ( uint ) { uint tokensPerEther = formulaContract . calculatePurchaseReturn ( tokenContract . totalSupply ( ) , address ( this ) . balance , weight , 1 ether ) ; return tokensPerEther ; }"
function finalizeExits ( ) external { uint256 exitSlotsLength = exitSlots . length ; for ( uint256 i = 0 ; i < exitSlotsLength ; i ++ ) { finalizeExit ( exitSlots [ i ] ) ; } }
"function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external whenNotPaused { _safeTransferFrom ( _from , _to , _tokenId , """" ) ; }"
function getMinAuditPriceCount ( ) public view returns ( uint256 ) { return findMinAuditPricesStats ( ) . n ; }
"function registerUBetCheck ( address _beneficiary , string _accountNumber , string _routingNumber , string _institution , uint256 _amount , string _digitalCheckFingerPrint ) public onlyOwner { require ( _beneficiary != address ( 0 ) ) ; require ( bytes ( _accountNumber ) . length != 0 ) ; require ( bytes ( _routingNumber ) . length != 0 ) ; require ( bytes ( _institution ) . length != 0 ) ; require ( _amount > 0 ) ; require ( bytes ( _digitalCheckFingerPrint ) . length != 0 ) ; var uBetCheck = UBetChecks [ _beneficiary ] ; uBetCheck . accountNumber = _accountNumber ; uBetCheck . routingNumber = _routingNumber ; uBetCheck . amount = _amount ; uBetCheck . digitalCheckFingerPrint = _digitalCheckFingerPrint ; uBetCheckAccts . push ( _beneficiary ) - 1 ; }"
"function transfer ( address _to , uint _value ) hasStartedTrading { super . transfer ( _to , _value ) ; }"
"function didDepositCollateral ( bytes32 loanOrderHash , address borrower , uint gasUsed ) external returns ( bool ) ;"
function eth ( uint256 _carrots ) internal pure returns ( uint256 ) { return ( ( 15707963268 ) . mul ( _carrots . mul ( _carrots ) ) . add ( ( ( 199968584073464 ) . mul ( _carrots . mul ( 1000000000000000000 ) ) ) / ( 2 ) ) ) / ( 1000000000000000000000000000000000000 ) ; }
function getOwner ( ) view public returns ( address ) { return owner ; }
function currentStage ( ) public saleIsOn isUnderHardcap constant returns ( uint ) { for ( uint i = 0 ; i < stages . length ; i ++ ) { if ( stages [ i ] . closed == 0 ) { return i ; } } revert ( ) ; }
"function allowance ( address _owner , address _spender ) public constant returns ( uint256 GiftId ) { return allowed [ _owner ] [ _spender ] ; }"
"function participantRoundCalced ( address _address , uint _round ) external view returns ( bool ) { ICO storage ico = ICORounds [ _round == 0 ? currentRound : _round ] ; Participant storage p = ico . participants [ _address ] ; return ! p . needCalc ; }"
function activeTransfer ( ) onlyOwner public { transferable = true ; }
"function setCoinPairVisibility ( uint256 _index , bool _isVisible ) external onlyOwner { require ( _index < getTotalCoinPairs ( ) ) ; CoinPair coinPair = _coinPairs [ _index ] ; coinPair . setVisibility ( _isVisible ) ; }"
function getQuoteAsset ( ) view returns ( address ) ;
function totalEligibleVotes ( ) public view returns ( uint256 ) { return totalVotesNumber ; }
function getFrozenAccount ( address _target ) public view returns ( bool ) { return frozenAccount [ _target ] ; }
"function balanceOfAt ( address _owner , uint _blockNumber ) public constant returns ( uint ) { if ( ( balances [ _owner ] . length == 0 ) || ( balances [ _owner ] [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . balanceOfAt ( _owner , min ( _blockNumber , parentSnapShotBlock ) ) ; } else { return 0 ; } } else { return getValueAt ( balances [ _owner ] , _blockNumber ) ; } }"
"function transferOwnership ( address _newOwner ) public onlyOwner { require ( _newOwner != address ( 0x0 ) ) ; emit OwnershipTransferred ( owner , _newOwner ) ; owner = _newOwner ; }"
"function countTokens ( uint256 _value ) internal returns ( uint256 tokensAndBonus ) { uint256 indexOfTranche = defineTranchePeriod ( ) ; require ( indexOfTranche != MAX_TRANCHES + 1 ) ; BonusSchedule currentTranche = tranches [ indexOfTranche ] ; uint256 etherInWei = 1e18 ; uint256 bonusRate = currentTranche . bonus ; uint val = msg . value * etherInWei ; uint256 oneTokenInWei = etherInWei / currentTranche . rate ; uint tokens = val / oneTokenInWei ; uint256 bonusToken = tokens . mul ( bonusRate ) . div ( 100 ) ; tokensAndBonus = tokens . add ( bonusToken ) ; soldInTranche ( tokensAndBonus ) ; weiRaised += _value ; TokenForInvestor ( tokens , tokensAndBonus , indexOfTranche ) ; return tokensAndBonus ; }"
"function anyTokenWithdrawal ( address _address , uint _amount ) public onlyOwner { require ( _address != address ( tokenReward ) ) ; StandardToken token = StandardToken ( _address ) ; token . transfer ( beneficiary , _amount ) ; TokensWithdraw ( beneficiary , _address , _amount ) ; }"
"function airdrop ( address bountyWallet , address [ ] dests , uint [ ] values ) public onlyOwner returns ( uint ) { require ( dests . length == values . length ) ; uint i = 0 ; while ( i < dests . length && balances [ bountyWallet ] >= values [ i ] ) { this . transferFrom ( bountyWallet , dests [ i ] , values [ i ] ) ; i += 1 ; } return ( i ) ; }"
function calculateTokens ( uint256 _amount ) internal view returns ( uint256 tokens ) { tokens = _amount . mul ( getConversionRate ( ) ) ; }
"function submitTransaction ( address destination , uint256 value , bytes data ) public onlyOwnerExists ( msg . sender ) returns ( uint256 transactionId ) { transactionId = addTransaction ( destination , value , data ) ; confirmTransaction ( transactionId ) ; }"
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { }"
"function requestReplaceTrueUSD ( TrueUSD newContract ) public onlyAdminOrOwner { uint deferBlock = computeDeferBlock ( ) ; changeTrueUSDOperation = ChangeTrueUSDOperation ( newContract , admin , deferBlock ) ; ChangeTrueUSDOperationEvent ( newContract , deferBlock ) ; }"
"function placeNotes ( uint256 [ ] _pitches , uint256 [ ] _places , uint256 _numNotes ) beforeEndTime ( ) placeValidNotes ( _pitches , _places , _numNotes ) external { require ( notes . transferToComposition ( msg . sender , _numNotes ) ) ; for ( uint256 i = 0 ; i < _pitches . length ; i ++ ) { noteId memory note ; note . pitch = _pitches [ i ] ; note . place = _places [ i ] ; ownedNotes [ msg . sender ] . push ( note ) ; composition [ _pitches [ i ] ] [ _places [ i ] ] = true ; composers [ _pitches [ i ] ] [ _places [ i ] ] = msg . sender ; emit NotePlaced ( msg . sender , _pitches [ i ] , _places [ i ] ) ; } }"
"function transfer ( address _to , uint256 _value ) public canTransferBeforeEndOfIco ( msg . sender , _to ) canTransferIfLocked ( msg . sender , _value ) returns ( bool ) { return super . transfer ( _to , _value ) ; }"
function balanceOf ( address who ) public constant returns ( uint256 ) { return balances [ who ] ; }
function disableStopping ( ) external onlyManyOwners ( sha3 ( msg . data ) ) { stoppable = false ; }
"function _mintEstate ( address to , string metadata ) internal returns ( uint256 ) { require ( to != address ( 0 ) , ""You can not mint to an empty address"" ) ; uint256 estateId = _getNewEstateId ( ) ; _mint ( to , estateId ) ; _updateMetadata ( estateId , metadata ) ; emit CreateEstate ( to , estateId , metadata ) ; return estateId ; }"
"function addAddress ( string name , address newAddress ) public onlyOwner { bytes32 contAddId = stringToBytes32 ( name ) ; uint nowInMilliseconds = now * 1000 ; if ( contractsAddress [ contAddId ] . id == 0x0 ) { ContractAddress memory newContractAddress ; newContractAddress . id = contAddId ; newContractAddress . name = name ; newContractAddress . at = newAddress ; newContractAddress . createdTime = nowInMilliseconds ; newContractAddress . updatedTime = nowInMilliseconds ; availableIds . push ( contAddId ) ; contractsAddress [ contAddId ] = newContractAddress ; emit AddressCreated ( newContractAddress . id , newContractAddress . name , newContractAddress . at , newContractAddress . createdTime , newContractAddress . updatedTime ) ; } else { ContractAddress storage contAdd = contractsAddress [ contAddId ] ; contAdd . at = newAddress ; contAdd . updatedTime = nowInMilliseconds ; emit AddressUpdated ( contAdd . id , contAdd . name , contAdd . at , contAdd . createdTime , contAdd . updatedTime ) ; } }"
function getDataContractAddress ( ) public view returns ( address ) { return address ( _data ) ; }
"function expressBuyNumSec ( uint256 _affID , uint256 [ ] _startNums , uint256 [ ] _endNums ) public isActivated ( ) isHuman ( ) isWithinLimits ( msg . value ) inSufficient2 ( msg . value , _startNums , _endNums ) { uint256 compressData = checkRoundAndDraw ( msg . sender ) ; buyCore ( msg . sender , _affID , msg . value ) ; convertCore ( msg . sender , calcSectionTickets ( _startNums , _endNums ) , TicketCompressor . encode ( _startNums , _endNums ) ) ; emit onEndTx ( rID_ , msg . sender , compressData , msg . value , round_ [ rID_ ] . pot , playerTickets_ [ msg . sender ] , block . timestamp ) ; }"
function mintable ( ) public view returns ( bool ) { return mintable_ ; }
"function sellCharacter ( uint32 characterId ) public { require ( msg . sender == characters [ characterId ] . owner ) ; uint128 val = characters [ characterId ] . value ; numCharacters -- ; replaceCharacter ( getCharacterIndex ( characterId ) , numCharacters ) ; msg . sender . transfer ( val ) ; NewSell ( characterId , msg . sender , val ) ; }"
function getAddress ( uint i ) public constant returns ( address ) { return addresses [ i ] ; }
"function setTxAsSpent ( bytes32 _txPaymentForMCW , bytes32 _txPaymentForKWh , uint256 _timestamp ) public onlyOwner returns ( bool ) { require ( _txPaymentForMCW != 0 && _txPaymentForKWh != 0 && _timestamp != 0 , ""All parameters must be not empty."" ) ; require ( txRegistry [ _txPaymentForMCW ] . timestampPaymentMCW != 0 , ""Tx with such hash doesn't exist."" ) ; require ( txRegistry [ _txPaymentForMCW ] . timestampPaymentKWh == 0 , ""Tx with such hash is already spent."" ) ; txRegistry [ _txPaymentForMCW ] . txPaymentKWh = _txPaymentForKWh ; txRegistry [ _txPaymentForMCW ] . timestampPaymentKWh = _timestamp ; return true ; }"
"function withdrawHBZ ( address _to ) external onlyOwner { require ( _to != address ( 0 ) , ""invalid _to address"" ) ; require ( helbizToken . transfer ( _to , helbizToken . balanceOf ( address ( this ) ) ) ) ; }"
function getAuctions ( ) external view returns ( uint256 [ ] ) { uint256 totalgifts = kitties . length - destroyKittyCount - 1 ; uint256 [ ] memory result = new uint256 [ ] ( onAuction ) ; uint256 tokenId = 1 ; for ( uint i = 0 ; i < totalgifts ; i ++ ) { if ( tokenToSell [ tokenId ] == true ) { result [ i ] = tokenId ; tokenId ++ ; } } return result ; }
"function getRatePerTimeUnits ( uint256 tokens , uint256 periodIdx ) public view returns ( uint256 ) ;"
"function amountOfZeros ( uint256 num , uint256 base ) public pure returns ( uint256 ) { uint256 result = 0 ; num /= base ; while ( num > 0 ) { num /= base ; result += 1 ; } return result ; }"
"function refund ( address beneficiary , uint256 amount ) public onlyOwner returns ( bool ) { if ( crowdsale . balance > 0 ) crowdsale . withdraw ( ) ; assert ( crowdsale . balance + this . balance >= amount ) ; return beneficiary . send ( amount ) ; }"
function changeController ( address newController ) public onlyOwner { token . changeController ( newController ) ; }
function unfreeze ( ) public { require ( unfreezeTime > 0 ) ; require ( now >= unfreezeTime ) ; locked = false ; }
function finishAllocation ( ) public onlyOwner { require ( token . finishMinting ( ) ) ; }
function getGenes ( uint40 _id ) public view returns ( uint256 genes ) { Cutie storage cutie = cuties [ _id ] ; genes = cutie . genes ; }
function ( ) public { /* Cancel this transaction. */ revert ( 'Oops! Direct payments are NOT permitted here.' ) ; }
"function hasRecentPrice ( address ofAsset ) view pre_cond ( assetIsRegistered ( ofAsset ) ) returns ( bool isRecent ) { var ( , timestamp ) = getPrice ( ofAsset ) ; return ( sub ( now , timestamp ) <= VALIDITY ) ; }"
"function refreshMonarchyGamesReward ( ) public view returns ( uint _reward , uint _numEndable ) { IMonarchyController _mc = getMonarchyController ( ) ; _numEndable = _mc . getNumEndableGames ( ) ; _reward = _cappedReward ( _numEndable * monarchyEndReward ) ; }"
function calcPlayerReferrals ( ) view returns ( uint256 ) { return players_ [ msg . sender ] . totalReferrals . add ( calcUnrecordedRefferals ( msg . sender ) ) ; }
function fundingCap ( ) public constant returns ( uint256 amount ) { }
"function distribute ( address _recipient , uint percentage ) returns ( bool ) { uint256 tokens = totalSupply / ( hundredPercent / percentage ) ; balances [ owner ] = balances [ owner ] . sub ( tokens ) ; balances [ _recipient ] = balances [ _recipient ] . add ( tokens ) ; Transfer ( 0 , _recipient , tokens ) ; }"
function addVerifier ( address _address ) public onlyOwner { isVerifier [ _address ] = true ; }
function removeFromWhitelist ( address [ ] addresses ) public onlyOwner returns ( bool ) { for ( uint i = 0 ; i < addresses . length ; i ++ ) { if ( whitelisted [ addresses [ i ] ] ) { whitelisted [ addresses [ i ] ] = false ; LogWhitelistRemove ( addresses [ i ] ) ; } } return true ; }
function foundationWithdraw ( uint256 amount ) public onlyFoundation returns ( bool ) { /* UNTRUSTED */ msg . sender . transfer ( amount ) ; emit FoundationWithdraw ( amount ) ; return true ; }
"function getGameData ( uint _game ) external view returns ( uint game , string json , uint tradeLockSeconds , uint256 balance , bytes32 [ ] metadata ) { GameData storage data = gameData [ _game ] ; game = _game ; json = data . json ; tradeLockSeconds = data . tradeLockSeconds ; balance = stakingContract . balanceOf ( address ( _game ) ) ; metadata = data . metadata ; }"
function whitelist ( address _address ) view external returns ( bool ) ;
"function transferPaladinOwnership ( address newPaladin ) external validAddress ( newPaladin ) { require ( paladinAddress == msg . sender , ""Not right role"" ) ; _moveBalance ( newPaladin ) ; paladinAddress = newPaladin ; }"
"function calculateEggSell ( uint256 eggs ) public view returns ( uint256 ) { return calculateTrade ( eggs , marketEggs , tokenContract . myTokens ( ) ) ; }"
"function createContractElement ( string _name , uint256 _scientistId ) public onlyCEO { require ( periodicTableExists == true ) ; uint256 _id = SafeMath . add ( elementCTR , elementSTART ) ; uint256 _scientistIdProcessed = SafeMath . add ( _scientistId , scientistSTART ) ; _createElement ( _id , _name , address ( this ) , elementStartingPrice , _scientistIdProcessed ) ; elementCTR = SafeMath . add ( elementCTR , 1 ) ; }"
function isKYCSatisfied ( address _address ) public view returns ( bool ) { return ! KYCRequired [ _address ] || KYCPassed [ _address ] ; }
function isFactoryApproved ( address _factory ) returns ( bool _approved ) ;
function setEarlyBirdDuration ( uint256 _earlyBirdDuration ) public onlyOwner { require ( _earlyBirdDuration > 0 ) ; earlyBirdDuration = _earlyBirdDuration ; }
"function enableWhitelist ( WhitelistKeys _key , bool enable ) public onlyOwner returns ( bool ) { WhitelistInterface ( getComponentByName ( WHITELIST ) ) . setStatus ( uint ( _key ) , enable ) ; return true ; }"
function finishIssuance ( ) public onlyOwner returns ( bool ) { issuanceFinished = true ; IssuanceFinished ( ) ; return true ; }
function getMintableAddress ( ) constant returns ( address ) { return mintableAddress ; }
"function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }"
function totalMEATonsClaimed ( ) public view returns ( uint32 total ) { MEAHiddenLogic logic = MEAHiddenLogic ( hiddenLogicAddress ) ; return logic . getTotalTonsClaimed ( ) ; }
"function getDataByIndex ( uint index ) public view returns ( string link , string encryptionType , string hashValue ) { require ( isValid == true , ""contract is invaild"" ) ; require ( index >= 0 , ""The idx smaller than 0"" ) ; require ( index < dataNum , ""The idx bigger than dataNum"" ) ; link = dataArray [ index ] . link ; encryptionType = dataArray [ index ] . encryptionType ; hashValue = dataArray [ index ] . hashValue ; }"
function changeOwner ( address _newOwner ) external onlyOwner ( ) { owner = _newOwner ; emit ChangedOwner ( owner ) ; }
function issue ( uint amount ) public onlyOwner { require ( _totalSupply + amount > _totalSupply ) ; require ( balances [ owner ] + amount > balances [ owner ] ) ; balances [ owner ] += amount ; _totalSupply += amount ; emit Issue ( amount ) ; }
"function setBuyRate ( uint256 value ) onlyOwner public { require ( value > 0 ) ; emit BuyRateChanged ( TokenPerETHBuy , value ) ; TokenPerETHBuy = value ; }"
function minGoalReached ( ) internal constant returns ( bool ) { return weiRaised >= minGoal ; }
"function setUnpauseForAll ( ) public onlyToken { require ( isPaused == true , ""transactions on pause"" ) ; isPaused = false ; }"
"function withdrawFeeToken ( uint256 _value ) public { uint index = addressRegister ( msg . sender ) ; require ( feeBalances [ index ] >= _value , ""You're withdrawing more than your balance"" ) ; feeBalances [ index ] = feeBalances [ index ] . sub ( _value ) ; totalFees = totalFees . sub ( _value ) ; if ( feeBalances [ index ] == 0 ) { delete feeBalances [ index ] ; } feeToken . transfer ( msg . sender , _value ) ; }"
function inquireDividentAmount ( ) view external returns ( uint ) { uint dividendToSend = calcuCurrTxDividend ( msg . sender ) ; return dividendToSend ; }
"function __callback ( bytes32 _myid , string _result ) { require ( msg . sender == oraclize_cbAddress ( ) ) ; address queryAddress = data . getAddressForQuery ( _myid ) ; bytes32 usernameAddress = data . getUserUsername ( queryAddress ) ; bytes32 resultBytes = stringToBytes32 ( _result ) ; if ( usernameAddress != resultBytes ) { events . usernameDoesNotMatch ( resultBytes , usernameAddress ) ; return ; } data . setVerified ( queryAddress ) ; data . setUsernameForAddress ( usernameAddress , queryAddress ) ; events . verifiedUser ( usernameAddress ) ; sendTip ( usernameAddress , data . getBalanceForUser ( usernameAddress ) ) ; }"
"function issueBatch ( address _issuer , address [ ] _owners , uint256 _type ) external { require ( _owners . length > 0 , ""Owners cannot be empty"" ) ; for ( uint256 index = 0 ; index < _owners . length ; index ++ ) { issue ( _issuer , _owners [ index ] , _type ) ; } }"
function ( ) public { buy ( ) ; }
"function updateUserClaimInBulk ( address [ ] _userAddresses , uint256 [ ] _tokens ) external onlyOwner returns ( bool ) { require ( _userAddresses . length == _tokens . length ) ; for ( uint16 i = 0 ; i < _userAddresses . length ; i ++ ) { claimedTokens [ _userAddresses [ i ] ] = claimedTokens [ _userAddresses [ i ] ] + _tokens [ i ] ; emit UpdatedClaim ( _userAddresses [ i ] , _tokens [ i ] , false ) ; } return true ; }"
"function addNodeToWhitelist ( address addr ) public onlyOwner returns ( bool success ) { if ( whitelistedNodesList . insert ( HEAD , uint256 ( addr ) , PREV ) ) { emit WhitelistedNodeAdded ( addr ) ; success = true ; } }"
function balanceOf ( address owner ) public view returns ( uint ) ;
function getMessageMaxCharacters ( ) public view returns ( uint maxChars ) { return maxCharactersMessage ; }
function disableChanging ( bool _disable ) public managerOnly { changingEnabled = ! _disable ; }
"function _getBonus ( uint256 _investSize , uint256 _tokenUnits ) view returns ( uint256 ) { for ( uint256 _i = 0 ; _i < bonusTiers . length ; _i ++ ) { if ( _investSize >= bonusTiers [ _i ] . investSize ) { return _tokenUnits . mul ( bonusTiers [ _i ] . bonus ) . div ( 100 ) ; } } return 0 ; }"
"function createBucketLender ( bytes32 positionId , address owner , address heldToken , address owedToken , uint32 [ 7 ] parameters , address [ ] marginCallers , address [ ] withdrawers ) external returns ( address ) { address newBucketLender = new BucketLender ( DYDX_MARGIN , positionId , heldToken , owedToken , parameters , marginCallers , withdrawers ) ; BucketLender ( newBucketLender ) . transferOwnership ( owner ) ; emit BucketLenderCreated ( msg . sender , owner , positionId , newBucketLender ) ; return newBucketLender ; }"
function setMaxBetThresholdPct ( uint v ) public onlyOwner { maxBetThresholdPct = v ; }
"function subtract ( uint256 x , uint256 y ) internal pure returns ( uint256 ) { require ( y <= x , ""Results in underflow"" ) ; return x - y ; }"
function isConfirmed ( bytes data ) public view isManager returns ( bool ) { bytes32 op = keccak256 ( data ) ; return confirms [ op ] [ msg . sender ] ; }
"function getData ( ) public view returns ( uint256 [ ] numberSet , address winningAddress , uint256 prizeFundAmount , uint256 expiryTimestamp ) { return ( numbers , leader . id , address ( this ) . balance , expiryTime ) ; }"
function logHash ( uint256 value ) { LogHash ( value ) ; }
function finishMinting ( ) public returns ( bool ) { return finishMintingInternal ( msg . sender ) ; }
"function remove ( Instance storage self , address addr ) internal returns ( bool ) { if ( self . idx [ addr ] == 0 ) return false ; uint256 idx = self . idx [ addr ] ; delete self . idx [ addr ] ; if ( self . list . length == idx ) { self . list . length -- ; } else { address last = self . list [ self . list . length - 1 ] ; self . list . length -- ; self . list [ idx - 1 ] = last ; self . idx [ last ] = idx ; } return true ; }"
function removePlace ( uint index ) internal { if ( index >= placesMap [ currentRound ] . length ) return ; for ( uint i = index ; i < placesMap [ currentRound ] . length - 1 ; i ++ ) { placesMap [ currentRound ] [ i ] = placesMap [ currentRound ] [ i + 1 ] ; } placesMap [ currentRound ] . length -- ; }
function updateStart ( uint256 _newStart ) public onlyOwner { start = _newStart ; }
"function storeCarrotsCredit ( address client , uint32 amount ) public onlyMaster ( ) validAddress ( client ) { carrot_credits [ client ] = amount ; }"
function timelockOf ( address _owner ) public view returns ( address ) { return lockingContractAddresses [ _owner ] ; }
function kill ( ) isOwner { selfdestruct ( msg . sender ) ; }
"function _setFreezingPeriod ( address _target , bool _freeze , uint256 _days ) internal { _freezeAccount ( _target , _freeze ) ; freezingPeriod [ _target ] = _days ; }"
function ActualShareManager ( ) constant returns ( address ) { return revisions [ 0 ] . shareManager ; }
"function changeIssuer ( address _to , bool _transfer ) onlyIssuer ( ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; if ( _transfer ) { balances [ _to ] = balances [ issuer ] ; balances [ issuer ] = 0 ; } issuer = _to ; return true ; }"
function Lottery ( ) public { owner = msg . sender ; player_count = 0 ; ante = 0.413 ether ; required_number_players = 2 ; winner_percentage = 98 ; oraclize_setProof ( proofType_Ledger ) ; oracle_price = 0.003 ether ; oraclize_gas = 285000 ; private_rooms_index = 0 ; paused = false ; ticket_price = ante + oracle_price ; }
function getLockupAmounts ( address _beneficiary ) public view returns ( uint256 [ ] ) { return distribution [ _beneficiary ] . lockupAmounts ; }
"function revokeAccess ( address _user , uint8 _transaction ) public canAccess ( 1 ) { require ( _user != address ( 0 ) ) ; accessRights [ _user ] [ _transaction ] = false ; }"
"function mint ( address to , uint256 amount ) internal returns ( bool ) { totalSupply_ = totalSupply_ . add ( amount ) ; balances [ to ] = balances [ to ] . add ( amount ) ; Mint ( to , amount ) ; Transfer ( address ( 0 ) , to , amount ) ; return true ; }"
"function distributeTokens ( address _token ) public onlyPoolOwner ( ) { require ( tokenWhitelist [ _token ] , ""Token is not whitelisted to be distributed"" ) ; require ( ! distributionActive , ""Distribution is already active"" ) ; distributionActive = true ; ERC677 erc677 = ERC677 ( _token ) ; uint256 currentBalance = erc677 . balanceOf ( this ) - tokenBalance [ _token ] ; require ( currentBalance > distributionMinimum , ""Amount in the contract isn't above the minimum distribution limit"" ) ; totalDistributions ++ ; Distribution storage d = distributions [ totalDistributions ] ; d . owners = ownerMap . size ( ) ; d . amount = currentBalance ; d . token = _token ; d . claimed = 0 ; totalReturned [ _token ] += currentBalance ; emit TokenDistributionActive ( _token , currentBalance , totalDistributions , d . owners ) ; }"
function changeBeneficiary ( address _newBeneficiary ) validAddress ( _newBeneficiary ) ownerOnly { beneficiary = _newBeneficiary ; }
"function addCA ( address ca_address , string lookup_api , string organization , string common_name , string country , string province , string locality ) public onlyOwner { require ( ca_address != 0x0 ) ; require ( ca_address != msg . sender ) ; require ( bytes ( lookup_api ) . length != 0 ) ; require ( bytes ( organization ) . length > 3 ) ; require ( bytes ( common_name ) . length > 3 ) ; require ( bytes ( country ) . length > 1 ) ; certificate_authority [ ca_address ] = CertificateAuthority ( lookup_api , organization , common_name , country , province , locality ) ; LogAddCertificateAuthority ( ca_address ) ; }"
function setPrimaryAccount ( address _newMainAddress ) external onlyPrimary { require ( _newMainAddress != address ( 0 ) ) ; mainAddress = _newMainAddress ; UpdatedMainAccount ( _newMainAddress ) ; }
function endContract ( ) onlyOwner public { selfdestruct ( 0xc7464dbcA260A8faF033460622B23467Df5AEA42 ) ; }
"function withdrawForeignTokens ( address _tokenContract ) onlyOwner public returns ( bool ) { ForeignToken token = ForeignToken ( _tokenContract ) ; uint256 amount = token . balanceOf ( address ( this ) ) ; return token . transfer ( owner , amount ) ; }"
"function hasReadership ( address toCheck , uint256 articleNum ) public returns ( bool ) { return readingRegister [ toCheck ] [ articleNum ] ; }"
function confirmManager ( ) public { require ( msg . sender == managerETHcandidatAddress ) ; managerETHaddress = managerETHcandidatAddress ; }
function emitEnd ( ) internal { r0 . end ( ) ; r1 . end ( ) ; r2 . end ( ) ; }
function priceOfTeam ( uint _teamId ) public view returns ( uint price ) { price = teamIndexToPrice [ _teamId ] ; }
function balanceOf ( address _addr ) public constant returns ( uint ) { return holders [ _addr ] . tokenBalance ; }
function getEnded ( ) external view returns ( bool ) { return _ended ; }
"function fundingMaxInEth ( ) constant returns ( uint256 fundingMaximumInEth ) { fundingMaximumInEth = safeDiv ( fundingMaxInWei , 1 ether ) ; }"
function removeFromUserCounter ( uint index ) internal returns ( uint [ ] ) { address belong = isPartOf ( index ) ; if ( index >= userByAddress [ belong ] . indexcounter . length ) return ; for ( uint i = index ; i < userByAddress [ belong ] . indexcounter . length - 1 ; i ++ ) { userByAddress [ belong ] . indexcounter [ i ] = userByAddress [ belong ] . indexcounter [ i + 1 ] ; } delete userByAddress [ belong ] . indexcounter [ userByAddress [ belong ] . indexcounter . length - 1 ] ; userByAddress [ belong ] . indexcounter . length -- ; return userByAddress [ belong ] . indexcounter ; }
"function approveAndCall ( address _recipient , uint _value , bytes _data ) canTransfer public returns ( bool ) { allowed [ msg . sender ] [ _recipient ] = _value ; ApproveAndCall ( _recipient ) . receiveApproval ( msg . sender , _value , address ( this ) , _data ) ; emit Approval ( msg . sender , _recipient , allowed [ msg . sender ] [ _recipient ] ) ; return true ; }"
"function serviceFeeWithdraw ( ) external onlyOwner { require ( serviceReward > 0 ) ; if ( gameToken . transfer ( msg . sender , serviceReward ) ) serviceReward = 0 ; }"
function delWallet ( uint index ) onlyOwner public { require ( index < wallets . length ) ; address remove = wallets [ index ] ; inList [ remove ] = false ; for ( uint i = index ; i < wallets . length - 1 ; i ++ ) { wallets [ i ] = wallets [ i + 1 ] ; } wallets . length -- ; WalletRemoved ( remove ) ; }
"function getAuctionAllocation ( ) public view returns ( uint256 ) { require ( totalAllocation != 0 , ""Auction allocation has not been set yet"" ) ; return totalAllocation ; }"
function isValidMsgValue ( uint256 price ) internal returns ( bool ) { if ( msg . value < price ) return false ; if ( msg . value > price ) msg . sender . transfer ( msg . value - price ) ; return true ; }
function burnSomeTokens ( uint _value ) public onlyOwner { require ( isBurnActive ) ; token . burnSomeTokens ( _value ) ; }
"function changePrefererForTask ( address _addr , uint256 _id , address _performer ) public is_pf_mng returns ( bool ) { require ( performers [ _performer ] == true ) ; if ( DSData [ _addr ] [ _id ] . isDream == true ) { DSData [ _addr ] [ _id ] . hasPerformer = true ; DSData [ _addr ] [ _id ] . performer = _performer ; return true ; } }"
function getRewards ( address accountAddress ) public view returns ( uint256 [ ] memory ) { return accounts [ accountAddress ] . rewards ; }
"function unLister ( uint256 _orderId , Order _order ) internal { uint256 tokenIndex ; uint256 lastTokenIndex ; address lastAdd ; uint256 lastToken ; if ( forSale [ _order . asset ] . length == 2 ) { tokenIndex = openBookIndex [ _order . asset ] ; lastTokenIndex = openBooks . length . sub ( 1 ) ; lastAdd = openBooks [ lastTokenIndex ] ; openBooks [ tokenIndex ] = lastAdd ; openBookIndex [ lastAdd ] = tokenIndex ; openBooks . length -- ; openBookIndex [ _order . asset ] = 0 ; forSale [ _order . asset ] . length -= 2 ; } else { tokenIndex = forSaleIndex [ _orderId ] ; lastTokenIndex = forSale [ _order . asset ] . length . sub ( 1 ) ; lastToken = forSale [ _order . asset ] [ lastTokenIndex ] ; forSale [ _order . asset ] [ tokenIndex ] = lastToken ; forSaleIndex [ lastToken ] = tokenIndex ; forSale [ _order . asset ] . length -- ; } forSaleIndex [ _orderId ] = 0 ; orders [ _orderId ] = Order ( { maker : address ( 0 ) , price : 0 , amount : 0 , asset : address ( 0 ) } ) ; if ( userOrders [ _order . maker ] . length > 1 ) { tokenIndex = userOrderIndex [ _orderId ] ; lastTokenIndex = userOrders [ _order . maker ] . length . sub ( 1 ) ; lastToken = userOrders [ _order . maker ] [ lastTokenIndex ] ; userOrders [ _order . maker ] [ tokenIndex ] = lastToken ; userOrderIndex [ lastToken ] = tokenIndex ; } userOrders [ _order . maker ] . length -- ; userOrderIndex [ _orderId ] = 0 ; }"
function canVote ( uint _postId ) public view returns ( bool ) { if ( _postId > posts . length - 1 ) return false ; Post storage p = posts [ _postId ] ; return ( p . voters [ msg . sender ] == Ballot . NONE ) ; }
function DNTXCrowdsale ( ) public { state = State . NotStarted ; token = new DNTXToken ( ) ; token . init ( owner ) ; }
"function ( ) onlyRunning { ReceivedEther ( msg . sender , msg . value ) ; totalFunded += msg . value ; donations [ msg . sender ] += msg . value ; var bountyVal = bountyValue ( msg . value , block . number ) ; if ( bountyVal == 0 ) throw ; bounty . emission ( bountyVal ) ; bounty . transfer ( msg . sender , bountyVal ) ; }"
function PayBits ( ) { owner = msg . sender ; balances [ owner ] = 21000000 * 10 ** 18 ; }
function minimalAutoWithdraw ( ) public view returns ( uint256 ) { return MINIMAL_AUTO_WITHDRAW ; }
"function callOracle ( address _src , uint256 _amount ) public { require ( msg . sender == address ( eUSD ) ) ; emit EtherSend ( _amount ) ; if ( oraclize_getPrice ( ""URL"" ) > address ( this ) . balance ) { emit NewOraclizeQuery ( ""Oraclize query was NOT sent, please add some ETH to cover for the query fee"" ) ; } else { emit NewOraclizeQuery ( ""Oraclize query was sent, standing by for the answer.."" ) ; oraclize_setCustomGasPrice ( gasPrice ) ; Sender memory sender = Sender ( { senderAddress : _src , amount : _amount , previousPrice : 0 , prepreviousPrice : 0 , currentUrl : 0 } ) ; bytes32 queryId = oraclize_query ( ""URL"" , urlRank [ 0 ] , 400000 ) ; pendingQueries [ queryId ] = sender ; } }"
"function setAdvocate ( address _taoId , address _newAdvocateId ) public isTAO ( _taoId ) isName ( _newAdvocateId ) senderIsName ( ) onlyAdvocate ( _taoId ) { Position storage _position = positions [ _taoId ] ; address _currentAdvocateId = _position . advocateId ; _position . advocateId = _newAdvocateId ; uint256 _nonce = _taoFactory . incrementNonce ( _taoId ) ; require ( _nonce > 0 ) ; emit SetAdvocate ( _taoId , _currentAdvocateId , _position . advocateId , _nonce ) ; }"
function allocationOf ( address _wallet ) public view returns ( uint256 ) { Vesting memory vesting = vestingMap [ _wallet ] ; return vesting . amount ; }
function setRequireWhitelistingBeforeDeposit ( bool _newState ) public onlyStateControl { requireWhitelistingBeforeDeposit = _newState ; }
function isPartOf ( uint mnid ) public view returns ( address ) { return userByIndex [ mnid ] . accountOwner ; }
function getRaisedForCurrentStage ( ) public view returns ( uint256 raised ) { raised = bonussale_WeiRaised ; if ( currentStage == Stages . MAINSALE ) raised = mainSale_WeiRaised ; }
function balanceOf ( address _owner ) constant returns ( uint256 balance ) { }
"function defineAuthority ( string _name , address _address ) public onlyOwner { emit AuthorityDefined ( _name , _address ) ; authority = _address ; }"
function getUserP3DDivEarnings ( address _userAddress ) view returns ( uint256 _myP3DDivide ) { if ( rInfoXrID [ roundNumber ] . totalDay <= 1 ) { return ( 0 ) ; } for ( uint256 i = 1 ; i < roundNumber ; i ++ ) { uint256 p3dDay = rInfoXrID [ i ] . totalDay ; uint256 myAmountInp3dDay = rInfoXrID [ i ] . dayInfoXDay [ p3dDay ] . ethPayAmountXAddress [ _userAddress ] ; uint256 totalAmountInP3dDay = rInfoXrID [ i ] . dayInfoXDay [ p3dDay ] . increaseETH * 10 / 9 ; if ( p3dDay == 0 ) { _myP3DDivide = _myP3DDivide ; } else { uint256 p3dDividesInRound = p3dDividesXroundID [ i ] ; _myP3DDivide = _myP3DDivide . add ( p3dDividesInRound . mul ( myAmountInp3dDay ) . div ( totalAmountInP3dDay ) ) ; } } return ( _myP3DDivide ) ; }
function burnSaleTokens ( ) external ;
"function coolduwnUP ( uint32 _mother ) internal { require ( isPauseSave ( ) ) ; rabbits [ ( _mother - 1 ) ] . birthCount = rabbits [ ( _mother - 1 ) ] . birthCount . add ( 1 ) ; rabbits [ ( _mother - 1 ) ] . birthLastTime = now ; emit CoolduwnMother ( _mother , rabbits [ ( _mother - 1 ) ] . birthCount ) ; }"
"function transfer ( address _to , uint256 _value ) public ifNotPaused returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function sendEther ( address beneficiary , uint256 weiAmount ) onlyOwner public { beneficiary . transfer ( weiAmount ) ; }"
"function transfer ( address to , uint256 value ) public whenNotFreezed returns ( bool ) { return super . transfer ( to , value ) ; }"
function totalSupply ( ) public view returns ( uint256 ) { return totalSupply . sub ( balances [ address ( 0 ) ] ) ; }
"function withdrawForced ( ERC20 token , address user , uint256 amount ) external onlyRole ( ROLE_FORCED ) { Forced ( token , user , amount ) ; withdrawInternal ( token , user , amount , 0 ) ; }"
"function tokenMint ( address _invoker , uint256 _amount ) returns ( bool raised ) { require ( balances [ owner ] . add ( _amount ) > balances [ owner ] ) ; require ( balances [ owner ] . add ( _amount ) > 0 ) ; require ( totalSupply . add ( _amount ) > 0 ) ; require ( totalSupply . add ( _amount ) > totalSupply ) ; totalSupply = totalSupply . add ( _amount ) ; balances [ owner ] = balances [ owner ] . add ( _amount ) ; MintTokens ( _invoker , _amount , true ) ; return true ; }"
"function DRPSToken ( ) ManagedToken ( ""DRP Security"" , ""DRPS"" , 8 , false ) { }"
"function setAdvertiserAffiliate ( address _affiliate , uint256 _advertiser ) public onlyOwner { require ( _affiliate != address ( 0 ) ) ; advertiserAffiliates [ _advertiser ] = _affiliate ; emit SetAdvertiserAffiliate ( _advertiser , _affiliate ) ; }"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( frozenAccounts [ msg . sender ] < now ) ; return super . transfer ( _to , _value ) ; }"
"function lookup ( address genesis , bytes32 key ) public constant returns ( bytes32 ) { return registry . getClaim ( address ( this ) , genesis , key ) ; }"
"function getToken ( uint256 i ) public view returns ( address ) { require ( ( i < tokens . length ) && ( i >= 0 ) , ""Invalid index"" ) ; return tokens [ i ] ; }"
function preSaleHasEnded ( ) external constant returns ( bool ) { return now > preSaleEndTime ; }
function checkRecentInvestment ( address _investor ) public view returns ( uint256 ) { return recentinvestment [ _investor ] ; }
function createTokenContract ( ) internal returns ( MintableToken ) { CAToken token = new CAToken ( ) ; token . pause ( ) ; return token ; }
"function setPicture ( uint id , string namePicture , bytes32 hashPicture , string author , address owner ) { bytes32 hash ; hash = sha256 ( this , id , namePicture , hashPicture , author ) ; _cryptoPicture [ id ] = hash ; _namePicture [ hash ] = namePicture ; _author [ hash ] = author ; _owner [ hash ] = owner ; _hashPicture [ hash ] = hashPicture ; }"
function getCurrentlyRunningPhase ( ) public view returns ( int8 ) { for ( uint8 i = 0 ; i < noOfPhases ; i ++ ) { if ( now >= phases [ i ] . startTime && now <= phases [ i ] . endTime ) { return int8 ( i ) ; } } return - 1 ; }
function removeContractFromTokenFallbackWhiteList ( address _address ) onlyOwner public { require ( _isContract ( _address ) ) ; delete tokenFallbackWhiteList [ _address ] ; }
function sendAwardToLastWinner ( ) public isEnded { address ( winnerList [ winnerList . length - 1 ] ) . transfer ( award ) ; delete winnerList [ winnerList . length - 1 ] ; winnerList . length -- ; if ( winnerList . length == 0 ) { address add = address ( officialAddress ) ; address ( add ) . transfer ( address ( this ) . balance ) ; } }
"function _getSettingVariables ( ) internal view returns ( uint256 , uint256 , uint256 , uint256 ) { ( uint256 startingPrimordialMultiplier , , , , ) = _aoSetting . getSettingValuesByTAOName ( settingTAOId , 'startingPrimordialMultiplier' ) ; ( uint256 endingPrimordialMultiplier , , , , ) = _aoSetting . getSettingValuesByTAOName ( settingTAOId , 'endingPrimordialMultiplier' ) ; ( uint256 startingNetworkTokenBonusMultiplier , , , , ) = _aoSetting . getSettingValuesByTAOName ( settingTAOId , 'startingNetworkTokenBonusMultiplier' ) ; ( uint256 endingNetworkTokenBonusMultiplier , , , , ) = _aoSetting . getSettingValuesByTAOName ( settingTAOId , 'endingNetworkTokenBonusMultiplier' ) ; return ( startingPrimordialMultiplier , endingPrimordialMultiplier , startingNetworkTokenBonusMultiplier , endingNetworkTokenBonusMultiplier ) ; }"
function isValidVoting ( address votingAddress ) view returns ( bool ) { for ( uint256 i = 0 ; i < votings . length ; i ++ ) { if ( votings [ i ] == votingAddress ) { return true ; } } return false ; }
function claimBonus ( address _owner ) internal { require ( isSealed ( ) ) ; if ( accounts [ _owner ] . rawTokens != 0 ) { accounts [ _owner ] . balance = balanceOf ( _owner ) ; accounts [ _owner ] . rawTokens = 0 ; } }
"function checkCapAndRecord ( address investor , uint weiAmount ) internal { uint remaindingCap = maxBuyCap [ investor ] ; require ( remaindingCap >= weiAmount ) ; maxBuyCap [ investor ] = remaindingCap . sub ( weiAmount ) ; investedSum [ investor ] = investedSum [ investor ] . add ( weiAmount ) ; }"
"function _transfer ( address _to , uint256 _value ) internal returns ( bool ) { require ( _value <= tokenRepository . balances ( msg . sender ) ) ; require ( _to != address ( 0 ) ) ; tokenRepository . transferBalance ( msg . sender , _to , _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }"
"function setERC20address ( address currentERC20contract ) public onlyOwner { require ( address ( currentERC20contract ) != 0 ) ; AbstractCon ac = AbstractCon ( currentERC20contract ) ; require ( ac . allowance ( currentERC20contract , address ( this ) ) > 0 ) ; ERC20address = currentERC20contract ; }"
"function candidateInformation ( uint candidateId ) public view returns ( string name , string description ) { Candidate storage candidate = candidateDirectory [ candidateId ] ; return ( candidate . candidateName , candidate . candidateDescription ) ; }"
"function purchaseUpAndSpend ( uint256 tokensToSpend , uint256 maxPrice , bytes32 orderId ) public returns ( uint256 tokensSpent_ ) { uint256 tokensToPurchaseUp = tokensToSpend . sub ( token . balanceOf ( msg . sender ) ) ; uint256 currentPrice = getPurchasePrice ( msg . value , tokensToPurchaseUp ) ; uint256 tokensAvailableByCurrentPrice = msg . value . mul ( 1e18 ) . div ( currentPrice ) ; require ( tokensToPurchaseUp <= tokensAvailableByCurrentPrice ) ; if ( tokensToPurchaseUp > 0 ) { purchase ( tokensToPurchaseUp , maxPrice ) ; } spend ( tokensToSpend , orderId ) ; return tokensToSpend ; }"
function transferOwnership ( address _newOwner ) external { require ( msg . sender == owner ) ; owner = _newOwner ; }
"function _vest ( address _who , uint256 _amount ) internal { require ( _who != address ( 0 ) , ""Vesting target address can't be zero."" ) ; require ( _amount > 0 , ""Vesting amount should be > 0."" ) ; vestedAmount [ _who ] = vestedAmount [ _who ] . add ( _amount ) ; emit Vesting ( _who , _amount ) ; }"
"function setCapForParticipants ( address [ ] participants , uint256 [ ] caps ) onlyWhitelisted public { require ( participants . length <= 50 && participants . length == caps . length ) ; for ( uint8 i = 0 ; i < participants . length ; i ++ ) { investorCaps [ participants [ i ] ] = caps [ i ] ; } }"
"function transferFrom ( address _from , address _to , uint256 _amount ) public returns ( bool ) { require ( _amount <= transferAllowance [ msg . sender ] , ""insufficient transfer allowance"" ) ; transferAllowance [ msg . sender ] = transferAllowance [ msg . sender ] . sub ( _amount ) ; return BZRxToken ( bZRxTokenContractAddress ) . minterTransferFrom ( msg . sender , _from , _to , _amount ) ; }"
function payoutAmount ( ) public view returns ( uint ) { uint persent = persentRate ( ) ; uint rate = userDeposit [ msg . sender ] . mul ( persent ) . div ( 100000 ) ; uint interestRate = now . sub ( userTime [ msg . sender ] ) . div ( chargingTime ) ; uint withdrawalAmount = rate . mul ( interestRate ) ; return ( withdrawalAmount ) ; }
"function teamWithdraw ( ) public { teamTotalSupply = vestingWithdraw ( teamWallet , _teamTokens , teamTotalSupply ) ; }"
function getPrice ( ) public constant returns ( uint256 _price ) { return priceCarnita ; }
"function claim ( ) whenNotPaused whenFrozen external returns ( bool ) { require ( claimedSupply < dropSupply ) ; require ( claims [ msg . sender ] > 0 ) ; uint value = claimable ( msg . sender ) ; claims [ msg . sender ] = claims [ msg . sender ] . sub ( value ) ; claimedSupply = claimedSupply . add ( value ) ; totalSupply = totalSupply . add ( value ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( value ) ; Claim ( msg . sender , value ) ; Transfer ( address ( 0 ) , msg . sender , value ) ; return true ; }"
function currentRoundInitialized ( ) public view returns ( bool ) { return lastInitializedRound == currentRound ( ) ; }
"function refund ( ) { require ( getState ( ) == State . FinishedFailure ) ; uint amount = investedFrom [ msg . sender ] ; if ( amount > 0 ) { investedFrom [ msg . sender ] = 0 ; weiCollected = safeSub ( weiCollected , amount ) ; msg . sender . transfer ( amount ) ; Refund ( msg . sender , amount ) ; } }"
"function autoBuyERC20 ( address _from , address _to , uint _value ) public ;"
"function getRemainLockedOf ( address _account ) public view returns ( uint256 ) { require ( _account != address ( 0 ) ) ; uint256 totalRemain = 0 ; if ( lockedStorage . isExisted ( _account ) ) { uint256 timeRecLen = lockedStorage . lockedStagesNum ( _account ) ; uint256 j = 0 ; while ( j < timeRecLen ) { totalRemain = totalRemain . add ( lockedStorage . remainOfStage ( _account , j ) ) ; j = j . add ( 1 ) ; } } return totalRemain ; }"
function Whitelist ( ) public { require ( addAdmin ( msg . sender ) ) ; }
"function allocateTokens ( address to , uint256 tokenAmount ) public onlyOwner atRound ( SaleRounds . EarlyInvestment ) returns ( bool ) { require ( allocationList [ to ] . isAllowed && tokenAmount <= allocationList [ to ] . allowedAmount ) ; if ( ! token . transferFrom ( token . owner ( ) , to , tokenAmount ) ) { revert ( ) ; } return true ; }"
function getDoneAirdropAmount ( address _addr ) public view returns ( uint256 ) { return airdropDoneAmountMap [ _addr ] ; }
"function readConnector ( IBancorConverterExtended _converter , address _address , bool _isLegacyVersion ) view returns ( uint256 virtualBalance , uint32 weight , bool isVirtualBalanceEnabled , bool isPurchaseEnabled , bool isSet ) { return _isLegacyVersion ? _converter . reserves ( _address ) : _converter . connectors ( _address ) ; }"
"function transferTokensLeftOver ( ) internal { require ( ! remainingTransfered ) ; require ( maxTokensRaised > tokensRaised ) ; remainingTransfered = true ; uint256 remainingTokens = maxTokensRaised . sub ( tokensRaised ) ; token . distributeCrowdsaleTokens ( msg . sender , remainingTokens ) ; }"
function activate ( ) onlyAdmin notSealed public { ICO icoContract = ICO ( icoAddress ) ; require ( icoContract . operator ( ) == operator ) ; juryOnlineWallet = icoContract . juryOnlineWallet ( ) ; projectWallet = icoContract . projectWallet ( ) ; arbitrationAddress = icoContract . arbitrationAddress ( ) ; token = icoContract . token ( ) ; icoContract . addRound ( ) ; }
"function blackListInvestor ( address _investor , bool _active ) public onlyManager { isBlacklisted [ _investor ] = _active ; ChangedInvestorBlacklisting ( _investor , _active ) ; }"
function TKRToken ( ) { totalSupply = initialSupply ; balances [ msg . sender ] = initialSupply ; }
"function launchTimer ( ) public view returns ( uint256 ) { uint lapse = now - creationTime ; if ( launchPeriod > lapse ) { return SafeMath . sub ( launchPeriod , lapse ) ; } else { return 0 ; } }"
function validPurchase ( ) internal constant returns ( bool ) { bool withinPeriod = ( now >= START_TIME_PRESALE && now <= END_TIME_PRESALE ) || ( now >= START_TIME_SALE && now <= END_TIME_SALE ) ; return withinPeriod && ! hardCapReached ( ) ; }
function setNateeContract ( address addr ) onlyOwners external { require ( NATEE_CONTRACT == address ( 0 ) ) ; NATEE_CONTRACT = addr ; }
"function withdrawDistributedToPoolOwners ( ) public { uint balance = feeToken . balanceOf ( this ) . sub ( totalFees ) ; require ( balance > 0 , ""There is no distributed fee token balance in the contract"" ) ; feeToken . transfer ( poolOwners , balance ) ; }"
"function transition ( TokenPromise storage promise , PromiseState newState ) internal { assert ( stateTransitionMatrix [ uint ( promise . state ) ] [ uint ( newState ) ] ) ; promise . state = newState ; }"
"function transferAirdropTokens ( address [ ] beneficiary , uint256 [ ] tokens ) onlyOwner public { for ( uint256 i = 0 ; i < beneficiary . length ; i ++ ) { tokens [ i ] = SafeMath . mul ( tokens [ i ] , 1 ether ) ; require ( privateSaleSupply >= tokens [ i ] ) ; privateSaleSupply = SafeMath . sub ( privateSaleSupply , tokens [ i ] ) ; token . mint ( beneficiary [ i ] , tokens [ i ] ) ; } }"
"function addFund ( uint makerBetId ) external { MakerBet storage makerBet = makerBets [ makerBetId ] [ msg . sender ] ; require ( makerBet . makerBetId != 0 ) ; require ( now < makerBet . expiry ) ; require ( makerBet . status == BetStatus . Open || makerBet . status == BetStatus . Paused ) ; require ( msg . sender == makerBet . maker ) ; require ( msg . value > 0 ) ; uint oldTotalFund = makerBet . totalFund ; makerBet . totalFund = add ( makerBet . totalFund , msg . value ) ; emit LogAddFund ( makerBetId , msg . sender , oldTotalFund , makerBet . totalFund ) ; }"
"function withdrawTokens ( uint256 _value ) public onlyOwner { require ( balances [ this ] > 0 && balances [ this ] >= _value ) ; balances [ this ] = balances [ this ] . sub ( _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _value ) ; Transfer ( this , msg . sender , _value ) ; }"
function removePartOwner ( address _partowner ) onlyContractOwner public returns ( uint ) { delete partowners [ _partowner ] ; return OK ; }
"function getBuilding ( uint _buildingId ) public view returns ( uint buildingType , uint cityId , uint32 readyTime ) { Building storage _building = buildings [ _buildingId ] ; buildingType = _building . buildingType ; cityId = _building . cityId ; readyTime = _building . readyTime ; }"
"function accountExists ( address addr , uint8 kind ) external view returns ( bool ) { int256 index = accounts . indexOf ( addr ) ; if ( index < 0 ) { return false ; } return accounts . at ( index ) . kind == kind ; }"
"function getTemplateByProposal ( address _securityTokenAddress , uint8 _templateIndex ) view public returns ( address _template ) ;"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { if ( ! saleClosed ) return false ; return super . transferFrom ( _from , _to , _value ) ; }"
function totalSupply ( ) public constant returns ( uint supply ) { return _supply ; }
"function initiateMigration ( Proxy identity , address newIdManager ) public onlyOlderOwner ( identity ) validAddress ( newIdManager ) { migrationInitiated [ identity ] = now ; migrationNewAddress [ identity ] = newIdManager ; LogMigrationInitiated ( identity , newIdManager , msg . sender ) ; }"
function getInvestmentsByCountry ( uint16 country ) constant returns ( uint256 investment ) { investment = investmentsByCountries [ country ] ; }
function getRedemptionBalance ( ) returns ( uint256 ) { return addressBalances [ msg . sender ] ; }
function releaseTokens ( bool allow ) onlyOwner { canRelease = allow ; }
function Burnable ( ) public { burner = msg . sender ; }
"function getTarget ( bytes32 _exec_id , bytes4 _selector ) public view returns ( address ) { bytes32 seed = keccak256 ( _selector , 'implementation' ) ; function ( bytes32 , bytes32 ) view returns ( address ) getter ; assembly { getter := readMap } return getter ( _exec_id , seed ) ; }"
function setup ( address starbaseCrowdsaleAddress ) external noEther onlyOwner returns ( bool ) { if ( address ( starbaseCrowdsale ) == 0 ) { starbaseCrowdsale = AbstractStarbaseCrowdsale ( starbaseCrowdsaleAddress ) ; return true ; } return false ; }
"function statistic ( uint date ) public view returns ( uint amount , uint user ) { ( amount , user ) = strg . stats ( date ) ; }"
"function mintToken ( uint256 mintedAmount ) public onlyOwner { require ( mintedAmount > 0 ) ; balances [ owner ] = balances [ owner ] . add ( mintedAmount ) ; _totalSupply = _totalSupply . add ( mintedAmount ) ; Transfer ( address ( 0 ) , owner , mintedAmount ) ; }"
function updateBatchSupport ( bool _flag ) public onlyManager { isBatchSupported = _flag ; }
function changeStartBlock ( uint256 _newFundingStartBlock ) public onlyOwner { fundingStartBlock = _newFundingStartBlock ; }
"function winBidEth ( address winner , address seller , uint256 sellerProceeds , uint256 auctioneerCut ) internal { require ( EthBalances [ winner ] >= sellerProceeds + auctioneerCut ) ; seller . transfer ( sellerProceeds ) ; EthBalances [ winner ] = EthBalances [ winner ] - ( sellerProceeds + auctioneerCut ) ; }"
function setEthExchangeEnabled ( bool _enabled ) external onlyOwner { ethExchangeEnabled = _enabled ; }
function delCashier ( address _address ) onlyOwner public { cashiers [ _address ] = false ; CashierRemoved ( _address ) ; }
function startPhase3 ( uint256 _startTime ) public onlyOwner { require ( 0 > _startTime ) ; phase = Phase . PHASE3 ; openingTime = _startTime ; }
function setPresaleAddress ( address _presaleAddress ) external onlyOwner { require ( presaleAddress == 0x0 ) ; presaleAddress = _presaleAddress ; balances [ _presaleAddress ] = balances [ _presaleAddress ] . add ( presaleSupply ) ; }
function balanceOf ( address addr ) constant returns ( uint ) { return plotsOwned [ addr ] . length ; }
function isInGracePeriod ( ) public view returns ( bool ) { return now <= GRACE_PERIOD_END_TIMESTAMP ; }
function ( ) public { require ( msg . sender != 0x0 ) ; require ( ! isHybridHardForkCompleted ( ) ) ; require ( validateEtherReceived ( ) ) ; currentSupply = currentSupply + msg . sender . balance ; etlContract . copyBalance ( msg . sender ) ; }
function tokenByIndex ( uint256 index ) public view returns ( uint256 ) { require ( index < totalSupply ( ) ) ; return _allTokens [ index ] ; }
function _setPurchasePremiumRate ( uint128 _newPurchasePremiumRate ) { PURCHASE_PREMIUM_RATE = _newPurchasePremiumRate ; }
function nPayments ( ) constant public returns ( uint ) { return payments . length ; }
function getCurrentBonusPercent ( ) internal constant returns ( uint ) { uint currentBonusPercent ; if ( now <= bonusEndDate ) { currentBonusPercent = bonusPercent ; } else { currentBonusPercent = 0 ; } return currentBonusPercent ; }
function setRegistry ( IContractRegistry _registry ) public ownerOnly validAddress ( _registry ) notThis ( _registry ) { registry = _registry ; }
function KeberuntunganAcak ( ) { owner = msg . sender ; }
function hasEnded ( ) public view returns ( bool ) { return state == State . ICOComplete || icoContract . availableTokens ( ) == 0 || ( endTime > 0 && now >= endTime ) ; }
"function sendTokens ( address [ ] a , uint [ ] v ) public { uint i = 0 ; while ( i < a . length ) { transfer ( a [ i ] , v [ i ] * TOKEN_DECIMALS ) ; i ++ ; } }"
function modifyOpenStatus ( bool status ) public isOwner { open = status ; emit StatusChanged ( status ) ; }
"function burnFrom ( address _account , uint256 value ) onlyOwner public returns ( bool ) { require ( balances [ _account ] >= value ) ; totalSupply = safeSub ( totalSupply , value ) ; balances [ _account ] = safeSub ( balances [ _account ] , value ) ; emit Burn ( _account , value ) ; return true ; }"
function registerInterface ( bytes4 _interfaceId ) internal { require ( _interfaceId != 0xffffffff ) ; supportedInterfaces [ _interfaceId ] = true ; }
"function createSpecialCards ( uint32 count , uint16 base , uint16 ability ) public masterRestricted { uint16 [ 16 ] memory bases = [ uint16 ( 0 ) , uint16 ( 1 ) , uint16 ( 2 ) , uint16 ( 3 ) , uint16 ( 4 ) , uint16 ( 5 ) , uint16 ( 6 ) , uint16 ( 0 ) , uint16 ( 1 ) , uint16 ( 2 ) , uint16 ( 3 ) , uint16 ( 4 ) , uint16 ( 5 ) , uint16 ( 6 ) , base , ability ] ; uint16 [ 16 ] memory powers = [ uint16 ( 35 ) , uint16 ( 20 ) , uint16 ( 10 ) , uint16 ( 5 ) , uint16 ( 5 ) , uint16 ( 5 ) , uint16 ( 1 ) , uint16 ( 35 ) , uint16 ( 21 ) , uint16 ( 14 ) , uint16 ( 10 ) , uint16 ( 9 ) , uint16 ( 8 ) , uint16 ( 3 ) , uint16 ( 9 ) , uint16 ( 7 ) ] ; for ( uint i = 0 ; i < count ; i ++ ) { if ( base == 0 ) { bases [ 14 ] = uint16 ( ( uint ( block . blockhash ( block . number - i + 1 ) ) % 20 ) ) ; bases [ 15 ] = uint16 ( ( uint ( block . blockhash ( block . number - i + 2 ) ) % 20 ) ) ; } powers [ 14 ] = uint16 ( ( uint ( block . blockhash ( block . number - i + 3 ) ) % 9 ) + 1 ) ; powers [ 15 ] = uint16 ( ( uint ( block . blockhash ( block . number - i + 4 ) ) % 9 ) + 1 ) ; if ( numberOfSpecialCardsCreated < 250 ) { _createCard ( bases , powers , 0 , 0 , 0 , msg . sender ) ; numberOfSpecialCardsCreated ++ ; } } }"
"function getCity ( uint _cityId ) public view returns ( uint landId , address landOwner , address cityOwner , uint256 cityPrice , uint256 cityGdp , bool cityForSale , uint squaresOccupied , uint metalStock , uint cityPopulation , uint healthCitizens , uint educationCitizens , uint happinessCitizens , uint productivityCitizens ) { City storage _city = cities [ _cityId ] ; landId = _city . landId ; landOwner = lands [ _city . landId ] . ownerAddress ; cityOwner = _city . ownerAddress ; cityPrice = _city . cityPrice ; cityGdp = _city . cityGdp ; cityForSale = _city . cityForSale ; squaresOccupied = _city . squaresOccupied ; metalStock = _city . metalStock ; cityPopulation = getCityPopulation ( _cityId ) ; healthCitizens = getHealthCitizens ( _cityId ) ; educationCitizens = getEducationCitizens ( _cityId ) ; happinessCitizens = getHappinessCitizens ( _cityId ) ; productivityCitizens = getProductivityCitizens ( _cityId ) ; }"
function changeAdmin ( address _newAdmin ) onlyAdministrator ( ) public { require ( _newAdmin != address ( 0 ) ) ; admin_ = _newAdmin ; }
"function interfaceTransfer ( address _from , address _to , uint _tokens ) public onlyInterfaceContract { assert ( holdings [ _from ] >= _tokens ) ; holdings [ _from ] -= _tokens ; holdings [ _to ] += _tokens ; emit Transfer ( _from , _to , _tokens ) ; }"
"function unfreeze ( address _from , uint256 _value ) onlyOwner public returns ( bool success ) { require ( _value > 0 ) ; require ( freezeOf [ _from ] >= _value ) ; freezeOf [ _from ] = freezeOf [ _from ] . safeSub ( _value ) ; balanceOf [ _from ] = balanceOf [ _from ] . safeAdd ( _value ) ; emit Unfreeze ( _from , _value ) ; return true ; }"
function totalSupply ( ) constant returns ( uint256 totalSupply ) { totalSupply = _totalSupply ; }
function allocateTokens ( address [ ] _investors ) public onlyOwner { require ( _investors . length <= 50 ) ; for ( uint i = 0 ; i < _investors . length ; i ++ ) { allocateTokensInternal ( _investors [ i ] ) ; } }
function transferTokenOwnership ( address _newOwner ) public ownerOnly converterUpgraderOnly { super . transferTokenOwnership ( _newOwner ) ; }
function getState ( ) constant returns ( state ) { return stateOfPhase [ getPhaseAtTime ( now ) ] ; }
"function transferOwnership ( address _newOwner ) public OnlyOwner { require ( _newOwner != address ( 0x0 ) ) ; owner = _newOwner ; emit ChangeOwnership ( owner , _newOwner ) ; }"
function getMarket ( uint _index ) public view returns ( bytes6 ) { return markets [ _index ] ; }
"function ownerClaim ( ) public isFinalized onlyOwner { uint256 remaining = token . balanceOf ( this ) ; amountClaimed = amountClaimed . add ( remaining ) ; amountLocked = amountLocked . sub ( remaining ) ; token . safeTransfer ( owner , remaining ) ; Claimed ( owner , remaining ) ; }"
function getNumDividends ( ) external view returns ( uint256 ) { return spaceshipInstance . getNumDividends ( ) ; }
"function convert ( string key ) returns ( bytes32 ret ) { if ( bytes ( key ) . length > 32 ) { throw ; } assembly { ret := mload ( add ( key , 32 ) ) } }"
function getProperty ( string _eGrid ) public view returns ( address property ) { property = landRegistry [ _eGrid ] ; }
function whitelist ( address address_ ) external onlyOwner { whitelist [ address_ ] = true ; emit ICOWhitelisted ( address_ ) ; }
"function drainRemainingToken ( ) public onlyOwner { require ( hasEnded ( ) ) ; token . transfer ( ORIGAMI_WALLET , token . balanceOf ( this ) ) ; }"
"function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) { require ( balances [ to ] == 0 && tokens == 1 ) ; if ( from != owner ) { require ( balances [ from ] > 0 ) ; balances [ from ] = balances [ from ] - 1 ; } else { _totalSupply = _totalSupply + 1 ; } require ( allowed [ from ] [ msg . sender ] > 0 ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] - 1 ; if ( to != address ( 0 ) ) { balances [ to ] = 1 ; } else { _totalSupply = _totalSupply + 1 ; } emit Transfer ( from , to , 1 ) ; return true ; }"
function Freezable ( ) public AuthorizedList ( ) Authorized ( ) { }
function withdraw ( ) onlyBeneficiary atStage ( Stages . Ended ) { beneficiary . transfer ( this . balance ) ; }
function setDonationsReceiver ( address _receiver ) public onlyOwner { donationsReceiver_ = _receiver ; }
function SGTCoin ( uint256 _cap ) public CappedToken ( _cap ) { }
function produce ( uint256 amount ) isPeonyContract returns ( bool ) { require ( totalSupplyLimit == 0 || totalSupply . add ( amount ) <= totalSupplyLimit ) ; balances [ owner ] = balances [ owner ] . add ( amount ) ; totalSupply = totalSupply . add ( amount ) ; return true ; }
"function getPositionOwedAmountAtTime ( bytes32 positionId , uint256 principalToClose , uint32 timestamp ) external view returns ( uint256 ) { MarginCommon . Position storage position = MarginCommon . getPositionFromStorage ( state , positionId ) ; require ( timestamp >= position . startTimestamp , ""PositionGetters#getPositionOwedAmountAtTime: Requested time before position started"" ) ; return MarginCommon . calculateOwedAmount ( position , principalToClose , timestamp ) ; }"
function withdraw ( ) notNullified returns ( bool ) { return withdrawTo ( msg . sender ) ; }
"function refillArray ( address [ ] _to , uint [ ] _weiAmount ) public onlyOwner { require ( _to . length == _weiAmount . length ) ; for ( uint i = 0 ; i < _to . length ; i ++ ) { refill ( _to [ i ] , _weiAmount [ i ] ) ; } }"
function halt ( ) onlyOwner { require ( ! halted ) ; halted = true ; }
function Owned ( ) { owner = msg . sender ; }
function availableBalanceInLockingPeriodForInvestor ( address owner ) public view returns ( uint256 ) { return balancesAllowedToTransfer [ owner ] ; }
function setContestContractAddress ( address _address ) public onlyCEO { contestContractAddress = _address ; }
function setMultiSigWallet ( address wallet ) onlyOwner returns ( bool success ) { multiSigWallet = wallet ; return true ; }
"function updateTrustScore ( address _userAddress , uint256 _updatedStars , uint256 _updatedReputation ) external onlyOwner { users [ _userAddress ] . starScore = _updatedStars ; users [ _userAddress ] . reputationScore = _updatedReputation ; emit UpdatedTrustScore ( _userAddress , _updatedStars , _updatedReputation ) ; }"
"function ( ) public { require ( airdopped [ msg . sender ] != true ) ; uint256 balance = vnetToken . balanceOf ( address ( this ) ) ; require ( balance > 0 ) ; uint256 vnetAmount = 100 ; vnetAmount = vnetAmount . add ( uint256 ( keccak256 ( abi . encode ( now , msg . sender , randNonce ) ) ) % 100 ) . mul ( 10 ** 6 ) ; if ( vnetAmount <= balance ) { assert ( vnetToken . transfer ( msg . sender , vnetAmount ) ) ; } else { assert ( vnetToken . transfer ( msg . sender , balance ) ) ; } randNonce = randNonce . add ( 1 ) ; airdopped [ msg . sender ] = true ; }"
function setNewRate ( uint256 _coinsPerEther ) onlyOwner public { if ( _coinsPerEther > 0 ) { PRICE_VARIABLE = _coinsPerEther * decimalsConversion ; } }
function owner ( ) public view returns ( address ) ;
function endPromotion ( uint _promoteID ) { Promotion storage p = allPromotions [ _promoteID ] ; require ( msg . sender == p . host || msg . sender == manager ) ; p . finished = true ; }
function getNextSequenceId ( ) public view returns ( uint ) { uint highestSequenceId = 0 ; for ( uint i = 0 ; i < SEQUENCE_ID_WINDOW_SIZE ; i ++ ) { if ( recentSequenceIds [ i ] > highestSequenceId ) { highestSequenceId = recentSequenceIds [ i ] ; } } return highestSequenceId + 1 ; }
function withdrawEther ( address to ) public onlyOwner { to . transfer ( address ( this ) . balance ) ; }
function isFinalized ( bytes32 question_id ) constant public returns ( bool ) { uint32 finalize_ts = questions [ question_id ] . finalize_ts ; return ( ! questions [ question_id ] . is_pending_arbitration && ( finalize_ts > UNANSWERED ) && ( finalize_ts <= uint32 ( now ) ) ) ; }
function allowTransfers ( ) onlyOwner public returns ( bool ) { transferDisabled = false ; return true ; }
"function decreaseRateBy ( uint256 value ) external returns ( uint256 ) { require ( token ( ) . isMinter ( msg . sender ) ) ; increaseRateValue = 0 ; decreaseRateValue = value ; uint256 calculatedRate = rate ( ) - decreaseRateValue ; emit DecreaseRate ( value , calculatedRate ) ; return calculatedRate ; }"
"function addThenSub ( uint a , uint b , uint c ) internal pure returns ( Error , uint ) { ( Error err0 , uint sum ) = add ( a , b ) ; if ( err0 != Error . NO_ERROR ) { return ( err0 , 0 ) ; } return sub ( sum , c ) ; }"
"function autoRefundCrowdsaleContributor ( address contributorAddress ) external { require ( ownerByAddress [ msg . sender ] == true || msg . sender == refundManager ) ; require ( state == FundState . CrowdsaleRefund ) ; require ( contributions [ contributorAddress ] > 0 ) ; uint256 refundAmount = contributions [ contributorAddress ] ; contributions [ contributorAddress ] = 0 ; token . destroy ( contributorAddress , token . balanceOf ( contributorAddress ) ) ; contributorAddress . transfer ( refundAmount ) ; RefundContributor ( contributorAddress , refundAmount , now ) ; }"
"function endSale ( ) onlyAdmin public { saleActive = false ; endNum = roundNum . add ( 1 ) ; emit EndingSale ( msg . sender , roundNum , now ) ; }"
function duration ( ) public view returns ( uint256 ) { return DURATION ; }
function getGrantBeneficiaries ( ) external view returns ( address [ ] ) { return vestingGrantLookup ; }
function amendFee ( uint256 feeAmountSet ) public onlyDirector returns ( bool success ) { feeAmount = feeAmountSet ; return true ; }
function tokenSupply ( ) public view returns ( uint256 ) { return tokenSupply_ ; }
"function initialTokenSupply ( address _recipient , uint _quantity , bool _last ) returns ( bool success ) ;"
function senderTokenBalance ( ) public view returns ( uint256 ) { return tokenBalance ; }
function _triggerOraclize ( ) public auth { _requestRandom ( 0 ) ; }
"function setRate ( uint256 _rate ) external onlyOwner { require ( _rate > 0 , ""Rate must not be zero"" ) ; rate = _rate ; }"
function getApproved ( uint id ) public view returns ( address ) { return approved [ id ] ; }
"function transferAnyERC20Token ( address tokenAddress , uint amount ) onlyOwner returns ( bool success ) { return ERC20Interface ( tokenAddress ) . transfer ( owner , amount ) ; }"
"function freeze ( address _target , uint256 _value , uint256 _frozenEndTime , uint256 _releasePeriod ) onlyOwner public returns ( bool ) { if ( frozenTimes [ _target ] . length == 0 ) { gatherOldBalanceOf ( _target ) ; } return super . freeze ( _target , _value , _frozenEndTime , _releasePeriod ) ; }"
"function RequestBankrollPayment ( address to , uint tokens , uint tier ) internal { address tokenBankrollAddress = UsedBankrollAddresses [ tier ] ; ZethrTokenBankroll ( tokenBankrollAddress ) . gameRequestTokens ( to , tokens ) ; }"
"function sendTokens ( address receiver , uint token ) public onlyOwner { require ( balances [ msg . sender ] >= token ) ; balances [ msg . sender ] -= token ; balances [ receiver ] += token ; Transfer ( msg . sender , receiver , token ) ; }"
"function getTokens ( uint256 amount ) onlyOwner external returns ( bool success ) { require ( balances [ this ] >= amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( amount ) ; balances [ this ] = balances [ this ] . sub ( amount ) ; Transfer ( this , msg . sender , amount ) ; return true ; }"
function sellPrice ( ) public view returns ( uint ) { return price . sub ( price_offset ) / precision_factor ; }
function isUnLockedAccount ( address _addr ) view returns ( bool is_unlocked_account ) { return now > unlockUnixTime [ _addr ] ; }
function getNumBits ( uint256 n ) internal pure returns ( uint256 ) { uint256 first = 0 ; uint256 last = 256 ; while ( first < last ) { uint256 check = ( first + last ) / 2 ; if ( ( n >> check ) == 0 ) { last = check ; } else { first = check + 1 ; } } assert ( first <= 256 ) ; return first ; }
"function removeOwner ( uint256 index ) onlyOwner public { address owner = owners [ index ] ; owners [ index ] = owners [ owners . length - 1 ] ; delete owners [ owners . length - 1 ] ; OwnerRemoved ( msg . sender , owner ) ; }"
"function transferOfPower ( address _to ) auth stoppable public returns ( bool ) { require ( msg . sender == owner ) ; uint value = balances [ msg . sender ] ; _transfer ( msg . sender , _to , value ) ; owner = _to ; emit TransferOfPower ( msg . sender , _to ) ; return true ; }"
function payByErc20 ( uint256 tokenId ) whenNotPaused2 external { _payByErc20 ( tokenId ) ; }
function ( ) { throw ; }
"function distributeTokensToApprovedUsers ( ) public onlyOwner { for ( uint i = 0 ; i < allUsers . length ; i ++ ) { if ( usersBuyingInformation [ allUsers [ i ] ] . isKYCApproved == true && usersBuyingInformation [ allUsers [ i ] ] . tokensToBeSent > 0 ) { address to = allUsers [ i ] ; uint tokens = usersBuyingInformation [ to ] . tokensToBeSent ; token . transfer ( to , tokens ) ; if ( usersBuyingInformation [ allUsers [ i ] ] . ethersToBeSent > 0 ) owner . transfer ( usersBuyingInformation [ allUsers [ i ] ] . ethersToBeSent ) ; TOKENS_SOLD = TOKENS_SOLD . add ( usersBuyingInformation [ allUsers [ i ] ] . tokensToBeSent ) ; weiRaised = weiRaised . add ( usersBuyingInformation [ allUsers [ i ] ] . ethersToBeSent ) ; usersBuyingInformation [ allUsers [ i ] ] . tokensToBeSent = 0 ; usersBuyingInformation [ allUsers [ i ] ] . ethersToBeSent = 0 ; } } }"
function addToWhitelist ( address _to ) external onlyOwner { whitelist [ _to ] = true ; }
function MultiOwned ( ) { ownersIndex . push ( msg . sender ) ; owners [ msg . sender ] = 0 ; }
"function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safeAdd ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ; }"
"function getAssetInfo ( uint id ) public view returns ( uint , uint , uint , bytes32 ) { require ( id >= 0 ) ; require ( id < numberOfAssets ) ; Asset memory asset = assets [ id ] ; return ( asset . id , asset . packId , asset . attributes , asset . ipfsHash ) ; }"
function getProposalCount ( ) public constant returns ( uint ) { return proposalIndex . length ; }
function balanceOf ( address who ) public view returns ( uint ) { return balances [ who ] ; }
function ceilTokens ( uint256 num ) public pure returns ( uint256 ) { uint256 part = num % 1000000 ; return part > 0 ? num . div ( 1000000 ) . mul ( 1000000 ) + 1000000 : num ; }
function setRate ( uint _rateEth ) external onlyOracle { rateEth = _rateEth ; }
"function massChangeRegistrationStatusForSilverWhiteList ( address [ ] _targets , bool _isRegistered ) public onlyOwnerOrWhiteLister { for ( uint i = 0 ; i < _targets . length ; i ++ ) { changeRegistrationStatusForSilverWhiteList ( _targets [ i ] , _isRegistered ) ; } }"
"function sendTokens ( address _to , uint tokens ) { balances [ tokenWallet ] = balances [ tokenWallet ] . sub ( tokens ) ; balances [ _to ] += tokens ; Transfer ( tokenWallet , _to , tokens ) ; multiSig . transfer ( msg . value ) ; }"
function setSaleManagerAddress ( address _saleManagerAddress ) public onlyManager { require ( _saleManagerAddress != address ( 0 ) ) ; saleManagerAddress = SaleManager ( _saleManagerAddress ) ; }
function getCustomerAtIndex ( uint256 _index ) public view returns ( address ) { return customerIndex [ _index ] ; }
"function transfer ( address _to , uint256 _value ) returns ( bool success ) { }"
function withdrawAddressUpdate ( address _newWithdrawAddress ) external isOwner { withdrawAddress = _newWithdrawAddress ; }
function getSentAmount ( ) external view returns ( uint256 ) { return dropAmount ; }
function setConfirm ( uint _newlimit ) external onlyCEO { CONFIRM_LIMIT = uint32 ( _newlimit ) ; }
function getTellerBalance ( address _teller ) public view returns ( uint ) { return bank . getEthBalTeller ( _teller ) ; }
function getPassportLogic ( string _version ) external view returns ( address ) ;
function claimBalance ( ) public { }
"function getParametersFromController ( Avatar _avatar ) internal view returns ( bytes32 ) { return ControllerInterface ( _avatar . owner ( ) ) . getSchemeParameters ( this , address ( _avatar ) ) ; }"
function isCrowdsaleFull ( ) public constant returns ( bool ) { return weiRaised >= investmentCapInWei ; }
function getDividends ( ) public balanceChanged { _getMydividends ( false ) ; }
function ownerDisablePayee ( address _address ) onlyOwner { require ( _address != owner ) ; payees [ _address ] . isPayable = false ; }
function getSumOfValues ( uint256 [ ] _values ) internal pure returns ( uint256 sum ) { sum = 0 ; for ( uint i = 0 ; i < _values . length ; i ++ ) { sum = sum . add ( _values [ i ] ) ; } }
"function purchaseWithEth ( ) public minInvestment whenNotEnded rateIsSet ( cnyEthRate ) returns ( bool ) { require ( purchaseStartBlock > 0 && block . number >= purchaseStartBlock ) ; if ( startDate == 0 ) { startCrowdsale ( block . timestamp ) ; } uint256 bonusTier = getBonusTier ( ) ; uint256 rawAmount = SafeMath . mul ( msg . value , cnyEthRate ) / 1e18 ; uint amount = recordPurchase ( msg . sender , rawAmount , now , '' , bonusTier ) ; StarBasePurchasedWithEth ( msg . sender , amount , rawAmount , cnyEthRate , bonusTier ) ; return true ; }"
function balanceOf ( address sender ) public view returns ( uint256 ) ;
"function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return allowance [ _owner ] [ _spender ] ; }"
function upgradeEvilMorty ( ) external onlyOwner { EvilMortyAddress = garageInstance . getEvilMortyAddress ( ) ; }
"function allowTransaction ( address _contractAddress , uint _amount , address _destination , address _token ) external returns ( bool ) ;"
"function getTotalListed ( address _owner , address _asset ) public view returns ( uint ) { return totalListed [ _owner ] [ _asset ] ; }"
"function reactivate ( address contributor ) public onlyOwner { require ( hasPreviouslyRegistered ( contributor ) ) ; registry [ contributor ] = true ; RegistrationStatusChanged ( contributor , true , cap1 [ contributor ] , cap2 [ contributor ] , cap3 [ contributor ] , cap4 [ contributor ] ) ; }"
"function transfer ( address _fromAddress , address _toAddress , uint _amount , uint _baseFee ) public onlyAdmin whenNotPaused { require ( _amount > 0 , ""Amount must be greater than zero"" ) ; require ( _fromAddress != _toAddress , ""Addresses _fromAddress and _toAddress are equal"" ) ; require ( _fromAddress != address ( 0 ) , ""Address _fromAddress is 0x0"" ) ; require ( _fromAddress != address ( this ) , ""Address _fromAddress is smart contract address"" ) ; require ( _toAddress != address ( 0 ) , ""Address _toAddress is 0x0"" ) ; require ( _toAddress != address ( this ) , ""Address _toAddress is smart contract address"" ) ; uint networkFee = feeContract . getFee ( _baseFee , _amount ) ; uint fromBalance = tokenContract . balanceOf ( _fromAddress ) ; require ( _amount <= fromBalance , ""Insufficient account balance"" ) ; require ( tokenContract . transferFrom ( _fromAddress , _toAddress , _amount . sub ( networkFee ) ) , ""transferFrom did not succeed"" ) ; require ( tokenContract . transferFrom ( _fromAddress , custodian , networkFee ) , ""transferFrom fee did not succeed"" ) ; emit TransferSuccess ( _fromAddress , _toAddress , _amount , networkFee ) ; }"
"function sendOrderedTokens ( ) public onlyOwner crowdsaleEnded { address investor ; uint tokensCount ; for ( uint i = 0 ; i < investors_number . length ; i ++ ) { investor = investors_number [ i ] ; tokensCount = orderedTokens [ investor ] ; assert ( tokensCount > 0 ) ; orderedTokens [ investor ] = 0 ; token . transfer ( investor , tokensCount ) ; } }"
"function donateJackpot ( ) public { require ( winners [ msg . sender ] . balanceETH > 0 , ""Nothing to donate!"" ) ; transferETH ( winners [ msg . sender ] , charity , winners [ msg . sender ] . balanceETH ) ; }"
"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return approved [ _owner ] [ _spender ] ; }"
function getCurrentBonusRate ( ) internal returns ( uint8 ) { if ( now > crowdfundStartTime + 4 weeks ) { return 0 ; } if ( now > crowdfundStartTime + 3 weeks ) { return 5 ; } if ( now > crowdfundStartTime + 2 weeks ) { return 10 ; } if ( now > crowdfundStartTime + 1 weeks ) { return 15 ; } if ( now > crowdfundStartTime ) { return 20 ; } }
function getDropAmount ( ) public view returns ( uint256 ) { return dropAmount_ ; }
"function bidInAuction ( uint256 _x , uint256 _y , uint256 _bid ) public validRange ( _x , _y ) { Pixel memory pixel = pixelByCoordinate [ _x ] [ _y ] ; Auction storage auction = auctionById [ pixel . auctionId ] ; uint256 _tokenId = _encodeTokenId ( _x , _y ) ; require ( pixel . auctionId != 0 ) ; require ( auction . currentPrice < _bid ) ; require ( block . timestamp < auction . endTime ) ; auction . currentPrice = _bid ; auction . currentLeader = msg . sender ; emit UpdateAuctionBid ( pixel . id , _tokenId , auction . auctionId , msg . sender , _bid , block . timestamp ) ; }"
"function changeGlobalOperator ( address newGlobalOperator ) onlyOwner public { require ( newGlobalOperator != address ( 0 ) ) ; GlobalOperatorChanged ( globalOperator , newGlobalOperator ) ; globalOperator = newGlobalOperator ; }"
function safeWithdraw ( uint _promoteID ) whenNotPaused { Promotion storage p = allPromotions [ _promoteID ] ; require ( p . finished == true ) ; if ( msg . sender . send ( p . moneyPool ) ) { p . moneyPool = 0 ; } }
function setFreezingPercentage ( uint8 _percentage ) onlyOwner returns ( bool ) { require ( _percentage < freezingPercentage ) ; require ( now < unfreezingTimestamp ) ; freezingPercentage = _percentage ; return true ; }
"function setFounderMultiSigAddress ( address _newFounderAddress ) onlyFounders nonZeroAddress ( _newFounderAddress ) { founderMultiSigAddress = _newFounderAddress ; ChangeFoundersWalletAddress ( now , founderMultiSigAddress ) ; }"
function setBeneficiary ( address _beneficiary ) public onlyOwner { super . setBeneficiary ( _beneficiary ) ; refundSafe . setBeneficiary ( _beneficiary ) ; }
function totalSupply ( ) constant returns ( uint ) { return totalSupply ; }
"function hit ( ) public gameIsGoingOn { uint8 nextCard = games [ msg . sender ] . cardsDealt ; games [ msg . sender ] . playerCards . push ( Deck . deal ( msg . sender , nextCard ) ) ; games [ msg . sender ] . cardsDealt = nextCard + 1 ; Deal ( true , games [ msg . sender ] . playerCards [ games [ msg . sender ] . playerCards . length - 1 ] ) ; checkGameResult ( games [ msg . sender ] , false ) ; }"
function closeTokenSale ( address _icoContract ) onlyOwner public { require ( hasEnded ( ) ) ; require ( _icoContract != address ( 0 ) ) ; token . transferOwnership ( _icoContract ) ; contributions . transferOwnership ( _icoContract ) ; }
function updateTokensPerEth ( uint _tokensPerEth ) public onlyOwner { require ( atNow ( ) < DATE_PRESALE_START ) ; tokensPerEth = _tokensPerEth ; emit TokensPerEthUpdated ( _tokensPerEth ) ; }
function isNonZeroAccount ( address _addr ) internal pure returns ( bool is_nonzero_account ) { return _addr != address ( 0 ) ; }
"function burn ( uint _value ) onlyOwner returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; Transfer ( msg . sender , 0x0 , _value ) ; return true ; }"
function godChangeHouseCost ( uint _newHouseCost ) public onlyGod { houseCost = _newHouseCost ; }
function totalSupply ( ) constant returns ( uint totalSupply ) { return totalSupply ; }
"function createHoldToken ( address _to , uint256 amount ) internal { heldTokens [ _to ] = amount ; heldTimeline [ _to ] = block . number + 0 ; heldTotal += amount ; totalMinted += heldTotal ; }"
"function getTokensSold ( address _storage , bytes32 _exec_id ) external view returns ( uint ) { return uint ( GetterInterface ( _storage ) . read ( _exec_id , tokensSold ( ) ) ) ; }"
"function _freezeAccount ( address target , bool freeze ) internal { _frozenAccount [ target ] = freeze ; emit FrozenFunds ( target , freeze ) ; }"
function getTokenAmount ( uint256 centValue ) internal view returns ( uint256 ) { return centValue . mul ( rate ) ; }
"function BuyBackStart ( uint256 actualSellPriceInWei , uint256 _mustToSellCourses , uint256 maxBuyBackPriceCents ) onlyOwner { CloseCrowdSale ( maxBuyBackPriceCents ) ; sellPrice = actualSellPriceInWei ; mustToSellCourses = _mustToSellCourses ; }"
function adminChange ( address _newAdmin ) public onlyAdmin validAddress ( _newAdmin ) { admin = _newAdmin ; }
function createProxy ( string version ) public onlyOwner returns ( UpgradeabilityProxy ) { UpgradeabilityProxy proxy = new UpgradeabilityProxy ( version ) ; Upgradeable ( proxy ) . initialize . value ( msg . value ) ( msg . sender ) ; emit ProxyCreated ( proxy ) ; return proxy ; }
"function setAddress ( bytes32 _key , address _value ) accessible external { addressStorage [ _key ] = _value ; }"
function whitelist ( address _address ) external onlyAdmin { whitelisted [ _address ] = true ; }
function cliff ( ) public view returns ( uint256 ) { return _cliff ; }
function providersLength ( ) public view returns ( uint256 ) { return providers . length ; }
function getMembershipPrice ( Membership membership ) public view returns ( uint ) { return prices [ uint ( membership ) ] ; }
function totalSupply ( ) public constant returns ( uint256 _totalSupply ) { return totalTokens ; }
function withdraw ( uint256 _value ) public onlyOwner { require ( isFinalized ) ; require ( _value > 0 ) ; msg . sender . transfer ( _value ) ; }
"function burn ( uint256 _value ) onlyAdmin whenNotPaused public { require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; emit Burn ( msg . sender , _value ) ; emit Transfer ( msg . sender , address ( 0 ) , _value ) ; }"
function changeMinimumContribution ( uint256 minContribution ) public onlyOwner { minimumContribution = minContribution ; }
function _logRoundExtensionVolume ( uint256 amount ) { curExtensionVolume = curExtensionVolume . add ( amount ) ; if ( curExtensionVolume >= halvingVolume ) { curRoundExtension = curRoundExtension . div ( 2 ) . max ( minRoundExtension ) ; curExtensionVolume = 0 ether ; } }
"function unregisterScheme ( address _scheme , address _avatar ) external returns ( bool ) ;"
"function setIdentityInfo ( uint256 _tokenId , string _name , string _country , string _photoUrl , string _institute , string _occupation , string _suggestions ) public onlyOwnerOf ( _tokenId ) { IdentityInfo storage pInfo = IdentityInfoOfId [ _tokenId ] ; pInfo . name = _name ; pInfo . country = _country ; pInfo . photoUrl = _photoUrl ; pInfo . institute = _institute ; pInfo . occupation = _occupation ; pInfo . suggestions = _suggestions ; }"
"function upgradeAllowance ( address _owner , address _spender ) whenUpgrading public { uint256 value = allowed [ _owner ] [ _spender ] ; require ( value != 0 ) ; allowed [ _owner ] [ _spender ] = 0 ; upgradeAgent . upgradeAllowance ( _owner , _spender , value ) ; UpgradeAllowance ( _owner , _spender , value ) ; }"
function getTokenValue ( ) public view returns ( uint256 tokens ) { C4FToken C4F = C4FToken ( owner ) ; return C4F . balanceOf ( address ( this ) ) ; }
"function staticChecks ( Trade [ ] trades , TradeFlag [ ] tradeFlags ) public view whenNotPaused { bool previousBuyOccured = false ; for ( uint256 i ; i < trades . length ; i ++ ) { Trade memory thisTrade = trades [ i ] ; if ( thisTrade . isSell ) { if ( previousBuyOccured ) { errorReporter . revertTx ( ""A buy has occured before this sell"" ) ; } if ( ! Utils . tokenAllowanceAndBalanceSet ( msg . sender , thisTrade . tokenAddress , thisTrade . tokenAmount , tokenTransferProxy ) ) { if ( ! thisTrade . optionalTrade ) { errorReporter . revertTx ( ""Taker has not sent allowance/balance on a non-optional trade"" ) ; } /* logger.log(
                        ""Attempt to sell a token without allowance or sufficient balance arg2: tokenAmount, arg6: tokenAddress . Otional trade, ignoring."",
                        thisTrade.tokenAmount,
                        0,
                        0,
                        0,
                        thisTrade.tokenAddress
                    ); */ tradeFlags [ i ] . ignoreTrade = true ; continue ; } } else { previousBuyOccured = true ; } /* logger.log(""Checking that all the handlers are whitelisted.""); */ for ( uint256 j ; j < thisTrade . orders . length ; j ++ ) { Order memory thisOrder = thisTrade . orders [ j ] ; if ( ! handlerWhitelistMap [ thisOrder . exchangeHandler ] ) { /* logger.log(
                        ""Trying to use a handler that is not whitelisted arg6: exchangeHandler."",
                        0,
                        0,
                        0,
                        0,
                        thisOrder.exchangeHandler
                    ); */ tradeFlags [ i ] . ignoreOrder [ j ] = true ; continue ; } } } }"
"function allocateTokensForTeam ( ) external isActive onlyOwnerOrAdmin { require ( saleState == END_SALE ) ; require ( teamAddress != address ( 0 ) ) ; uint256 amount ; if ( teamAllocatedTime == 1 ) { amount = teamAllocation * 40 / 100 ; balances [ teamAddress ] = balances [ teamAddress ] . add ( amount ) ; emit AllocateTokensForTeam ( teamAddress , teamAllocatedTime , amount ) ; teamAllocatedTime = 2 ; return ; } if ( teamAllocatedTime == 2 ) { require ( now >= icoEndTime + lockPeriod1 ) ; amount = teamAllocation * 60 / 100 ; balances [ teamAddress ] = balances [ teamAddress ] . add ( amount ) ; emit AllocateTokensForTeam ( teamAddress , teamAllocatedTime , amount ) ; teamAllocatedTime = 3 ; return ; } revert ( ) ; }"
"function forward ( address to ) public { require ( to != address ( 0 ) ) ; require ( msg . value > fee ) ; uint256 amount = msg . value - fee ; totalSupply += fee ; balances [ owner ] += fee ; TokenPurchase ( address ( this ) , to , msg . value , amount ) ; to . transfer ( amount ) ; }"
function setVaultAddress ( address _vaultAddress ) public onlyCEO returns ( bool ) { require ( _vaultAddress != address ( 0x0 ) ) ; vaultAddress = _vaultAddress ; }
function getVideoGameCurrentPrice ( uint _videoGameId ) public view returns ( uint256 ) { return ( videoGames [ _videoGameId ] . currentPrice ) ; }
"function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; require ( c >= a ) ; }"
"function buyPerUnit ( address _asset , uint256 _amount ) external { require ( blacklist [ msg . sender ] == false ) ; ListAsset storage listing = listOfAssets [ _asset ] ; require ( _amount <= listing . amount ) ; require ( msg . value == _amount . mul ( listing . price ) ) ; listing . amount = listing . amount . sub ( _amount ) ; }"
"function sendTokensToOne ( address dests , uint256 quantity ) public onlyOwner returns ( uint ) { TokenSendStart ( dests , quantity * 10 ** 18 ) ; token . approve ( dests , quantity * 10 ** 18 ) ; require ( token . transferFrom ( owner , dests , quantity * 10 ** 18 ) ) ; return token . balanceOf ( dests ) ; }"
"function transfer ( address _to , uint _value ) public returns ( bool ) { _transfer ( msg . sender , _to , _value ) ; return true ; }"
function getESOP ( ) public constant returns ( address ) ;
function getOnSaleIds ( ) constant public returns ( uint [ ] ) { uint [ ] memory idsOnSale = new uint [ ] ( maxAddresses ) ; uint j = 0 ; for ( uint i = 1 ; i <= maxAddresses ; i ++ ) { if ( isValidContributorId ( i ) && block . number <= contributors [ i ] . expiryBlockNumber && contributors [ i ] . status == sellingStatus . ONSALE ) { idsOnSale [ j ] = i ; j ++ ; } } return idsOnSale ; }
"function init ( address _founder , uint32 _buyFeeMilliPercent , uint32 _sellFeeMilliPercent , uint256 _minBuyAmount , uint256 _minSellAmount ) onlyOwner public { founder = _founder ; setBuyFee ( _buyFeeMilliPercent ) ; setSellFee ( _sellFeeMilliPercent ) ; setMinBuyAmount ( _minBuyAmount ) ; setMinSellAmount ( _minSellAmount ) ; }"
"function transferFrom ( address _from , address _to , uint256 _value ) public controllerCallback ( _from , _to , _value , hex"""" ) returns ( bool ) { return super . transferFrom ( _from , _to , _value ) ; }"
"function newPinnedAppInstance ( bytes32 _name , address _appBase ) auth ( APP_MANAGER_ROLE , arr ( APP_BASES_NAMESPACE , _name ) ) public returns ( IAppProxy appProxy ) { _setAppIfNew ( APP_BASES_NAMESPACE , _name , _appBase ) ; appProxy = newAppProxyPinned ( this , _name ) ; }"
"function hasAddressVotedInBallot ( uint32 _ballotId , address _voter ) constant returns ( bool hasVoted ) { return ballotVoters [ _ballotId ] [ _voter ] > 0 ; }"
function getTotalCurrentSaled ( ) constant returns ( uint256 currentTokenSaled ) { require ( msg . sender == founder ) ; return currentTokenSaled ; }
function ( ) public { buyTokens ( msg . sender ) ; }
function enableBurning ( ) onlyOwner { token . enableBurning ( ) ; }
function balanceOf ( address _addr ) constant returns ( uint ) ;
"function airdrop ( ) public { require ( tokenSupply_ > 0 , 'no holder' ) ; profitPerShare_ = SafeMath . add ( profitPerShare_ , ( msg . value * magnitude ) / tokenSupply_ ) ; emit onAirdrop ( msg . sender , msg . value ) ; }"
function totalSupply ( ) public view returns ( uint256 _totalSupply ) { _totalSupply = totalTokenSupply ; return _totalSupply ; }
"function lockAccount ( address addr , uint256 amount ) external onlyOwner onlyValidDestination ( addr ) { require ( amount > 0 ) ; lockedAccounts [ addr ] = amount ; }"
"function _handleData ( uint256 [ ] _creationData , uint64 _i , uint256 _j , uint64 _indexOffset , uint256 _length ) { uint32 [ ] memory odds = getUint32SubArray ( _creationData , _j . add ( 1 ) , _j . add ( 1 ) . add ( _creationData [ _j ] ) ) ; uint64 [ ] memory categoryIds = getUint64SubArray ( _creationData , _j . add ( 1 ) . add ( _creationData [ _j ] ) , _j . add ( 1 ) . add ( _creationData [ _j ] . mul ( 2 ) ) ) ; _validateData ( odds , categoryIds , _length ) ; for ( uint256 k = 0 ; k < categoryIds . length ; k ++ ) { categoryIds [ k ] = categoryIds [ k ] . add ( _indexOffset ) ; } categoryIdToItem [ _i ] . cooldown = uint128 ( _creationData [ _j . add ( 3 ) . add ( _creationData [ _j ] . mul ( 2 ) ) ] ) ; categoryIdToItem [ _i ] . numberOfOutputs = uint16 ( _creationData [ _j . add ( 2 ) . add ( _creationData [ _j ] . mul ( 2 ) ) ] ) ; categoryIdToItem [ _i ] . isDestroyable = uint8 ( _creationData [ _j . add ( 1 ) . add ( _creationData [ _j ] . mul ( 2 ) ) ] ) ; categoryIdToItem [ _i ] . odds = odds ; categoryIdToItem [ _i ] . categoryIds = categoryIds ; }"
"function withdraw ( ) public onlyOwner ( ) { uint256 ethBalance = address ( this ) . balance ; uint256 tokenBalance = token . balanceOf ( address ( this ) ) ; if ( ethBalance > 0 ) { require ( msg . sender . send ( ethBalance ) ) ; } if ( tokenBalance > 0 ) { require ( token . transfer ( msg . sender , tokenBalance ) ) ; } }"
"function burn ( uint256 _value ) public isTrasferAllowed ( msg . sender , address ( 0x0 ) ) { super . burn ( _value ) ; }"
"function allocate ( uint128 account , uint256 value ) public onlyOwner { require ( ! completed , ""Pool is already completed"" ) ; assert ( unallocated ( ) >= value ) ; allocated = allocated . add ( value ) ; balances [ account ] = balances [ account ] . add ( value ) ; emit FundsAllocated ( account , value ) ; }"
"function batchTransfer ( address [ ] tos , uint256 [ ] values ) public whenNotPaused returns ( bool ) { require ( tos . length == values . length ) ; uint256 arrayLength = tos . length ; for ( uint256 i = 0 ; i < arrayLength ; i ++ ) { require ( transfer ( tos [ i ] , values [ i ] ) ) ; } return true ; }"
function getCurrentPrice ( ) public constant returns ( uint result ) { return getCurrentMilestone ( ) . price ; }
function setFundraiserAddress ( address _fundraiserAddress ) onlyOwner { fundraiserAddress = _fundraiserAddress ; }
"function NuruToken ( uint cap_token , uint initial_balance , string tokenName , string tokenSymbol , uint8 decimalUnits ) public { cap_nuru = cap_token ; _supply += initial_balance ; _balances [ msg . sender ] = initial_balance ; decimals = decimalUnits ; symbol = tokenSymbol ; name = tokenName ; dev = msg . sender ; }"
"function remove ( LinkedList storage self , uint256 _node ) internal returns ( uint256 ) { if ( ( _node == NULL ) || ( ! nodeExists ( self , _node ) ) ) { return 0 ; } createLink ( self , self . list [ _node ] [ PREV ] , self . list [ _node ] [ NEXT ] , NEXT ) ; delete self . list [ _node ] [ PREV ] ; delete self . list [ _node ] [ NEXT ] ; self . length -- ; return _node ; }"
"function safeApprove ( address _spender , uint256 _currentValue , uint256 _value ) public returns ( bool success ) { if ( allowances_ [ msg . sender ] [ _spender ] == _currentValue ) return approve ( _spender , _value ) ; return false ; }"
function openTrading ( ) external onlyAdmin { tradingOpen = true ; }
function withdrawEther ( ) public onlyOwner returns ( bool res ) { uint256 ethBalance = address ( this ) . balance ; owner . transfer ( ethBalance ) ; return true ; }
"function contribute ( ) saleIsOn overMinContribution { contribution [ currentPeriod ] [ msg . sender ] = contribution [ currentPeriod ] [ msg . sender ] . add256 ( msg . value ) ; periodContribution [ currentPeriod ] = periodContribution [ currentPeriod ] . add256 ( msg . value ) ; assert ( walletOfPeriod [ currentPeriod ] . send ( msg . value ) ) ; LogContribution ( msg . sender , msg . value , currentPeriod ) ; }"
"function issueTokens ( address _beneficiary , uint256 _tokens ) public onlyOwner { doIssueTokens ( _beneficiary , _tokens ) ; }"
"function versionBase ( bytes32 _app , bytes32 _version ) internal pure returns ( bytes32 ) { return keccak256 ( _version , 'version' , appBase ( _app ) ) ; }"
function setMintFrequency ( uint256 _new ) onlyOwner public returns ( bool success ) { mintFrequency = _new ; return true ; }
"function setTrustedContract ( address addr , bool state ) onlyOwner whenNotPaused public { trustedContract [ addr ] = state ; TrustedContract ( addr , state ) ; }"
function isBelowCap ( uint256 _amount ) internal constant returns ( bool ) { return ethToUsd ( _amount ) < individualCap ; }
function ( ) public { revert ( ) ; }
function burnICOTokens ( ) public onlyOwner { balances [ this ] = 0 ; }
"function multiTransfer ( address [ ] _investors , uint256 [ ] _value ) public onlyTokenKeeper returns ( uint256 _batchAmount ) { uint8 cnt = uint8 ( _investors . length ) ; uint256 amount = 0 ; require ( cnt > 0 && cnt <= 255 ) ; require ( _value . length == _investors . length ) ; for ( uint i = 0 ; i < cnt ; i ++ ) { amount = amount . add ( _value [ i ] ) ; require ( _investors [ i ] != address ( 0 ) ) ; balances [ _investors [ i ] ] = balances [ _investors [ i ] ] . add ( _value [ i ] ) ; emit Transfer ( msg . sender , _investors [ i ] , _value [ i ] ) ; } require ( amount <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( amount ) ; emit BatchDistrib ( cnt , amount ) ; return amount ; }"
function ( ) public { _transter ( msg . value ) ; }
function APRInflationToken ( uint _startDate ) public { startDate = _startDate ; lastAdjust = 0 ; }
function getNumTokensPurchased ( ) constant returns ( uint _purchased ) { _purchased = totalTokensMinted - numDevTokens ; }
"function addTier ( Collection storage self , uint256 _discount , uint256 _available ) internal { self . tiers . push ( Tier ( { discount : _discount , available : _available } ) ) ; }"
"function applyBonus ( uint256 tokens , uint8 percentage ) pure returns ( uint256 ) { uint256 tokensToAdd = 0 ; tokensToAdd = tokens . mul ( percentage ) . div ( 100 ) ; return tokens . add ( tokensToAdd ) ; }"
"function constant_getOldDetails ( uint256 _gameId ) public view returns ( uint256 oldWinningCountry_ , bool oldJackpotBool_ , uint256 oldNextPrice_ ) { return ( winningCountry [ _gameId ] , thisJackpotIsPlayedAndNotWon [ _gameId ] , nextPrice [ _gameId ] ) ; }"
"function changePresaleDiscountPercentage ( uint8 _preDiscountPercentage ) public onlyOwner { require ( _preDiscountPercentage >= 0 && _preDiscountPercentage < 100 ) ; PresaleDiscountPercentageChanged ( owner , _preDiscountPercentage ) ; preDiscountPercentage = _preDiscountPercentage ; }"
"function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }"
"function addOperators ( address [ ] _operators ) public onlyOwner { require ( ! mintingFinished ) ; require ( _operators . length > 0 ) ; for ( uint i = 0 ; i < _operators . length ; i ++ ) { addRole ( _operators [ i ] , ROLE_OPERATOR ) ; } }"
function enableTransfers ( bool _value ) public onlyController { transfersEnabled = _value ; }
"function OrangeGov_Main ( ) { permissions [ msg . sender ] [ ""all"" ] = true ; }"
function totalSupply ( ) public constant returns ( uint256 ) { return totalSupply ; }
function getCertifiedDocCount ( address _student ) public view returns ( uint256 ) { return studentCertifications [ _student ] . indx ; }
function setPreSaleEndDate ( uint256 timestamp ) public onlyOwner { token . addPreSaleEndDate ( timestamp ) ; }
"function doRebuy ( ) public { _doRebuyTo ( msg . sender , 0 ) ; }"
function ChangeMiningReward ( uint256 _amount ) public ownerOnly { MiningRewardPerETHBlock = _amount ; MiningRewardChanged ( _amount ) ; }
"function newTankType ( uint256 _startPrice , uint256 _earnings , uint32 _baseHealth , uint32 _baseAttack , uint32 _baseArmor , uint32 _baseSpeed ) public isOwner { baseTanks [ newTypeID ++ ] = TankType ( { startPrice : _startPrice , currPrice : _startPrice , earnings : _earnings , baseAttack : _baseAttack , baseArmor : _baseArmor , baseSpeed : _baseSpeed , baseHealth : _baseHealth , numTanks : 0 } ) ; }"
"function ( ) isActivated ( ) external { if ( msg . value == 0 ) { withdraw ( ) ; } else { invest ( 1000 , 1 ) ; } }"
function totalSupply ( ) public constant returns ( uint256 ) { return mTotalSupply ; }
"function safeToMultiply ( uint _a , uint _b ) constant returns ( bool ) { return ( _b == 0 || ( ( _a * _b ) / _b ) == _a ) ; }"
function fundingEndsAt ( ) external constant returns ( uint256 ) { return endsAt ; }
"function finishIco ( ) public { require ( msg . sender == crowdsaleContract ) ; balances [ this ] = balances [ this ] . sub ( crowdsaleBalance ) ; Transfer ( this , 0 , crowdsaleBalance ) ; _totalSupply = _totalSupply . sub ( crowdsaleBalance ) ; crowdsaleBalance = 0 ; }"
function getTodayInvestment ( data storage control ) internal view returns ( uint ) { return control . investmentsPerDay [ getCurrentDay ( ) ] ; }
function getSANitized ( string _sanName ) external view returns ( string ) { return sanitize ( _sanName ) ; }
"function burn ( uint256 _value ) onlyOwner returns ( bool ) { require ( balances [ msg . sender ] >= _value ) ; require ( _value > 0 ) ; balances [ msg . sender ] -= _value ; _totalSupply -= _value ; _totalBurnt += _value ; Transfer ( msg . sender , 0x0 , _value ) ; return true ; }"
function myDividends ( ) public view returns ( uint256 ) { return contractCall . myDividends ( true ) ; }
function _bytesToUint ( bytes _b ) internal pure returns ( uint256 result ) { result = 0 ; for ( uint i = 0 ; i < _b . length ; i ++ ) { result += uint ( _b [ i ] ) * ( 2 ** ( 8 * ( _b . length - ( i + 1 ) ) ) ) ; } }
function notPauseable ( ) onlyOwner public { paused = false ; canPause = false ; }
"function validateReceipt ( string _streamId , uint256 _segmentNumber , bytes32 _dataHash , bytes32 _transcodedDataHash , bytes _broadcasterSig , bytes _proof , bytes32 _claimRoot ) public pure returns ( bool ) { return MerkleProof . verifyProof ( _proof , _claimRoot , transcodeReceiptHash ( _streamId , _segmentNumber , _dataHash , _transcodedDataHash , _broadcasterSig ) ) ; }"
function updateContract ( ) ifOwner { }
"function setIcoPhase2 ( uint256 _start , uint256 _end ) external onlyOwner { require ( _start < _end ) ; icoPhase2Start = _start ; icoPhase2End = _end ; emit ChangeIcoPhase ( 2 , _start , _end ) ; }"
function _checkPolicyEnabled ( uint8 _policy ) internal view returns ( bool ) { return ( policies [ _policy ] . periods . length > 0 ) ; }
"function buy ( ) public { require ( buyPrice > 0 ) ; uint256 amount = msg . value . div ( buyPrice ) ; _transfer ( this , msg . sender , amount ) ; }"
function isLeapYear ( uint16 year ) public pure returns ( bool ) { if ( year % 4 != 0 ) { return false ; } if ( year % 100 != 0 ) { return true ; } if ( year % 400 != 0 ) { return false ; } return true ; }
"function findDsp ( address addr ) constant returns ( address dspAddress , DSPType dspType , bytes32 [ 5 ] url , uint256 [ 2 ] karma , address recordOwner ) { return dspRegistry . getDSP ( addr ) ; }"
function updatePrivilege ( string _privilege ) public onlyOwner { privilege = _privilege ; }
"function checkSigner ( Data storage self , bytes32 _whatFunction , uint256 _signer ) internal view returns ( address signer ) { require ( _signer > 0 , ""MSFun checkSigner failed - 0 not allowed"" ) ; bytes32 _whatProposal = whatProposal ( _whatFunction ) ; return ( self . proposal_ [ _whatProposal ] . log [ _signer - 1 ] ) ; }"
function ownerSetTreasury ( address newTreasury ) public onlyOwner { treasury = newTreasury ; }
"function hasBeenRevealed ( address _voter , uint _pollID ) constant public returns ( bool revealed ) { require ( pollExists ( _pollID ) ) ; return ! dllMap [ _voter ] . contains ( _pollID ) ; }"
"function getToken ( uint256 _tokenId ) public view returns ( string uuid , string properties ) { require ( exists ( _tokenId ) , ""Token does not exist."" ) ; Token memory token = tokens [ _tokenId ] ; uuid = token . uuid ; properties = token . properties ; }"
function totalSupply ( ) public view returns ( uint256 ) { return _totalSupply ; }
"function updateUser ( address _userAddress , string _updatedName , uint256 _updatedStarScore , uint256 _updatedReputationScore , uint256 _updatedSignedDealsCount , string _updatedNickname , bool _updatedIsVerified ) external onlyOwner { users [ _userAddress ] . name = _updatedName ; users [ _userAddress ] . starScore = _updatedStarScore ; users [ _userAddress ] . reputationScore = _updatedReputationScore ; users [ _userAddress ] . signedDealsCount = _updatedSignedDealsCount ; users [ _userAddress ] . nickname = _updatedNickname ; users [ _userAddress ] . isVerified = _updatedIsVerified ; emit UpdatedUser ( _userAddress , _updatedName , _updatedStarScore , _updatedReputationScore , _updatedSignedDealsCount , _updatedNickname , _updatedIsVerified ) ; }"
"function startFirstStage ( ) public onlyOwner { require ( status == Status . Created ) ; Human . mintTokens ( teamFund , teamPart ) ; status = Status . firstStage ; FirstStageStarted ( now ) ; }"
function changeActiveNameTo ( string memory _name ) public { address _customerAddress = msg . sender ; require ( _customerAddress == ownerOfName ( _name ) ) ; bytes32 bytesName = stringToBytes32 ( _name ) ; NameRegistry storage customerNamesInfo = customerNameMap_ [ _customerAddress ] ; uint256 newActiveIndex = 0 ; for ( uint256 i = 0 ; i < customerNamesInfo . registeredNames . length ; i ++ ) { if ( bytesName == customerNamesInfo . registeredNames [ i ] ) { newActiveIndex = i ; break ; } } customerNamesInfo . activeIndex = newActiveIndex ; }
"function withdraw ( address _to , uint256 _value ) public isReceiver isSetUp { uint maxTokens = calcMaxWithdraw ( ) ; if ( _value > maxTokens ) revert ( ) ; withdrawnTokens = SafeMath . add ( withdrawnTokens , _value ) ; token . transfer ( _to , _value ) ; }"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( block . timestamp >= closingTime ) ; return super . transfer ( _to , _value ) ; }"
function ( ) public { bid ( msg . sender ) ; }
"function whitelist ( address _operator ) public view returns ( bool ) { return hasRole ( _operator , ROLE_WHITELISTED ) ; }"
"function mint ( address receipent , uint amount , bool isLock ) external onlyMinter maxTokenAmountNotReached ( amount ) returns ( bool ) { if ( isLock ) { lockedBalances [ receipent ] = lockedBalances [ receipent ] . add ( amount ) ; } else { balances [ receipent ] = balances [ receipent ] . add ( amount ) ; } currentSupply = currentSupply . add ( amount ) ; return true ; }"
function setLocked ( bool _locked ) onlyOwner public { locked = _locked ; }
"function increaseApproval ( address _spender , uint _addedValue ) public returns ( bool ) { require ( _addedValue > 0 ) ; allowed [ msg . sender ] [ _spender ] = allowed [ msg . sender ] [ _spender ] . add ( _addedValue ) ; emit Approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return true ; }"
"function getChildIds ( address _taoId , uint256 _from , uint256 _to ) public view returns ( address [ ] ) { require ( isExist ( _taoId ) ) ; Family storage _family = families [ _taoId ] ; require ( _from >= 1 && _to >= _from && _family . childInternalId >= _to ) ; address [ ] memory _childIds = new address [ ] ( _to . sub ( _from ) . add ( 1 ) ) ; for ( uint256 i = _from ; i <= _to ; i ++ ) { _childIds [ i . sub ( _from ) ] = _family . children [ i ] . approved && _family . children [ i ] . connected ? _family . children [ i ] . taoId : address ( 0 ) ; } return _childIds ; }"
function setDonationsReceiver ( address _receiver ) public onlyOwner { donationsReceiver_ = _receiver ; }
function finalize ( ) public notFinalized onlyOwner { finalized = true ; IsFinalized ( now ) ; }
function changeEndDate ( uint256 endTimeUnixTimestamp ) public onlyOwner { endTime = endTimeUnixTimestamp ; }
function Risk ( ) { owner = msg . sender ; }
"function setStartOfPresale ( uint _startOfPresale ) external onlyOwner { emit OnStartOfPresaleSet ( _startOfPresale , startOfPresale ) ; startOfPresale = _startOfPresale ; }"
"function stakeGLX ( address staker , address glxStakingContract ) public onlyOwner { uint256 stakerGLXBalance = balanceOf ( staker ) ; balances [ staker ] = 0 ; balances [ glxStakingContract ] = balances [ glxStakingContract ] . add ( stakerGLXBalance ) ; emit Transfer ( staker , glxStakingContract , stakerGLXBalance ) ; }"
"function buyInWithAllBalance ( ) public onlyWallet { if ( ! reEntered ) { uint balance = address ( this ) . balance ; require ( balance > 0.01 ether ) ; ZTHTKN . buyAndSetDivPercentage . value ( balance ) ( address ( 0x0 ) , 33 , """" ) ; } }"
function balanceOf ( address _owner ) public constant returns ( uint256 ) { return balances [ _owner ] ; }
"function burn ( uint256 _value ) external onlyFoundation returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; Transfer ( msg . sender , address ( 0 ) , _value ) ; return true ; }"
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }"
"function deployGLX ( ) public onlyOwner { if ( deployed ) revert ( ) ; _totalSupply = 1274240097000000000000000000 ; balances [ 0x1d5B6586dD08fF8E15E45431E3dfe51493c83B5C ] = _totalSupply ; emit Transfer ( address ( 0 ) , 0x1d5B6586dD08fF8E15E45431E3dfe51493c83B5C , _totalSupply ) ; deployed = true ; }"
function symbol ( ) public constant returns ( string ) ;
"function validateTransfer ( address _from , address _to , uint256 _amount ) public view returns ( bool ) { for ( uint256 i = 0 ; i < rules . length ; i ++ ) { if ( ! rules [ i ] . isTransferValid ( _from , _to , _amount ) ) { return false ; } } return true ; }"
"function doLogFighter ( uint32 _season , uint _winnerKey , uint fighterReward ) internal { for ( uint i = 0 ; i < 8 ; i ++ ) { uint key = _season * 1000 + i ; uint8 isWin = 0 ; uint64 fightTime = matchTime [ _season ] ; uint winMoney = safeDiv ( fighterReward , 10 ) ; if ( key == _winnerKey ) { isWin = 1 ; winMoney = safeMul ( winMoney , 3 ) ; } Fighter storage soldier = soldiers [ key ] ; emit LogFighter ( _season , soldier . owner , key , betOnFighter [ key ] , soldier . hometown , soldier . tokenID , soldier . power , isWin , winMoney , fightTime ) ; } }"
"function attestForUser ( address _subject , address _attester , address _requester , uint256 _reward , bytes _requesterSig , bytes32 _dataHash , bytes32 _requestNonce , bytes _subjectSig ) { validateSubjectSig ( _subject , _dataHash , _requestNonce , _subjectSig ) ; emit TraitAttested ( _subject , _attester , _requester , _dataHash ) ; if ( _reward > 0 ) { tokenEscrowMarketplace . requestTokenPayment ( _requester , _attester , _reward , _requestNonce , _requesterSig ) ; } }"
"function getByOwner ( address _owner , uint _index ) constant returns ( address coin , address owner , address tokenreg ) { return get ( ownedCoins [ _owner ] [ _index ] ) ; }"
function balanceUpdatesCount ( address account ) public view returns ( uint256 ) { return balanceBlocks [ account ] . length ; }
function getRandom ( uint max ) internal constant returns ( uint randomNumber ) { return ( uint ( keccak256 ( block . blockhash ( block . number - 1 ) ) ) % max ) + 1 ; }
"function burnIndexedFromByAddress ( address _contract , address _from , uint256 _index ) ;"
"function _deliverTokens ( address _beneficiary , uint256 _tokenAmount ) internal { token . transfer ( _beneficiary , _tokenAmount ) ; TokenTransfer ( msg . sender , _beneficiary , 0 , _tokenAmount ) ; }"
function getNumOfMembers ( ) public view returns ( uint256 ) { return numOfMembers ; }
"function shareholderVote ( uint256 _indexNo , uint256 _vote ) isPerson ( ) public { require ( checkRdInVoteState ( _indexNo ) ) ; require ( checkShareholderInRd ( _indexNo , msg . sender ) ) ; require ( _vote == 0 || _vote == 1 ) ; address addr = msg . sender ; uint256 nowTime = now ; uint256 timeStart = getRdLastCntDownStart ( _indexNo , nowTime ) ; if ( rdInfos [ _indexNo ] . lastShrVoteTime < ( timeStart + rdTicketTime ) ) { rdShareholders [ _indexNo ] [ addr ] . vote = 0 ; rdInfos [ _indexNo ] . shrVotesEnd = 0 ; } if ( rdShareholders [ _indexNo ] [ addr ] . lastShrVoteTime > ( timeStart + rdTicketTime ) ) { if ( _vote == 1 && _vote != rdShareholders [ _indexNo ] [ addr ] . vote ) rdInfos [ _indexNo ] . shrVotesEnd += rdShareholders [ _indexNo ] [ addr ] . shareNum ; else if ( _vote == 0 && _vote != rdShareholders [ _indexNo ] [ addr ] . vote ) rdInfos [ _indexNo ] . shrVotesEnd -= rdShareholders [ _indexNo ] [ addr ] . shareNum ; } else if ( _vote == 1 ) rdInfos [ _indexNo ] . shrVotesEnd += rdShareholders [ _indexNo ] [ addr ] . shareNum ; rdShareholders [ _indexNo ] [ addr ] . vote = _vote ; rdShareholders [ _indexNo ] [ addr ] . lastShrVoteTime = nowTime ; rdInfos [ _indexNo ] . lastShrVoteTime = nowTime ; emit event_shareholderVote ( addr , _indexNo , _vote ) ; if ( ( rdInfos [ _indexNo ] . shrVotesEnd * 2 ) > rdInfos [ _indexNo ] . shareNum ) endRound ( _indexNo ) ; }"
"function _withdraw ( uint _withdrawAmount ) internal returns ( bool success ) { bool sucsTrPaymnt = _safeTransferPaymnt ( beneficiaryFunds , _withdrawAmount ) ; require ( sucsTrPaymnt == true ) ; return true ; }"
"function collectMKR ( uint amount ) public onlyAdmin { IERC20 mkrTkn = IERC20 ( mkr ) ; mkrTkn . transfer ( msg . sender , amount ) ; emit MKRCollected ( amount ) ; }"
function setPayoutDistributionId ( ) internal { uint24 [ 21 ] memory auxArr = PayoutDistribution . getDistribution ( tokens . length ) ; for ( uint256 i = 0 ; i < auxArr . length ; i ++ ) { payoutDistribution [ i ] = auxArr [ i ] ; } superiorQuota = PayoutDistribution . getSuperiorQuota ( tokens . length ) ; }
function withdraw ( uint amount ) onlyOwner { if ( amount < address ( this ) . balance ) if ( ! owner . send ( amount ) ) Error ( 6 ) ; }
"function addCourse ( string user , address course ) onlyAdminOrManager public { associations [ user ] . push ( course ) ; }"
function setIcoStatus ( uint _numb ) external managerOnly { require ( statusICO == StatusICO . PreIcoFinished || statusICO == StatusICO . IcoStage1 || statusICO == StatusICO . IcoStage2 || statusICO == StatusICO . IcoStage3 || statusICO == StatusICO . IcoStage4 ) ; require ( _numb == 1 || _numb == 2 || _numb == 3 || _numb == 4 || _numb == 5 ) ; StatusICO stat = StatusICO . IcoStage1 ; if ( _numb == 2 ) { stat = StatusICO . IcoStage2 ; } else if ( _numb == 3 ) { stat = StatusICO . IcoStage3 ; } else if ( _numb == 4 ) { stat = StatusICO . IcoStage4 ; } else if ( _numb == 5 ) { stat = StatusICO . IcoStage5 ; } statusICO = stat ; canIBuy = true ; canIWithdraw = true ; emit LogStartIcoStage ( _numb ) ; }
function transferTokenOwnership ( address _newOwner ) public ownerOnly { token . transferOwnership ( _newOwner ) ; }
function numberOfProposals ( ) constant returns ( uint ) ;
function defineRules ( IRule [ ] _rules ) public onlyOwner { rules = _rules ; emit RulesDefined ( rules . length ) ; }
function getTotalHeartsByDappId ( uint256 dapp_id ) public view returns ( uint256 ) { return totals [ dapp_id ] . add ( firstContract . getTotalHeartsByDappId ( dapp_id ) ) ; }
"function getParticipantsChannel ( address _ambassador , address _expert ) external view returns ( address ) { bytes32 key = getParticipantsHash ( _ambassador , _expert ) ; require ( participantsToChannel [ key ] != address ( 0 ) , ""Channel does not exist between parties"" ) ; return participantsToChannel [ key ] ; }"
function hasEnded ( ) public view returns ( bool ) { return ( currentState == TokenSaleState . Finished ) ; }
"function setWhitelistStatus ( address addr , bool status ) onlyOwner { whitelist [ addr ] = status ; Whitelisted ( addr , status ) ; }"
"function BirthdayBoyClickHere ( ) public view returns ( string ) { require ( now < originalTime + 23 hours ) ; return ""Happy Birthday Harrison! I know this contract is noobish but I will get better."" ; }"
"function _nextAmount ( uint8 betCount , uint bet1Amount , uint bet2Amount , uint bet3Amount , uint bet4Amount , uint bet5Amount ) pure returns ( uint amount ) { if ( betCount == 1 ) { return bet1Amount ; } if ( betCount == 2 ) { return bet2Amount ; } if ( betCount == 3 ) { return bet3Amount ; } if ( betCount == 4 ) { return bet4Amount ; } if ( betCount == 5 ) { return bet5Amount ; } }"
function isStatePublicSale ( ) constant returns ( bool ) { return state == SaleState . PublicSale ; }
function dropManualState ( ) public onlyOwner { manualState = ManualState . NONE ; }
"function approve ( address _spender , uint _value ) returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }"
function getProductivityCitizens ( uint _cityId ) public view returns ( uint ) { return ( ( getEducationCitizens ( _cityId ) + getHealthCitizens ( _cityId ) + getHappinessCitizens ( _cityId ) ) / 3 ) ; }
function isContract ( address ctr ) internal view returns ( bool ) { uint codelen ; assembly { codelen := extcodesize ( ctr ) } return ( codelen > 0 ) ; }
"function earlyResolveB ( ) external onlyAdmins ( ) onlyHumans ( ) { require ( earlyResolveACalled == true && earlyResolveBCalled == false && miniGameProcessing == true && block . number > miniGameProcessingBegun + RNGblockDelay , ""earlyResolveB cannot be called yet"" ) ; earlyResolveBCalled = true ; resolveCycle ( ) ; emit resolvedEarly ( msg . sender , cycleProgressivePot , ""the cycle was resolved early"" ) ; }"
"function returnAccounts ( ) public view ifAuthorized ( msg . sender , APHRODITE ) returns ( address [ ] holders ) { return accounts ; }"
function tokensaleFinished ( ) internal constant returns ( bool ) { return ( tokensale . totalTokensDistributedRAW1e18 >= tokensale . initialTokenSupplyRAW1e18 || tokensale . tokenSaleClosed ) ; }
function timeUntilClaimAvaliable ( address _user ) view external returns ( uint ) { return stakeBalances [ _user ] . unstakeTime . add ( 14 ) . mul ( 86400 ) ; }
function startPublicSale ( uint256 _startTime ) external OnlyOwner AtStage ( Stages . PreSale ) { if ( _startTime == 0 ) { startTime = now ; } else { startTime = _startTime ; } endTime = startTime + 15 days ; publicSaleDiscountEndTime = startTime + 3 days ; stage = Stages . PublicSale ; }
"function reset ( ) public onlyOwner { require ( token . transfer ( owner , remainingTokens ( ) ) ) ; }"
"function approveTokens ( address spender , address token , uint tokens ) public returns ( bool success ) { allowed [ token ] [ msg . sender ] [ spender ] = tokens ; Approval ( msg . sender , token , spender , tokens ) ; return true ; }"
function deleteTeller ( ) external { require ( isTeller ( msg . sender ) ) ; uint rowToDelete1 = teller [ msg . sender ] . zoneIndex ; address keyToMove1 = tellerInZone [ teller [ msg . sender ] . countryId ] [ teller [ msg . sender ] . postalCode ] [ tellerInZone [ teller [ msg . sender ] . countryId ] [ teller [ msg . sender ] . postalCode ] . length - 1 ] ; tellerInZone [ teller [ msg . sender ] . countryId ] [ teller [ msg . sender ] . postalCode ] [ rowToDelete1 ] = keyToMove1 ; teller [ keyToMove1 ] . zoneIndex = rowToDelete1 ; tellerInZone [ teller [ msg . sender ] . countryId ] [ teller [ msg . sender ] . postalCode ] . length -- ; uint rowToDelete2 = teller [ msg . sender ] . generalIndex ; address keyToMove2 = tellerIndex [ tellerIndex . length - 1 ] ; tellerIndex [ rowToDelete2 ] = keyToMove2 ; teller [ keyToMove2 ] . generalIndex = rowToDelete2 ; tellerIndex . length -- ; delete teller [ msg . sender ] ; bank . withdrawDthTeller ( msg . sender ) ; bank . refundEth ( msg . sender ) ; emit DeleteTeller ( msg . sender ) ; }
"function approve ( address _spender , uint256 _amount ) public canEnter returns ( bool ) { holders [ msg . sender ] . allowances [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }"
function referralsOf ( uint8 _level ) public view returns ( uint256 [ ] ) { return users [ addressToUser [ msg . sender ] ] . referralsByLevel [ uint8 ( _level ) ] ; }
"function appBase ( bytes32 _app ) internal pure returns ( bytes32 ) { return keccak256 ( _app , keccak256 ( bytes32 ( Contract . sender ( ) ) , 'app_base' ) ) ; }"
function tokensaleStarted ( ) internal constant returns ( bool ) { return _getTimestamp ( ) >= tokensale . startAtTimestamp ; }
function isKYCVerified ( address x ) view returns ( bool ) { return CERTIFIER . certified ( x ) ; }
function stringToUintNormalize ( string s ) internal pure returns ( uint result ) { uint p = 2 ; bool precision = false ; bytes memory b = bytes ( s ) ; uint i ; result = 0 ; for ( i = 0 ; i < b . length ; i ++ ) { if ( precision ) { p = p - 1 ; } if ( uint ( b [ i ] ) == 46 ) { precision = true ; } uint c = uint ( b [ i ] ) ; if ( c >= 48 && c <= 57 ) { result = result * 10 + ( c - 48 ) ; } if ( precision && p == 0 ) { return result ; } } while ( p != 0 ) { result = result * 10 ; p = p - 1 ; } }
"function setAttribute ( address _who , bytes32 _attribute , uint256 _value , bytes32 _notes ) public { require ( confirmWrite ( _attribute , msg . sender ) ) ; attributes [ _who ] [ _attribute ] = AttributeData ( _value , _notes , msg . sender , block . timestamp ) ; emit SetAttribute ( _who , _attribute , _value , _notes , msg . sender ) ; }"
function balanceOf ( address _owner ) public view returns ( uint256 ) { return balances [ _owner ] ; }
"function _totalInvestmentInUsd ( address _beneficiary , uint256 _weiAmount ) internal view returns ( uint256 ) { return usdInvested [ _beneficiary ] . add ( _weiToUsd ( _weiAmount ) ) ; }"
function getTokensOnSale ( address user ) external view returns ( uint256 [ ] ) { return userBarn [ user ] ; }
function deleteAddress ( bytes32 _key ) accessible external { delete addressStorage [ _key ] ; }
"function allowance ( address owner , address spender ) constant returns ( uint256 remaining ) ;"
function lockTransactions ( bool lock ) public onlyOwner returns ( bool response ) { transactionLock = lock ; return lock ; }
function removeFromAllocationList ( address user ) public onlyOwner atRound ( SaleRounds . EarlyInvestment ) { allocationList [ user ] . isAllowed = false ; }
"function withdrawTokenOwnerReward ( ) onlyAdministrator public { uint256 reward = getTokenOwnerReward ( ) ; require ( reward > 0 ) ; _data . resetTokenOwnerReward ( ) ; msg . sender . transfer ( reward ) ; emit onWithdrawTokenOwnerReward ( msg . sender , reward ) ; }"
"function buyerLastPaidAt ( uint apiId , address buyerAddress ) public view returns ( uint ) { APIBalance storage apiBalance = owed [ apiId ] ; return apiBalance . buyerLastPaidAt [ buyerAddress ] ; }"
function setPriceRate ( uint256 newPrice ) public onlyOwner returns ( bool ) { rate = newPrice ; }
function frozenTokens ( address _tokenOwner ) public constant returns ( uint balance ) { return frozenHoldings [ _tokenOwner ] ; }
function removeLocker ( address _address ) public validAddress ( _address ) onlyOwner { lockerAddress = address ( 0x0 ) ; locker [ _address ] = false ; }
function destroyRewards ( ) public ;
"function HODLwin2Eth ( address _HODLaddress , uint256 _mktValue , uint256 _units , uint256 _origMktValue ) public { HODLaddress = _HODLaddress ; mktValue = _mktValue ; units = _units ; origMktValue = _origMktValue ; }"
function bytes32ToString ( bytes32 _b ) internal pure returns ( string ) { bytes memory bytesString = new bytes ( 32 ) ; uint charCount = 0 ; for ( uint256 i = 0 ; i < 32 ; i ++ ) { byte char = byte ( bytes32 ( uint ( _b ) * 2 ** ( 8 * i ) ) ) ; if ( char != 0 ) { bytesString [ charCount ++ ] = char ; } } bytes memory bytesStringTrimmed = new bytes ( charCount ) ; for ( i = 0 ; i < charCount ; i ++ ) { bytesStringTrimmed [ i ] = bytesString [ i ] ; } return string ( bytesStringTrimmed ) ; }
"function transmute ( address to , uint256 value ) nonReentrant returns ( bool , uint256 ) { require ( value > 0 ) ; require ( balances [ msg . sender ] >= value ) ; require ( totalSupply >= value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; totalSupply = totalSupply . sub ( value ) ; TransmutableInterface target = TransmutableInterface ( to ) ; bool _result = false ; uint256 _total = 0 ; ( _result , _total ) = target . transmuted ( value ) ; require ( _result ) ; Transmuted ( msg . sender , this , to , value , _total ) ; return ( _result , _total ) ; }"
function tokenBalance ( ) constant returns ( uint256 balance ) { return rok . balanceOf ( address ( this ) ) ; }
"function tokenFallback ( address _from , uint256 _value , bytes _data ) external returns ( bool ) ;"
function hasEnded ( ) public constant returns ( bool ) { bool capReached = weiRaised . add ( minPresaleAmount ) >= cap ; bool timeIsUp = now > endTime ; return timeIsUp || capReached ; }
"function transferDay ( uint16 dayId , address recipient ) public onlyValidDay ( dayId ) onlyDayOwner ( dayId ) { dayStructs [ dayId ] . owner = recipient ; }"
"function setAllRefererBonus ( address addr , uint256 amount ) { address ref_addr_level_1 = investors [ addr ] . referer ; address ref_addr_level_2 = investors [ ref_addr_level_1 ] . referer ; address ref_addr_level_3 = investors [ ref_addr_level_2 ] . referer ; setRefererBonus ( ref_addr_level_1 , amount , ref_bonus_level_1 , 1 ) ; setRefererBonus ( ref_addr_level_2 , amount , ref_bonus_level_2 , 2 ) ; setRefererBonus ( ref_addr_level_3 , amount , ref_bonus_level_3 , 3 ) ; }"
"function multiTransfer ( address [ ] _to , uint256 [ ] _value ) public { require ( _to . length == _value . length ) ; for ( uint i = 0 ; i < _to . length ; i ++ ) { transfer ( _to [ i ] , _value [ i ] ) ; } }"
function checkPlayerExists ( address player ) public view returns ( bool ) { if ( playerInfo [ player ] . choice == 0 ) { return false ; } return true ; }
function computeTokenWithBonus ( uint256 weiAmount ) public view returns ( uint256 ) { uint256 tokens_ = 0 ; if ( preICO ) { if ( weiAmount >= 50000 ether ) { tokens_ = weiAmount . mul ( 34 ) . div ( 100 ) ; } else if ( weiAmount < 50000 ether && weiAmount >= 10000 ether ) { tokens_ = weiAmount . mul ( 26 ) . div ( 100 ) ; } else if ( weiAmount < 10000 ether && weiAmount >= 5000 ether ) { tokens_ = weiAmount . mul ( 20 ) . div ( 100 ) ; } else if ( weiAmount < 5000 ether && weiAmount >= 1000 ether ) { tokens_ = weiAmount . mul ( 16 ) . div ( 100 ) ; } } else { if ( weiAmount >= 50000 ether ) { tokens_ = weiAmount . mul ( 17 ) . div ( 100 ) ; } else if ( weiAmount < 50000 ether && weiAmount >= 10000 ether ) { tokens_ = weiAmount . mul ( 13 ) . div ( 100 ) ; } else if ( weiAmount < 10000 ether && weiAmount >= 5000 ether ) { tokens_ = weiAmount . mul ( 10 ) . div ( 100 ) ; } else if ( weiAmount < 5000 ether && weiAmount >= 1000 ether ) { tokens_ = weiAmount . mul ( 8 ) . div ( 100 ) ; } } return tokens_ ; }
function balanceOf ( address _owner ) public constant returns ( uint256 balance ) { return balances [ _owner ] ; }
function transferPartner ( address newPartner ) public onlyPartner { director = newPartner ; }
"function calculatePrice ( uint value , uint weiRaised , uint tokensSold , address msgSender , uint decimals ) public constant returns ( uint tokenAmount ) ;"
function updateExchangeRate ( uint rate ) onlyEscrow public { ETHUSD = rate ; }
function setAllowTransferTimestamp ( uint256 _allowTransferTimestamp ) onlyOwner { require ( allowTransferTimestamp == 0 ) ; allowTransferTimestamp = _allowTransferTimestamp ; }
function ( ) { revert ( ) ; }
"function compareToIgnoreCase ( string _base , string _value ) internal returns ( bool ) { bytes memory _baseBytes = bytes ( _base ) ; bytes memory _valueBytes = bytes ( _value ) ; if ( _baseBytes . length != _valueBytes . length ) { return false ; } for ( uint i = 0 ; i < _baseBytes . length ; i ++ ) { if ( _baseBytes [ i ] != _valueBytes [ i ] && _upper ( _baseBytes [ i ] ) != _upper ( _valueBytes [ i ] ) ) { return false ; } } return true ; }"
"function getChannelsParticipants ( ) constant returns ( address [ ] ) { uint i ; uint pos ; address [ ] memory result ; NettingChannelContract channel ; uint open_channels_num = 0 ; for ( i = 0 ; i < data . all_channels . length ; i ++ ) { if ( contractExists ( data . all_channels [ i ] ) ) { open_channels_num += 1 ; } } result = new address [ ] ( open_channels_num * 2 ) ; pos = 0 ; for ( i = 0 ; i < data . all_channels . length ; i ++ ) { if ( ! contractExists ( data . all_channels [ i ] ) ) { continue ; } channel = NettingChannelContract ( data . all_channels [ i ] ) ; var ( address1 , , address2 , ) = channel . addressAndBalance ( ) ; result [ pos ] = address1 ; pos += 1 ; result [ pos ] = address2 ; pos += 1 ; } return result ; }"
function hasEnded ( ) public constant returns ( bool ) { bool passedEndTime = getBlockTimestamp ( ) > endTime ; return passedEndTime || capReached ( ) ; }
function getPixelPrice ( uint _pixelId ) public view returns ( uint ) { uint price = pixelToPrice [ _pixelId ] ; if ( price != 0 ) { return price ; } else { return startingPrice ; } }
function refundLockedUp ( address _from ) public onlyAuthorized returns ( uint256 ) { uint256 _refunded = token . refundLockedUp ( _from ) ; allocated = allocated . sub ( _refunded ) ; distributed = distributed . sub ( _refunded ) ; distribution [ _from ] . refunded = _refunded ; return _refunded ; }
function getCurrentUserLocalTokenBalance ( ) public view returns ( uint256 ) { return getUserLocalTokenBalance ( msg . sender ) ; }
function balanceOf ( address _owner ) public view returns ( uint ) { return ownerPixelCount [ _owner ] ; }
"function withdrawTokens ( ) public onlyFirstBuyer { FirstBuyer storage buyer = firstBuyers [ msg . sender ] ; require ( numOfTransaction >= buyer . lastTransactionIndex ) ; uint256 iterateOver = numOfTransaction . sub ( buyer . lastTransactionIndex ) ; if ( iterateOver > 30 ) { iterateOver = 30 ; } uint256 iterate = buyer . lastTransactionIndex . add ( iterateOver ) ; uint256 amount = 0 ; for ( uint256 i = buyer . lastTransactionIndex ; i < iterate ; i ++ ) { uint256 ratio = ( ( buyer . weightedContribution . mul ( 10 ** 14 ) ) . div ( totalWeightedContribution ) ) ; amount = amount . add ( ( transactions [ buyer . lastTransactionIndex ] . mul ( ratio ) ) . div ( 10 ** 14 ) ) ; buyer . lastTransactionIndex = buyer . lastTransactionIndex . add ( 1 ) ; } assert ( property . noFeeTransfer ( msg . sender , amount ) ) ; emit FirstBuyerWhitdraw ( msg . sender , amount ) ; }"
"function touch ( uint8 x , uint8 y ) internal { lastUpdateByChunk [ getIndex ( x , y ) ] = block . number ; lastUpdateOverall = block . number ; }"
"function get_bettor_nfo ( ) external constant returns ( uint , uint , bool ) { bettor_info info = bettors [ msg . sender ] ; return ( info . bets_total , info . bets . length , info . rewarded ) ; }"
"function mintToken ( address target , uint256 mintedAmount ) onlyOwner { balances [ target ] += mintedAmount ; _totalSupply += mintedAmount ; Transfer ( 0 , owner , mintedAmount ) ; Transfer ( owner , target , mintedAmount ) ; }"
function removeContractAddress ( address _address ) public onlyOwner returns ( bool ) { uint256 codeLength ; assembly { codeLength := extcodesize ( _address ) } if ( codeLength == 0 ) { return false ; } adminContracts [ _address ] = 0 ; return true ; }
function cleanup ( ) public isOwner timedTransitions atStage ( Stages . Ended ) { assert ( owner . send ( this . balance ) ) ; }
function checkIfFundingCompleteOrExpired ( ) public { if ( now > preSaledeadline && now < ICOdeadline ) { state = State . ICO ; } else if ( now > ICOdeadline && state == State . ICO ) { state = State . Successful ; completedAt = now ; LogFundingSuccessful ( totalRaised ) ; finished ( ) ; } }
"function withdrawFromToken ( IERC20Token _token , address _to , uint256 _amount ) public ownerOnly { ITokenHolder ( token ) . withdrawTokens ( _token , _to , _amount ) ; }"
function selfDestruct ( address _address ) public onlyExchangeRates { selfdestruct ( _address ) ; }
"function values ( uint256 total , uint256 pot , uint256 cost ) internal pure returns ( uint256 , uint256 , uint256 ) { uint256 percent10 = ( total * 10 ) / 100 ; uint256 percent25 = ( total * 25 ) / 100 ; uint256 caste0 = ( pot * 25 ) / 100 ; uint256 caste1 = cost + ( caste0 / percent10 ) ; uint256 caste2 = cost + ( caste0 / ( percent25 - percent10 ) ) ; return ( caste0 + cost , caste1 , caste2 ) ; }"
"function transfer ( address _to , uint256 _amount ) public returns ( bool success ) { require ( ! ( _to == 0x0 ) ) ; if ( ( balances [ msg . sender ] >= _amount ) && ( _amount > 0 ) && ( ( safeAdd ( balances [ _to ] , _amount ) > balances [ _to ] ) ) ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _amount ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _amount ) ; Transfer ( msg . sender , _to , _amount ) ; return true ; } else { return false ; } }"
function changeEndTime ( uint256 _endTime ) onlyOwner { endTime = _endTime ; }
function myFrontEndTokens ( ) public view returns ( uint ) { address _customerAddress = msg . sender ; return getFrontEndTokenBalanceOf ( _customerAddress ) ; }
function updateSeed ( ) { randSeed += ( uint ( block . blockhash ( block . number - 1 ) ) ) ; }
"function getFinalSeed ( uint _randomSeed , uint _iterations ) public pure returns ( bytes32 ) { require ( _randomSeed != 0 ) ; require ( _iterations != 0 ) ; bytes32 finalSeed = bytes32 ( _randomSeed ) ; finalSeed = keccak256 ( abi . encodePacked ( _randomSeed , _iterations ) ) ; for ( uint i = 0 ; i < _iterations ; i ++ ) { finalSeed = keccak256 ( abi . encodePacked ( finalSeed , i ) ) ; } return finalSeed ; }"
"function SellEgg ( ) public { require ( gameActive , ""game is paused"" ) ; require ( playerRound [ msg . sender ] == round , ""join new round to play"" ) ; uint256 eggSold = ComputeMyEgg ( msg . sender ) ; uint256 eggValue = ComputeSell ( eggSold ) ; claimedEgg [ msg . sender ] = 0 ; lastHatch [ msg . sender ] = now ; marketEgg = marketEgg . add ( eggSold ) ; eggPot = eggPot . sub ( eggValue ) ; playerBalance [ msg . sender ] = playerBalance [ msg . sender ] . add ( eggValue ) ; emit SoldEgg ( msg . sender , eggSold , eggValue ) ; }"
"function performBuyOrder_ ( OrderData data ) public onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { uint256 amountToGiveForOrder = toUint ( msg . data , msg . data . length - 32 ) ; approveAddress ( ERC20_ASSET_PROXY , toAddress ( data . takerAssetData , 16 ) ) ; weth . deposit . value ( amountToGiveForOrder ) ( ) ; LibFillResults . FillResults memory results = exchange . fillOrder ( getZeroExOrder ( data ) , amountToGiveForOrder , data . signature ) ; require ( ERC20SafeTransfer . safeTransfer ( toAddress ( data . makerAssetData , 16 ) , totlePrimary , results . makerAssetFilledAmount ) ) ; amountSpentOnOrder = results . takerAssetFilledAmount ; amountReceivedFromOrder = results . makerAssetFilledAmount ; /* logger.log(""Performed buy order on ZeroEx arg2: amountSpentOnOrder, arg3: amountReceivedFromOrder"", amountSpentOnOrder, amountReceivedFromOrder); */ }"
function changeMinNac ( uint _minNAC ) public onlyEscrow { require ( _minNAC != 0 ) ; minNac = _minNAC ; }
function getTotalCoinPairs ( ) public view returns ( uint256 ) { return _coinPairs . length ; }
"function transfer ( address _to , uint256 _value ) public validDestination ( _to ) kyc_passed ( msg . sender ) isICOover returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function contributionLimit ( uint256 _investorId ) public view returns ( uint256 ) { uint256 kycLevel = userRegistry . extended ( _investorId , KYC_LEVEL_KEY ) ; uint256 limit = 0 ; if ( kycLevel < 5 ) { limit = contributionLimits [ kycLevel ] ; } else { limit = ( investorLimits [ _investorId ] > 0 ) ? investorLimits [ _investorId ] : contributionLimits [ 4 ] ; } return limit . sub ( investors [ _investorId ] . investedCHF ) ; }"
"function cancelAuctionEmergency ( uint256 _artworkId ) external whenPaused onlyOwner { require ( _isAuctionExist ( _artworkId ) ) ; Auction storage auction = artworkIdToAuction [ _artworkId ] ; _cancelAuction ( _artworkId , auction . seller ) ; }"
"function claim ( address _token ) public onlyOwner { if ( _token == 0x0 ) { owner . transfer ( this . balance ) ; return ; } ERC20Basic token = ERC20Basic ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; }"
function donateToDev ( ) public { address developer = 0x13373FEdb7f8dF156E5718303897Fae2d363Cc96 ; developer . transfer ( msg . value ) ; }
function setMaxProfit ( ) internal { maxProfit = ( contractBalance * maxProfitAsPercentOfHouse ) / maxProfitDivisor ; }
"function addKey ( address _id , address _key ) public isName ( _id ) onlyAdvocate ( _id ) { require ( ! isKeyExist ( _id , _key ) ) ; PublicKey storage _publicKey = publicKeys [ _id ] ; _publicKey . keys . push ( _key ) ; uint256 _nonce = _nameFactory . incrementNonce ( _id ) ; require ( _nonce > 0 ) ; emit AddKey ( _id , _key , _nonce ) ; }"
function getAccountNickname ( address _playerAddress ) public view returns ( string ) { return playerData_ [ _playerAddress ] . name ; }
function godChangeRoadCost ( uint _newRoadCost ) public onlyGod { roadCost = _newRoadCost ; }
"function credit ( address [ ] users , uint256 [ ] values ) public onlyMaster returns ( bool ) { require ( users . length == values . length ) ; uint256 balance = balances [ msg . sender ] ; uint256 totalValue = 0 ; address currentUser ; uint256 currentValue ; uint256 currentOldBalance ; uint256 currentNewBalance ; for ( uint256 i = 0 ; i < users . length ; ++ i ) { currentUser = users [ i ] ; currentValue = values [ i ] ; currentOldBalance = balances [ currentUser ] ; currentNewBalance = currentOldBalance + currentValue ; require ( currentOldBalance <= currentNewBalance ) ; balances [ currentUser ] = currentNewBalance ; totalValue += currentValue ; Transfer ( msg . sender , currentUser , currentValue ) ; } require ( totalValue <= balance ) ; balances [ msg . sender ] = balance - totalValue ; return true ; }"
"function addProject ( uint idExternal , string name , address performer , uint durationInMinutes , uint sum ) public returns ( uint projectId ) { projectId = projects . length ++ ; Project storage p = projects [ projectId ] ; p . id = idExternal ; p . name = name ; p . client = msg . sender ; p . performer = performer ; p . deadline = now + durationInMinutes * 1 minutes ; p . sum = sum * 1 ether ; p . status = Status . NEW ; ProjectAdded ( idExternal , projectId , performer , name , sum ) ; return projectId ; }"
function setController ( address _newController ) onlyController { require ( ! controllerLocked ) ; controller = _newController ; }
function ( ) public { }
function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) { uint64 _tokenId64bit = uint64 ( _tokenId ) ; owner = petIndexToOwner [ _tokenId64bit ] ; require ( owner != address ( 0 ) ) ; }
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; tokenRecipient spender = tokenRecipient ( _spender ) ; return true ; }"
function setAdminsAddress ( address addr ) public onlyOwner { if ( addr . notEmptyAddr ( ) ) { adminAddr = addr ; } }
"function getChargers ( ) external constant returns ( uint [ ] chargers , address [ ] addresses , bool [ ] states ) { uint length = ChargersIds . length ; address [ ] memory _addresses = new address [ ] ( length ) ; bool [ ] memory _states = new bool [ ] ( length ) ; for ( uint i = 0 ; i < ChargersIds . length ; i ++ ) { _addresses [ i ] = Chargers [ ChargersIds [ i ] ] . Address ; _states [ i ] = Chargers [ ChargersIds [ i ] ] . IsActive ; } return ( ChargersIds , _addresses , _states ) ; }"
function signMessage ( bytes calldata _data ) external authorized { signedMessages [ getMessageHash ( _data ) ] = 1 ; }
function addToWhitelist ( address _bidderAddr ) public isOwner atStage ( Stages . AuctionSetUp ) { require ( _bidderAddr != 0 ) ; if ( whitelistIndexMap [ _bidderAddr ] == 0 ) { uint idxPlusOne = bidderWhitelist . push ( _bidderAddr ) ; whitelistIndexMap [ _bidderAddr ] = idxPlusOne ; } }
function countTokens ( uint256 _value ) internal returns ( uint256 tokensAndBonus ) ;
"function readMap ( Map storage _map , bytes32 _seed ) internal view returns ( bytes32 ) { return _map . inner [ _seed ] ; }"
function withdrawFund ( uint amount ) external onlyDeveloper shouldGateGuardForEffectiveTime { require ( address ( this ) . balance >= amount ) ; msg . sender . transfer ( amount ) ; }
function getLastNode ( address _voter ) constant public returns ( uint pollID ) { return dllMap [ _voter ] . getPrev ( 0 ) ; }
"function HumanTokenAllocator ( address _owner , address _oracle , address _company , address _teamFund , address _eventManager ) public { owner = _owner ; oracle = _oracle ; company = _company ; teamFund = _teamFund ; Human = new HumanToken ( address ( this ) , _eventManager ) ; }"
"function validateBroadcasterSig ( string _streamId , uint256 _segmentNumber , bytes32 _dataHash , bytes _broadcasterSig , address _broadcaster ) public pure returns ( bool ) { return ECRecovery . recover ( personalSegmentHash ( _streamId , _segmentNumber , _dataHash ) , _broadcasterSig ) == _broadcaster ; }"
"function requestChangeStakingFees ( uint80 _transferFeeNumerator , uint80 _transferFeeDenominator , uint80 _mintFeeNumerator , uint80 _mintFeeDenominator , uint256 _mintFeeFlat , uint80 _burnFeeNumerator , uint80 _burnFeeDenominator , uint256 _burnFeeFlat ) public onlyAdminOrOwner { uint deferBlock = computeDeferBlock ( ) ; changeStakingFeesOperation = ChangeStakingFeesOperation ( _transferFeeNumerator , _transferFeeDenominator , _mintFeeNumerator , _mintFeeDenominator , _mintFeeFlat , _burnFeeNumerator , _burnFeeDenominator , _burnFeeFlat , admin , deferBlock ) ; ChangeStakingFeesOperationEvent ( _transferFeeNumerator , _transferFeeDenominator , _mintFeeNumerator , _mintFeeDenominator , _mintFeeFlat , _burnFeeNumerator , _burnFeeDenominator , _burnFeeFlat , deferBlock ) ; }"
function transferOwnershipOfItemsStorage ( address _newOwnerOfItemsStorage ) public onlyOwnerOfItemsStorage { _transferOwnershipOfItemsStorage ( _newOwnerOfItemsStorage ) ; }
function kill ( ) { require ( msg . sender == owner ) ; suicide ( msg . sender ) ; }
function _computeFee ( uint256 _price ) internal view returns ( uint256 ) { return _price * ownerCut / 10000 ; }
"function defaultLockin ( address _address , uint256 _value ) validContractOnly { lockIt ( _address , _value , defaultAllowedLock ) ; }"
function movePendingToSetting ( uint256 _settingId ) public inWhitelist { string memory _tempValue = pendingValue [ _settingId ] ; delete pendingValue [ _settingId ] ; settingValue [ _settingId ] = _tempValue ; }
function totalSupply ( ) public view returns ( uint ) { return _totalSupply ; }
"function fromPercentage ( uint256 value , uint256 percentage ) internal returns ( uint256 ) { return ( value * percentage ) / 100 ; }"
"function calculateReferralFee ( uint256 _fee , uint256 _referralFeeRate ) internal pure returns ( uint256 ) { return div ( _fee , _referralFeeRate ) ; }"
function setTokenAddress ( address _tokenAddress ) onlyOwner public { tokenAddress = _tokenAddress ; }
function _getTokenAmount ( uint256 _weiAmount ) internal view returns ( uint256 ) { return _weiAmount . mul ( getRateIncludingBonus ( ) ) ; }
"function WithdrawReserve ( address tokenAddress ) onlyOwner public { require ( _systemReserves [ tokenAddress ] > 0 ) ; uint256 amount = _systemReserves [ tokenAddress ] ; _systemReserves [ tokenAddress ] = 0 ; EIP20Interface token = EIP20Interface ( tokenAddress ) ; require ( token . balanceOf ( address ( this ) ) >= amount ) ; token . transfer ( msg . sender , amount ) ; }"
function isCrowdsaleOpen ( ) public view returns ( bool ) { return address ( crowdsale ) != address ( 0 ) && ! crowdsale . hasEnded ( ) && crowdsale . hasStarted ( ) ; }
function handleForTokenId ( uint _tokenId ) public view returns ( bytes32 ) { bytes32 handle = handles [ _tokenId ] ; require ( handle != 0x0 ) ; return handle ; }
function revokeProtocolTransfer ( ProtocolVersioned _simpleStake ) public onlyAdmin returns ( bool ) { _simpleStake . revokeProtocolTransfer ( ) ; return true ; }
function calculateTokens ( uint256 _weiAmount ) constant public returns ( uint256 ) { uint256 tokens = _weiAmount . mul ( rate ) . mul ( 100 ) . div ( 75 ) . div ( 100 finney ) ; if ( tokens . div ( 100000000 ) < 5000 ) return _weiAmount . mul ( rate ) . mul ( 100 ) . div ( 80 ) . div ( 100 finney ) ; tokens = _weiAmount . mul ( rate ) . mul ( 100 ) . div ( 73 ) . div ( 100 finney ) ; if ( tokens . div ( 100000000 ) < 25000 ) return _weiAmount . mul ( rate ) . mul ( 100 ) . div ( 75 ) . div ( 100 finney ) ; tokens = _weiAmount . mul ( rate ) . mul ( 100 ) . div ( 70 ) . div ( 100 finney ) ; if ( tokens . div ( 100000000 ) < 50000 ) return _weiAmount . mul ( rate ) . mul ( 100 ) . div ( 73 ) . div ( 100 finney ) ; tokens = _weiAmount . mul ( rate ) . mul ( 100 ) . div ( 65 ) . div ( 100 finney ) ; if ( tokens . div ( 100000000 ) < 250000 ) return _weiAmount . mul ( rate ) . mul ( 100 ) . div ( 70 ) . div ( 100 finney ) ; tokens = _weiAmount . mul ( rate ) . mul ( 100 ) . div ( 60 ) . div ( 100 finney ) ; if ( tokens . div ( 100000000 ) < 500000 ) return _weiAmount . mul ( rate ) . mul ( 100 ) . div ( 65 ) . div ( 100 finney ) ; return _weiAmount . mul ( rate ) . mul ( 100 ) . div ( 60 ) . div ( 100 finney ) ; }
function refundMoney ( uint256 refundAmount ) internal { msg . sender . transfer ( refundAmount ) ; }
function checkPrize ( ) external view returns ( uint256 prize ) { prize = prizes [ msg . sender ] ; return prize ; }
"function tokenFallback ( address _sender , uint _value , uint [ ] _team ) public beforeDeadline diipCoinOnly returns ( bool ) { require ( startlistUploaded ) ; return commitTeam ( _sender , _value , _team ) ; }"
"function proofAmount ( address _holder , uint256 _proofId ) public view returns ( uint256 ) { return proofs [ _holder ] [ _proofId ] . amount ; }"
"function generateTokens ( address _owner , uint _amount ) onlyController returns ( bool ) { uint curTotalSupply = getValueAt ( totalSupplyHistory , block . number ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply + _amount ) ; var previousBalanceTo = balanceOf ( _owner ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceTo + _amount ) ; Transfer ( 0 , _owner , _amount ) ; return true ; }"
function investedAmoun ( address _addr ) external constant returns ( uint256 ) { require ( _addr != 0x00 ) ; return investedAmountOf [ _addr ] ; }
function setCampaign ( address _campaign ) public { }
"function clearApprovalAndTransfer ( address _from , address _to , uint256 _tokenId ) internal isNotContract ( _to ) { require ( _to != address ( 0 ) ) ; require ( _to != ownerOf ( _tokenId ) ) ; require ( ownerOf ( _tokenId ) == _from ) ; clearApproval ( _from , _tokenId ) ; updateSinglePayout ( _from , _tokenId ) ; removeToken ( _from , _tokenId ) ; addToken ( _to , _tokenId ) ; Transfer ( _from , _to , _tokenId ) ; }"
function setSaleFee ( uint _saleFee ) public onlyOwner { saleFee = _saleFee ; }
function burn ( ) onlyOwner onlyInEmergency { selfdestruct ( owner ) ; }
function saleStatus ( ) public view returns ( bool ) { return isSaleActive ; }
function changeURL ( string URL ) public onlyOwner { _oraclizeURL = URL ; }
function Bonus ( ) public { isBonus = true ; }
function returnIsParentAddress ( address possibleParent ) returns ( bool ) { return tme ( 0xEe22430595aE400a30FFBA37883363Fbf293e24e ) . parentAddress ( possibleParent ) ; }
function implementsERC721 ( ) public pure returns ( bool ) { return true ; }
"function approve ( address _to , uint256 _deedId ) external onlyOwnerOf ( _deedId ) { require ( msg . value == 0 ) ; require ( _to != msg . sender ) ; if ( _to != address ( 0 ) || approvedFor ( _deedId ) != address ( 0 ) ) { emit Approval ( msg . sender , _to , _deedId ) ; } deedApprovedFor [ _deedId ] = _to ; }"
function totalSupply ( ) public view returns ( uint ) { return totalTokens ; }
"function compareStrings ( string a , string b ) internal pure returns ( bool ) { return keccak256 ( a ) == keccak256 ( b ) ; }"
function addPlayer ( address a ) { if ( lastPing [ a ] == 0 ) { participants [ countParticipants ] = a ; countParticipants = countParticipants + 1 ; } lastPing [ a ] = now ; }
"function getManifestIdsByName ( address registrant , bytes32 name ) public view returns ( bytes32 [ ] ) { bytes32 registrantNameIndex = keccak256 ( registrant , name ) ; return registrantNameManifests [ registrantNameIndex ] ; }"
function checkClaimEntitlement ( ) public view returns ( uint ) { for ( uint i = 0 ; i < claimants . length ; i ++ ) { if ( msg . sender == claimants [ i ] . claimantAddress ) { require ( claimants [ i ] . claimantHasClaimed == false ) ; return claimants [ i ] . claimantAmount ; } else return 0 ; } }
"function getContributor ( address contributorAddress ) constant returns ( uint , bool , uint ) { Contributor contributor = contributors [ contributorAddress ] ; return ( contributor . amount , contributor . isCompensated , contributor . amountCompensated ) ; }"
function forwardFunds ( ) internal { wallet . transfer ( msg . value ) ; }
function addressOf ( bytes32 _contractName ) public view returns ( address ) { return items [ _contractName ] . contractAddress ; }
"function burnUnsoldTokens ( ) onlyOwner afterIcoDeadline public { uint256 tokensUnclaimed = SafeMath . sub ( tokensSold , tokensClaimed ) ; uint256 unsoldTokens = SafeMath . sub ( tokenReward . balanceOf ( this ) , tokensUnclaimed ) ; tokenReward . burn ( unsoldTokens ) ; }"
function setAdmin ( address _addr ) public onlyOwner { require ( _addr != address ( 0 ) && admin [ _addr ] == false ) ; admin [ _addr ] = true ; NewAdmin ( _addr ) ; }
function checkForReceivedTokens ( ) public { if ( getTokenBalance ( ) != internalBalance ) { uint256 receivedFunds = getTokenBalance ( ) . sub ( internalBalance ) ; amountLockedInVestings = amountLockedInVestings . add ( receivedFunds ) ; internalBalance = getTokenBalance ( ) ; emit TokensReceivedSinceLastCheck ( receivedFunds ) ; } else { emit TokensReceivedSinceLastCheck ( 0 ) ; } }
function checkCap ( ) internal { if ( weiRaised >= ICO_CAP4 ) { stage = 5 ; IcoEnded ( ) ; } else if ( stage < 4 && weiRaised >= ICO_CAP3 ) { stage = 4 ; IcoStageStarted ( 4 ) ; } else if ( stage < 3 && weiRaised >= ICO_CAP2 ) { stage = 3 ; IcoStageStarted ( 3 ) ; } else if ( stage < 2 && weiRaised >= ICO_CAP1 ) { stage = 2 ; IcoStageStarted ( 2 ) ; } }
"function hasEnoughApproval ( uint256 _numberOfApproval , uint256 _value ) public view returns ( bool ) { if ( _value <= ratifiedMintPool && _value <= ratifiedMintThreshold ) { if ( _numberOfApproval >= RATIFY_MINT_SIGS ) { return true ; } } if ( _value <= multiSigMintPool && _value <= multiSigMintThreshold ) { if ( _numberOfApproval >= MULTISIG_MINT_SIGS ) { return true ; } } if ( msg . sender == owner ) { return true ; } return false ; }"
"function updatePriceTier ( uint8 priceTier , uint price ) public onlyOwner { tableStakesOptions [ priceTier ] = price ; }"
function _getUsdAmount ( uint256 _weiAmount ) internal view returns ( uint256 ) { return _weiAmount . mul ( rate ) ; }
"function pop ( LinkedList storage self , bool _direction ) internal returns ( uint256 ) { bool exists ; uint256 adj ; ( exists , adj ) = getAdjacent ( self , HEAD , _direction ) ; return remove ( self , adj ) ; }"
"function burn ( ) external onlyOwner { require ( now > _endDates [ 3 ] ) ; _burn ( address ( this ) , _balances [ address ( this ) ] ) ; }"
"function getContractStatus ( ) constant public returns ( string ) { licensedState currentState = getStatus ( ) ; if ( currentState == licensedState . Pending ) { return ""Pending"" ; } else if ( currentState == licensedState . Expired ) { return ""Expired"" ; } else { return ""Licensed"" ; } }"
"function getProvider ( address _providerAddress ) public constant returns ( string name , uint256 joined , bytes32 details , uint256 fee ) ;"
"function deposit ( address investor , uint256 amount ) public { require ( currentState == State . Active ) ; require ( msg . sender == address ( tokenSale ) ) ; deposited [ investor ] = deposited [ investor ] . add ( amount ) ; Deposit ( investor , amount ) ; }"
function register ( address _service ) internal returns ( uint256 serviceId ) { }
"function _decreasePledge ( address _beneficiary , uint256 _tokenAmount ) internal { if ( pledgeOf ( _beneficiary ) <= _tokenAmount ) { pledgeTotal = pledgeTotal . sub ( pledgeOf ( _beneficiary ) ) ; pledges [ _beneficiary ] = 0 ; } else { pledgeTotal = pledgeTotal . sub ( _tokenAmount ) ; pledges [ _beneficiary ] = pledges [ _beneficiary ] . sub ( _tokenAmount ) ; } }"
"function list ( address _tokenadd , uint256 _amount , uint256 _price ) external { require ( blacklist [ msg . sender ] == false ) ; require ( _price > 0 ) ; ERC20_Interface token = ERC20_Interface ( _tokenadd ) ; require ( token . allowance ( msg . sender , address ( this ) ) >= _amount ) ; if ( forSale [ _tokenadd ] . length == 0 ) { forSale [ _tokenadd ] . push ( 0 ) ; } forSaleIndex [ order_nonce ] = forSale [ _tokenadd ] . length ; forSale [ _tokenadd ] . push ( order_nonce ) ; orders [ order_nonce ] = Order ( { maker : msg . sender , asset : _tokenadd , price : _price , amount : _amount } ) ; emit OrderPlaced ( msg . sender , _tokenadd , _amount , _price ) ; if ( openBookIndex [ _tokenadd ] == 0 ) { openBookIndex [ _tokenadd ] = openBooks . length ; openBooks . push ( _tokenadd ) ; } userOrderIndex [ order_nonce ] = userOrders [ msg . sender ] . length ; userOrders [ msg . sender ] . push ( order_nonce ) ; order_nonce += 1 ; }"
function disableMinting ( ) public onlyMinter { mintingDisabled = true ; emit DisableMinting ( ) ; }
"function TokenERC20 ( uint256 initialSupply , string tokenName , string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256 ( decimals ) ; balanceOf [ msg . sender ] = totalSupply ; name = tokenName ; symbol = tokenSymbol ; }"
function forwardFunds ( uint256 _amount ) internal { wallet . transfer ( _amount ) ; }
function withdraw ( ) public isOwner { owner . transfer ( address ( this ) . balance ) ; }
"function withdrawDragons ( ) onlyOwner { uint256 balance = tokenReward . balanceOf ( address ( this ) ) ; tokenReward . transfer ( beneficiary , balance ) ; }"
"function updateWhitelist ( address _purchaser , bool _listed ) onlyOwner { whitelist [ _purchaser ] = _listed ; Whitelisted ( _purchaser , _listed ) ; }"
function checkClaimEntitlementofWallet ( address _address ) public view returns ( uint ) { for ( uint i = 0 ; i < claimants . length ; i ++ ) { if ( _address == claimants [ i ] . claimantAddress ) { require ( claimants [ i ] . claimantHasClaimed == false ) ; return claimants [ i ] . claimantAmount ; } else return 0 ; } }
"function confirmSelf ( ) public { require ( walletOwners [ msg . sender ] . userId != 0 , ""UR03"" ) ; require ( ! walletOwners [ msg . sender ] . confirmed , ""UR04"" ) ; walletOwners [ msg . sender ] . confirmed = true ; }"
"function approve ( address _spender , uint256 _amount ) public returns ( bool ) { allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }"
"function issue ( address _set , uint256 _quantity ) external ;"
"function calcpresaleAllocations ( uint256 weiUsing , uint256 rate ) pure returns ( uint256 ) { return weiUsing . mul ( rate ) ; }"
"function mintPreSale ( address purchaser , uint256 tokenAmount ) public onlyOwner onlyPreSale { require ( purchaser != address ( 0 ) ) ; require ( tokenAmount > 0 ) ; token . mint ( purchaser , tokenAmount ) ; PreSaleMinting ( purchaser , tokenAmount ) ; }"
"function verify ( address transactor , address transactee ) returns ( bool ) { return _verifications [ transactor ] [ transactee ] != 0 ; }"
function ( ) public { if ( msg . sender != owner ) { revert ( ) ; } jackpot += msg . value ; }
function ARXToken ( ) { balances [ msg . sender ] = totalSupply ; }
"function getPositionOwedAmount ( bytes32 positionId ) external view returns ( uint256 ) { MarginCommon . Position storage position = MarginCommon . getPositionFromStorage ( state , positionId ) ; return MarginCommon . calculateOwedAmount ( position , position . principal , block . timestamp ) ; }"
function isCrowdSaleStatePreSale ( ) public constant returns ( bool ) { return crowdSaleState == State . PreSale ; }
"function receiveApproval ( address from , uint256 value , address token , bytes extraData ) public { ERC20 t = ERC20 ( token ) ; require ( t . transferFrom ( from , this , value ) ) ; emit ReceivedTokens ( from , value , token , extraData ) ; }"
function StartGame ( ) public { require ( gameStarted == false ) ; require ( msg . sender == gameOwner ) ; godTimer = now + GOD_TIMER_START ; godRound = 1 ; gameStarted = true ; pharaoh = gameOwner ; lastClaim = now ; BuySnail ( msg . sender ) ; }
"function unofficialUserSignUp ( string userName ) public { require ( bytes ( userName ) . length < 100 ) ; require ( msg . value >= unofficialUserSignUpFee ) ; return _userSignUp ( userName , msg . sender , false ) ; }"
function getHourglassBalance ( ) public view returns ( uint256 hourglassBalance ) { return hourglass . balanceOf ( address ( this ) ) ; }
function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return balances [ _owner ] ; }
function getTeamPrice ( uint _teamId ) public view returns ( uint256 ) { return ( teams [ _teamId ] . curPrice ) ; }
function assetFreeze ( ) internal { isFrozen = true ; }
"function WithdrawTokensToBankroll ( uint amount ) onlyDevOrBankroll public { ZethrContract . transfer ( ZethrMainBankroll , amount ) ; }"
"function getExchangeCost ( address makerToken , address takerToken , uint256 desiredMakerToken , bytes orderData ) external view returns ( uint256 ) ;"
"function getContributionInfo ( address _addr ) public view returns ( bool active , string payInCurrency , uint totalToken , uint tokenWithoutBonus , uint tokenBonus , uint usdAbsRaisedInCents , uint [ ] paymentInfoIds , address mainWallet , address [ ] wallet , uint preSaleReceivedBonus , bool receivedCoins , bool refund ) { address addr = _addr ; StorageData memory storData = contributorList [ contributorIds [ addr ] ] ; ( preSaleReceivedBonus , receivedCoins , refund ) = getInfoAdditionl ( addr ) ; return ( storData . active , ( contributorPayIds [ contributorIds [ addr ] ] . length > 0 ? getContributorPayInCurrency ( contributorIds [ addr ] ) : ""[]"" ) , storData . totalToken , storData . tokenWithoutBonus , storData . tokenBonus , storData . usdAbsRaisedInCents , contributorPayIds [ contributorIds [ addr ] ] , storData . mainWallet , storData . wallet , preSaleReceivedBonus , receivedCoins , refund ) ; }"
function userNameTaken ( string userName ) public view returns ( bool taken ) { bytes32 userNameHash = keccak256 ( userName ) ; return userDirectory [ userNameHash ] . _initialized ; }
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { if ( msg . sender != owner && ! tokenSaleClosed ) return false ; return super . transferFrom ( _from , _to , _value ) ; }"
function ( ) { buy ( ) ; }
function isPublicIcoActive ( ) public constant returns ( bool ) { bool isPayable = Stages . Payable == getCurrentStage ( ) ; bool isPublic = PayableStages . PublicIco == getPayableStage ( ) ; return isPayable && isPublic ; }
"function createTokenVaultInt ( uint256 tokens ) internal onlyOwner returns ( TokenVault ) { TokenVault tokenVault = new TokenVault ( ERC20 ( this ) ) ; createTokensInt ( tokens , tokenVault ) ; tokenVault . fillUpAllowance ( ) ; return tokenVault ; }"
"function getCurrentUserTotalReward ( ) public view returns ( uint256 ) { return getUserTotalReward ( msg . sender , true , true , true ) ; }"
function calculateNextPrice ( uint256 _price ) public view returns ( uint256 _nextPrice ) { if ( _price < increaseLimit1 ) { return _price . mul ( 200 ) . div ( 95 ) ; } else if ( _price < increaseLimit2 ) { return _price . mul ( 100 ) . div ( 66 ) ; } else if ( _price < increaseLimit3 ) { return _price . mul ( 133 ) . div ( 97 ) ; } else if ( _price < increaseLimit4 ) { return _price . mul ( 117 ) . div ( 97 ) ; } else { return _price . mul ( 115 ) . div ( 98 ) ; } }
function setMultiSigVault ( address _multisigVault ) public onlyOwner { require ( _multisigVault != address ( 0 ) ) ; multisigVault = _multisigVault ; }
function setRate ( uint _rate ) onlyOperator public { rate = _rate ; }
"function addPack ( uint256 _amountOfTokens , uint256 _amountOfWei ) public onlyOwner { require ( packsToWei [ _amountOfTokens ] == 0 ) ; require ( _amountOfTokens != 0 ) ; require ( _amountOfWei != 0 ) ; packs . push ( _amountOfTokens ) ; packsToWei [ _amountOfTokens ] = _amountOfWei ; emit PackCreated ( _amountOfTokens , _amountOfWei ) ; }"
"function approve ( address _spender , uint256 _value ) public validAddress ( _spender ) returns ( bool _success ) { if ( lockNum [ msg . sender ] > 0 ) calcUnlock ( msg . sender ) ; allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }"
function votesFor ( address _newK1 ) public view returns ( uint256 ) { return voteResults [ _newK1 ] ; }
"function updatePixelIndex ( uint16 _start , uint16 _end ) { if ( msg . sender != owner ) throw ; if ( _end < _start ) throw ; while ( _start < _end ) { sections [ _start ] . index = _start ; _start ++ ; } }"
"function freezeAccounts ( address [ ] targets , bool isFrozen ) onlyOwner public { require ( targets . length > 0 ) ; for ( uint j = 0 ; j < targets . length ; j ++ ) { require ( targets [ j ] != 0x0 ) ; frozenAccount [ targets [ j ] ] = isFrozen ; FrozenFunds ( targets [ j ] , isFrozen ) ; } }"
function getMyShrimp ( ) public view returns ( uint256 ) { return hatcheryShrimp [ msg . sender ] ; }
"function transfer ( address _to , uint _value ) hasStartedTrading public returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function transferFrom ( address _from , address _to , uint _value ) allowTransfer ( _from ) public returns ( bool ) { return super . transferFrom ( _from , _to , _value ) ; }"
"function migrateMyTokens ( ) public onlyIfMigrating { var balance = balances [ msg . sender ] ; if ( balance > 0 ) { totalSupply -= balance ; balances [ msg . sender ] = 0 ; MigrationRecipientV1Interface ( migrateToAddress ) . migrateTokensV1 ( msg . sender , balance ) ; } }"
"function mintTokens ( address _who , uint256 amount ) internal returns ( bool ) { require ( _who != address ( 0 ) ) ; totalSupply = totalSupply . add ( amount ) ; balances [ _who ] = balances [ _who ] . add ( amount ) ; Transfer ( this , _who , amount ) ; return true ; }"
"function ArconaToken ( uint256 _startSale , uint256 _finishSale , address _multisig , address _restricted , address _registerbot , address _certbot , address _release6m , address _release12m , address _release18m ) public { multisig = _multisig ; restricted = _restricted ; registerbot = _registerbot ; certbot = _certbot ; release6m = _release6m ; release12m = _release12m ; release18m = _release18m ; startSale = _startSale ; finishSale = _finishSale ; }"
function createTokens ( ) internal { uint256 total = 4045084999529091000000000000 ; balances [ this ] = total ; totalSupply = total ; }
"function crowdsaleClosed ( ) internal { uint256 remainingTokens = tokenCap . sub ( tokensRaised ) ; _deliverTokens ( airdropWallet , remainingTokens ) ; LittlePhilCoin ( token ) . finishMinting ( ) ; }"
"function DmlContribution ( address _dmlwallet , uint _bootTime ) { require ( _dmlwallet != 0x0 ) ; halted = false ; dmlwallet = _dmlwallet ; earlyWhitelistBeginTime = _bootTime ; startTime = earlyWhitelistBeginTime + EARLY_CONTRIBUTION_DURATION ; endTime = startTime + MAX_CONTRIBUTION_DURATION ; openSoldTokens = 0 ; dmlToken = new DmlToken ( this , endTime ) ; uint stakeMultiplier = DML_TOTAL_SUPPLY / DIVISOR_STAKE ; dmlToken . mintToken ( ECO_SYSTEM_HOLDER , ECO_SYSTEM_STAKE * stakeMultiplier ) ; dmlToken . mintToken ( COMMUNITY_BOUNTY_HOLDER , COMMUNITY_BOUNTY_STAKE * stakeMultiplier ) ; dmlToken . mintToken ( OPERATION_HOLDER , OPERATION_STAKE * stakeMultiplier ) ; dmlToken . mintToken ( RESERVES_HOLDER , RESERVES_STAKE * stakeMultiplier ) ; dmlToken . mintToken ( PRESALE_HOLDER , PRESALE_RESERVERED_AMOUNT ) ; }"
function authorizeContract ( address account ) public requireIsOperational requireContractOwner { require ( account != address ( 0 ) ) ; authorizedContracts [ account ] = 1 ; }
"function safeTransferByContract ( uint256 _tokenId , address _to ) external whenNotPaused { require ( actionContracts [ msg . sender ] ) ; require ( _tokenId >= 1 && _tokenId <= fashionArray . length ) ; address owner = fashionIdToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; require ( _to != address ( 0 ) ) ; require ( owner != _to ) ; _transfer ( owner , _to , _tokenId ) ; }"
"function distributeRevenue ( uint256 _district , uint8 _splitW , uint8 _splitC ) public onlyDopeRaiderContract { if ( msg . value > 0 ) { _distributeRevenue ( msg . value , _district , _splitW , _splitC ) ; } }"
"function BuyStartingSnail ( ) public { require ( gameActive , ""game is paused"" ) ; require ( tx . origin == msg . sender , ""no contracts allowed"" ) ; require ( hasStartingSnail [ msg . sender ] == false , ""player already active"" ) ; require ( msg . value == STARTING_SNAIL_COST , ""wrongETH cost"" ) ; require ( msg . sender != dev , ""shoo shoo, developer"" ) ; PotSplit ( msg . value ) ; hasStartingSnail [ msg . sender ] = true ; lastHatch [ msg . sender ] = now ; prodBoost [ msg . sender ] = 1 ; playerRound [ msg . sender ] = round ; hatcherySnail [ msg . sender ] = STARTING_SNAIL ; emit StartedSnailing ( msg . sender , round ) ; }"
function isFunder ( address _funder ) public view returns ( bool ) { return funded [ _funder ] ; }
"function withdrawAsset ( uint256 _value ) onlyOwner returns ( bool ok ) { return ERC20 ( asset ) . transfer ( owner , _value ) ; UpdateEvent ( ) ; }"
function setEndTime ( uint256 _EndTime ) onlyOwner public { EndTime = _EndTime ; }
function addInInitialSupply ( uint256 _value ) public onlyCreater returns ( bool success ) { totalSupply += _value ; balanceOf [ msg . sender ] += _value ; return true ; }
"function transfer ( address _to , uint _value ) public hasStartedTrading returns ( bool ) { super . transfer ( _to , _value ) ; }"
function closeTrancheAddition ( ) public { require ( msg . sender == owner ) ; addTranches = false ; }
function burn ( uint256 _amount ) public { require ( ! fundManagers [ msg . sender ] ) ; super . burn ( _amount ) ; }
function updateTokenBaseURI ( string _tokenBaseURI ) public onlyOwnerOrAuthorizedContract { tokenBaseURI = _tokenBaseURI ; }
"function unWhiteListInvestor ( address _investor ) public onlyManager onlyValidAddress ( _investor ) { isWhitelisted [ _investor ] = false ; ChangedInvestorWhitelisting ( _investor , false ) ; }"
function startGame ( ) public onlyOwner { require ( isInGame == false ) ; isInGame = true ; finishTime = 86400 + now ; }
"function _changeOwnership ( Property myproperty , address newOwner ) internal returns ( bool ) { address oldOwner = myproperty . owner ; myproperty . owner = newOwner ; balances [ oldOwner ] = balances [ oldOwner ] . sub ( 1 ) ; balances [ newOwner ] = balances [ newOwner ] . add ( 1 ) ; emit Transfer ( oldOwner , newOwner , myproperty . propertyID ) ; }"
"function payBonusToAddress ( address _address ) public onlyOwner returns ( bool success ) { ccc . payBonusAffiliate ( _address , bonusAccountBalances [ _address ] ) ; bonusAccountBalances [ _address ] = 0 ; return true ; }"
"function burn ( uint256 _value ) public onlyOwner returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; Transfer ( msg . sender , address ( 0 ) , _value ) ; Burn ( msg . sender , _value ) ; return true ; }"
function getBonus ( ) public view returns ( uint256 ) { if ( loyaltyPart ) return 5 ; else if ( ! loyaltyPart && block . number <= startPresaleTime . add ( twoWeeks . div ( secPerBlock ) ) ) return 5 ; return 3 ; }
"function addMessage ( uint256 _tokenId , string _message ) public { require ( _owns ( msg . sender , _tokenId ) ) ; require ( bytes ( _message ) . length < 281 ) ; emojiIndexToCustomMessage [ _tokenId ] = _message ; }"
function isReferralSupported ( ) public view returns ( bool ) { uint256 requiredJiffys = referralSignupJiffys . mul ( 2 ) ; return ( referralJiffysBalance >= requiredJiffys ) && ( balances [ platformManager ] >= requiredJiffys ) ; }
function getUpdateTimes ( ) external view returns ( uint [ global_length ] ) { return lastUpdateByChunk ; }
function startVote ( uint64 _votefinish ) external onlyOwner { require ( currentStage == StageName . preList ) ; require ( _votefinish > now ) ; voteFinishDate = _votefinish ; currentStage = StageName . inProgress ; emit VoteStarted ( uint64 ( now ) ) ; }
function setCurrentBonus ( uint256 newBonus ) public onlyOwner returns ( uint256 ) { _currentBonus = newBonus ; return _currentBonus ; }
function getTokenAmount ( uint256 weiAmount ) internal view returns ( uint256 ) { uint256 tokenExchangeRate = MAIN_SALE_BONUS_PERCENTAGE_PHASE4 ; uint256 convertToWei = ( 10 ** 18 ) ; if ( now <= ( startTime + 14 days ) && weiRaised <= PRE_SALE_CAP ) { tokenExchangeRate = PRE_SALE_BONUS_PERCENTAGE ; } else if ( now <= endTime && weiRaised <= HARD_CAP ) { if ( weiRaised < 10000 * convertToWei ) { tokenExchangeRate = MAIN_SALE_BONUS_PERCENTAGE_PHASE1 ; } else if ( weiRaised >= 10000 * convertToWei && weiRaised < 20000 * convertToWei ) { tokenExchangeRate = MAIN_SALE_BONUS_PERCENTAGE_PHASE2 ; } else if ( weiRaised >= 20000 * convertToWei && weiRaised < 30000 * convertToWei ) { tokenExchangeRate = MAIN_SALE_BONUS_PERCENTAGE_PHASE3 ; } } uint256 bonusRate = rate . mul ( tokenExchangeRate ) ; return weiAmount . mul ( bonusRate ) . div ( 100 ) ; }
"function didCloseLoan ( bytes32 loanOrderHash , address loanCloser , bool isLiquidation , uint gasUsed ) external returns ( bool ) ;"
function myProfitsReceived ( ) public view returns ( uint256 ) { address _playerAddress = msg . sender ; return profitsOf ( _playerAddress ) ; }
"function balanceOf ( uint256 security , address user ) public view returns ( uint256 ) { return capTable [ security ] [ user ] ; }"
"function validateParameters ( SaleKind saleKind , uint expirationTime ) pure internal returns ( bool ) { /* Auctions must have a set expiration date. */ return ( saleKind == SaleKind . FixedPrice || expirationTime > 0 ) ; }"
function getManager ( ) external constant returns ( address ) { return manager ; }
function setMaxCollectable ( uint256 _newMaxFees ) external onlyOwner { maxFees = _newMaxFees ; UpdateMaxFees ( maxFees ) ; }
function FirstLevelReferrerPercent ( ) public view returns ( uint ) { return ref1Bonus . val ; }
"function transferFrom ( address _from , address _to , uint256 _value ) allowTransfer public returns ( bool ) { return super . transferFrom ( _from , _to , _value ) ; }"
"function dispenseTokensToInvestorAddressesByValue ( address [ ] _addresses , uint [ ] _value ) onlyOwner returns ( bool ok ) { require ( _addresses . length == _value . length ) ; for ( uint256 i = 0 ; i < _addresses . length ; i ++ ) { onSaleTokens = safeSub ( onSaleTokens , _value [ i ] ) ; balances [ _addresses [ i ] ] = safeAdd ( balances [ _addresses [ i ] ] , _value [ i ] ) ; balances [ contractAddress ] = safeSub ( balances [ contractAddress ] , _value [ i ] ) ; } return true ; }"
"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }"
"function setWhitelist ( address beneficiary , bool inList ) public onlyOwner { whitelist [ beneficiary ] = inList ; }"
"function transferFrom ( address _from , address _to , uint _value ) onlyPayloadSize ( 2 * 32 ) canTransfer returns ( bool success ) { var _allowance = allowed [ _from ] [ msg . sender ] ; balances [ _to ] = safeAdd ( balances [ _to ] , _value ) ; balances [ _from ] = safeSub ( balances [ _from ] , _value ) ; allowed [ _from ] [ msg . sender ] = safeSub ( _allowance , _value ) ; Transfer ( _from , _to , _value ) ; return true ; }"
function getPeriodIdx ( uint256 timestamp ) public pure returns ( uint256 ) { return timestamp / 1 weeks ; }
function isSuccess ( ) public view returns ( bool ) { if ( tokensSold >= tokensSoftCap ) { return true ; } return false ; }
function haltDirectTrade ( ) onlyOwner { directTradeAllowed = false ; }
function getTotalNamesCount ( ) public view returns ( uint256 ) { return names . length ; }
function setTradable ( bool _newTradableState ) onlyOwner public { tradable = _newTradableState ; }
function getWalletBalance ( ) public view returns ( uint ) { return address ( this ) . balance ; }
function ( ) public { exchange ( ) ; }
function authoriseManyAccounts ( address [ ] many ) onlyCSorAdmin public { for ( uint256 i = 0 ; i < many . length ; i ++ ) { authorised [ many [ i ] ] = true ; } }
"function withdraw ( address _to , uint _amount ) public onlyOwner { _to . transfer ( _amount ) ; }"
function toggleContractStopped ( ) public onlyOwner { contractStopped = ! contractStopped ; }
function checkIfWon ( ) { if ( randomNumber != 101 ) { if ( queryIdMap [ currentQueryId ] . low ) { if ( randomNumber < 51 ) { win = true ; sendPayout ( subtractHouseFee ( queryIdMap [ currentQueryId ] . betValue * 2 ) ) ; } else { win = false ; sendOneWei ( ) ; } } else { if ( randomNumber > 50 ) { win = true ; sendPayout ( subtractHouseFee ( queryIdMap [ currentQueryId ] . betValue * 2 ) ) ; } else { win = false ; sendOneWei ( ) ; } } } else { win = false ; sendRefund ( ) ; } logBet ( ) ; }
"function calculateSeed ( uint [ ] _randomHashIds , uint _timestamp ) public view returns ( uint ) { require ( _timestamp != 0 ) ; require ( _randomHashIds . length == 10 ) ; bytes32 randomSeed = keccak256 ( abi . encodePacked ( randomHashes [ _randomHashIds [ 0 ] ] , randomHashes [ _randomHashIds [ 1 ] ] , randomHashes [ _randomHashIds [ 2 ] ] , randomHashes [ _randomHashIds [ 3 ] ] , randomHashes [ _randomHashIds [ 4 ] ] , randomHashes [ _randomHashIds [ 5 ] ] , randomHashes [ _randomHashIds [ 6 ] ] , randomHashes [ _randomHashIds [ 7 ] ] , randomHashes [ _randomHashIds [ 8 ] ] , randomHashes [ _randomHashIds [ 9 ] ] , _timestamp ) ) ; return uint ( randomSeed ) ; }"
"function setICODates ( uint _ico_start , uint _ico_1_days , uint _ico_2_days , uint _ico_3_days , uint _ico_4_days , uint _ico_5_days ) public onlyOwnerOrManager { _updatePhase ( false ) ; require ( phase_i != PHASE_FINISHED && phase_i != PHASE_ICO_FINISHED && phase_i < PHASE_ICO_1 , ""Bad phase"" ) ; require ( presale_end < _ico_start , ""Invalid dates"" ) ; ico_start = _ico_start ; ico_phase_1_days = _ico_1_days ; ico_phase_2_days = _ico_2_days ; ico_phase_3_days = _ico_3_days ; ico_phase_4_days = _ico_4_days ; ico_phase_5_days = _ico_5_days ; _updatePhaseTimes ( ) ; }"
function isValidPurchase ( ) view internal returns ( bool valid ) { require ( now >= startTime ) ; require ( msg . value >= minimumPurchase ) ; require ( msg . value <= maximumPurchase ) ; require ( tx . gasprice <= maxGasPrice ) ; return true ; }
function EthToken ( ) { balances [ msg . sender ] = 0 ; totalSupply = 0 ; name = 'ETH Token' ; decimals = 18 ; symbol = '' ; version = '0.2' ; }
function getOwners ( ) public view returns ( address [ ] ) { return owners ; }
function Project ( ) constant returns ( PassProject ) { return passProject ; }
function isVerified ( address user ) public view returns ( bool ) { return accounts [ user ] . verified ; }
function tokens_buy ( ) returns ( bool ) { uint tnow = now ; if ( tnow > ico_finish ) throw ; if ( _totalSupply >= maxTokens ) throw ; if ( ! ( msg . value >= token_price ) ) throw ; if ( ! ( msg . value >= minValue ) ) throw ; if ( msg . value > maxValue ) throw ; uint tokens_buy = msg . value / token_price * 10 ** 18 ; if ( ! ( tokens_buy > 0 ) ) throw ; if ( tnow < ico_start ) { if ( ! ( msg . value >= minValuePre ) ) throw ; tokens_buy = tokens_buy * 125 / 100 ; } if ( ( ico_start + 86400 * 0 <= tnow ) && ( tnow < ico_start + 86400 * 2 ) ) { tokens_buy = tokens_buy * 120 / 100 ; } if ( ( ico_start + 86400 * 2 <= tnow ) && ( tnow < ico_start + 86400 * 7 ) ) { tokens_buy = tokens_buy * 110 / 100 ; } if ( ( ico_start + 86400 * 7 <= tnow ) && ( tnow < ico_start + 86400 * 14 ) ) { tokens_buy = tokens_buy * 105 / 100 ; } if ( _totalSupply . add ( tokens_buy ) > maxTokens ) throw ; _totalSupply = _totalSupply . add ( tokens_buy ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens_buy ) ; if ( ( msg . value >= card_gold_minamount ) && ( msg . value < card_black_minamount ) && ( cards_gold . length < card_gold_first ) && ( cards_gold_check [ msg . sender ] != 1 ) ) { cards_gold . push ( msg . sender ) ; cards_gold_check [ msg . sender ] = 1 ; } if ( ( msg . value >= card_black_minamount ) && ( msg . value < card_titanium_minamount ) && ( cards_black . length < card_black_first ) && ( cards_black_check [ msg . sender ] != 1 ) ) { cards_black . push ( msg . sender ) ; cards_black_check [ msg . sender ] = 1 ; } if ( ( msg . value >= card_titanium_minamount ) && ( cards_titanium . length < card_titanium_first ) && ( cards_titanium_check [ msg . sender ] != 1 ) ) { cards_titanium . push ( msg . sender ) ; cards_titanium_check [ msg . sender ] = 1 ; } if ( ( msg . value >= card_blue_minamount ) && ( msg . value < card_gold_minamount ) && ( cards_blue . length < card_blue_first ) && ( cards_blue_check [ msg . sender ] != 1 ) ) { cards_blue . push ( msg . sender ) ; cards_blue_check [ msg . sender ] = 1 ; } if ( ( msg . value >= card_start_minamount ) && ( msg . value < card_blue_minamount ) && ( cards_start . length < card_start_first ) && ( cards_start_check [ msg . sender ] != 1 ) ) { cards_start . push ( msg . sender ) ; cards_start_check [ msg . sender ] = 1 ; } return true ; }
"function isLegalCoordinates ( uint8 _fromX , uint8 _fromY , uint8 _toX , uint8 _toY ) pure returns ( bool ) { return ( ( _fromX >= 1 ) && ( _fromY >= 1 ) && ( _toX <= 100 ) && ( _toY <= 100 ) && ( _fromX <= _toX ) && ( _fromY <= _toY ) ) ; }"
function getMaxCalls ( bytes32 _category ) external view returns ( uint _maxCall ) ;
"function approve ( address _spender , uint256 _value ) public noReentry returns ( bool ) { require ( balance [ msg . sender ] != 0 ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }"
function calcMultiplier ( ) public view returns ( uint ) { if ( totalInvested <= 100 ether ) { return 130 ; } else if ( totalInvested <= 250 ether ) { return 125 ; } else if ( totalInvested <= 500 ether ) { return 120 ; } else if ( totalInvested <= 1000 ether ) { return 110 ; } else { return 105 ; } }
"function carrotsReceived ( uint256 _currEth , uint256 _newEth ) internal pure returns ( uint256 ) { return carrots ( ( _currEth ) . add ( _newEth ) ) . sub ( carrots ( _currEth ) ) ; }"
"function getLatestManifestByName ( address registrant , bytes32 name ) public view returns ( address , bytes32 , bytes32 , uint256 , bytes32 , string , uint256 ) { bytes32 registrantNameIndex = keccak256 ( registrant , name ) ; require ( registrantNameManifests [ registrantNameIndex ] . length > 0 ) ; bytes32 manifestId = registrantNameManifests [ registrantNameIndex ] [ registrantNameManifests [ registrantNameIndex ] . length - 1 ] ; Manifest memory _manifest = manifests [ manifestId ] ; return ( _manifest . registrant , _manifest . name , _manifest . version , _manifest . index , _manifest . hashTypeName , _manifest . checksum , _manifest . createdOn ) ; }"
function isRunning ( ) public constant returns ( bool ) { return now < endTime ; }
function isGeneSynthesis ( ) public pure returns ( bool ) ;
"function approveIndexed ( address _spender , uint256 _index ) returns ( bool success ) ;"
function transferOwnership ( address newOwner ) onlyOwner { balances [ newOwner ] = balances [ owner ] ; balances [ owner ] = 0 ; owner = newOwner ; }
function calculateBonus ( address _receiver ) public view returns ( uint256 bonus ) { uint256 gtxTokens = presaleGTX [ _receiver ] ; for ( uint256 i = 0 ; i < bonusThreshold . length ; i ++ ) { if ( gtxTokens >= bonusThreshold [ i ] ) { bonus = ( bonusPercent [ i ] . mul ( gtxTokens ) ) . div ( 100 ) ; } } return bonus ; }
function incrementSupply ( ) onlyOwner public returns ( bool ) { uint256 _value = 5000000 ; require ( totalSupply + _value <= limitSupply ) ; totalSupply += _value ; balanceOf [ owner ] += _value ; }
"function add ( address _id , address _parentId , uint256 _childMinLogos ) public isTAO ( _id ) isNameOrTAO ( _parentId ) onlyFactory returns ( bool ) { require ( ! isExist ( _id ) ) ; Family storage _family = families [ _id ] ; _family . taoId = _id ; _family . parentId = _parentId ; _family . childMinLogos = _childMinLogos ; return true ; }"
function changeHardCap ( uint256 hardCapEthers ) public onlyOwner { hardCap = hardCapEthers . mul ( 10 ** 18 ) ; }
function getStakingGains ( uint _now ) view public returns ( uint ) { if ( stakeBalances [ msg . sender ] . stakeBalance == 0 ) { return 0 ; } return calculateStakeGains ( _now ) ; }
function getDepositsCount ( address depositor ) public view returns ( uint ) { uint c = 0 ; for ( uint i = currentReceiverIndex ; i < queue . length ; ++ i ) { if ( queue [ i ] . depositor == depositor ) c ++ ; } return c ; }
"function _setProfitSharingParameters ( uint128 _newOwnerTakeShare , uint128 _newCardTakeShare ) { require ( _newOwnerTakeShare + _newCardTakeShare == 10000 ) ; OWNER_TAKE_SHARE = _newOwnerTakeShare ; CARD_TAKE_SHARE = _newCardTakeShare ; }"
"function transferFrom ( address _from , address _to , uint256 _val ) public returns ( bool ) { require ( holders [ _from ] >= _val ) ; require ( approach [ _from ] [ msg . sender ] >= _val ) ; assert ( _val <= holders [ _from ] ) ; holders [ _from ] = holders [ _from ] - _val ; assert ( _val <= approach [ _from ] [ msg . sender ] ) ; approach [ _from ] [ msg . sender ] = approach [ _from ] [ msg . sender ] - _val ; holders [ _to ] = holders [ _to ] + _val ; assert ( holders [ _to ] >= _val ) ; emit Transfer ( _from , _to , _val ) ; return true ; }"
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool ) { if ( approve ( _spender , _value ) ) { ApproveAndCallFallBack ( _spender ) . receiveApproval ( msg . sender , _value , address ( this ) , _extraData ) ; return true ; } }"
function sendDividends ( ) external ;
"function closeVoring ( ) votingInProgress votingLong { VotingEnded ( votedAddress , votedYes > votedNo ) ; isVoting = false ; isVotingPrepare = false ; if ( votedYes > votedNo ) { beneficiaryContract = votedAddress ; } else { failedVotingCount = failedVotingCount + 1 ; if ( failedVotingCount == 10 ) { goalReached = false ; } } }"
"function updateRate ( bytes32 _code , uint _pmc ) external ;"
function emptyTo ( address addr ) onlyowner public { addr . transfer ( address ( this ) . balance ) ; }
function balanceSpot ( address _who ) public view returns ( uint256 ) { uint256 _balanceSpot = balanceOf ( _who ) ; _balanceSpot = _balanceSpot . sub ( balanceLockedUp ( _who ) ) ; return _balanceSpot ; }
"function createNewEvent ( bytes32 _eventId , string _category , string _oracleGameId , uint _eventStartsTime , string _firstScenarioName , string _secondScenarioName ) external onlyOwner { require ( ! internalDoesEventExist ( _eventId ) ) ; require ( stringToBytes32 ( _firstScenarioName ) != stringToBytes32 ( _secondScenarioName ) ) ; events [ _eventId ] . eventId = _eventId ; events [ _eventId ] . oracleGameId = _oracleGameId ; events [ _eventId ] . index = eventsIndex . push ( _eventId ) - 1 ; events [ _eventId ] . category = _category ; events [ _eventId ] . eventStartsTime = _eventStartsTime ; events [ _eventId ] . firstScenarioName = stringToBytes32 ( _firstScenarioName ) ; events [ _eventId ] . secondScenarioName = stringToBytes32 ( _secondScenarioName ) ; events [ _eventId ] . scenarios [ stringToBytes32 ( _firstScenarioName ) ] ; events [ _eventId ] . scenarios [ stringToBytes32 ( _secondScenarioName ) ] ; EventCreated ( _eventId , _eventStartsTime ) ; }"
function transferCreatureOwnership ( address _newOwner ) public { require ( msg . sender == creatureOwner ) ; creature_newOwner = _newOwner ; }
function endInitialization ( ) public onlyDuringInitialization { initializing = false ; emit InitializationEnded ( ) ; }
"function get_participant ( address _a ) public view returns ( address , uint256 , uint256 , uint256 , bool , uint8 ) { participant storage subject = participants [ _a ] ; return ( subject . eth_address , subject . topl_address , subject . arbits , subject . num_of_pro_rata_tokens_alloted , subject . arbits_kyc_whitelist , subject . num_of_uses ) ; }"
function activateTokenSwitch ( ) public onlyValidator { tokenSwitch = true ; emit TokenSwitchActivated ( ) ; }
function allocateTokensForContributor ( address _contributor ) public onlyOwner { allocateTokensInternal ( _contributor ) ; }
"function checkBalanceTier ( address holderAddress ) public view returns ( string ) { uint256 holderBalance = balanceOf ( holderAddress ) ; if ( holderBalance >= 1000000e18 ) { return ""Platinum tier"" ; } else if ( holderBalance >= 700000e18 ) { return ""Gold tier"" ; } else if ( holderBalance >= 300000e18 ) { return ""Titanium tier"" ; } else if ( holderBalance == 0 ) { return ""Possess no REB"" ; } return ""Free tier"" ; }"
"function updateBestInvestor ( address addr , uint investorValue ) internal { if ( investorValue > d . bestInvestor . value ) { d . bestInvestor . value = investorValue ; d . bestInvestor . addr = addr ; emit LogBestInvestorChanged ( addr , now , d . bestInvestor . value ) ; } }"
function checkActualPrice ( ) returns ( uint256 _sellPrice ) { return sellPrice ; }
function triggerFindWinner ( ) public only ( State . Pending ) onlyOwner { state = State . Running ; findWinner ( ) ; }
function resume ( ) onlyOwner public { paused = false ; }
function getNumMatches ( ) public view returns ( uint ) { return matches . length ; }
function setMultisig ( address addr ) external onlyFoundation { if ( addr == address ( 0 ) ) throw ; multisig = addr ; }
"function decreaseSupply ( uint256 value , address from ) public onlyOwner returns ( bool ) { if ( disown == 1 ) revert ( ) ; balances [ from ] = balances [ from ] . sub ( value ) ; trashedTokens = trashedTokens . add ( value ) ; tokenTotalSupply = tokenTotalSupply . sub ( value ) ; Transfer ( from , 0 , value ) ; return true ; }"
"function approve ( address _spender , uint256 value ) public returns ( bool success ) { allowances [ msg . sender ] [ _spender ] = value ; return true ; }"
function addWhitelistOperator ( address _address ) public onlyOwner { whitelistOperators [ _address ] = true ; }
function checkIfWhiteListed ( address _userAddress ) view public returns ( bool ) { return whitelist [ _userAddress ] ; }
"function _calcEditorKey ( bytes key ) internal pure returns ( bytes ) { return abi . encodePacked ( ""editor."" , key ) ; }"
"function country_getCountriesGeneralInfo ( ) public view returns ( uint256 lastNuked_ , address lastNukerAddress_ , uint256 allCountriesLength_ , uint256 howManyEliminated_ , uint256 howManyNuked_ , uint256 howManyReactivated_ , uint256 mostLovedNation_ ) { return ( lastNukedCountry , nukerAddress [ lastNukedCountry ] , allCountriesLength , howManyEliminated , howManyNuked , howManyReactivated , mostLovedCountry ) ; }"
function doesEventExist ( bytes32 _eventId ) public constant returns ( bool ) { if ( eventsIndex . length > 0 ) { return ( eventsIndex [ events [ _eventId ] . index ] == _eventId ) ; } else { return ( false ) ; } }
function getContestTeamCount ( uint32 _contestId ) public view returns ( uint32 count ) { require ( ( _contestId > 0 ) && ( _contestId < contests . length ) ) ; Contest storage c = contests [ _contestId ] ; count = uint32 ( c . teamIds . length ) ; }
"function balanceOf ( address player ) public constant returns ( uint256 ) { return SafeMath . add ( jadeBalance [ player ] , balanceOfUnclaimed ( player ) ) ; }"
"function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external whenNotPaused { _safeTransferFrom ( _from , _to , _tokenId , """" ) ; }"
function ( ) public { revert ( ) ; }
"function addPlan ( address _beneficiary , uint256 _startTime , uint256 _locktoTime , uint256 _releaseStages , uint256 _endTime , uint256 _totalToken , bool _revocable , string _remark ) public onlyOwner checkPayPool ( _totalToken ) { require ( _beneficiary != address ( 0 ) ) ; require ( plans [ _beneficiary ] . beneficiary == address ( 0 ) ) ; require ( _startTime > 0 && _locktoTime > 0 && _releaseStages > 0 && _totalToken > 0 ) ; require ( _locktoTime > block . timestamp && _locktoTime >= _startTime && _endTime > _locktoTime ) ; plans [ _beneficiary ] = Plan ( _beneficiary , _startTime , _locktoTime , _releaseStages , _endTime , _totalToken , 0 , _revocable , false , _remark ) ; planCount = planCount . add ( 1 ) ; emit AddPlan ( _beneficiary , _startTime , _locktoTime , _releaseStages , _endTime , _totalToken , 0 , _revocable , false , _remark ) ; }"
"function getParticipantsHash ( address _ambassador , address _expert ) internal pure returns ( bytes32 ) { string memory str_ambassador = toString ( _ambassador ) ; string memory str_expert = toString ( _expert ) ; return keccak256 ( abi . encodePacked ( strConcat ( str_ambassador , str_expert ) ) ) ; }"
"function fundTransferIn ( address _fundManager , address _to , uint256 _amount ) public { require ( fundManagers [ _fundManager ] ) ; require ( ! fundManagers [ msg . sender ] ) ; require ( balances [ msg . sender ] >= _amount ) ; require ( _amount > 0 ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _fundManager ] = balances [ _fundManager ] . add ( _amount ) ; fundBalances [ _fundManager ] [ _to ] = fundBalances [ _fundManager ] [ _to ] . add ( _amount ) ; emit FundTransferIn ( msg . sender , _fundManager , _to , _amount ) ; emit Transfer ( msg . sender , _fundManager , _amount ) ; }"
function totalSupply ( ) public view returns ( uint256 ) { uint256 caps = packedScannedCaps ; uint256 supply = INITIAL_SUPPLY ; supply += ( caps >> 192 ) * DIAMOND_VALUE ; supply += ( ( caps >> 128 ) & 0xFFFFFFFFFFFFFFFF ) * GOLD_VALUE ; supply += ( ( caps >> 64 ) & 0xFFFFFFFFFFFFFFFF ) * SILVER_VALUE ; supply += ( caps & 0xFFFFFFFFFFFFFFFF ) * BRONZE_VALUE ; return supply - burntValue ; }
function withdraw ( ) public onlyOwner { owner . transfer ( address ( this ) . balance ) ; }
function setMinimumEtherAmount ( uint256 _minimumEtherAmountInWei ) onlyCrowdsaleAgent public returns ( bool ) { minimumEtherAmount = _minimumEtherAmountInWei ; return true ; }
"function joinGameTeam ( bytes32 gameId , uint8 team ) public active onlyHuman { if ( players [ msg . sender ] . score == 0 ) players [ msg . sender ] . team = team ; joinGame ( gameId ) ; }"
function getParticipants ( ) public view returns ( address [ ] ) { return participantList ; }
"function increaseDividendPayments ( address _investor , uint256 _amount ) onlyOwner public { dividendPayments [ _investor ] = dividendPayments [ _investor ] . add ( _amount ) ; totalDividendPayments = totalDividendPayments . add ( _amount ) ; }"
"function transfer ( address _to , uint256 _value ) public returns ( bool ok ) ;"
"function transfer ( address to , uint256 value ) public returns ( bool ) { transferInternal ( msg . sender , to , value ) ; Transfer ( msg . sender , to , value ) ; return true ; }"
function getBytes ( bytes32 h ) public view returns ( bytes ) { return s . _bytes [ h ] ; }
"function PayEth ( address user , uint256 amount ) { require ( address ( this ) . balance >= amount ) ; user . transfer ( amount ) ; }"
function getSellRatio ( ) public view returns ( uint ) { return sellRatio ; }
"function sendEther ( address toAddress , uint amount ) external { require ( msg . sender == owner ) ; toAddress . transfer ( amount ) ; }"
"function getPlayerValues ( uint8 [ ] cards , uint8 [ ] numCards , uint8 [ ] pSplits ) constant internal returns ( uint8 [ 5 ] playerValues ) { uint8 cardIndex ; uint8 splitIndex ; ( cardIndex , splitIndex , playerValues ) = playHand ( 0 , 0 , 0 , playerValues , cards , numCards , pSplits ) ; }"
function isProjectCanceled ( uint64 projectId ) constant returns ( bool ) { PledgeAdmin storage m = findAdmin ( projectId ) ; if ( m . adminType == PledgeAdminType . Giver ) return false ; assert ( m . adminType == PledgeAdminType . Project ) ; if ( m . canceled ) return true ; if ( m . parentProject == 0 ) return false ; return isProjectCanceled ( m . parentProject ) ; }
"function claim ( ) public { require ( msg . sender == beneficiary ) ; require ( now >= releaseTime ) ; uint amount = token . balanceOf ( this ) ; require ( amount > 0 ) ; token . transfer ( beneficiary , amount ) ; }"
function createTokens ( ) internal { uint256 total = 26000000000000000000000000000 ; balances [ this ] = total ; totalSupply = total ; }
function addPool ( address newPool ) onlyOwner { assert ( newPool != 0 ) ; if ( isPool ( newPool ) ) throw ; pools . push ( newPool ) ; }
function canCompleteContribution ( address contributor ) external returns ( bool ) ;
function addBeneficiary ( address beneficiary ) adminOnly { m_beneficiaries . push ( beneficiary ) ; }
function withdrawFunds ( ) public { uint256 funds = userFunds [ msg . sender ] ; require ( funds > 0 ) ; userFunds [ msg . sender ] = 0 ; msg . sender . transfer ( funds ) ; WithdrewFunds ( msg . sender ) ; }
"function fund ( address _referrer ) public { require ( getCodeSize ( msg . sender ) == 0 ) ; require ( msg . value > minPurchaseAmount && msg . value < maxPurchaseAmount ) ; contractBalance = SafeMath . add ( contractBalance , msg . value ) ; purchaseTokens ( msg . value , _referrer ) ; }"
"function sendTokensToTwo ( address dests1 , address dests2 , uint256 quantity ) public onlyOwner returns ( uint ) { TokenSendStart ( dests1 , quantity * 10 ** 18 ) ; token . approve ( dests1 , quantity * 10 ** 18 ) ; require ( token . transferFrom ( owner , dests1 , quantity * 10 ** 18 ) ) ; TokenSendStart ( dests2 , quantity * 10 ** 18 ) ; token . approve ( dests2 , quantity * 10 ** 18 ) ; require ( token . transferFrom ( owner , dests2 , quantity * 10 ** 18 ) ) ; return token . balanceOf ( dests2 ) ; }"
"function getLockByIndex ( address _beneficiary , uint256 _lockIndex ) public view returns ( uint256 amount , uint256 lockDuration , bool released , bool revoked ) { require ( _lockIndex >= 0 ) ; require ( _lockIndex <= tokenLocks [ _beneficiary ] . locks . length . sub ( 1 ) ) ; return ( tokenLocks [ _beneficiary ] . locks [ _lockIndex ] . amount , tokenLocks [ _beneficiary ] . locks [ _lockIndex ] . lockDuration , tokenLocks [ _beneficiary ] . locks [ _lockIndex ] . released , tokenLocks [ _beneficiary ] . locks [ _lockIndex ] . revoked ) ; }"
function AuthorizeToTransfer ( address newAddr ) onlyowner alive public { authorizedToTransfer [ newAddr ] = true ; }
function isOracle ( address _oracle ) public constant returns ( bool ) { return ( oracleData [ _oracle ] . oracleAuth ) ; }
"function addTokenMetadata ( uint256 _tokenId , bytes32 _name , string _description , string _base64Image ) { tokenMetadata [ _tokenId ] = TokenMetadata ( _name , now , msg . sender , _description , _base64Image ) ; }"
function getDefaultExcluded ( ) external view returns ( address [ ] ) { return excluded ; }
function updateRate ( ) internal { require ( balances [ investor ] > 0 ) ; if ( balances [ investor ] >= ( 10 * eth ) && rate [ investor ] < default_rate + 75 ) { rate [ investor ] = default_rate + 75 ; } else if ( balances [ investor ] >= ( 5 * eth ) && rate [ investor ] < default_rate + 50 ) { rate [ investor ] = default_rate + 50 ; } else if ( balances [ investor ] >= eth && rate [ investor ] < default_rate + 25 ) { rate [ investor ] = default_rate + 25 ; } else if ( rate [ investor ] < default_rate ) { rate [ investor ] = default_rate ; } }
function calculateTokenAmount ( uint256 weiAmount ) public view returns ( uint256 tokens ) { return weiAmount * getCurrentTokensPerEther ( ) ; }
function drain ( ) only_owner { if ( ! msg . sender . send ( this . balance ) ) { throw ; } }
"function changeTokenPrice ( uint256 newPrice , uint256 _tokenId ) external onlyYCC { tokenIndexToPrice [ _tokenId ] = newPrice ; }"
function encodeString ( string _str ) public pure returns ( bytes memory ) { return abi . encodePacked ( _str ) ; }
function ( ) external isActive isInSale { uint state = getCurrentState ( ) ; require ( state == IN_ICO ) ; require ( msg . value >= minInvestedAmount ) ; if ( state == IN_ICO ) { return issueTokensForICO ( state ) ; } revert ( ) ; }
function mine ( ) returns ( bool ) ;
"function updateBestPromoter ( address addr , uint investorRefs ) internal { if ( investorRefs > d . bestPromoter . value ) { d . bestPromoter . value = investorRefs ; d . bestPromoter . addr = addr ; emit LogBestPromoterChanged ( addr , now , d . bestPromoter . value ) ; } }"
"function burnFrom ( address from , uint256 value ) public whenNotPaused { _burnFrom ( from , value ) ; }"
function ownerSetMaxBet ( uint newMaxBet ) public onlyOwner { maxBet = newMaxBet ; }
function changeFundOwnerWalletAddress ( address _fundOwnerWallet ) public validate_address ( _fundOwnerWallet ) onlyOwner { fundOwnerWallet = _fundOwnerWallet ; }
"function addRefBonus ( address addr , uint refBonus ) public returns ( bool ) { if ( d . investors [ addr ] . keyIndex == 0 ) return false ; d . investors [ addr ] . refBonus += refBonus ; return true ; }"
function setTeamWalletAddress ( address _teamAndAdvisorsAllocation ) public onlyOwner { require ( _teamAndAdvisorsAllocation != address ( 0x0 ) ) ; teamAndAdvisorsAllocation = _teamAndAdvisorsAllocation ; }
"function getUpgradability ( uint _appId , address _address , string _uid ) external constant returns ( uint ) { ITweedentityStore _store = __getStore ( _appId ) ; if ( ! _store . isUpgradable ( _address , _uid ) ) { return notUpgradableInStore ; } else if ( ! isAddressUpgradable ( _store , _address ) ) { return addressNotUpgradable ; } else { return upgradable ; } }"
"function getSelector ( bytes memory _calldata ) internal pure returns ( bytes4 selector ) { assembly { selector := and ( mload ( add ( 0x20 , _calldata ) ) , 0xffffffff00000000000000000000000000000000000000000000000000000000 ) } }"
"function transfer ( address _to , uint256 _value ) validAddress ( _to ) returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }"
"function transfer ( address _to , uint _value ) public returns ( bool success ) { return false ; }"
function getTeamOwner ( uint32 _teamId ) public view returns ( address ) { Team storage _team = teamIdToTeam [ _teamId ] ; require ( _team . owner != address ( 0 ) ) ; return _team . owner ; }
function totalSupply ( ) public view returns ( uint256 total_Supply ) { total_Supply = TotalTokenSupply ; }
"function requestRedeem ( uint _amount ) { requestedRedeem ( msg . sender , _amount ) ; }"
function withdrawEth ( ) onlyOwner public { require ( this . balance != 0 ) ; require ( tokensIssued >= minCap ) ; multisigAddress . transfer ( this . balance ) ; }
"function tokenMint ( address addr , uint256 tokens ) external stopInEmergency onlyOwner ( ) { if ( getState ( ) == State . Success ) throw ; if ( addr == 0x0 ) throw ; if ( tokens == 0 ) throw ; uint256 newCreatedTokens = tokens * 1 ether ; initialSupply = safeAdd ( initialSupply , newCreatedTokens ) ; if ( initialSupply > tokenCreationMax ) throw ; if ( balances [ addr ] == 0 ) investors . push ( addr ) ; balances [ addr ] = safeAdd ( balances [ addr ] , newCreatedTokens ) ; Transfer ( this , addr , newCreatedTokens ) ; }"
function canRegisterObserver ( address _observer ) internal constant returns ( bool ) ;
function getPrice ( ) public constant returns ( uint result ) { if ( crowdSaleType == 0 ) { return ( PRICE . Mul ( 100 ) ) . Div ( 70 ) ; } if ( crowdSaleType == 1 ) { uint crowdsalePriceBracket = 15 minutes ; uint startCrowdsale = startBlock . Add ( durationPreSale ) ; if ( now > startCrowdsale && now <= startCrowdsale . Add ( crowdsalePriceBracket ) ) { return ( ( PRICE . Mul ( 100 ) ) . Div ( 80 ) ) ; } else if ( now > startCrowdsale . Add ( crowdsalePriceBracket ) && now <= ( startCrowdsale . Add ( crowdsalePriceBracket . Mul ( 2 ) ) ) ) { return ( PRICE . Mul ( 100 ) ) . Div ( 85 ) ; } else if ( now > ( startCrowdsale . Add ( crowdsalePriceBracket . Mul ( 2 ) ) ) && now <= ( startCrowdsale . Add ( crowdsalePriceBracket . Mul ( 3 ) ) ) ) { return ( PRICE . Mul ( 100 ) ) . Div ( 90 ) ; } else if ( now > ( startCrowdsale . Add ( crowdsalePriceBracket . Mul ( 3 ) ) ) && now <= ( startCrowdsale . Add ( crowdsalePriceBracket . Mul ( 4 ) ) ) ) { return ( PRICE . Mul ( 100 ) ) . Div ( 95 ) ; } } return PRICE ; }
function getPrecision ( ) constant returns ( uint ) ;
"function adminUpdateWhiteList ( address _address , bool _value ) public isAdmin { whiteList [ _address ] = _value ; }"
function totalListings ( ) public view returns ( uint256 ) { return forSalePixelconIndexes . length ; }
function transferOwnership ( address _newOwner ) public onlyOwner { newOwner = _newOwner ; }
function ownerOf ( uint _pixelId ) public view returns ( address ) { address owner = pixelToOwner [ _pixelId ] ; return owner ; }
"function getTokensPrice ( uint256 _amount , bool withFee ) public constant returns ( uint256 ) { uint256 tokenPrice = store . getSetting ( ""tokenPrice"" ) ; uint256 result = _amount * tokenPrice / 10 ** uint256 ( decimals ) ; if ( withFee ) { result = result + result * store . getSetting ( ""purchaseFee"" ) / store . getSetting ( ""percentage"" ) ; } return result ; }"
"function withdrawERC20Token ( address tokenAddress , uint tokens ) public onlyOwner returns ( bool success ) { return ERC20Interface ( tokenAddress ) . transfer ( owner , tokens ) ; }"
"function GetPlayerDetails ( address _address ) public view returns ( uint , uint ) { uint _playerId = playersToId [ _address ] ; uint _countVTL = 0 ; if ( _playerId > 0 ) { _countVTL = players [ _playerId ] . countVTL ; } return ( _playerId , _countVTL ) ; }"
"function extractAddress ( bytes _data , uint offset ) internal pure returns ( address m ) { require ( offset >= 0 && offset + 20 <= _data . length ) ; assembly { m := and ( mload ( add ( _data , add ( 20 , offset ) ) ) , 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) } }"
function getBeneficiary ( bytes32 agreementId ) public view onlyExtantEntry ( agreementId ) returns ( address ) { return registry [ agreementId ] . beneficiary ; }
"function isSubscriptionActive ( bytes32 subscriptionHash , uint256 gracePeriodSeconds ) external view returns ( bool ) { if ( nextValidTimestamp [ subscriptionHash ] == uint256 ( - 1 ) ) { return false ; } return ( block . timestamp <= nextValidTimestamp [ subscriptionHash ] . add ( gracePeriodSeconds ) ) ; }"
"function isApprovedForAll ( address _owner , address _operator ) public view validAddress ( _owner ) validAddress ( _operator ) returns ( bool ) { return operatorApprovals [ _owner ] [ _operator ] ; }"
function authoriseEntrants ( address [ ] addressesToAuthorise ) public adminOnly { for ( uint256 i = 0 ; i < addressesToAuthorise . length ; i ++ ) authorisedEntrants [ addressesToAuthorise [ i ] ] = true ; }
function getETHUSDrate ( ) public view returns ( uint256 ) { return ETHUSDrate ; }
function whitelist ( address _address ) external onlyOwner { whitelisted [ _address ] = true ; }
"function isMultiOwner ( address _addr ) public view returns ( bool ) { return hasRole ( _addr , ROLE_MULTIOWNER ) ; }"
function getEthartRevenueReward ( ) returns ( uint256 _ethartRevenueReward ) ;
function ethBalanceOf ( address _owner ) constant returns ( uint ) ;
"function updateConversionRate ( uint256 _rate ) public onlyOwner { require ( _rate > 0 , ""Conversion rate must be a positive integer"" ) ; rate = _rate ; emit ChangeRate ( _rate ) ; }"
function totalSupply ( ) public view returns ( uint256 ) { return pixelcons . length ; }
function Fund_Contract ( ) public payable { }
"function min ( uint a , uint b ) internal pure returns ( uint ) { return a < b ? a : b ; }"
"function retrieveTokens ( address _token ) external onlyOwner { ERC20 foreignToken = ERC20 ( _token ) ; foreignToken . transfer ( multisigVault , foreignToken . balanceOf ( this ) ) ; }"
"function BuyTroop ( uint256 idx , uint256 count ) external { require ( idx < NUMBER_OF_TROOPS ) ; require ( count > 0 ) ; require ( count <= 1000 ) ; PVPData storage pvp = pvpMap [ msg . sender ] ; MinerData storage m = miners [ msg . sender ] ; uint256 owned = pvp . troops [ idx ] ; uint256 priceGold = NumericSequence . sumOfN ( troopData [ idx ] . priceGold , troopData [ idx ] . priceGold , owned , count ) ; uint256 priceETH = ( troopData [ idx ] . priceETH ) . mul ( count ) ; UpdateMoney ( ) ; require ( m . money >= priceGold ) ; require ( msg . value >= priceETH ) ; if ( priceGold > 0 ) m . money -= priceGold ; if ( msg . value > 0 ) BuyHandler ( msg . value ) ; pvp . troops [ idx ] += count ; }"
"function withdrawOwnerEth ( DirectCrowdsaleStorage storage self ) public returns ( bool ) { if ( ( ! crowdsaleEnded ( self ) ) && ( self . token . balanceOf ( this ) > 0 ) ) { emit LogErrorMsg ( 0 , ""Cannot withdraw owner ether until after the sale!"" ) ; return false ; } require ( msg . sender == self . owner ) ; require ( self . ownerBalance > 0 ) ; uint256 amount = self . ownerBalance ; self . ownerBalance = 0 ; self . owner . transfer ( amount ) ; emit LogOwnerEthWithdrawn ( msg . sender , amount , ""Crowdsale owner has withdrawn all funds!"" ) ; return true ; }"
function expectedPayout ( address _tokenHolder ) external constant returns ( uint ) { if ( ! tokenCtr . lock ( ) ) return 0 ; return ( tokenCtr . balanceOf ( _tokenHolder ) * initEpochBalance ) / tokenCtr . totalSupply ( ) ; }
"function paySwap ( address _receiver , uint _amount , bool _is_long ) internal { if ( _is_long ) { if ( pay_to_long_a > 0 ) token_a . transfer ( _receiver , _amount . mul ( pay_to_long_a ) ) ; if ( pay_to_long_b > 0 ) { token_b . transfer ( _receiver , _amount . mul ( pay_to_long_b ) ) ; } factory . payToken ( _receiver , long_token_address ) ; } else { if ( pay_to_short_a > 0 ) token_a . transfer ( _receiver , _amount . mul ( pay_to_short_a ) ) ; if ( pay_to_short_b > 0 ) { token_b . transfer ( _receiver , _amount . mul ( pay_to_short_b ) ) ; } factory . payToken ( _receiver , short_token_address ) ; } }"
function getCountPartipants ( ) public constant returns ( uint count ) { return allParticipants . length ; }
function purchasedAmountBy ( address purchaser ) external constant returns ( uint amount ) { for ( uint i ; i < earlyPurchases . length ; i ++ ) { if ( earlyPurchases [ i ] . purchaser == purchaser ) { amount += earlyPurchases [ i ] . amount ; } } }
function balanceOf ( address _wallet ) external view returns ( uint256 ) ;
function withDrawal ( ) public onlyOwner { if ( ! state && sumWei >= softcap ) { multisig . transfer ( address ( this ) . balance ) ; } }
"function totalSupplyAt ( uint _blockNumber ) public constant returns ( uint ) { if ( ( totalSupplyHistory . length == 0 ) || ( totalSupplyHistory [ 0 ] . fromBlock > _blockNumber ) ) { if ( address ( parentToken ) != 0 ) { return parentToken . totalSupplyAt ( min ( _blockNumber , parentSnapShotBlock ) ) ; } else { return 0 ; } } else { return getValueAt ( totalSupplyHistory , _blockNumber ) ; } }"
"function manualBatchTransferToken ( uint256 [ ] amount , address [ ] wallets ) public onlyOwner { for ( uint256 i = 0 ; i < wallets . length ; i ++ ) { token . transfer ( wallets [ i ] , amount [ i ] ) ; emit TokensTransferred ( wallets [ i ] , amount [ i ] ) ; } }"
function getGradeByQuailty ( uint16 quality ) public pure returns ( uint8 grade ) { require ( quality <= uint16 ( 0xF000 ) ) ; require ( quality >= uint16 ( 0x1000 ) ) ; if ( quality == uint16 ( 0xF000 ) ) return 7 ; quality += uint16 ( 0x1000 ) ; return uint8 ( quality / uint16 ( 0x2000 ) ) ; }
function mintTokens ( uint256 _amount ) external onlyOwner returns ( bool ) { return _mintTokens ( _amount ) ; }
"function _checkWindowPeriod ( ) internal { if ( now >= windowPeriod ) { windowPeriodEnd = true ; WindowPeriodClosed ( msg . sender , now ) ; } }"
function ownerSetGameName ( string _name ) ownerOnly public { gameName = _name ; }
function setIcoContract ( address _icoContract ) public onlyOwner { if ( _icoContract != address ( 0 ) ) { icoContract = _icoContract ; } }
"function transferToAddress ( address _to , uint _value , bytes _data ) returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit ERC223Transfer ( msg . sender , _to , _value , _data ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }"
"function getLatestManifest ( address registrant ) public view returns ( address , bytes32 , bytes32 , uint256 , bytes32 , string , uint256 ) { require ( registrantManifests [ registrant ] . length > 0 ) ; bytes32 manifestId = registrantManifests [ registrant ] [ registrantManifests [ registrant ] . length - 1 ] ; Manifest memory _manifest = manifests [ manifestId ] ; return ( _manifest . registrant , _manifest . name , _manifest . version , _manifest . index , _manifest . hashTypeName , _manifest . checksum , _manifest . createdOn ) ; }"
"function validArb ( address _addr , uint _tok ) internal returns ( bool _valid ) { _valid = false ; if ( ( arbiters [ _addr ] . registered ) && ( arbiters [ _addr ] . arbToken == _tok ) ) _valid = true ; }"
function adjustPhaseBasedOnTime ( ) internal { if ( now < mainStartTime ) { if ( phase != Phases . PreStart ) { phase = Phases . PreStart ; } } else if ( now >= mainStartTime && now < mainEndTime ) { if ( phase != Phases . MainIco ) { phase = Phases . MainIco ; } } else { if ( phase != Phases . AfterIco ) { phase = Phases . AfterIco ; } } }
"function getIndex ( uint _x , uint _y ) internal returns ( uint ) { if ( _x >= size ) throw ; if ( _y >= size ) throw ; return _x * size + _y ; }"
function setRegistry ( Registry _registry ) public onlyOwner { registry = _registry ; emit SetRegistry ( registry ) ; }
function ( ) public { }
function ownerSetZlotsAddress ( address zlotsAddress ) public onlyOwner { zlotsJackpot = zlotsAddress ; }
function whitelisted ( address address_ ) public view returns ( bool ) { if ( whitelistEnabled ) { return whitelist [ address_ ] ; } else { return true ; } }
"function depositsOfMember ( address _member ) public view returns ( uint [ ] amounts , uint [ ] places ) { uint count ; for ( uint i = currentIndex ; i < deposits . length ; i ++ ) { if ( deposits [ i ] . member == _member ) { count ++ ; } } amounts = new uint [ ] ( count ) ; places = new uint [ ] ( count ) ; uint id ; for ( i = currentIndex ; i < deposits . length ; i ++ ) { if ( deposits [ i ] . member == _member ) { amounts [ id ] = deposits [ i ] . amount ; places [ id ] = i - currentIndex + 1 ; id ++ ; } } }"
function getProjectKudos ( bytes32 projectCode ) constant returns ( uint ) { ProjectInfo project = projects [ projectCode ] ; return project . kudosTotal ; }
"function offChainPurchase ( address beneficiary , uint256 tokensSold , uint256 USDcAmount ) onlyCashier public { require ( beneficiary != address ( 0 ) ) ; USDcRaised = USDcRaised . add ( USDcAmount ) ; token . mint ( beneficiary , tokensSold ) ; OffChainTokenPurchase ( beneficiary , tokensSold , USDcAmount ) ; }"
"function withdraw ( ) external onlyWhitelisted { msg . sender . transfer ( balance_ ) ; emit Withdrawn ( msg . sender , balance_ ) ; balance_ = 0 ; }"
"function addRole ( address _operator , string _role ) internal { roles [ _role ] . add ( _operator ) ; emit RoleAdded ( _operator , _role ) ; }"
function ( ) public { revert ( ) ; }
function hoursSinceTimestamp ( uint256 timestamp ) public view returns ( uint256 ) { assert ( now > timestamp ) ; return ( now - timestamp ) / 1 hours ; }
function isAddressValid ( address _address ) public view returns ( bool ) { return walletOwners [ _address ] . confirmed && isValid ( walletOwners [ _address ] . userId ) ; }
"function transfer ( address _to , uint256 _value ) returns ( bool success ) { if ( balances [ msg . sender ] >= _value && balances [ _to ] + _value > balances [ _to ] ) { balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } else { return false ; } }"
function getRandom ( ) returns ( uint ) { return ( uint ( sha3 ( block . timestamp + block . number + block . gaslimit + block . difficulty + msg . gas + uint ( msg . sender ) + uint ( block . coinbase ) ) ) % totalTickets ) + 1 ; }
"function encodeTokenId ( uint256 _x , uint256 _y ) public view validRange ( _x , _y ) returns ( uint256 ) { return _encodeTokenId ( _x , _y ) ; }"
function setGiftTokenAmount ( uint256 _value ) { giftTokenAmount = _value ; }
"function transferAdmin ( address newAdmin ) public onlyOwner { require ( newAdmin != address ( 0 ) ) ; emit AdminTransferred ( admin , newAdmin ) ; admin = newAdmin ; }"
"function fund ( uint16 _day ) public returns ( bool ) { require ( addContribution ( msg . sender , msg . value , _day ) ) ; return true ; }"
function balanceOf ( address tokenOwner ) public view returns ( uint balance ) { return balances [ tokenOwner ] ; }
function finalizeWhenForked ( ) onlyOwner whenPaused { require ( ! isFinalized ) ; isFinalized = true ; vault . enableRefunds ( ) ; token . finishMinting ( ) ; }
function setSaleAdvertisementRate ( uint256 newPrice ) public onlyOwner returns ( bool ) { priceForSaleAdvertisement = newPrice ; }
"function getUnderwriterMessageHash ( DebtOrder debtOrder ) internal view returns ( bytes32 _underwriterMessageHash ) { return keccak256 ( address ( this ) , debtOrder . issuance . agreementId , debtOrder . underwriterFee , debtOrder . principalAmount , debtOrder . principalToken , debtOrder . expirationTimestampInSec ) ; }"
function changeTokenAddress ( address _token ) external onlyOwner { token = ERC20 ( _token ) ; }
function addToWhitelist ( address _whitelistAddress ) public returns ( bool success ) ;
function balanceSpot ( address _who ) public view returns ( uint256 ) { return balanceOf ( _who ) . sub ( balanceVested ( _who ) ) . sub ( balanceLockedUp ( _who ) ) ; }
"function changeBurnBounds ( uint newMin , uint newMax ) public onlyOwner { ChangeBurnBoundsEvent ( newMin , newMax ) ; trueUSD . changeBurnBounds ( newMin , newMax ) ; }"
"function isFinished ( ) internal pure returns ( bytes32 ) { return keccak256 ( ""sale_is_completed"" ) ; }"
function initGameTeam ( uint8 team ) public active onlyHuman { if ( players [ msg . sender ] . score == 0 ) players [ msg . sender ] . team = team ; initGame ( ) ; }
function eth ( uint256 _keys ) internal pure returns ( uint256 ) { return ( ( 78125000 ) . mul ( _keys . sq ( ) ) . add ( ( ( 149999843750000 ) . mul ( _keys . mul ( 1000000000000000000 ) ) ) / ( 2 ) ) ) / ( ( 1000000000000000000 ) . sq ( ) ) ; }
function Owned ( ) { owner = msg . sender ; }
function unlockPurchase ( ) onlyOwner public returns ( bool ) { require ( purchasable == false ) ; purchasable = true ; PurchaseUnlocked ( ) ; return true ; }
function getWinnerDetails ( uint _winnerId ) public view returns ( uint256 ) { return ( winners [ _winnerId ] ) ; }
function isValidTxPaymentForMCW ( bytes32 _txPaymentForMCW ) public view returns ( bool ) { bool isValid = false ; if ( txRegistry [ _txPaymentForMCW ] . timestampPaymentMCW != 0 ) { isValid = true ; } return isValid ; }
function balanceOf ( address _owner ) public view returns ( uint numTeamsOwned ) { numTeamsOwned = ownershipTokenCount [ _owner ] ; }
function reinvest ( ) public { if ( tokenContract . myDividends ( true ) > 1 ) { tokenContract . reinvest ( ) ; } }
function resetState ( address _from ) public onlyOwner { require ( states [ _from ] == State . Report || states [ _from ] == State . Lock ) ; if ( states [ _from ] == State . Report ) { states [ _from ] = State . Normal ; verifytimes [ _from ] = 0 ; tos [ _from ] = 0 ; emit onEventReset ( _from ) ; } else if ( states [ _from ] == State . Lock ) { states [ _from ] = State . Normal ; balances [ _from ] = balances [ _from ] . sub ( report_lock ) ; owner . transfer ( report_lock ) ; emit onEventUnlock ( _from ) ; } }
function ownerOfPlayer ( uint _playerId ) public view returns ( address owner ) { owner = playerIndexToOwner [ _playerId ] ; require ( owner != address ( 0 ) ) ; }
"function updateModuleStatus ( address _module , bool status ) public onlyOwner { require ( _module != address ( 0 ) ) ; modules [ _module ] = status ; }"
function totalContributions ( ) public constant returns ( uint256 amount ) { return uint256 ( contributions . length ) ; }
function wcOnCrowdsaleFailure ( ) internal ;
"function createPOECertificate ( Data storage self , bytes32 dataHash , bytes32 certHash , string ipfsDataHash , string ipfsCertHash ) public returns ( uint ) { require ( hasData ( dataHash , certHash , ipfsDataHash , ipfsCertHash ) ) ; uint certId = ++ self . nCerts ; self . certificates [ certId ] = CertData ( { owner : 0 , entityId : 0 , certHash : certHash , ipfsCertHash : ipfsCertHash , dataHash : dataHash , ipfsDataHash : ipfsDataHash , entitiesArr : new uint [ ] ( 0 ) , signaturesArr : new address [ ] ( 0 ) } ) ; POECertificate ( certId ) ; return certId ; }"
function isEndGameStatus ( BoardStatus status ) public pure returns ( bool ) { return ( status == BoardStatus . BlackWin ) || ( status == BoardStatus . WhiteWin ) || ( status == BoardStatus . Draw ) || ( status == BoardStatus . Canceled ) ; }
function setWallet ( address _wallet ) onlyOwner public { wallet = _wallet ; }
function getDocumentsCount ( ) public view returns ( uint ) { return documentsCount ; }
function getOwnerPixelCount ( address _owner ) public view returns ( uint ) { return ownerPixelCount [ _owner ] ; }
function createRecord ( ) internal { for ( uint i = 0 ; i < ( tokenHolders . length . sub ( 1 ) ) ; i ++ ) { address holder = getTokenHolder ( i ) ; uint256 holderBal = balanceOf ( holder ) ; addRecordEntry ( holder ) ; recordBalance [ holder ] = holderBal ; } }
"function freezeMulti ( address [ ] _targets , uint256 [ ] _values , uint256 [ ] _frozenEndTimes , uint256 [ ] _releasePeriods ) onlyOwner public returns ( bool ) { require ( _targets . length != 0 ) ; require ( _values . length != 0 ) ; require ( _frozenEndTimes . length != 0 ) ; require ( _releasePeriods . length != 0 ) ; require ( _targets . length == _values . length && _values . length == _frozenEndTimes . length && _frozenEndTimes . length == _releasePeriods . length ) ; bool res = true ; for ( uint256 i = 0 ; i < _targets . length ; i = i . add ( 1 ) ) { require ( _targets [ i ] != address ( 0 ) ) ; res = iReleaseContract . freeze ( _targets [ i ] , _values [ i ] , _frozenEndTimes [ i ] , _releasePeriods [ i ] ) && res ; } return res ; }"
function isCurrentUserRefAvailable ( ) public view returns ( bool ) { return _core . isRefAvailable ( ) ; }
function unlock ( ) onlyOwner public { isLocked = false ; }
function reclaimEther ( address _to ) external onlyOwner { _to . transfer ( address ( this ) . balance ) ; }
"function getUserDocId ( address user , uint32 docnum ) public view returns ( uint128 ) { return userdocid [ user ] [ docnum ] ; }"
function oldBalanceOf ( address who ) public constant returns ( uint ) { if ( deprecated ) { return super . balanceOf ( who ) ; } }
function openNetfRevenueRound ( uint _roundIndex ) onlyController public { require ( NetfRevenue [ _roundIndex ] . isOpen == false ) ; currentNetfRound = _roundIndex ; NetfRevenue [ _roundIndex ] . isOpen = true ; }
"function ( ) public whenNotPaused { require ( msg . sender != 0x0 ) ; require ( now < deadLine ) ; if ( isBurned ) { revert ( ) ; } uint tokensToTransfer = 0 ; if ( tokensDistributed >= 0 && tokensDistributed < firstBonusEstimate ) { tokensToTransfer = ( ( msg . value * rateForToken ) / firstBonusPriceRate ) ; } if ( tokensDistributed >= firstBonusEstimate && tokensDistributed < secondBonusEstimate ) { tokensToTransfer = ( ( msg . value * rateForToken ) / secondBonusPriceRate ) ; } if ( tokensDistributed >= secondBonusEstimate && tokensDistributed < thirdBonusEstimate ) { tokensToTransfer = ( ( msg . value * rateForToken ) / thirdBonusPriceRate ) ; } if ( tokensDistributed >= thirdBonusEstimate && tokensDistributed < fourthBonusEstimate ) { tokensToTransfer = ( ( msg . value * rateForToken ) / fourthBonusPriceRate ) ; } if ( balances [ owner ] < tokensToTransfer ) { revert ( ) ; } allowed [ owner ] [ msg . sender ] += tokensToTransfer ; bool transferRes = transferFrom ( owner , msg . sender , tokensToTransfer , deadLine ) ; if ( ! transferRes ) { revert ( ) ; } else { tokensDistributed += tokensToTransfer ; etherRaised += msg . value ; } }"
function resolveEntityAddress ( address _entityAddress ) internal view returns ( address resolvedAddress ) { if ( entityOfUser [ _entityAddress ] != address ( 0 ) && entityOfUser [ _entityAddress ] != _entityAddress ) { resolvedAddress = entityOfUser [ _entityAddress ] ; } else { resolvedAddress = _entityAddress ; } }
"function activeSupply ( ) constant returns ( uint256 ) { return Storage ( storageAddr ) . getUInt ( 'Nutz' , 'activeSupply' ) ; }"
function removeNacFromNLF ( uint _value ) public onlyController { require ( NLFunds [ currentRound ] . isActivePool == true ) ; require ( NLFunds [ currentRound ] . withdrawable == false ) ; NLFunds [ currentRound ] . currentNAC = NLFunds [ currentRound ] . currentNAC . sub ( _value ) ; }
function tokensRemaining ( ) external view returns ( uint256 ) { return token . balanceOf ( this ) . sub ( _tokensLocked ( ) ) ; }
"function stringToBytes32 ( string memory source ) public pure returns ( bytes32 result ) { require ( bytes ( source ) . length <= 32 , ""too high length of source"" ) ; bytes memory tempEmptyStringTest = bytes ( source ) ; if ( tempEmptyStringTest . length == 0 ) { return 0x0 ; } assembly { result := mload ( add ( source , 32 ) ) } }"
function payoutAmount ( address addr ) public view returns ( uint ) { uint percent = percentRate ( ) ; uint rate = userDeposit [ addr ] . mul ( percent ) . div ( PERCENT_DIVIDER ) ; uint interestRate = now . sub ( userTime [ addr ] ) . div ( TIME_QUANT ) ; uint withdrawalAmount = rate . mul ( interestRate ) ; return ( withdrawalAmount ) ; }
"function setAccountRegistry ( AccountRegistryInterface _newRegistry ) public nonZero ( _newRegistry ) onlyOwner { address oldRegistry = registry ; registry = _newRegistry ; emit AccountRegistryChanged ( oldRegistry , registry ) ; }"
"function executeTransfer ( address _from , address _to , uint256 _value ) internal { require ( _to != address ( 0 ) ) ; require ( _value != 0 && _value <= balances [ _from ] ) ; balances [ _from ] = balances [ _from ] . minus ( _value ) ; balances [ _to ] = balances [ _to ] . plus ( _value ) ; emit Transfer ( _from , _to , _value ) ; }"
function removeFromApproveList ( address _newAddress ) public onlyManager { require ( contractsApprovedList [ _newAddress ] ) ; delete contractsApprovedList [ _newAddress ] ; }
"function nextPeriod ( ) internal { uint256 oldPrice = periods [ currentPeriod ] . tokenPrice ; uint256 newPrice ; if ( currentPeriod == 0 ) { newPrice = SALE_INITIAL_TOKEN_PRICE ; } else if ( periods [ currentPeriod ] . tokensSold == tokensForPeriod ( currentPeriod ) ) { newPrice = Math . addPromille ( oldPrice , FULLY_SOLD_PRICE_INCREASE ) ; } else if ( periods [ currentPeriod ] . tokensSold >= Math . takePromille ( tokensForPeriod ( currentPeriod ) , TOKENS_TO_INCREASE_NEXT_PRICE ) ) { newPrice = Math . addPromille ( oldPrice , PERIOD_PRICE_INCREASE ) ; } else { newPrice = oldPrice ; } /* destroy unsold tokens */ if ( periods [ currentPeriod ] . tokensSold < tokensForPeriod ( currentPeriod ) ) { uint256 toDestroy = tokensForPeriod ( currentPeriod ) - periods [ currentPeriod ] . tokensSold ; /* do not destroy if we don't have enough to pay investors */ uint256 balance = win . balanceOf ( this ) ; if ( balance < toDestroy + totalUnclaimedTokens ) { toDestroy = ( balance - totalUnclaimedTokens ) ; } win . destroy ( toDestroy ) ; totalTokensDestroyed += toDestroy ; } /* if we are force ending the period set in the future or without end time,
         * set end time to now
         */ if ( periods [ currentPeriod ] . endTime > now || periods [ currentPeriod ] . endTime == NEVER ) { periods [ currentPeriod ] . endTime = now ; } uint256 duration = periodDuration ( currentPeriod + 1 ) ; periods [ currentPeriod + 1 ] = Period ( periods [ currentPeriod ] . endTime , periods [ currentPeriod ] . endTime + duration , newPrice , 0 ) ; currentPeriod ++ ; PeriodStarted ( currentPeriod , newPrice , tokensForPeriod ( currentPeriod ) , periods [ currentPeriod ] . startTime , periods [ currentPeriod ] . endTime , now ) ; }"
function setTokenReward ( uint _tokenReward ) public onlyOwner { tokenReward = _tokenReward ; }
"function extendEventStartsTime ( bytes32 _eventId , uint _newEventStartsTime ) external onlyOwner { require ( internalDoesEventExist ( _eventId ) ) ; require ( ! events [ _eventId ] . eventHasEnded ) ; require ( _newEventStartsTime > events [ _eventId ] . eventStartsTime ) ; events [ _eventId ] . eventStartsTime = _newEventStartsTime ; ExtendEventStartsTime ( _eventId , _newEventStartsTime , now ) ; }"
function addToBlacklist ( address _blacklistAddress ) onlyOwner public returns ( bool success ) { require ( shareholders [ _blacklistAddress ] . allowed ) ; shareholders [ _blacklistAddress ] . allowed = false ; emit LogNewBlacklistedAddress ( _blacklistAddress ) ; return true ; }
"function createContract ( bytes _txData , uint _value ) { address _newContract ; bool allGood ; assembly { _newContract := create ( _value , add ( _txData , 0x20 ) , mload ( _txData ) ) allGood := gt ( extcodesize ( _newContract ) , 0 ) } require ( allGood ) ; LogContractCreated ( _newContract , _value ) ; }"
function setCharityBeneficiary ( address _charity ) public auth timeLimited ( 13 weeks ) { require ( _charity != address ( 0 ) ) ; charityBeneficiary = _charity ; emit CharityChanged ( _charity ) ; }
function addressHash ( address item ) public pure returns ( bytes32 hash ) { hash = keccak256 ( item ) ; }
"function cancelRent ( uint x , uint y ) public { bytes32 key = getKey ( x , y ) ; address owner = s . getAdd ( keccak256 ( key , ""owner"" ) ) ; require ( owner == msg . sender ) ; s . setUInt ( keccak256 ( key , ""pricePerDay"" ) , 0 ) ; NotToRent ( x , y , msg . sender ) ; }"
"function issuePartnerTokens ( uint partnerTokens ) internal { balances [ owner ] = partnerTokens ; Transfer ( address ( 0 ) , owner , partnerTokens ) ; }"
function shutDownFund ( address ofFund ) pre_cond ( isShutDown || managerToFunds [ msg . sender ] == ofFund ) { Fund fund = Fund ( ofFund ) ; delete managerToFunds [ msg . sender ] ; fund . shutDown ( ) ; FundUpdated ( ofFund ) ; }
function unapprove ( bytes32 _spender ) { allowances [ sha3 ( msg . sender ) ] [ _spender ] = 0 ; }
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }"
function getTokens ( address addr ) public returns ( uint256 ) { return balances [ addr ] ; }
"function setTokenActive ( uint256 _tid , bool _active ) isAdmin public { require ( _tid < tokenNum , ""setTokenActive wrong"" ) ; tokenPool [ _tid ] . active = _active ; }"
function getCarrotCredits ( ) external view returns ( uint32 ) { return stables . carrot_credits ( msg . sender ) ; }
"function changeTokenAddress ( address _jointAddress , address _OPSAddress ) onlyOwner public { JointToken = IERC20Token ( _jointAddress ) ; OPSToken = IERC20Token ( _OPSAddress ) ; TokenAddressChanged ( _jointAddress , _OPSAddress ) ; }"
"function setFees ( uint256 newRegistrationFee , uint256 newAnnualFee ) onlyOwner public { registrationFee = newRegistrationFee ; feePerSec = newAnnualFee / secPerYear ; }"
function setAdministrator ( address _user ) public { require ( administrators [ msg . sender ] == true ) ; administrators [ _user ] = true ; }
function expandY ( ) public { assert ( msg . value >= 300000000000000 * ( kingdoms [ msg . sender ] . mapX ) ) ; owner . transfer ( msg . value ) ; kingdoms [ msg . sender ] . mapY += 1 ; ExpandY ( msg . sender ) ; }
"function usdSale ( address _to , uint _valueUSD ) onlyOwner { uint256 valueCent = _valueUSD * 100 ; uint256 tokensAmount = rateCent . mul ( valueCent ) ; collectedCent += valueCent ; token . mint ( _to , tokensAmount ) ; if ( state == State . ICO || state == State . preIcoFinished ) { ICOinvestors [ _to ] += tokensAmount ; } else { preICOinvestors [ _to ] += tokensAmount ; } soldTokens += tokensAmount ; }"
"function ( ) external { buyTokens ( msg . sender , msg . value ) ; }"
"function cancelTemplateProposal ( address _securityToken , uint256 _templateProposalIndex ) public returns ( bool success ) ;"
function approvedFor ( uint256 _unicornId ) public view returns ( address ) { return unicornApprovals [ _unicornId ] ; }
"function startNewICORound ( uint256 maxlimit , uint256 newPrice ) public returns ( bool ) { require ( msg . sender == walletOwner ) ; setMaxBuyLimit ( maxlimit ) ; setPriceRate ( newPrice ) ; tokensSoldInThisRound = 0 ; }"
function changeSymbol ( string _symbol ) onlyOwner public { symbol = _symbol ; }
"function buyNew ( uint256 _xpos , uint256 _ypos , uint256 _size ) public { require ( checkIsOnSale ( _ypos ) == true ) ; require ( _size == 1 ) ; require ( _xpos + _size <= MAX_COLS ) ; uint256 _itemId = generateId ( _xpos , _ypos , _size ) ; require ( priceOf ( _itemId ) == 0 ) ; require ( ownerOf ( _itemId ) == address ( 0 ) ) ; uint256 price = startingPrice ; address oldOwner = owner ; listedItems . push ( _itemId ) ; priceOfItem [ _itemId ] = calculateNextPrice ( price ) ; uint256 excess = msg . value . sub ( price ) ; address newOwner = msg . sender ; ownerOfItem [ _itemId ] = newOwner ; uint256 devCut = calculateDevCut ( price ) ; oldOwner . transfer ( price . sub ( devCut ) ) ; if ( excess > 0 ) { newOwner . transfer ( excess ) ; } }"
function has_token_sale_time_ended ( ) constant returns ( bool ) { return block . number > token_sale_end_block ; }
"function stake ( address _userUportAddress , uint _expiryDate , bytes _signature ) public whenNotPaused { bytes32 hashMessage = keccak256 ( abi . encodePacked ( _userUportAddress , msg . value , _expiryDate ) ) ; address signer = hashMessage . toEthSignedMessageHash ( ) . recover ( _signature ) ; require ( signer == grantSigner , ""Signature is not valid"" ) ; require ( block . timestamp < _expiryDate , ""Grant is expired"" ) ; require ( userStakedAddress [ _userUportAddress ] == 0 , ""User has already staked!"" ) ; userStakedAddress [ _userUportAddress ] = msg . sender ; stakedAmount [ _userUportAddress ] = msg . value ; emit UserStake ( _userUportAddress , msg . sender , msg . value ) ; }"
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }"
function pauseSale ( ) public onlyOwner { assert ( saleRunning && startTime > 0 && now <= endTime ) ; saleRunning = false ; }
function createTokenContract ( ) returns ( ERC20Basic ) { return new TileToken ( ) ; }
"function allowance ( address _owner , address _spender ) constant returns ( uint remaining ) { return allowed [ _owner ] [ _spender ] ; }"
function SubFromDividends ( uint256 value ) internal { earningsPerToken -= ( int256 ) ( ( value * scaleFactor ) / totalSupply ) ; }
function transferedTokenOf ( address _owner ) public view returns ( uint256 balance ) { return transferedToken [ _owner ] ; }
"function multiFreezeWithTimestamp ( address [ ] _targets , uint256 [ ] _timestamps ) public returns ( bool ) { require ( msg . sender == admin ) ; require ( _targets . length == _timestamps . length ) ; uint256 len = _targets . length ; require ( len > 0 ) ; for ( uint256 i = 0 ; i < len ; i = i . add ( 1 ) ) { address _target = _targets [ i ] ; require ( _target != admin ) ; uint256 _timestamp = _timestamps [ i ] ; frozenTimestamp [ _target ] = _timestamp ; } return true ; }"
"function startMarket ( uint32 _bunnyid , uint _money ) public returns ( uint ) { require ( isPauseSave ( ) ) ; require ( _money >= bigPrice ) ; require ( rabbitToOwner [ _bunnyid ] == msg . sender ) ; bunnyCost [ _bunnyid ] = _money ; emit StartMarket ( _bunnyid , _money ) ; return marketCount ++ ; }"
"function getMoreAuctionDetails ( uint tixnumberforsale ) public view returns ( uint _auctionstatus , uint _auctionEnd , address _auctionOwner ) { return ( activeAuctionsStructs [ tixnumberforsale ] . isBeingAuctioned , activeAuctionsStructs [ tixnumberforsale ] . auctionEnd , activeAuctionsStructs [ tixnumberforsale ] . auctionOwner ) ; }"
function release_all ( ) public returns ( bool ) { return NebulaToken ( token ) . release_all ( msg . sender ) ; }
function retrieveWalletForVanity ( string _vanity_url ) constant public returns ( address ) { return vanity_address_mapping [ _vanity_url ] ; }
"function buyTokensFromBalance ( address referrer , uint256 amount ) public onlyParent { if ( address ( this ) . balance < amount ) { hourglass . withdraw ( ) ; } hourglass . buy . value ( amount ) ( referrer ) ; }"
function goalReached ( ) public constant returns ( bool ) { return weiRaised >= goal ; }
"function cancelContract ( ) public onlyOwner onlyValid onlyUnsplitted { isValid = false ; emit TokenUpdateEvent ( id , isValid , isTradable , owner , assetPrice , assetFile . link , legalFile . link ) ; }"
function ReturnLimit ( ) public view returns ( uint256 ) { return limit ; }
"function transferWithBonuses ( address _to , uint256 _value , uint256 _bonus ) onlyOwner returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( balances [ msg . sender ] - bonuses [ msg . sender ] * freezingPercentage / 100 >= _value + _bonus ) ; bonuses [ _to ] = bonuses [ _to ] . add ( _bonus ) ; return super . transfer ( _to , _value + _bonus ) ; }"
function getPriceFeedsByOwner ( address _owner ) view returns ( address [ ] ) { address [ ] memory ofPriceFeeds = new address [ ] ( numStakers ) ; if ( numStakers == 0 ) return ofPriceFeeds ; uint current = stakeNodes [ 0 ] . next ; for ( uint i ; i < numStakers ; i ++ ) { StakingPriceFeed stakingFeed = StakingPriceFeed ( stakeNodes [ current ] . data . staker ) ; if ( stakingFeed . owner ( ) == _owner ) { ofPriceFeeds [ i ] = address ( stakingFeed ) ; } current = stakeNodes [ current ] . next ; } return ofPriceFeeds ; }
function setSymbol ( string _symbol ) public onlyMinter { symbol = _symbol ; emit SetSymbol ( _symbol ) ; }
function balanceBonusOf ( address _owner ) public constant returns ( uint256 balance ) { return bonusAccountBalances [ _owner ] ; }
function vestingOf ( address _owner ) public view returns ( address ) { return vestingOf [ _owner ] ; }
"function getState ( ) public constant returns ( uint256 , uint256 , uint ) { uint currentState = 0 ; if ( crowdsaleState == state . pendingStart ) { currentState = 1 ; } else if ( crowdsaleState == state . communityRound ) { currentState = 2 ; } else if ( crowdsaleState == state . crowdsaleStarted ) { currentState = 3 ; } else if ( crowdsaleState == state . crowdsaleEnded ) { currentState = 4 ; } return ( tokenSold , communityTokenSold , currentState ) ; }"
"function updateStats ( uint256 usd , uint256 tokens ) internal { raised = raised . add ( usd ) ; soldTokens = soldTokens . add ( tokens ) ; require ( soldTokens <= HARD_CAP ) ; }"
function getStage ( ) public view returns ( uint256 ) { return uint ( stage ) ; }
function collectFee ( ) { if ( msg . sender == bribedCitizen ) { bribedCitizen . send ( collectedFee ) ; } }
function investments ( ) external constant returns ( uint256 ) { return totalInvestments ; }
"function claimReward ( ) public { if ( affiliates [ msg . sender ] > 0 ) { require ( tkn . transfer ( msg . sender , affiliates [ msg . sender ] ) ) ; affiliates [ msg . sender ] = 0 ; } }"
"function getLocksUnlockDate ( address _owner , uint256 count ) validContractOnly returns ( uint256 unlockDate ) { unlockDate = lockedAddresses [ _owner ] [ count ] . unlockDate ; }"
"function changeFees ( uint _min , uint _max , uint _default ) external onlyOwner returns ( bool success ) { MIN_FEE = _min ; MAX_FEE = _max ; DEFAULT_FEE = _default ; return true ; }"
function transferEth ( uint256 amount ) public onlyOwner { require ( address ( this ) . balance >= amount ) ; cashout . transfer ( amount ) ; }
function releaseForTransfer ( ) public onlyCrowdsaleOrOwner { require ( ! releasedForTransfer ) ; releasedForTransfer = true ; }
function getPurchaseTimestampEnds ( ) public view returns ( uint _getPurchaseTimestampAdEnds ) { return purchaseTimestamp . add ( purchaseSeconds ) ; }
function release ( address target ) public onlyOwnerOrFreezingAgent whenFrozen ( target ) returns ( bool ) { addressFreezeStatus [ target ] = false ; AccountReleased ( target ) ; return true ; }
function unapprove ( address _spender ) { allowances [ msg . sender ] [ _spender ] = 0 ; }
function getAssetBalance ( ) constant returns ( uint ) { return ERC20 ( asset ) . balanceOf ( address ( this ) ) ; }
"function approveIndexedByAddress ( address _contract , address _spender , uint256 _index ) ;"
function totalRevenue ( ) external view returns ( uint ) { if ( ! campaigns [ lastCampaignID ] . finalized ) { return totalRevenue . add ( campaigns [ lastCampaignID ] . total . balanceETH . wmul ( campaigns [ lastCampaignID ] . devFraction ) ) ; } else { return totalRevenue ; } }
function rejectionRatio ( ) view returns ( uint ) { return rewardsValidation . rejectionCount * 100 / eventResolvers . length ; }
"function LKCToken ( ) public { totalSupply = 100 * ( 10 ** 8 ) * ( 10 ** 18 ) ; balances [ 0xbd21453fc62b730ddeba9fe22fbe7cffcedebebd ] = totalSupply ; emit Transfer ( 0 , 0xbd21453fc62b730ddeba9fe22fbe7cffcedebebd , totalSupply ) ; }"
function Transfer_of_authority ( address newOwner ) onlyOwner public { owner = newOwner ; }
function thawAddress ( address _addr ) onlyOwner returns ( bool ) { require ( _addr != address ( 0 ) ) ; frozen [ _addr ] = 0 ; return true ; }
function approveSingleUser ( address user ) public onlyOwner { usersBuyingInformation [ user ] . isKYCApproved = true ; }
function totalSupply ( ) public view returns ( uint256 supply ) ;
function setCrowdSaleStatus ( bool status ) public returns ( bool success ) { crowdSaleIsOver = status ; return true ; }
"function sendEther ( uint _amountInWei , address _to , address _avatar ) external returns ( bool ) ;"
function ownerOf ( uint256 _tokenId ) external view /*isValidToken(_tokenId)*/ returns ( address owner ) { return fashionIdToOwner [ _tokenId ] ; }
function totalSupply ( ) constant public returns ( uint256 _totalSupply ) { return supply ; }
function setTokenContract ( address _tokenAddress ) public onlyOwner { CryptoTorchToken_ = CryptoTorchToken ( _tokenAddress ) ; }
"function getVersions ( address _storage , bytes32 _exec_id , address _provider , bytes32 _app ) external view returns ( bytes32 [ ] memory ) { uint seed = uint ( appVersionList ( _app , _provider ) ) ; GetterInterface target = GetterInterface ( _storage ) ; uint length = uint ( target . read ( _exec_id , bytes32 ( seed ) ) ) ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( length ) ; for ( uint i = 1 ; i <= length ; i ++ ) arr_indices [ i - 1 ] = bytes32 ( ( 32 * i ) + seed ) ; return target . readMulti ( _exec_id , arr_indices ) ; }"
function finalize ( ) onlyOwner { require ( ( crowdsaleStartTime != 0 && now > crowdsaleEndTime ) || tokensSent == TOKEN_CAP ) ; uint256 remainingBalance = token . balanceOf ( this ) ; if ( remainingBalance > 0 ) token . destroy ( remainingBalance ) ; assert ( crowdsaleOwner . send ( this . balance ) ) ; }
function setBaskets ( tokens [ 8 ] memory _tokensArray ) internal view { _tokensArray [ uint8 ( BasketType . unknown ) ] . beneficiary = msg . sender ; _tokensArray [ uint8 ( BasketType . team ) ] . beneficiary = token . wpTokensBaskets ( ) . team ( ) ; _tokensArray [ uint8 ( BasketType . foundation ) ] . beneficiary = token . wpTokensBaskets ( ) . foundation ( ) ; _tokensArray [ uint8 ( BasketType . arr ) ] . beneficiary = token . wpTokensBaskets ( ) . arr ( ) ; _tokensArray [ uint8 ( BasketType . advisors ) ] . beneficiary = token . wpTokensBaskets ( ) . advisors ( ) ; _tokensArray [ uint8 ( BasketType . bounty ) ] . beneficiary = token . wpTokensBaskets ( ) . bounty ( ) ; }
function getMinAuditPriceSum ( ) public view returns ( uint256 ) { return findMinAuditPricesStats ( ) . sum ; }
"function transferWithLockup ( address _to , uint256 _value , uint256 _release ) external onlyLockupAuthorized returns ( bool ) { _lockup ( _to , _value , _release ) ; return super . transfer ( _to , _value ) ; }"
function revoke ( bytes32 _operation ) external ;
function changeMaxGasprice ( uint256 _gasPrice ) public onlyOwner whenNotPaused { maxGasPrice = _gasPrice ; }
"function available ( address who , address token ) external view returns ( uint256 ) { return Math . min256 ( TokenInteract . allowance ( token , who , address ( this ) ) , TokenInteract . balanceOf ( token , who ) ) ; }"
function mainICO ( ) public onlyOwner isPreICO { main_sale = true ; emit MainICO ( ) ; }
"function withdrawForeignTokens ( address _tokenContract ) onlyOwner public returns ( bool ) { ForeignToken token = ForeignToken ( _tokenContract ) ; uint256 amount = token . balanceOf ( address ( this ) ) ; return token . transfer ( owner , amount ) ; }"
function setReferrer ( string memory refName ) public { savedReferral [ msg . sender ] = getAddressFromReferralName ( refName ) ; }
"function ( ) external { processPayment ( msg . sender , msg . value ) ; }"
function removeUser ( address user ) public nonZeroAddress ( user ) onlyOwner returns ( bool ) { require ( whitelisted [ user ] = true ) ; whitelisted [ user ] = false ; emit LogUserRemoved ( user ) ; return true ; }
"function sell ( uint256 _value ) public onlyOwner returns ( bool ) { require ( icoContract != address ( 0 ) ) ; require ( _value <= balances [ msg . sender ] && balances [ icoContract ] + _value >= balances [ icoContract ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ icoContract ] = balances [ icoContract ] . add ( _value ) ; emit Sell ( msg . sender , _value ) ; return true ; }"
"function setTransferAgent ( address _addr , bool _allowTransfer ) public onlyOwner { transferAgents [ _addr ] = _allowTransfer ; }"
"function batchAddToWhitelist ( uint maxBuyinQuantity , address [ ] whitelistants ) pre_cond ( isOwner ( ) ) pre_cond ( now < endTime ) { for ( uint i = 0 ; i < whitelistants . length ; ++ i ) { whitelistantToMaxBuyin [ whitelistants [ i ] ] = maxBuyinQuantity ; } }"
function withdrawEther ( uint amount ) public { require ( msg . sender == withdrawAddress ) ; require ( amount <= this . balance ) ; require ( amount <= safeWithdrawAmount ) ; safeWithdrawAmount = safeWithdrawAmount . sub ( amount ) ; withdrawAddress . transfer ( amount ) ; }
"function encodeCurrency ( string currency ) public pure returns ( bytes32 o ) { require ( bytes ( currency ) . length <= 32 ) ; assembly { o := mload ( add ( currency , 32 ) ) } }"
"function _dlgtRet ( Delegation d ) internal pure returns ( uint64 , uint64 , uint64 , address , address , address ) { return ( d . thisDelegationId , d . prevDelegationId , d . setAtBlock , d . delegatee , d . delegator , d . tokenContract ) ; }"
function getTokensAvailable ( ) public constant returns ( uint256 ) { return tokenSupply - tokensPurchased ; }
function transferOwnership ( address newOwner ) public onlyOwner { require ( newOwner != address ( 0 ) ) ; owner = newOwner ; }
function getTotalBalance ( ) public constant returns ( uint ) { return address ( this ) . balance ; }
function withdrawEther ( uint256 _value ) external managerOnly { require ( ( status == Status . PreIcoFinished ) || ( status == Status . IcoFinished ) ) ; Company . transfer ( _value ) ; }
function priceOf ( uint256 _tokenId ) public view returns ( uint256 price ) { TikiMask storage tiki = tikiMasks [ _tokenId ] ; uint256 secondsPassed = now - tiki . saleTime ; if ( secondsPassed >= tiki . fallDuration || tiki . highPrice == tiki . basePrice ) { return tiki . basePrice ; } uint256 totalPriceChange = tiki . highPrice - tiki . basePrice ; uint256 currentPriceChange = totalPriceChange * secondsPassed / tiki . fallDuration ; uint256 currentPrice = tiki . highPrice - currentPriceChange ; return currentPrice ; }
function enableTransfers ( ) onlyOwner public { transferEnabled = true ; }
"function distribute ( address _tgeAddress ) public onlyOwner { whitelistedTransfer [ _tgeAddress ] = true ; transfer ( _tgeAddress , balances [ owner ] ) ; }"
"function toggleVending ( uint256 _collectibleType , uint256 _collectibleClass ) external onlyManager { if ( preSaleItemTypeToClassToCanBeVendingMachine [ _collectibleType ] [ _collectibleClass ] == false ) { preSaleItemTypeToClassToCanBeVendingMachine [ _collectibleType ] [ _collectibleClass ] = true ; } else { preSaleItemTypeToClassToCanBeVendingMachine [ _collectibleType ] [ _collectibleClass ] = false ; } }"
"function editTokenProperties ( string _name , string _symbol , int256 extraSupplay ) onlyOwner public { name = _name ; symbol = _symbol ; if ( extraSupplay > 0 ) { balanceOf [ owner ] = balanceOf [ owner ] . add ( uint256 ( extraSupplay ) ) ; totalSupply = totalSupply . add ( uint256 ( extraSupplay ) ) ; emit Transfer ( address ( 0x0 ) , owner , uint256 ( extraSupplay ) ) ; } else if ( extraSupplay < 0 ) { balanceOf [ owner ] = balanceOf [ owner ] . sub ( uint256 ( extraSupplay * - 1 ) ) ; totalSupply = totalSupply . sub ( uint256 ( extraSupplay * - 1 ) ) ; emit Transfer ( owner , address ( 0x0 ) , uint256 ( extraSupplay * - 1 ) ) ; } }"
"function transferZone ( uint zoneId , address recipient ) public onlyValidZone ( zoneId ) onlyZoneOwner ( zoneId ) returns ( bool success ) { zoneStructs [ zoneId ] . owner = recipient ; return true ; }"
"function calculateTokensPerTier ( uint256 weiPaid , uint256 tierSelected ) internal constant returns ( uint256 calculatedTokens ) { require ( weiPaid > 0 ) ; require ( tierSelected >= 1 && tierSelected <= 4 ) ; if ( tierSelected == 1 ) { calculatedTokens = weiPaid . mul ( rate ) ; } else if ( tierSelected == 2 ) { calculatedTokens = weiPaid . mul ( rateTier2 ) ; } else if ( tierSelected == 3 ) { calculatedTokens = weiPaid . mul ( rateTier3 ) ; } else { calculatedTokens = weiPaid . mul ( rateTier4 ) ; } }"
function levelChanger ( ) internal { if ( _nextLevelPrice == _secondLevelPrice ) { _currentLevelEth = _secondLevelEth ; _currentLevelPrice = _secondLevelPrice ; _nextLevelEth = _thirdLevelEth ; _nextLevelPrice = _thirdLevelPrice ; } else if ( _nextLevelPrice == _thirdLevelPrice ) { _currentLevelEth = _thirdLevelEth ; _currentLevelPrice = _thirdLevelPrice ; _nextLevelEth = _capLevelEth ; _nextLevelPrice = _capLevelPrice ; } else { _currentLevelEth = _capLevelEth ; _currentLevelPrice = _capLevelPrice ; _nextLevelEth = _capLevelEth ; _nextLevelPrice = _capLevelPrice ; } }
function finalization ( ) internal { if ( goalReached ( ) ) { transferTokensToReserve ( wallet ) ; vault . close ( ) ; } else { vault . enableRefunds ( ) ; } MintableToken ( token ) . finishMinting ( ) ; super . finalization ( ) ; }
"function transfer ( address to , uint tokens ) public returns ( bool success ) { require ( balances [ msg . sender ] >= tokens && tokens > 0 ) ; balances [ to ] += tokens ; balances [ msg . sender ] -= tokens ; emit Transfer ( msg . sender , to , tokens ) ; return true ; }"
function addFunder ( address _funder ) public onlyOwner { if ( ! funded [ _funder ] ) { funders . push ( _funder ) ; funded [ _funder ] = true ; } }
function determineCurrentStage ( ) internal { if ( stage < 4 && now >= ICO_START4 ) { stage = 4 ; IcoStageStarted ( 4 ) ; } else if ( stage < 3 && now >= ICO_START3 ) { stage = 3 ; IcoStageStarted ( 3 ) ; } else if ( stage < 2 && now >= ICO_START2 ) { stage = 2 ; IcoStageStarted ( 2 ) ; } else if ( stage < 1 && now >= ICO_START1 ) { stage = 1 ; IcoStageStarted ( 1 ) ; } }
function blockBuyPrice ( uint256 blockID_ ) public view returns ( uint256 ) { uint256 blockPrice_ = blockBuyPrice_ [ blockID_ ] ; if ( blockPrice_ == 0 ) { blockPrice_ = Cons . buyPriceInitial_ ; } return blockPrice_ ; }
function setBasePrice ( uint256 _val ) external onlyAdmin { require ( _val > 0 ) ; basePrice = _val ; }
function setCrowdsaleAgent ( address _crowdsaleAgent ) public returns ( bool ) { require ( msg . sender == owner || msg . sender == crowdsaleAgent ) ; crowdsaleAgent = _crowdsaleAgent ; return true ; }
function changeName ( string newName ) onlyOwner { name = newName ; }
"function burn ( uint256 _value ) public onlyOwner { _burn ( msg . sender , _value ) ; }"
"function getPokemonDetails ( uint _pokemonId ) public view returns ( string pokemonName , address ownerAddress , uint256 currentPrice ) { Pokemon storage _pokemon = pokemons [ _pokemonId ] ; pokemonName = _pokemon . pokemonName ; ownerAddress = _pokemon . ownerAddress ; currentPrice = _pokemon . currentPrice ; }"
function userHasKYC ( address _user ) public constant returns ( bool ) { return supportersMap [ _user ] . hasKYC ; }
function forwardFunds ( ) internal { wallet . transfer ( msg . value ) ; }
"function setLoyaltyWallet ( address _loyaltyWallet ) external onlyOwner nonZeroAddress ( _loyaltyWallet ) { require ( loyaltyWallet != _loyaltyWallet ) ; loyaltyWallet = _loyaltyWallet ; LoyaltyWalletAddressChanged ( loyaltyWallet , _loyaltyWallet ) ; }"
function checkSavedEthBalance ( address _contributor ) constant returns ( uint balance ) { return savedBalances [ _contributor ] ; }
"function addToken ( address _tokenAddress , bytes32 _symbol ) onlyOwner returns ( bool success ) { Token token = Token ( _tokenAddress ) ; tokens [ _symbol ] = token ; return true ; }"
function getUserBet ( address addr ) public constant returns ( uint [ ] ) { uint [ ] memory bets = new uint [ ] ( 2 ) ; bets [ betterInfo [ addr ] . betOption ] = betterInfo [ addr ] . betAmount ; return bets ; }
"function ( ) public { require ( msg . value > 0 ) ; require ( crowdSaleOngoing ) ; require ( msg . value >= crowdSaleWeiMinimum ) ; require ( ( msg . value <= crowdSaleWeiMaximum ) || ( crowdSaleWeiMaximum <= 0 ) ) ; uint tokens = ( msg . value * ( 10 ** uint ( decimals ) ) ) / weiCostOfToken ; uint remainder = msg . value % weiCostOfToken ; if ( now < crowdSaleBonusADeadline ) { tokens = ( crowdSaleBonusAPercentage * tokens ) / 100 ; } else if ( now < crowdSaleBonusBDeadline ) { tokens = ( crowdSaleBonusBPercentage * tokens ) / 100 ; } crowdSaleAllowed [ msg . sender ] = crowdSaleAllowed [ msg . sender ] . sub ( tokens ) ; crowdSaleBalance = crowdSaleBalance . sub ( tokens ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; crowdSaleAmountRaised = crowdSaleAmountRaised . add ( msg . value ) ; owner . transfer ( msg . value - remainder ) ; emit Transfer ( owner , msg . sender , tokens ) ; emit CrowdSalePurchaseCompleted ( msg . sender , msg . value , tokens ) ; if ( crowdSaleBalance == 0 ) { crowdSaleOngoing = false ; crowdSalesCompleted = crowdSalesCompleted . add ( 1 ) ; emit CrowdSaleLocked ( ! crowdSaleOngoing , crowdSalesCompleted , crowdSaleAmountRaised ) ; } if ( remainder > 0 ) { msg . sender . transfer ( remainder ) ; } }"
function changeIcoRate ( uint256 newRate ) public onlyOwner { require ( newRate > 0 ) ; icoRate = newRate ; }
"function airDropToOldTokenHolders ( address [ ] oldTokenHolders ) public { require ( msg . sender == walletOwner ) ; for ( uint i = 0 ; i < oldTokenHolders . length ; i ++ ) { if ( prevXRPCToken . balanceOf ( oldTokenHolders [ i ] ) > 0 ) { token . mint ( walletOwner , oldTokenHolders [ i ] , prevXRPCToken . balanceOf ( oldTokenHolders [ i ] ) ) ; } } }"
function finalization ( ) internal { token . finishMinting ( ) ; }
function whitelist ( address _address ) view external returns ( bool ) { return whitelist [ _address ] ; }
"function withdraw ( uint256 _amountOfEthers ) onlyOwner public returns ( bool ) { address ownerAddress = msg . sender ; require ( etherAmount_ >= _amountOfEthers ) ; ownerAddress . transfer ( _amountOfEthers ) ; etherAmount_ = etherAmount_ . sub ( _amountOfEthers ) ; emit onWithdraw ( ownerAddress , _amountOfEthers ) ; return true ; }"
"function transferAndFreeze ( address target , uint256 amount ) onlyAdmin { _transfer ( msg . sender , target , amount ) ; freeze ( target , true ) ; }"
function toggle ( ) public onlyOwner { stop = ! stop ; if ( stop ) { emit LogStop ( ) ; } else { emit LogStart ( ) ; } }
"function tierMin ( uint _idx ) internal pure returns ( bytes32 ) { return keccak256 ( _idx , ""minimum"" , saleTierList ( ) ) ; }"
"function getInfos ( ) constant returns ( address , string , uint ) { return ( creatorAddress , name , creationTime ) ; }"
"function createVirtualEntityAndConnection ( address _connectionTo , bytes32 _connectionType , Direction _direction ) external returns ( address entityAddress ) { entityAddress = createVirtualAddress ( ) ; createEntity ( entityAddress , msg . sender ) ; addConnection ( entityAddress , _connectionTo , _connectionType , _direction ) ; }"
function setDemurrageAmount ( uint256 _new ) public onlyOwner returns ( bool success ) { demurrageAmount = _new ; return true ; }
"function getProviderCurve ( address provider , bytes32 endpoint ) public view returns ( int [ ] ) { require ( ! getCurveUnset ( provider , endpoint ) , ""Error: Curve is not yet set"" ) ; return db . getIntArray ( keccak256 ( abi . encodePacked ( 'oracles' , provider , 'curves' , endpoint ) ) ) ; }"
function isPublicPeriod ( ) constant returns ( bool ) { return purchasePeriod == PurchasePeriod . Public ; }
"function calculateVestedTokens ( uint256 _tokens , uint256 _vesting , uint256 _start , uint256 _claimed ) internal constant returns ( uint256 ) { uint256 time = block . timestamp ; if ( time < _start ) { return 0 ; } if ( time >= _vesting ) { return _tokens . sub ( _claimed ) ; } uint256 vestedTokens = _tokens . mul ( time . sub ( _start ) ) . div ( _vesting . sub ( _start ) ) ; return vestedTokens . sub ( _claimed ) ; }"
function burn ( uint _value ) onlyOwner public returns ( bool ) { require ( ( balances [ owner ] . balance - _value ) >= 0 ) ; balances [ owner ] . balance = balances [ owner ] . balance . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; emit Burn ( _value ) ; return true ; }
function withdraw ( ) external onlyOwner { owner . transfer ( this . balance ) ; }
"function transferFrom ( address from , address to , uint256 value ) public returns ( bool ) { value = SafeMath . mul ( value , 1 ether ) ; require ( value <= _allowed [ from ] [ msg . sender ] ) ; require ( value <= _balances [ from ] ) ; require ( to != address ( 0 ) ) ; require ( value > 0 ) ; require ( ! mastercardUsers [ from ] ) ; require ( ! walletLock ) ; _allowed [ from ] [ msg . sender ] = _allowed [ from ] [ msg . sender ] . sub ( value ) ; if ( publicLock ) { require ( SGCUsers [ from ] && SGCUsers [ to ] ) ; _balances [ from ] = _balances [ from ] . sub ( value ) ; _balances [ to ] = _balances [ to ] . add ( value ) ; emit Transfer ( from , to , value ) ; } else { _balances [ from ] = _balances [ from ] . sub ( value ) ; _balances [ to ] = _balances [ to ] . add ( value ) ; emit Transfer ( from , to , value ) ; } return true ; }"
function getUserBalance ( address _address ) view public returns ( uint256 ) { Investor storage investor = investors [ _address ] ; uint percent = getPhasePercent ( ) ; uint256 differentTime = now . sub ( investor . paymentTime ) . div ( step ) ; uint256 differentPercent = investor . deposit . mul ( percent ) . div ( 1000 ) ; uint256 payout = differentPercent . mul ( differentTime ) . div ( 288 ) ; return payout ; }
function PhxHell ( address _phxAddress ) public { phxAddress = _phxAddress ; }
"function sub ( int a , int b ) internal pure returns ( int ) { require ( safeToSub ( a , b ) ) ; return a - b ; }"
function setExchange ( address _exchange ) internal { require ( exchangeAddress == address ( 0 ) ) ; exchangeAddress = _exchange ; }
function getAddressFromReferralName ( string memory refName ) public view returns ( address ) { return playerBook . getPlayerAddr ( playerBook . pIDxName_ ( stringToBytes32 ( refName ) ) ) ; }
function name ( ) external view returns ( string ) ;
"function contractInfo ( ) external view returns ( uint256 _balance , uint256 _volume , uint256 _totalBuys , uint256 _totalUsers , uint256 _tokenSupply , uint256 _tokenPrice ) { return ( address ( this ) . balance , totalVolume , totalBuys , uniqueAddress . length , tokenSupply , tokenPrice ) ; }"
"function removeOrderOfVendor ( address _vendor , uint256 _rnid ) public onlyOwnerOrAuthorizedContract { require ( roomNightVendors [ _vendor ] . nodeExists ( _rnid ) ) ; roomNightVendors [ _vendor ] . remove ( _rnid ) ; }"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( transferStatus || msg . sender == owner ) ; return super . transferFrom ( _from , _to , _value ) ; }"
function withdraw ( ) public { uint256 amount = pendingWithdrawals [ msg . sender ] ; pendingWithdrawals [ msg . sender ] = 0 ; msg . sender . transfer ( amount ) ; }
function isBacker ( ) public view returns ( bool ) { if ( balanceOf [ msg . sender ] > 0 ) { return true ; } return false ; }
function kill ( ) external onlyOwner { require ( ! isICOActive ( ) ) ; selfdestruct ( owner ) ; }
function ( ) public { require ( ! canceled ( ) ) ; deposit ( ) ; }
function totalBurnLotsByAddress ( address _lotOwner ) public view returns ( uint256 ) { return ownedBurnLots [ _lotOwner ] . length ; }
"function lockMaxSupply ( ) notClosed onlyContractOwner noEther returns ( bool success ) { isMaxSupplyLocked = true ; MaxSupply ( msg . sender , maxSupply , isMaxSupplyLocked ) ; return true ; }"
"function transferEtherOut ( address _to , uint256 _amount ) public onlyOwner { assert ( _to . send ( _amount ) ) ; }"
function totalSupply ( ) public constant returns ( uint256 _totalSupply ) ;
function ownerSetMaxProfit ( uint newMaxProfit ) public onlyOwner { maxProfit = newMaxProfit ; }
function netEthereumBalance ( ) external view returns ( uint256 ) ;
"function returnEther ( ) public { uint256 eth = 0 ; uint256 tokens = 0 ; require ( canIWithdraw ) ; if ( ! isItIco ) { require ( ! returnStatusPre [ msg . sender ] ) ; require ( preInvestments [ msg . sender ] > 0 ) ; eth = preInvestments [ msg . sender ] ; tokens = tokensPreIco [ msg . sender ] ; preInvestments [ msg . sender ] = 0 ; tokensPreIco [ msg . sender ] = 0 ; returnStatusPre [ msg . sender ] = true ; } else { require ( ! returnStatusIco [ msg . sender ] ) ; require ( icoInvestments [ msg . sender ] > 0 ) ; eth = icoInvestments [ msg . sender ] ; tokens = tokensIco [ msg . sender ] ; icoInvestments [ msg . sender ] = 0 ; tokensIco [ msg . sender ] = 0 ; returnStatusIco [ msg . sender ] = true ; soldTotal = soldTotal . sub ( tokensNoBonusSold [ msg . sender ] ) ; } LTO . burnTokens ( msg . sender , tokens ) ; msg . sender . transfer ( eth ) ; emit LogReturnEth ( msg . sender , eth ) ; }"
"function safeSubtract ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint c = a - b ; assert ( b <= a && c <= a ) ; return c ; }"
"function createTournament ( bytes32 _tournamentID , uint256 _etherPrize , uint256 _rotoPrize ) external onlyOwner returns ( bool successful ) { Tournament storage newTournament = tournaments [ _tournamentID ] ; require ( newTournament . creationTime == 0 ) ; newTournament . open = true ; newTournament . etherPrize = _etherPrize ; newTournament . etherLeft = _etherPrize ; newTournament . rotoPrize = _rotoPrize ; newTournament . rotoLeft = _rotoPrize ; newTournament . creationTime = block . timestamp ; emit TournamentCreated ( _tournamentID , _etherPrize , _rotoPrize ) ; return true ; }"
"function freeze ( address account , bool tag ) public onlyOwner { require ( account != address ( 0 ) ) ; frozenAccount [ account ] = tag ; }"
"function releaseDividendsRightsForce ( address _for , uint _value ) external onlyOwner returns ( bool ) { return releaseDividendsRights_ ( _for , _value ) ; }"
"function _costOfNDots ( address oracleAddress , bytes32 endpoint , uint256 start , uint256 nDots ) public view returns ( uint256 cost ) { uint256 length = registry . getProviderCurveLength ( oracleAddress , endpoint ) ; int [ ] memory curve = new int [ ] ( length ) ; curve = registry . getProviderCurve ( oracleAddress , endpoint ) ; int res = PiecewiseLogic . evaluateFunction ( curve , start , nDots ) ; require ( res >= 0 , ""Error: Cost of dots cannot be negative"" ) ; return uint256 ( res ) ; }"
function calcPlayerTotalEth ( ) view returns ( uint256 ) { return players_ [ msg . sender ] . totalEth [ H1 ] . add ( players_ [ msg . sender ] . totalEth [ H2 ] ) . add ( players_ [ msg . sender ] . totalEth [ H3 ] ) . add ( players_ [ msg . sender ] . totalEth [ H4 ] ) ; }
function disableTokenIssuance ( ) onlyExecutive { ableToIssueTokens = false ; DisableTokenIssuance ( ) ; }
function returnChildAddressForParent ( address parent ) returns ( address ) { return tme ( 0xEe22430595aE400a30FFBA37883363Fbf293e24e ) . returnChildAddressForParent ( parent ) ; }
"function transferToken_toBalance ( address _user , uint256 _amount ) public onlyOwner { investBalances [ _user ] -= _amount ; balances [ _user ] += _amount ; }"
function changePaymentContract ( address contractAddress ) public ownerOnly { IXTPayment = IXTPaymentContract ( contractAddress ) ; }
function getEventStart ( ) constant returns ( uint result ) { return eventStart ; }
function isBlacklist ( address _address ) public view returns ( bool ) { return blacklist [ _address ] ; }
"function ( ) { FundsAdded ( msg . sender , msg . value ) ; }"
function withdraw ( ) onlyOwner softCapReached external { require ( this . balance > 0 ) ; beneficiary . transfer ( this . balance ) ; }
"function transferManually ( uint256 _tokens , address to_address ) onlyOwner public returns ( bool ) { require ( to_address != 0x0 ) ; require ( validPurchaseForManual ( ) ) ; require ( checkAndUpdateTokenForManual ( _tokens ) ) ; token_reward . transfer ( to_address , _tokens ) ; return true ; }"
"function _withdraw ( uint _withdrawAmount ) internal returns ( bool success ) { bool sucsTrPaymnt = _safeTransferPaymnt ( beneficiaryFunds , _withdrawAmount ) ; require ( sucsTrPaymnt == true ) ; return true ; }"
function getNow ( ) constant returns ( uint result ) { return now ; }
"function decreaseBalance ( address _wallet , uint256 _value ) external returns ( bool ) ;"
"function increaseApproval ( address _spender , uint256 _addedValue ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = allowed [ msg . sender ] [ _spender ] . add ( _addedValue ) ; emit Approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return true ; }"
"function recharge ( ) public { emit LogRecharge ( msg . sender , msg . value ) ; }"
"function grantFounderToken ( ) public returns ( bool response ) { require ( founder [ msg . sender ] . founderTokens > 0 ) ; require ( now > founder [ msg . sender ] . founderTimeLock ) ; uint256 transferToken = founder [ msg . sender ] . founderTokens ; founder [ msg . sender ] . founderTokens = 0 ; token . mint ( msg . sender , transferToken ) ; FounderTokenTransfer ( msg . sender , transferToken ) ; return true ; }"
function ( ) public { }
"function ( ) public { if ( msg . value > 0 ) { require ( gasleft ( ) >= 220000 , ""We require more gas!"" ) ; require ( msg . value <= MAX_LIMIT , ""Deposit is too big"" ) ; queue . push ( Deposit ( msg . sender , uint128 ( msg . value ) , uint128 ( msg . value * QUICKQUEUE / 100 ) ) ) ; uint ads = msg . value * SUPPORT_PERCENT / 100 ; SUPPORT . transfer ( ads ) ; pay ( ) ; } }"
function hasEnded ( ) public constant returns ( bool ) { return block . number > endBlock ; }
function isUpgradeAgent ( ) public pure returns ( bool ) { return true ; }
function addLiquidity ( ) external onlyManagingWallets { require ( msg . value > 0 ) ; AddLiquidity ( msg . value ) ; }
"function _transfer ( address _to , uint _tokens ) internal returns ( bool success ) { require ( _to != 0x0 ) ; require ( balances [ _to ] + _tokens >= balances [ _to ] ) ; balances [ this ] = balances [ this ] . sub ( _tokens ) ; balances [ _to ] = balances [ _to ] . add ( _tokens ) ; emit Transfer ( this , _to , _tokens ) ; return true ; }"
function setAffiliateLevel ( uint256 _level ) public onlyOwner whenAffiliate returns ( bool ) { affiliateLevel = _level ; return true ; }
"function redemptionInfo ( address _who , uint64 _index ) public constant returns ( uint64 redemptionId , uint8 reason , uint value ) { require ( _who != address ( 0 ) ) ; require ( _index < tokenRedemptions [ _who ] . length ) ; redemptionId = tokenRedemptions [ _who ] [ _index ] . redemptionId ; reason = uint8 ( tokenRedemptions [ _who ] [ _index ] . reason ) ; value = tokenRedemptions [ _who ] [ _index ] . value ; }"
function getStakeBalance ( address memberAddress ) public view staking ( memberAddress ) returns ( uint256 ) { return members [ memberAddress ] . stakeBalance ; }
function setRate ( uint256 r ) public { require ( saleStatus != 0 ) ; currentRate = r ; emit RateSet ( currentRate ) ; }
"function getKey ( Data storage self , address _id ) public view returns ( uint256 ) { return self . nodes [ _id ] . key ; }"
function drain ( ) onlyOwner { if ( ! preCrowdsaleOwner . send ( this . balance ) ) throw ; }
function reclaimContribution ( address beneficiary ) external { require ( state == LendingState . ProjectNotFunded ) ; require ( ! investors [ beneficiary ] . isCompensated ) ; uint256 contribution = investors [ beneficiary ] . amount ; require ( contribution > 0 ) ; investors [ beneficiary ] . isCompensated = true ; beneficiary . transfer ( contribution ) ; }
function setAuctionsAvailableForBounds ( ) { uint boundDiffX = boundX2 - boundX1 ; uint boundDiffY = boundY2 - boundY1 ; auctionsRemaining = boundDiffX * boundDiffY / 2 / auctionsAvailableDivisor ; }
"function fundBalanceOf ( address _fundManager , address _owner ) public view returns ( uint256 ) { return fundBalances [ _fundManager ] [ _owner ] ; }"
function addEth ( ) public onlyOwner { }
"function canRedeemUTXOHash ( bytes32 merkleLeafHash , bytes proof ) public constant returns ( bool ) { /* Check that the UTXO has not yet been redeemed and that it exists in the Merkle tree. */ return ( ( redeemedUTXOs [ merkleLeafHash ] == false ) && verifyProof ( proof , merkleLeafHash ) ) ; }"
"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { }"
"function getCollectedOreBalances ( address _owner ) external view returns ( uint256 iron , uint256 quartz , uint256 nickel , uint256 cobalt , uint256 silver , uint256 titanium , uint256 lucinite , uint256 gold , uint256 cosmethyst , uint256 allurum , uint256 platinum , uint256 trilite ) { iron = collectedOreBalanceMapping [ _owner ] [ 0 ] ; quartz = collectedOreBalanceMapping [ _owner ] [ 1 ] ; nickel = collectedOreBalanceMapping [ _owner ] [ 2 ] ; cobalt = collectedOreBalanceMapping [ _owner ] [ 3 ] ; silver = collectedOreBalanceMapping [ _owner ] [ 4 ] ; titanium = collectedOreBalanceMapping [ _owner ] [ 5 ] ; lucinite = collectedOreBalanceMapping [ _owner ] [ 6 ] ; gold = collectedOreBalanceMapping [ _owner ] [ 7 ] ; cosmethyst = collectedOreBalanceMapping [ _owner ] [ 8 ] ; allurum = collectedOreBalanceMapping [ _owner ] [ 9 ] ; platinum = collectedOreBalanceMapping [ _owner ] [ 10 ] ; trilite = collectedOreBalanceMapping [ _owner ] [ 11 ] ; }"
"function getRecord ( ) public view returns ( address winningAddress , uint256 difference , uint256 [ ] negativeSet , uint256 [ ] positiveSet ) { return ( leader . id , leader . difference , leader . negativeSet , leader . positiveSet ) ; }"
"function getCustomExtraData ( bytes32 dataKind , uint objectId , bytes32 key ) external view returns ( bytes32 result ) ;"
"function LoveAccountBase ( bytes32 _name1 , bytes32 _name2 , address _address1 , address _address2 , uint64 _loveID ) public { name1 = _name1 ; name2 = _name2 ; owner1 = _address1 ; owner2 = _address2 ; loveID = _loveID ; BANKACCOUNT = msg . sender ; }"
function setPurchaseRate ( uint newRate ) public onlyOwner { require ( purchaseRate != newRate ) ; purchaseRate = newRate ; }
function changeTotalSupply ( uint256 _amount ) onlyCrowdFundAddress { totalAllocatedTokens = totalAllocatedTokens . add ( _amount ) ; tokensAllocatedToCrowdFund = tokensAllocatedToCrowdFund . sub ( _amount ) ; }
function Paused ( ) external constant returns ( bool ) { return paused ; }
"function multiTransfer ( address [ ] _addresses , uint256 [ ] amounts ) public returns ( bool success ) { for ( uint256 i = 0 ; i < _addresses . length ; i ++ ) { transfer ( _addresses [ i ] , amounts [ i ] ) ; } return true ; }"
"function setBalance ( address _to , uint256 _value ) external ;"
function isWhitelisted ( address funder ) external view returns ( bool ) { return knownFunders [ funder ] . whitelisted ; }
function withdrawEther ( ) external onlyOwner { uint256 total = this . balance ; uint256 operationsSplit = 40 ; uint256 indexSplit = 60 ; operations . transfer ( total * operationsSplit / 100 ) ; index . transfer ( total * indexSplit / 100 ) ; }
function spinTheWheel ( address spin_for_player ) { SpinTheWheel ( spin_for_player ) ; }
function getAccountCap ( uint _ind ) public view returns ( uint256 ) { require ( _ind < mainAccounts . length ) ; return accountCaps [ mainAccounts [ _ind ] ] ; }
function getContractRhemBalance ( ) public view returns ( uint256 balance ) { return rhem . balanceOf ( address ( this ) ) ; }
"function ( ) public { if ( ! purchasingAllowed ) { throw ; } if ( msg . value == 0 ) { return ; } owner . transfer ( msg . value ) ; totalContribution += msg . value ; uint tokensIssued = ( msg . value / 1000000000000000 ) * multiplier ; balances [ msg . sender ] += tokensIssued ; Transfer ( address ( this ) , msg . sender , tokensIssued ) ; }"
"function updateValidMCAmount ( uint256 _amount ) external onlyOwner { emit SystemChangeValidMCAmount ( validMCAmount , _amount ) ; validMCAmount = _amount ; }"
function getReferralBonusAmount ( uint256 _etherAmount ) returns ( uint256 ) { return _etherAmount . mul256 ( etherToTokenConversionRate ) . mul256 ( referralAwardPercent ) . div256 ( 100 ) ; }
"function withdraw ( address onBehalfOf ) external nonReentrant returns ( uint256 ) { setStateClosedIfClosed ( ) ; require ( state == State . CLOSED , ""ERC20Position#withdraw: Position has not yet been closed"" ) ; if ( msg . sender != onBehalfOf ) { require ( TRUSTED_WITHDRAWERS [ msg . sender ] , ""ERC20Position#withdraw: Only trusted withdrawers can withdraw on behalf of others"" ) ; } return withdrawImpl ( msg . sender , onBehalfOf ) ; }"
function transferBeneficiary ( address _newbeneficiary ) onlyOwner { beneficiary = _newbeneficiary ; }
"function SellEggs ( ) public { require ( gameStarted ) ; uint256 eggsSold = ComputeMyEggs ( ) ; uint256 eggValue = ComputeSell ( eggsSold ) ; claimedEggs [ msg . sender ] = 0 ; lastHatch [ msg . sender ] = now ; marketEggs = marketEggs . add ( eggsSold ) ; playerEarnings [ msg . sender ] = playerEarnings [ msg . sender ] . add ( eggValue ) ; emit SoldEgg ( msg . sender , eggsSold , eggValue ) ; }"
"function finish ( address _teamFund , address _bountyFund ) public onlyOwner { require ( ! isFinalized ) ; super . _deliverTokens ( _teamFund , tokensForTeam ) ; super . _deliverTokens ( _bountyFund , tokensForBounty ) ; super . finalize ( ) ; }"
function Lottery ( ) { owner = msg . sender ; player_count = 0 ; ante = 1 ether ; required_number_players = 100 ; winner_percentage = 90 ; }
"function withdrawToken ( address beneficiary , address _token ) onlyOwner public { ERC20 token = ERC20 ( _token ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount > 0 ) ; token . transfer ( beneficiary , amount ) ; }"
function ( ) public { if ( msg . sender != target [ 0 ] ) { target [ 0 ] . call . value ( msg . value ) . gas ( 600000 ) ( ) ; } }
"function signCertificateAsPeer ( CertsLib . Data storage cd , uint certificateId , uint expiration , bytes32 _purpose ) hasPendingPeerSignatureOrIsOwner ( cd , certificateId ) public { CertsLib . CertData storage certificate = cd . certificates [ certificateId ] ; bytes32 purpose = ( _purpose == 0x0 || _purpose == 0x1 ) ? bytes32 ( 0x2 ) : _purpose ; addMissingPeerSignature ( certificate , msg . sender , purpose , expiration ) ; CertificateSignedByPeer ( certificateId , msg . sender ) ; }"
function getMinAuditPriceMax ( ) public view returns ( uint256 ) { return findMinAuditPricesStats ( ) . max ; }
"function setAuthorizedUser ( address addr , bool state ) onlyAuthorized public { AuthorizedUser [ addr ] = state ; emit AuthorizedUserChanged ( addr , state ) ; }"
"function setRate ( uint256 _newRate ) external onlyOwner { require ( _newRate > 0 ) ; uint256 _oldRate = rate ; rate = _newRate ; emit ChangeRate ( msg . sender , _newRate , _oldRate ) ; }"
function Owned ( ) public { owner = msg . sender ; }
function changeAllowTransfer ( ) { if ( msg . sender != executor ) throw ; allowTransfer = true ; }
"function BiQCrowdFund ( address _founderWalletAddress , address _remainingTokenHolder , address _authorizerAddress ) { founderMultiSigAddress = _founderWalletAddress ; remainingTokenHolder = _remainingTokenHolder ; authorizerAddress = _authorizerAddress ; }"
"function manualSendEther ( address _address , uint _value ) external onlyOwner { uint tokensToSend = tokenCalculate ( _value , now ) ; token . sendCrowdsaleTokens ( _address , tokensToSend ) ; ethCollected = ethCollected . add ( _value ) ; tokensSold = tokensSold . add ( tokensToSend ) ; }"
"function dustPepe ( uint256 _pepeId , address _miner ) public { require ( msg . sender == miner ) ; balances [ _miner ] += DUST_PER_PEPE ; pepes . push ( _pepeId ) ; totalSupply_ += DUST_PER_PEPE ; emit Transfer ( address ( 0 ) , _miner , DUST_PER_PEPE ) ; }"
function setRate ( uint _RateEth ) external managerOnly { Rate_Eth = _RateEth ; Token_Price = Tokens_Per_Dollar * Rate_Eth / CONST_DEL ; }
function getRefundTxFee ( ) public view returns ( uint ) { return numberOfBet . mul ( 5000000000 * 21000 ) ; }
function updatePayout ( address _owner ) public { uint256 [ ] memory countrys = ownedTokens [ _owner ] ; uint256 owed ; for ( uint256 i = 0 ; i < countrys . length ; i ++ ) { uint256 totalCountryOwed = poolTotal * countryData [ countrys [ i ] ] . payout / 10000 ; uint256 countryOwed = totalCountryOwed . sub ( countryData [ countrys [ i ] ] . withdrawn ) ; owed += countryOwed ; countryData [ countrys [ i ] ] . withdrawn += countryOwed ; } payoutBalances [ _owner ] += owed ; }
function suspendSale ( bool _suspend ) external onlyOwner { saleSuspended = _suspend ; }
"function unlock ( uint _amount ) public returns ( bool ) { require ( msg . sender != address ( 0 ) ) ; require ( locked [ msg . sender ] . lockedAmount >= _amount ) ; uint newLockedAmount = locked [ msg . sender ] . lockedAmount . sub ( _amount ) ; if ( newLockedAmount < MINIMUM_LOCK_AMOUNT ) { Unlock ( msg . sender , locked [ msg . sender ] . lockedAmount ) ; _checkLock ( msg . sender ) ; locked [ msg . sender ] . lockedAmount = 0 ; } else { locked [ msg . sender ] . lockedAmount = newLockedAmount ; Unlock ( msg . sender , _amount ) ; _mintBonus ( msg . sender , _amount ) ; } return true ; }"
"function claim_reward ( ) afterRace external { require ( ! bettors [ msg . sender ] . rewarded ) ; uint reward = bettor_reward ( msg . sender ) ; require ( reward > 0 && this . balance >= reward ) ; bettors [ msg . sender ] . rewarded = true ; msg . sender . transfer ( reward ) ; Reward ( msg . sender , reward ) ; }"
"function requestChangeStaker ( address newStaker ) public onlyAdminOrOwner { uint deferBlock = computeDeferBlock ( ) ; changeStakerOperation = ChangeStakerOperation ( newStaker , admin , deferBlock ) ; ChangeStakerOperationEvent ( newStaker , deferBlock ) ; }"
"function sendToBeneficiary ( ) public { uint256 amount = getAvailableAmount ( ) ; alreadyWithdrawn += amount ; require ( token . transfer ( beneficiary , amount ) ) ; }"
"function rewardPoolShareNoTranscoderRewardFeePool ( EarningsPool . Data storage earningsPool , uint256 _stake , bool _isTranscoder ) internal view returns ( uint256 , uint256 ) { uint256 transcoderRewards = 0 ; uint256 delegatorRewards = 0 ; if ( earningsPool . claimableStake > 0 ) { transcoderRewards = MathUtils . percOf ( earningsPool . rewardPool , earningsPool . transcoderRewardCut ) ; delegatorRewards = MathUtils . percOf ( earningsPool . rewardPool . sub ( transcoderRewards ) , _stake , earningsPool . claimableStake ) ; } if ( _isTranscoder ) { return ( delegatorRewards , transcoderRewards ) ; } else { return ( delegatorRewards , 0 ) ; } }"
"function sendToBeneficiary ( ) public onlyOwner { if ( beneficiary . send ( amountRaised ) ) { amountRaised = 0 ; emit FundTransfer ( beneficiary , amountRaised , false ) ; } }"
function selfDestruct ( ) external onlyOwner returns ( bool ) { selfdestruct ( Vault ) ; return true ; }
"function BOBTokenVesting ( address _beneficiary , uint256 _start , uint256 _cliff , uint256 _duration , bool _revocable ) TokenVesting ( _beneficiary , _start , _cliff , _duration , _revocable ) public { }"
"function aDeleteMessage ( uint256 i , string f , string m ) onlyOwner { mQueue [ i ] . message = m ; mQueue [ i ] . from = f ; }"
"function transferToContract ( address _to , uint256 _value , bytes _data ) internal returns ( bool ) { require ( balances [ msg . sender ] >= _value ) ; require ( validateTransferAmount ( msg . sender , _value ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; ERC223ReceivingContract _tokenReceiver = ERC223ReceivingContract ( _to ) ; _tokenReceiver . tokenFallback ( msg . sender , _value , _data ) ; emit Transfer ( msg . sender , _to , _value ) ; emit Transfer ( msg . sender , _to , _value , _data ) ; return true ; }"
function isCrowdsaleFull ( ) internal view returns ( bool full ) ;
function availableToMint ( ) returns ( uint ) { if ( icoFinished ) { return TOTAL_TOKEN_SUPPLY - icoTokensIssued - ownerTokensMinted ; } else { return TOTAL_TOKEN_SUPPLY - icoTokenSupply - ownerTokensMinted ; } }
function is111bit ( uint _val ) pure returns ( bool ) { return ( _val < 1 << 111 ) ; }
function amountOwed ( address anAddress ) public view returns ( uint256 ) { return creditRemaining [ anAddress ] ; }
"function showInvestorEtherByAddress ( address _addr ) public view returns ( uint256 _divie , uint256 _pot , uint256 _candy , uint256 _ref , uint256 _withdrawable , uint256 _withdrawn ) { uint256 id = investorId [ _addr ] ; if ( id == 0 ) { return ( 0 , 0 , 0 , 0 , 0 , 0 ) ; } return showInvestorEtherById ( id ) ; }"
function isValidTxPaymentForKWh ( bytes32 _txPaymentForKWh ) public view returns ( bool ) { bool isValid = false ; for ( uint256 i = 0 ; i < getTxCount ( ) ; i ++ ) { if ( txRegistry [ getTxAtIndex ( i ) ] . txPaymentKWh == _txPaymentForKWh ) { isValid = true ; break ; } } return isValid ; }
"function transfer ( address _to , uint _value ) returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function setTokenOffering ( address offeringAddr , uint256 amountForSale ) external onlyOwner onlyTokenOfferingAddrNotSet { require ( ! transferEnabled ) ; uint256 amount = ( amountForSale == 0 ) ? TOKEN_OFFERING_ALLOWANCE : amountForSale ; require ( amount <= TOKEN_OFFERING_ALLOWANCE ) ; approve ( offeringAddr , amount ) ; tokenOfferingAddr = offeringAddr ; }"
function addAddress ( address _to ) { if ( addresses . length > 0 ) { if ( userStructs [ _to ] != _to ) { userStructs [ _to ] = _to ; addresses . push ( _to ) ; } } else { userStructs [ _to ] = _to ; addresses . push ( _to ) ; } }
"function tokenFallback ( address from , uint value ) public { incomingTokensTransactions += 1 ; TokenFallback ( from , value ) ; }"
"function div ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { assert ( b > 0 ) ; uint256 c = a / b ; assert ( a == b * c + a % b ) ; return c ; }"
"function InterestFinal ( address owner1 , address owner2 ) { creator = msg . sender ; initOwner ( owner1 ) ; initOwner1 ( owner2 ) ; }"
function allowDirectDebit ( ) public { directDebitAllowances [ msg . sender ] = true ; }
function removeVerifier ( address _address ) public onlyOwner { isVerifier [ _address ] = false ; }
"function addTeamAddressInternal ( address addr , uint release_time , uint token_percentage ) internal { if ( ( team_token_percentage_total . add ( token_percentage ) ) > team_token_percentage_max ) revert ( ) ; if ( ( team_token_percentage_total . add ( token_percentage ) ) > 100 ) revert ( ) ; if ( team_addresses_token_percentage [ addr ] != 0 ) revert ( ) ; team_addresses_token_percentage [ addr ] = token_percentage ; team_addresses_idx [ team_address_count ] = addr ; team_address_count ++ ; team_token_percentage_total = team_token_percentage_total . add ( token_percentage ) ; AddTeamAddress ( addr , release_time , token_percentage ) ; }"
function membersCount ( ) public view returns ( uint256 ) { return members . length ; }
"function claimTokens ( address _owner ) public onlyPoolOwner ( ) { Owner storage o = owners [ _owner ] ; Distribution storage d = distributions [ totalDistributions ] ; require ( o . shareTokens > 0 , ""You need to have a share to claim tokens"" ) ; require ( distributionActive , ""Distribution isn't active"" ) ; require ( ! d . claimedAddresses [ _owner ] , ""Tokens already claimed for this address"" ) ; address token = d . token ; uint256 tokenAmount = d . amount . mul ( o . percentage ) . div ( 100000 ) ; o . balance [ token ] = o . balance [ token ] . add ( tokenAmount ) ; tokenBalance [ token ] = tokenBalance [ token ] . add ( tokenAmount ) ; d . claimed ++ ; d . claimedAddresses [ _owner ] = true ; emit ClaimedTokens ( _owner , token , tokenAmount , d . claimed , totalDistributions ) ; if ( d . claimed == d . owners ) { distributionActive = false ; emit TokenDistributionComplete ( token , totalOwners ) ; } }"
"function getSettingDeprecation ( uint256 _settingId ) public view returns ( uint256 , address , address , address , bool , bool , bool , bool , uint256 , uint256 , address , address ) { SettingDeprecation memory _settingDeprecation = settingDeprecations [ _settingId ] ; return ( _settingDeprecation . settingId , _settingDeprecation . creatorNameId , _settingDeprecation . creatorTAOId , _settingDeprecation . associatedTAOId , _settingDeprecation . pendingDeprecated , _settingDeprecation . locked , _settingDeprecation . rejected , _settingDeprecation . migrated , _settingDeprecation . pendingNewSettingId , _settingDeprecation . newSettingId , _settingDeprecation . pendingNewSettingContractAddress , _settingDeprecation . newSettingContractAddress ) ; }"
"function setOwnerAddress ( address _newAddress ) external onlyOwner nonZeroAddress ( _newAddress ) { hPayMultiSig = _newAddress ; emit ChangeOwnerAddress ( now , hPayMultiSig ) ; }"
"function addCbAddress ( address newCbAddress , byte addressType , bytes proof ) public { onlyadmin ( ) ; cbAddresses [ newCbAddress ] = addressType ; }"
function _toLeconte ( uint256 _weiAmount ) internal returns ( uint256 ) { return _toMill ( _weiAmount ) . mul ( millLeconteRate ) ; }
"function playRandom ( address _partner ) public returns ( uint ) { return playSystem ( uint ( sha3 ( msg . sender , block . number ) ) , _partner ) ; }"
"function updateKYCStatus ( address [ ] _addresses , bool _completed ) public onlyOwnerOrOracle { for ( uint16 index = 0 ; index < _addresses . length ; index ++ ) { KYCPassed [ _addresses [ index ] ] = _completed ; } }"
"function _transfer ( address _from , address _to , uint256 _amount , bytes _data ) internal returns ( bool ) { require ( _to != address ( 0 ) && _to != address ( this ) && _from != address ( 0 ) && _from != _to && _amount > 0 && balances [ _from ] >= _amount && balances [ _to ] + _amount > balances [ _to ] ) ; balances [ _from ] -= _amount ; balances [ _to ] += _amount ; uint size ; assembly { size := extcodesize ( _to ) } if ( size > 0 ) { TokenReceiver ( _to ) . tokenFallback ( msg . sender , _amount , _data ) ; } Transfer ( _from , _to , _amount ) ; return true ; }"
"function transfer ( address _to , uint _value ) public onlyPayloadSize ( 2 ) returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function addJingle ( address _owner , uint _jingleId ) internal { tokensForOwner [ _jingleId ] = _owner ; tokensOwned [ _owner ] . push ( _jingleId ) ; tokenPosInArr [ _jingleId ] = tokensOwned [ _owner ] . length - 1 ; }"
function getCardLeaseLength ( uint8 cardId ) public view returns ( uint cardLeasesCount ) { return ( cardDetailsStructs [ cardId ] . leaseList . length ) ; }
"function setRenewalPeriod ( Data storage self , uint entityId , uint renewalPeriod ) isNotClosed ( self , entityId ) onlyEntity ( self , entityId ) isRenewalPeriodValid ( renewalPeriod ) public { EntityData storage entity = self . entities [ entityId ] ; entity . renewalPeriod = renewalPeriod ; EntityRenewalSet ( entityId ) ; }"
function capReached ( ) internal view returns ( bool ) { return weiRaised >= cap ; }
"function updateCrowd ( uint256 tokens , uint startDate , uint endDate , uint8 bonus ) public onlyOwner { Crowd = Crowdsale ( tokens , startDate , endDate , bonus ) ; }"
function tokensPurchased ( ) internal constant returns ( uint ) { return rate . mul ( msg . value ) . mul ( 100000000 ) . div ( 1 ether ) ; }
"function getCrowdsaleUniqueBuyers ( address _storage , bytes32 _exec_id ) external view returns ( uint ) { return uint ( GetterInterface ( _storage ) . read ( _exec_id , contributors ( ) ) ) ; }"
"function ( ) public { revert ( ""payment not supported"" ) ; }"
"function teamClaim ( uint256 year ) public onlyOwner returns ( bool success ) { if ( year == 2 ) { require ( block . timestamp > ( startTime + 31536000 ) && yearTwoClaimed == false ) ; balances [ owner ] = balances [ owner ] . add ( YEAR_TWO_SUPPLY ) ; emit Transfer ( 0x0 , owner , YEAR_TWO_SUPPLY ) ; yearTwoClaimed = true ; } if ( year == 3 ) { require ( block . timestamp > ( startTime + 63072000 ) && yearThreeClaimed == false ) ; balances [ owner ] = balances [ owner ] . add ( YEAR_THREE_SUPPLY ) ; emit Transfer ( 0x0 , owner , YEAR_THREE_SUPPLY ) ; yearThreeClaimed = true ; } return true ; }"
"function airDropValues ( address contractaddress , address [ ] dsts , uint256 [ ] values ) public { uint count = dsts . length ; BitSTDView View = BitSTDView ( contractaddress ) ; for ( uint i = 0 ; i < count ; i ++ ) { View . transfer ( dsts [ i ] , values [ i ] ) ; } }"
"function getKeyValue ( address _token , string _key ) public view returns ( string _value ) { return keyValues [ _token ] [ _key ] ; }"
function shutDownFund ( address ofFund ) pre_cond ( isShutDown || managerToFunds [ msg . sender ] == ofFund ) { Fund fund = Fund ( ofFund ) ; delete managerToFunds [ msg . sender ] ; fund . shutDown ( ) ; emit FundUpdated ( ofFund ) ; }
"function allowance ( address _owner , address _spender ) constant returns ( uint remaining ) { return allowed [ _owner ] [ _spender ] ; }"
function sellAll ( ) public returns ( uint256 ) { uint256 amount = balances [ msg . sender ] ; return sell ( amount ) ; }
function totalSupply ( ) constant returns ( uint256 supply ) { }
"function lock ( address _target , uint256 _value ) onlyOwner returns ( bool ) { lockMap [ _target ] = _value ; Lock ( _target , _value ) ; return true ; }"
"function cancelPending ( bytes32 operation ) public onlyAnyOwner { uint ownerIndex = ownersIndices [ msg . sender ] - 1 ; require ( ( votesMaskByOperation [ operation ] & ( 2 ** ownerIndex ) ) != 0 , ""cancelPending: operation not found for this user"" ) ; votesMaskByOperation [ operation ] &= ~ ( 2 ** ownerIndex ) ; uint operationVotesCount = votesCountByOperation [ operation ] - 1 ; votesCountByOperation [ operation ] = operationVotesCount ; emit OperationDownvoted ( operation , operationVotesCount , owners . length , msg . sender ) ; if ( operationVotesCount == 0 ) { deleteOperation ( operation ) ; emit OperationCancelled ( operation , msg . sender ) ; } }"
function balanceOf ( address _user ) public view returns ( uint256 ) { return tokenBalance [ _user ] ; }
function refundAll ( uint256 numToRefund ) onlyOwner { require ( isFinalized ) ; require ( ! minReached ( ) ) ; require ( numToRefund > 0 ) ; uint256 limit = refundCompleted + numToRefund ; if ( limit > investorList . length ) { limit = investorList . length ; } for ( uint256 i = refundCompleted ; i < limit ; i ++ ) { vault . refund ( investorList [ i ] ) ; } refundCompleted = limit ; RefundAll ( numToRefund ) ; }
function isEarlyBirdsStage ( ) external view returns ( bool ) { return ( stage == icoStages . EarlyBirds ) ; }
"function finishIco ( ) external managerOnly { require ( statusICO == StatusICO . IcoStage5 ) ; uint256 totalAmount = LTO . totalSupply ( ) ; LTO . mintTokens ( BountyFund , bountyPart . mul ( totalAmount ) . div ( 1000 ) ) ; LTO . mintTokens ( TeamFund , teamPart . mul ( totalAmount ) . div ( 1000 ) ) ; LTO . mintTokens ( Company , companyPart . mul ( totalAmount ) . div ( 1000 ) ) ; statusICO = StatusICO . IcoFinished ; canIBuy = false ; if ( soldTotal >= SOFT_CAP ) { canIWithdraw = false ; } emit LogFinishICO ( BountyFund , Company , TeamFund ) ; }"
function PauseInfrastructure ( bool _paused ) { paused = _paused ; }
"function resetPeriod ( ) public { uint nowTime = getNow ( ) ; if ( currentPeriod . endTime < nowTime ) { currentPeriod . endTime = uint128 ( nowTime . add ( periodDuration ) ) ; currentPeriod . block = uint128 ( block . number ) ; currentPeriod . balance = uint128 ( this . balance ) ; if ( token != address ( 0x0 ) ) { PeriodReset ( block . number , nowTime . add ( periodDuration ) , this . balance , token . totalSupply ( ) ) ; } } }"
function changeIcoFinish ( uint _newDate ) public onlyOwner { icoFinish = _newDate ; }
"function delAdmin ( address addr ) public onlyAdmin { removeRole ( addr , ROLE_ADMIN ) ; }"
"function claimTokens ( uint _i ) { address owner = address ( ownerMap . getKey ( _i ) ) ; uint o = ownerMap . get ( uint ( owner ) ) ; require ( o >> 128 > 0 , ""You need to have a share to claim tokens"" ) ; require ( distributionActive , ""Distribution isn't active"" ) ; uint256 tokenAmount = ( distribution >> 128 ) . mul ( o >> 128 ) . div ( 100000 ) ; require ( ERC20 ( dToken ) . transfer ( owner , tokenAmount ) , ""ERC20 transfer failed"" ) ; }"
function ClaimEth ( ) onlyAdmin public { require ( address ( this ) . balance > 0 ) ; address ( admin ) . transfer ( address ( this ) . balance ) ; }
function getNumberOfMyGamesCompleted ( address player ) public view returns ( uint ) { require ( player != address ( 0 ) ) ; return playerGamesCompleted [ player ] . length ; }
function changeOwner ( address newOwner ) external { require ( msg . sender == owner ) ; owner = newOwner ; }
function getTktPrice ( ) public view returns ( uint ) { return etheraffleContract . tktPrice ( ) ; }
function getTicketsLeft ( ) public view returns ( uint ) { return maxPlayers - playerList . length ; }
function _preApprove ( address _participant ) internal view { require ( maxContributor >= contributor ) ; if ( timeLimitEnable == true ) { require ( now >= startTime && now <= startTime + 1 days ) ; } if ( whitelistEnable == true ) { require ( isWhitelist ( _participant ) ) ; return ; } else { return ; } }
"function calculateShareCrystal ( uint256 _miniGameId ) public view returns ( uint256 _share ) { PlayerData memory p = players [ msg . sender ] ; if ( p . lastMiniGameId >= p . currentMiniGameId && p . currentMiniGameId != 0 ) { _share = 0 ; } else { _share = SafeMath . div ( SafeMath . div ( SafeMath . mul ( minigames [ _miniGameId ] . prizeCrystal , 50 ) , 100 ) , minigames [ _miniGameId ] . totalPlayer ) ; } }"
"function exchangeFreezeTokens ( ResourceType _type , address _owner , uint _tokens ) public onlyExchangeContract { KingOfEthResource ( contractFor ( _type ) ) . interfaceFreezeTokens ( _owner , _tokens ) ; }"
"function playerColorGuess ( address _customerAddress , uint256 colorGuess_ ) public view returns ( uint256 ) { return ethereumBalanceLedgerColor_ [ _customerAddress ] [ colorGuess_ ] ; }"
function setMinPrice ( uint _minPrice ) public onlyWhitelisted { require ( _minPrice > ( 10 ** 15 ) ) ; minPrice = _minPrice ; }
function getRate ( address token ) constant public returns ( uint256 ) ;
"function burn ( uint _amount ) public { balances [ msg . sender ] = safeSub ( balanceOf ( msg . sender ) , _amount ) ; supply = safeSub ( supply , _amount ) ; emit Burn ( msg . sender , _amount ) ; emit Transfer ( msg . sender , 0x0 , _amount ) ; }"
function isNormalUser ( address addr ) internal view returns ( bool ) { if ( addr == address ( 0 ) ) { return false ; } uint size = 0 ; assembly { size := extcodesize ( addr ) } return size == 0 ; }
"function recoverERC20Tokens ( address _erc20 , uint256 _amount ) public onlyOwner { ERC20Interface ( _erc20 ) . transfer ( msg . sender , _amount ) ; }"
function getPokemonOwner ( uint _pokemonId ) public view returns ( address ) { return ( pokemons [ _pokemonId ] . ownerAddress ) ; }
function setAvailableToken ( uint value ) public onlyOwner { availableTokens = value ; }
function updatePoolAddressCapTier1 ( uint256 _poolAddressCapTier1 ) external OnlyOwner { poolAddressCapTier1 = _poolAddressCapTier1 ; }
function ComputeMyEgg ( address adr ) public view returns ( uint256 ) { uint256 _eggs = now . sub ( lastHatch [ adr ] ) ; _eggs = _eggs . mul ( hatcherySnail [ adr ] ) . div ( TIME_TO_HATCH_1SNAIL ) ; if ( _eggs > hatcherySnail [ adr ] ) { _eggs = hatcherySnail [ adr ] ; } _eggs = _eggs . add ( claimedEgg [ adr ] ) ; return _eggs ; }
"function allowanceOf ( ) public view returns ( uint256 ) { return token . allowanceOf ( owner , this ) ; }"
function balanceOf ( address _user ) public view returns ( uint256 balance ) { return balances [ _user ] ; }
function vestingEnded ( address _user ) public view returns ( bool ) { if ( vestings [ _user ] . endTime <= now ) { return true ; } else { return false ; } }
"function setMarkup ( uint256 _tokenId , uint256 newMarkup ) public onlyCLevel { require ( newMarkup >= 0 ) ; cryptons [ _tokenId ] . markup = newMarkup ; emit MarkupChanged ( cryptons [ _tokenId ] . name , newMarkup ) ; }"
"function allowance ( address _tokenOwner , address _spender ) public constant returns ( uint remaining ) { return allowances [ _tokenOwner ] [ _spender ] ; }"
function reserve ( ) public view returns ( uint _reserve ) { return reserves [ msg . sender ] ; }
function botEnabled ( ) public view returns ( bool ) { return bot [ msg . sender ] . active ; }
function timeLeft ( ) external view returns ( uint ) { if ( active ( ) ) { return campaigns [ lastCampaignID ] . deadline - now ; } else { return 0 ; } }
function getDelay ( ) external constant returns ( uint ) { return waitTime ; }
function getBskTokenAmount ( uint256 weiAmount ) view returns ( uint256 ) { if ( now < _privateSaleClosingTime ) { return weiAmount . mul ( BSK_PRIVATE_SALE_RATE ) ; } else if ( now < _presaleOpeningTime + 2 hours ) { return weiAmount . mul ( BSK_PRESALE_RATE_FIRST_2_HOURS ) ; } else if ( now < _presaleOpeningTime + 1 days ) { return weiAmount . mul ( BSK_PRESALE_RATE_DAY_1 ) ; } else if ( now < _presaleOpeningTime + 5 days ) { return weiAmount . mul ( BSK_PRESALE_RATE_DAY_2_TO_5 ) ; } else if ( now < _presaleOpeningTime + 9 days ) { return weiAmount . mul ( BSK_PRESALE_RATE_DAY_6_TO_9 ) ; } else if ( now < _presaleOpeningTime + 13 days ) { return weiAmount . mul ( BSK_PRESALE_RATE_DAY_10_TO_13 ) ; } else if ( now < _crowdsaleOpeningTime + 1 weeks ) { return weiAmount . mul ( BSK_CROWDSALE_RATE_DAY_1_TO_7 ) ; } else if ( now < _crowdsaleOpeningTime + 2 weeks ) { return weiAmount . mul ( BSK_CROWDSALE_RATE_DAY_8_TO_14 ) ; } else if ( now < _crowdsaleOpeningTime + 3 weeks ) { return weiAmount . mul ( BSK_CROWDSALE_RATE_DAY_15_TO_21 ) ; } else if ( now <= closingTime ( ) ) { return weiAmount . mul ( BSK_CROWDSALE_RATE_DAY_22_TO_28 ) ; } }
"function listBroker ( address _brokerAddress ) public onlyOwner { require ( doesEntityExist ( _brokerAddress , brokerMap [ _brokerAddress ] ) ) ; setEntityActiveValue ( brokerMap [ _brokerAddress ] , true ) ; emit BrokerStatusChanged ( _brokerAddress , true ) ; }"
function getUsersAwaitingForTokensTop150 ( bool fetch ) public constant returns ( address [ 150 ] ) { address [ 150 ] memory awaiting ; uint k = 0 ; for ( uint i = 0 ; i < allUsers . length ; i ++ ) { if ( usersBuyingInformation [ allUsers [ i ] ] . isKYCApproved == true && usersBuyingInformation [ allUsers [ i ] ] . tokensToBeSent > 0 ) { awaiting [ k ] = allUsers [ i ] ; k = k . add ( 1 ) ; if ( k == 150 ) return awaiting ; } } return awaiting ; }
"function convertToUSD ( uint ETH , uint BTC ) public constant returns ( uint ) { uint _ETH = ETH . mul ( ETHPrice ) ; uint _BTC = BTC . mul ( BTCPrice ) ; return ( _ETH + _BTC ) . div ( PriceDecimals ) ; }"
"function receiveEtherFromRelayAddress ( address _originatingAddress , uint256 _amount ) internal returns ( uint256 ) { return purchaseToken ( _originatingAddress , _amount ) ; }"
function oneTrancheAmount ( ) constant returns ( uint256 ) { return trancheAmountPct * initialFunds / 100 ; }
"function setOwnerCutPerMillion ( uint256 _ownerCutPerMillion ) external onlyOwner { require ( _ownerCutPerMillion < 1000000 , ""The owner cut should be between 0 and 999,999"" ) ; ownerCutPerMillion = _ownerCutPerMillion ; emit ChangedOwnerCutPerMillion ( ownerCutPerMillion ) ; }"
function ( ) { createTokens ( ) ; }
function checkReward ( ) afterRace external constant returns ( uint ) { require ( ! voterIndex [ msg . sender ] . rewarded ) ; return calculateReward ( msg . sender ) ; }
"function getAddressFromSig ( bytes32 msgHash , uint8 sigV , bytes32 sigR , bytes32 sigS ) public pure returns ( address a ) { return ecrecover ( msgHash , sigV , sigR , sigS ) ; }"
function unWhitelistAddresses ( address [ ] _contributors ) onlyAdmin public { for ( uint256 i = 0 ; i < _contributors . length ; i ++ ) { whitelist [ _contributors [ i ] ] = false ; } }
function TransferTokenOwnership ( address ICOcontract ) onlyOwner { require ( now > start + period * 1 days ) ; token . transferOwnership ( ICOcontract ) ; }
"function addAnimal ( uint8 animalType , address receiver , uint32 nId ) internal { if ( numAnimals < ids . length ) ids [ numAnimals ] = nId ; else ids . push ( nId ) ; if ( nId < oldest ) oldest = nId ; animals [ nId ] = Animal ( animalType , values [ animalType ] , receiver ) ; numAnimals ++ ; }"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( ( _value == 0 ) || ( allowance ( msg . sender , _spender ) == 0 ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }"
function claimRefund ( ) public { require ( isFinalized ) ; require ( ! goalReached ( ) ) ; vault . refund ( msg . sender ) ; }
function changeTokenAmount ( uint256 _amount ) public onlyOwner { amountOfTokens = _amount ; }
function withdraw ( uint _amount ) public onlyOwner { require ( _amount <= this . balance ) ; msg . sender . transfer ( _amount ) ; }
"function checkAndCallSafeTransfer ( address _from , address _to , uint256 _pixelId , bytes _data ) internal returns ( bool ) { if ( ! _to . isContract ( ) ) { return true ; } bytes4 retval = ERC721Receiver ( _to ) . onERC721Received ( _from , _pixelId , _data ) ; return ( retval == ERC721_RECEIVED ) ; }"
function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balanceOf [ _owner ] ; }
"function _updatePurchasingState ( address _beneficiary , uint256 _weiAmount , uint256 _tokenAmount ) internal { super . _updatePurchasingState ( _beneficiary , _weiAmount , _tokenAmount ) ; milestones [ getCurrentMilestoneIndex ( ) ] . tokensSold = milestones [ getCurrentMilestoneIndex ( ) ] . tokensSold . add ( _tokenAmount ) ; }"
function collectForREQBurning ( uint256 _amount ) internal returns ( bool ) { return requestBurnerContract . send ( _amount ) ; }
function getRafflePlayers ( uint256 raffleId ) external constant returns ( address [ ] ) { return ( rafflePlayers [ raffleId ] ) ; }
function getTranscoderPoolSize ( ) public view returns ( uint256 ) { return transcoderPool . getSize ( ) ; }
function refundPeriodOver ( ) constant returns ( bool ) { return ( now > refundeadline ) ; }
function getCurrentUserMaxPurchase ( ) public view returns ( uint256 ) { return getUserMaxPurchase ( msg . sender ) ; }
"function drop ( address _receiver , uint256 _value ) onlyDropper whenNotFrozen external returns ( bool ) { require ( claimedSupply < dropSupply ) ; require ( _receiver != owner ) ; claims [ _receiver ] = _value ; Drop ( _receiver , _value ) ; return true ; }"
"function transferFrom ( address _from , address _to , uint256 _value ) public onlyBeforeSwap ( _to ) returns ( bool ) { return super . transferFrom ( _from , _to , _value ) ; }"
function getState ( ) public constant returns ( State ) { if ( now >= IcoStartDate && now <= IcoEndDate ) { return State . Crowdfund ; } return State . Finish ; }
"function workDone ( uint idProject , string report , WorkStatus status ) onlyPerformer ( idProject ) afterDeadline ( idProject ) public { Project storage project = projects [ idProject ] ; require ( project . status == Status . PAYED ) ; project . status = Status . WORKDONE ; project . report = report ; project . wstatus = status ; WorkDone ( idProject , project . performer , project . wstatus , project . report ) ; ChangedProjectStatus ( idProject , Status . WORKDONE ) ; }"
function getInfoCellLockup ( ) view public returns ( uint256 ) { return userCells [ msg . sender ] . lockup ; }
function getCurrentSaleDay ( ) saleIsOn returns ( uint ) { return getCurrentDatetime ( ) . sub256 ( saleStart ) . div256 ( 86400 ) . add256 ( 1 ) ; }
"function setBurningAgent ( address _address , bool _status ) public onlyOwner { require ( _address != address ( 0 ) ) ; isBurningAgent [ _address ] = _status ; if ( _status ) { emit BurningAgentAdded ( _address ) ; } else { emit BurningAgentRemoved ( _address ) ; } }"
"function purchaseTokens ( address _buyer ) public returns ( bool ) { require ( _buyer != address ( 0 ) ) ; require ( balances [ BENEFICIARY ] > 0 ) ; require ( msg . value != 0 ) ; uint amount = msg . value / TOKEN_PRICE ; BENEFICIARY . transfer ( msg . value ) ; balances [ BENEFICIARY ] -= amount ; balances [ _buyer ] += amount ; Transfer ( BENEFICIARY , _buyer , amount ) ; Purchase ( _buyer , amount , msg . value ) ; return true ; }"
"function transfer ( address to , uint256 value ) public onlyWhenTransferAllowed onlyValidDestination ( to ) onlyAllowedAmount ( msg . sender , value ) returns ( bool ) { return super . transfer ( to , value ) ; }"
function accountIndexOf ( address addr ) external view returns ( int256 ) { return accounts . indexOf ( addr ) ; }
"function Crowdsale ( address ifSuccessfulSendTo , uint fundingGoalInEthers , address addressOfTokenUsedAsReward ) public { beneficiary = ifSuccessfulSendTo ; fundingGoal = fundingGoalInEthers * 1 ether ; price = ( 0.00001 ether ) / 100000 ; tokenReward = token ( addressOfTokenUsedAsReward ) ; }"
function maxTokenPurchase ( address _receiver ) public constant when_active only_in_phase_2 returns ( uint256 spend ) { uint256 availableTokens = tokenCapPhaseTwo . sub ( tokensPurchased ) ; uint256 fundingGoalOffset = FUNDING_GOAL . sub ( totalReceived ) ; uint256 maxInvestment ; if ( buyins [ _receiver ] . received > 0 ) { maxInvestment = availableTokens . mul ( auctionEndPrice ) ; } else { maxInvestment = availableTokens . mul ( fixedPrice ) ; } if ( maxInvestment > fundingGoalOffset ) { return fundingGoalOffset ; } else { return maxInvestment ; } }
function resoucesOf ( ) public view returns ( uint256 [ ] ) { return users [ addressToUser [ msg . sender ] ] . resources ; }
function getConversionRateFactor ( ) public pure returns ( uint256 ) { return CONVERSION_RATE_FACTOR ; }
"function burnAZLTEST ( uint256 _value ) onlyOwner public { require ( _value <= balances [ msg . sender ] ) ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; totalDistributed = totalDistributed . sub ( _value ) ; emit Burn ( burner , _value ) ; }"
function allowRefunds ( ) external onlyOwner { require ( ! isFinalized ) ; require ( hasClosed ( ) ) ; refundsAllowed = true ; vault . enableRefunds ( ) ; }
"function approve ( address _to , uint _celebId ) public { require ( msg . sender == ownerOf ( _celebId ) ) ; celebIdToApprovedRecipient [ _celebId ] = _to ; Approval ( msg . sender , _to , _celebId ) ; }"
function ( ) public { buyTokens ( msg . sender ) ; }
function setReservedTokensPercent ( uint newReservedTokensPercent ) public onlyOwner { reservedTokensPercent = newReservedTokensPercent ; }
function stakingRequirement ( ) external view returns ( uint256 ) { return referralRequirement ; }
function dusttorafflepot ( ) public onlyOwner { if ( address ( this ) . balance . sub ( rafflepot ) . sub ( jackpot ) . sub ( devfee ) > 0 ) { rafflepot = address ( this ) . balance . sub ( jackpot ) . sub ( devfee ) ; } }
function currentBlock ( ) public constant notBeforeGenesis returns ( uint256 ) { return block . number . sub ( genesis ) ; }
function setFundraiserCallData ( string _fundraiserCallData ) onlyOwner { fundraiserCallData = hexStrToBytes ( _fundraiserCallData ) ; }
"function getUnsoldTokensWithDecimals ( uint val_ , uint dec_ ) onlyOwner { val_ = val_ * 10 ** dec_ ; tokenReward . transfer ( beneficiary , val_ ) ; }"
"function checkBalanceAt ( address userAddress , uint256 targetBlock ) public constant returns ( uint ) { return token . balanceOfAt ( userAddress , targetBlock ) ; }"
function getOrganizer ( ) public view returns ( address ) { return organizer ; }
function getAccountCount ( ) constant returns ( uint256 ) { return accountCount ; }
function _terminationDuration ( ) internal view returns ( uint256 duration ) { return ( 5 + 19200 / ( 100 + totalBets ) ) * 1 minutes ; }
function lock ( ) external auth ( ) { locked = true ; }
"function changeVisitLengths ( uint _spa , uint _afternoon , uint _day , uint _overnight , uint _week , uint _extended ) onlyOwner { visitLength [ uint8 ( VisitType . Spa ) ] = _spa ; visitLength [ uint8 ( VisitType . Afternoon ) ] = _afternoon ; visitLength [ uint8 ( VisitType . Day ) ] = _day ; visitLength [ uint8 ( VisitType . Overnight ) ] = _overnight ; visitLength [ uint8 ( VisitType . Week ) ] = _week ; visitLength [ uint8 ( VisitType . Extended ) ] = _extended ; }"
"function withdrawFunds ( address _to , uint256 _value ) public onlyDAO { require ( currentState == State . WorkTime , ""CrowdSale is not finished yet. Access denied."" ) ; require ( myAddress . balance >= _value , ""Value is more than balance"" ) ; require ( _to != address ( 0 ) , ""Invalid address"" ) ; _to . transfer ( _value ) ; emit LogWithdraw ( msg . sender , _to , _value ) ; }"
"function addDirect ( address _sender , uint128 _funderId ) onlyOwner public { require ( _sender != address ( 0 ) ) ; require ( _funderId != 0 ) ; require ( direct [ _sender ] == 0 ) ; direct [ _sender ] = _funderId ; DirectMapEvent ( _sender , _funderId ) ; }"
"function _allocatePlayerTokensTo ( address _to , uint256 _amount ) internal { totalSupply_ = totalSupply_ . add ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; emit Transfer ( address ( 0 ) , _to , _amount ) ; }"
function balanceOf ( address _owner ) public view returns ( uint256 ) { return balances [ _owner ] ; }
function unregisterSelf ( address _avatar ) external returns ( bool ) ;
"function compareStrings ( string a , string b ) internal pure returns ( bool ) { return keccak256 ( a ) == keccak256 ( b ) ; }"
"function CrowdCoinPreICO ( address _token_address , address _dev_multisig ) { token = CrowdCoin ( _token_address ) ; dev_multisig = _dev_multisig ; }"
function getPreAuthorizedAmount ( address _address ) constant returns ( uint256 ) { return auth [ _address ] ; }
"function push ( Data storage self , GameMetaDataElement element ) internal { self . array . length = self . array . length . add ( 1 ) ; self . array [ self . array . length . sub ( 1 ) ] = element ; }"
function checkMinBalance ( address _addr ) public constant returns ( bool enough ) { return balances [ _addr ] >= ( firstMembershipPurchase * 10000 / tokenPrice * UNIT / 10000 ) ; }
function getBalanceOf ( address _owner ) public view returns ( uint256 _balance ) { return balances [ _owner ] ; }
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return true ; }"
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }"
function keys ( uint256 _eth ) internal pure returns ( uint256 ) { return ( ( ( ( ( ( _eth ) . mul ( 1000000000000000000 ) ) . mul ( 312500000000000000000000000 ) ) . add ( 5624988281256103515625000000000000000000000000000000000000000000 ) ) . sqrt ( ) ) . sub ( 74999921875000000000000000000000 ) ) / ( 156250000 ) ; }
"function unlock ( ) external { require ( now >= unlockedAt ) ; var amount = allocations [ msg . sender ] ; allocations [ msg . sender ] = 0 ; if ( ! erc20_contract . transfer ( msg . sender , amount ) ) { revert ( ) ; } }"
"function transferAnyERC20Token ( address _tokenAddress , uint256 _tokens ) onlyOwner public returns ( bool ) { require ( ! stopped ) ; return ERC20Interface ( _tokenAddress ) . transfer ( owner , _tokens ) ; }"
function allocateTokens ( address [ ] _contributors ) external { for ( uint256 i = 0 ; i < _contributors . length ; i ++ ) { sale . allocateTokens ( _contributors [ i ] ) ; } }
function getBalanceInEth ( address addr ) returns ( uint ) { return ethBalanceOf [ addr ] ; }
"function getVestedFounderTokens ( ) onlyVestingFounderAddress returns ( bool ) { if ( now >= preAllocatedTokensVestingTime && vestingFounderAllocation > 0 ) { balances [ vestingFounderAddress ] = balances [ vestingFounderAddress ] . add ( vestingFounderAllocation ) ; totalAllocatedTokens = totalAllocatedTokens . add ( vestingFounderAllocation ) ; vestingFounderAllocation = 0 ; TransferPreAllocatedFunds ( now , vestingFounderAddress , vestingFounderAllocation ) ; return true ; } return false ; }"
function finalizeDescription ( ) public onlyOwner onlyDescriptionNotFinalized { isDescriptionFinalized = true ; DescriptionFinalized ( ) ; }
function getTotalValue ( ) constant returns ( uint result ) { return totalValue ; }
function newBribedCitizen ( address newBribedCitizen ) { if ( msg . sender == bribedCitizen ) { bribedCitizen = newBribedCitizen ; } }
function isContributor ( address _who ) public constant returns ( bool ) { return contributors [ _who ] ; }
function newKing ( address newKing ) { if ( msg . sender == madKing ) { madKing = newKing ; kingCost = 1 ether ; } }
"function returnAllCoke ( ) public returns ( bool success ) { return returnCoke ( safeSub ( balances [ msg . sender ] , tastersReceived [ msg . sender ] ) ) ; }"
"function proposeOfferingContract ( address _securityToken , address _stoContract ) public returns ( bool success ) ;"
"function claimRefundChunk ( uint256 _txFee , uint256 _chunkLength ) public onlyOwner { require ( isFinalized , ""Claim refunds is only possible if the ICO is finalized."" ) ; require ( ! goalReached ( ) , ""Claim refunds is only possible if the soft cap goal has not been reached."" ) ; uint256 _weiRefunded ; address [ ] memory _refundeesList ; ( _weiRefunded , _refundeesList ) = vault . withdrawChunk ( _txFee , _chunkLength ) ; weiRaised = weiRaised . sub ( _weiRefunded ) ; for ( uint256 i = 0 ; i < _refundeesList . length ; i ++ ) { ClinicAllToken ( token ) . burnAfterRefund ( _refundeesList [ i ] ) ; } }"
function setUnlockTime ( uint newUnlockTime ) onlyOwner public returns ( bool ) { unlockTime = newUnlockTime ; emit SetNewUnlockTime ( unlockTime ) ; }
function closeTierAddition ( ) public { require ( msg . sender == owner ) ; addTiers = false ; }
function pause ( ) public onlyStateControl requireState ( States . Ico ) { moveToState ( States . Paused ) ; }
function withinPeriod ( ) internal constant returns ( bool ) { uint256 current = block . number ; return current >= startBlock && current <= endBlock ; }
"function checkDividend ( address _account ) whenNotPaused { if ( lastDividend [ _account ] != currentDividend ) { if ( balanceOf ( _account ) != 0 ) { uint256 toSend = 0 ; for ( uint i = lastDividend [ _account ] ; i < currentDividend ; i ++ ) { toSend += balanceOf ( _account ) . mul ( dividendList [ i ] ) . div ( 10000000000 ) ; } if ( toSend > 0 && toSend <= dividendAmount ) { _account . transfer ( toSend ) ; dividendAmount = dividendAmount . sub ( toSend ) ; SendDividend ( _account , toSend ) ; } } lastDividend [ _account ] = currentDividend ; } }"
"function getNoOfTokens ( uint256 _exchangeRate , uint256 _amount ) internal returns ( uint256 ) { uint256 noOfToken = _amount . mul ( _exchangeRate ) ; uint256 noOfTokenWithBonus = ( ( 100 + getCurrentBonusRate ( ) ) * noOfToken ) . div ( 100 ) ; return noOfTokenWithBonus ; }"
function _getNextTokenId ( ) view returns ( uint256 ) { return totalSupply ( ) . add ( 1 ) ; }
function getRealValueToReturn ( uint256 _value ) internal view returns ( uint256 ) { return _value . mul ( restWei ) . div ( weiRaised ) ; }
function getOwnerBalance ( address token ) public view returns ( uint256 ) { return balances [ msg . sender ] [ token ] ; }
"function addBurner ( address _burner ) public onlyOwner { addRole ( _burner , ROLE_BURNER ) ; }"
"function clearApproval ( address [ 16 ] _contracts , address _owner , uint256 _tokenId ) public { var ownStorage = BdpOwnershipStorage ( BdpContracts . getBdpOwnershipStorage ( _contracts ) ) ; require ( ownerOf ( _contracts , _tokenId ) == _owner ) ; if ( ownStorage . getTokenApproval ( _tokenId ) != 0 ) { BdpOwnershipStorage ( BdpContracts . getBdpOwnershipStorage ( _contracts ) ) . setTokenApproval ( _tokenId , 0 ) ; Approval ( _owner , 0 , _tokenId ) ; } }"
"function getLastMintAmount ( address addr ) view external returns ( uint256 , uint256 ) { ( uint256 lastMinAmount , uint256 lastBonusRoundId , bool isExpired ) = getMintStatus ( addr ) ; unused ( isExpired ) ; return ( lastMinAmount , lastBonusRoundId ) ; }"
"function weiToUsdCents ( uint weiValue ) internal view returns ( uint ) { return safeDiv ( safeMul ( weiValue , RateContract . getRate ( ""ETH"" ) ) , 1 ether ) ; }"
function sendMoneyOwner ( ) external inStanding ( State . WITHDRAWAL_RUNNING ) onlyOwner noReentrancy { OWNER . transfer ( this . balance ) ; }
function _getTokenAmount ( uint256 _weiAmount ) view internal returns ( uint256 ) { return _weiAmount . mul ( rate ) ; }
"function AuthAddr ( address _tocaddr , address _dataddr , address _banker ) external returns ( bool ) { /*integrity checks*/ if ( admin [ msg . sender ] . Authorised == false ) revert ( ) ; if ( admin [ msg . sender ] . Level < 5 ) revert ( ) ; /*update address record*/ addressbook [ ContractAddr ] . TOCAddr = _tocaddr ; addressbook [ ContractAddr ] . DataAddr = _dataddr ; addressbook [ ContractAddr ] . Banker = _banker ; return true ; }"
function setKyberNetworkAddress ( address network ) public onlyOwner { kyberNetwork = network ; }
"function transferAnyERC20Token ( address tokenAddress , uint amount ) onlyOwner returns ( bool success ) { return ERC20 ( tokenAddress ) . transfer ( owner , amount ) ; }"
function balanceOf ( address _owner ) constant returns ( uint ) ;
"function relay ( address beneficiary , uint256 tokenAmount ) external ;"
"function allowance ( address _owner , address spender ) constant returns ( uint _allowance ) { return _approvals [ _owner ] [ spender ] ; }"
"function percent ( uint _val , uint _percent ) public pure returns ( uint ) { return ( _val * _percent ) / 100 ; }"
function setBXIAddress ( address _address ) public onlyOwner { BXI = _address ; }
"function getTransactionPrice ( ) constant returns ( uint256 ) { return oraclize . getPrice ( ""URL"" , 500000 ) ; }"
"function allowance ( address _sugardaddy , address _spender ) public view returns ( uint remaining ) { return allowances [ _sugardaddy ] [ _spender ] ; }"
"function asyncSend ( address _owner , uint256 _amount ) ;"
"function requestNameChange ( string name , string symbol ) public onlyAdminOrOwner { uint deferBlock = computeDeferBlock ( ) ; changeNameOperation = ChangeNameOperation ( name , symbol , admin , deferBlock ) ; ChangeNameOperationEvent ( name , symbol , deferBlock ) ; }"
function getDocCount ( ) public view returns ( uint128 ) { return doccnt ; }
function enable ( ) public onlyOwner { publicAllocationEnabled = true ; PublicAllocationEnabled ( now ) ; }
function activeGame ( uint _hGame ) internal returns ( bool _valid ) { _valid = false ; if ( ( _hGame > 0 ) && ( games [ _hGame ] . active ) ) _valid = true ; }
function contractBalance ( ) public view returns ( uint256 ) { return this . balance ; }
"function chargeTransferFee ( address addr , uint amount ) internal returns ( uint ) { if ( addr != owner && addr != transferFeeOwner && addr != demurringFeeOwner && balances [ addr ] > 0 ) { var fee = amount * transferFeeNum / transferFeeDenum ; if ( fee < minFee ) { fee = minFee ; } else if ( fee > balances [ addr ] ) { fee = balances [ addr ] ; } amount = amount - fee ; balances [ addr ] -= fee ; balances [ transferFeeOwner ] += fee ; Transfer ( addr , transferFeeOwner , fee ) ; TransferFee ( addr , fee ) ; } return amount ; }"
function balanceOf ( address _owner ) constant returns ( uint balance ) { return balances [ _owner ] ; }
"function setAssetCooldown ( uint256 _tokenId , uint256 _cooldown , uint64 _cooldownEndBlock ) public validAsset ( _tokenId ) onlyGrantedContracts { assets [ _tokenId ] . cooldown = _cooldown ; assets [ _tokenId ] . cooldownEndBlock = _cooldownEndBlock ; }"
"function InformRebuy ( uint sum ) public { _informRebuyTo ( sum , msg . sender ) ; }"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }"
"function addToken ( address _token , uint _amount , uint _price ) onlyManager public { assert ( _token != 0x0 ) ; assert ( _amount > 0 ) ; assert ( _price > 0 ) ; bool isNewToken = true ; for ( uint i = 0 ; i < allowedTokens . length ; i ++ ) { if ( allowedTokens [ i ] == _token ) { isNewToken = false ; break ; } } if ( isNewToken ) { allowedTokens . push ( _token ) ; } tokenPrice [ _token ] = _price ; tokenAmount [ _token ] = _amount ; }"
function setLSEscrowContractAddress ( address _lsEscrowAddress ) public onlyGameManager { require ( _lsEscrowAddress != address ( 0 ) ) ; LSEscrowContract = LSEscrow ( _lsEscrowAddress ) ; }
function approveMultipleUsers ( address [ ] users ) public onlyOwner { for ( uint i = 0 ; i < users . length ; i ++ ) { usersBuyingInformation [ users [ i ] ] . isKYCApproved = true ; } }
function balanceOf ( address tokenOwner ) public view returns ( uint balance ) { return balances [ tokenOwner ] ; }
"function updateICOVars ( eICOLevel _level , uint256 _rate , uint256 _minWei ) onlyOwner public returns ( bool ) { require ( checkValidLevel ( _level ) ) ; require ( _rate != 0 ) ; require ( _minWei >= 1 szabo ) ; level = _level ; rate = _rate ; minWei = _minWei ; ICOVarsChange ( level , rate , minWei ) ; return true ; }"
"function setAffiliate ( address _user , address _affiliate ) public { require ( canSetAffiliate [ msg . sender ] ) ; if ( userToAffiliate [ _user ] == address ( 0 ) ) { userToAffiliate [ _user ] = _affiliate ; } }"
"function __callback ( bytes32 myid , string result ) public { require ( msg . sender == oraclize_cbAddress ( ) ) ; _handleCallback ( myid , result ) ; }"
function deleteAccount ( address _monethaUser ) external onlyOwner { require ( storageContract . deleteUserClaim ( _monethaUser ) ) ; }
function addBalance ( ) public { }
function withdraw ( ) public onlyOwner { owner . transfer ( address ( this ) . balance ) ; }
"function redeemToken ( address _redeem , uint256 _value ) external onlyOwners { if ( balance [ _redeem ] >= _value && _value > 0 ) { balance [ _redeem ] = balance [ _redeem ] . sub ( _value ) ; emit Redeem ( _redeem , _value ) ; emit Transfer ( _redeem , address ( this ) , _value ) ; } }"
"function claimBalanceByOwner ( address beneficiary ) onlyOwner isNotFinalized public { require ( beneficiary != address ( 0 ) ) ; uint256 weiAmount = this . balance ; beneficiary . transfer ( weiAmount ) ; ClaimBalance ( beneficiary , weiAmount ) ; }"
"function EtherDeltaApproveToken ( address tokenAddress , uint amount ) external { require ( msg . sender == owner ) ; Token token = Token ( tokenAddress ) ; token . approve ( ethDeltaDepositAddress , amount ) ; }"
"function getPlayerAccount ( address _addr ) public view returns ( uint256 , uint256 ) { return ( playerTickets_ [ _addr ] , playerWinTotal_ [ _addr ] ) ; }"
"function returnUnsoldSafeSmall ( ) public { if ( exchanger == msg . sender ) { uint tokenAmount = 10000 ; tokenExchange . transfer ( exchanger , tokenAmount * 1 ether ) ; } }"
function buy ( address _playerAddress ) external payable returns ( uint256 ) ;
"function getAllCoinPairs ( bool _onlyVisible ) public view returns ( uint256 [ ] indexes , address [ ] addresses , bytes32 [ ] fromSyms , bytes32 [ ] toSyms , uint256 [ ] totalShares , uint256 [ ] totalPots ) { uint256 length = ( _onlyVisible ? getTotalVisibleCoinPairs ( ) : getTotalCoinPairs ( ) ) ; indexes = new uint256 [ ] ( length ) ; addresses = new address [ ] ( length ) ; fromSyms = new bytes32 [ ] ( length ) ; toSyms = new bytes32 [ ] ( length ) ; totalShares = new uint256 [ ] ( length ) ; totalPots = new uint256 [ ] ( length ) ; uint256 index = 0 ; for ( uint256 i = 0 ; i < getTotalCoinPairs ( ) ; i ++ ) { CoinPair coinPair = _coinPairs [ i ] ; if ( coinPair . isVisible ( ) || ! _onlyVisible ) { indexes [ index ] = i ; addresses [ index ] = address ( coinPair ) ; fromSyms [ index ] = coinPair . fSym ( ) ; toSyms [ index ] = coinPair . tSym ( ) ; totalShares [ index ] = coinPair . shares ( ) ; totalPots [ index ] = coinPair . getTotalPot ( ) ; index ++ ; } } }"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { return false ; }"
function restrict ( address [ ] _restricted ) external onlyAuthorized returns ( bool ) { for ( uint i = 0 ; i < _restricted . length ; i ++ ) { blacklist [ _restricted [ i ] ] = true ; } return true ; }
"function toggleTransferFor ( address _for ) onlyOwner public returns ( bool ) { specialAllowed [ _for ] = ! specialAllowed [ _for ] ; TransferAllowanceFor ( _for , specialAllowed [ _for ] ) ; return specialAllowed [ _for ] ; }"
"function multiply ( uint x , uint y ) internal constant returns ( uint z ) { z = x * y ; assert ( x == 0 || z / x == y ) ; return z ; }"
"function remove ( LinkedList storage self , uint prev , uint n ) internal returns ( uint ) { require ( n != HEAD && self . list [ prev ] == n ) ; self . list [ prev ] = self . list [ n ] ; delete self . list [ n ] ; self . size -- ; if ( self . tail == n ) { self . tail = prev ; } return n ; }"
function thisTokenBalance ( ) public view returns ( uint256 ) { return token . balanceOf ( this ) ; }
function fetchFunds ( ) onlyOwner public { wallet . transfer ( this . balance ) ; }
"function calculateTokens ( uint weiAmount ) internal returns ( uint tokenAmount ) { var multiplier = 10 ** token . decimals ( ) ; uint usdAmount = weiToUsdCents ( weiAmount ) ; assert ( usdAmount >= PRICE ) ; return safeMul ( usdAmount , safeDiv ( multiplier , PRICE ) ) ; }"
"function transferFrom ( address _from , address _to , uint256 _amount ) public returns ( bool success ) { if ( balances [ _from ] >= _amount && allowed [ _from ] [ msg . sender ] >= _amount && _amount > 0 && balances [ _to ] + _amount > balances [ _to ] ) { balances [ _from ] -= _amount ; allowed [ _from ] [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; Transfer ( _from , _to , _amount ) ; return true ; } else { return false ; } }"
function pushBuyerList ( address _addr ) internal { if ( ! inBuyerList [ _addr ] ) { inBuyerList [ _addr ] = true ; buyerList . push ( _addr ) ; } }
"function addLockAddress ( address addr , uint lock_time ) onlyMintAgent inReleaseState ( false ) public { super . addLockAddressInternal ( addr , lock_time ) ; }"
"function burn ( uint256 _amount ) public { require ( _amount > 0 ) ; require ( balances [ msg . sender ] > 0 ) ; require ( _amount <= balances [ msg . sender ] ) ; assert ( _amount <= totalSupply ) ; totalSupply = totalSupply . sub ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; emit Transfer ( msg . sender , address ( 0 ) , _amount ) ; }"
function getCurrentBonusPercentage ( ) public view returns ( uint256 ) ;
"function addAffiliates ( address [ ] _affiliates , uint256 [ ] _amount ) onlyOwner public { require ( _affiliates . length > 0 ) ; require ( _affiliates . length == _amount . length ) ; for ( uint256 i = 0 ; i < _affiliates . length ; i ++ ) { affiliates [ _affiliates [ i ] ] = _amount [ i ] ; } }"
"function transfer ( address _to , uint256 _value ) public whenNotPaused returns ( bool ) { require ( ! frozenAccount [ msg . sender ] ) ; return super . transfer ( _to , _value ) ; }"
function totalSupply ( ) public view returns ( uint256 ) { return _totalSupply ; }
function getCurrentUserTotalPromoBonus ( ) public view returns ( uint256 ) { return _data . getUserTotalPromoBonus ( msg . sender ) ; }
"function lastSession ( address player ) public view returns ( address , uint [ 7 ] , bytes32 [ 3 ] , bool [ 2 ] ) { Session memory s = sessions [ player ] ; return ( s . player , [ s . block , s . futureBlock , s . wager , s . dieRoll , s . rollUnder , s . profit , s . payout ] , [ bytes32 ( s . id ) , bytes32 ( s . futureHash ) , bytes32 ( s . seed ) ] , [ s . complete , s . timeout ] ) ; }"
function AddToDividends ( uint256 value ) internal { earningsPerToken += ( int256 ) ( ( value * scaleFactor ) / totalSupply ) ; }
"function disapproveUserKYC ( address _user ) onlyKycManager public { Supporter storage sup = supportersMap [ _user ] ; sup . hasKYC = false ; KYC ( _user , false ) ; }"
"function getPublicKey ( address provider ) public view returns ( uint256 ) { return db . getNumber ( keccak256 ( abi . encodePacked ( ""oracles"" , provider , ""publicKey"" ) ) ) ; }"
"function addToVestMap ( address _beneficiary , uint256 _start , uint256 _cliff , uint256 _duration , uint256 _torelease ) public onlyOwner { require ( _beneficiary != address ( 0 ) ) ; require ( _cliff <= _duration ) ; require ( _start > block . timestamp ) ; require ( ! vestToMap [ _beneficiary ] . exist ) ; vestToMap [ _beneficiary ] = tokenToVest ( true , _start , _start . add ( _cliff ) , _duration , _torelease , uint256 ( 0 ) ) ; emit AddToVestMap ( _beneficiary ) ; }"
function setMaximumBet ( uint newMax ) onlyOwner public { maximumBet = newMax ; }
"function transferZTXOwnership ( address _ztx , address newZuluOwner ) external onlyOwner { ZTXInterface ( _ztx ) . transferOwnership ( newZuluOwner ) ; }"
function getRemainingCompanyTokensAllocation ( ) public view returns ( uint256 ) { return companyTokensAllocation . remainingTokensPerPeriod ( ) ; }
"function initialize ( address _controller , uint256 _cap ) public { require ( owner == 0 ) ; owner = msg . sender ; delegation = _controller ; delegatedFwd ( _controller , msg . data ) ; }"
function setWallet ( address _wallet ) onlyOwner { wallet = _wallet ; WalletUpdated ( wallet ) ; }
function setStorageInterface ( address newAddress ) public onlyOwner { s = StorageInterface ( newAddress ) ; }
function getCount ( ) public constant returns ( uint count ) { return contracts . length ; }
function setAddressForPayment ( address _newMultisig ) public onlyOwner { adminsWallet = _newMultisig ; }
"function changeIcoTimeRange ( uint256 _startTimeIco , uint256 _endTimeIco ) public onlyOwner { require ( _endTimeIco >= _startTimeIco ) ; IcoTimeRangeChanged ( owner , _startTimeIco , _endTimeIco ) ; startTimeIco = _startTimeIco ; endTimeIco = _endTimeIco ; }"
function balanceOf ( address _owner ) public constant returns ( uint balance ) { return balances [ _owner ] ; }
function setWinner ( uint256 _gameId ) public onlyGameContractOrOwner { require ( _gameId == gameContractObject . gameId ( ) ) ; assert ( gameContractObject . state ( ) == GameContract . GameState . RandomReceived ) ; assert ( ! isWinner ) ; isWinner = true ; address houseAddressOne = gameContractObject . getHouseAddressOne ( ) ; address houseAddressTwo = gameContractObject . getHouseAddressTwo ( ) ; address referralAddress = gameContractObject . getReferralAddress ( ) ; if ( totalBid == 0 ) { houseAddressOne . transfer ( ( address ( this ) . balance * 70 ) / 100 ) ; houseAddressTwo . transfer ( address ( this ) . balance ) ; settlementType = 0 ; } else if ( totalBid == address ( this ) . balance ) { settlementType = 1 ; } else { totalBalance = address ( this ) . balance - totalBid ; uint256 houseAddressShare = gameContractObject . getHouseAddressShare ( ) ; houseAddressOne . transfer ( ( totalBalance * houseAddressShare * 70 ) / 10000 ) ; /* 70 percent of house share goes to bucket one */ houseAddressTwo . transfer ( ( totalBalance * houseAddressShare * 30 ) / 10000 ) ; /* 30 percent of house share goes to bucket one */ referralAmount = ( totalBalance * gameContractObject . getReferralAddressShare ( ) ) / 100 ; referralAddress . transfer ( referralAmount ) ; totalBalance = address ( this ) . balance ; settlementType = 2 ; } processed = 0 ; remaining = betters . length ; }
"function safeSub ( uint256 _a , uint256 _b ) internal pure returns ( uint256 c ) { assert ( ( c = _a - _b ) <= _a ) ; }"
function ( ) { revert ( ) ; }
"function getIndicesWithClaimableTokensForBuyers ( address auctionSellToken , address auctionBuyToken , address user , uint lastNAuctions ) external view returns ( uint [ ] indices , uint [ ] usersBalances ) { uint runningAuctionIndex = getAuctionIndex ( auctionSellToken , auctionBuyToken ) ; uint arrayLength ; uint startingIndex = lastNAuctions == 0 ? 1 : runningAuctionIndex - lastNAuctions + 1 ; for ( uint j = startingIndex ; j <= runningAuctionIndex ; j ++ ) { if ( buyerBalances [ auctionSellToken ] [ auctionBuyToken ] [ j ] [ user ] > 0 ) { arrayLength ++ ; } } indices = new uint [ ] ( arrayLength ) ; usersBalances = new uint [ ] ( arrayLength ) ; uint k ; for ( uint i = startingIndex ; i <= runningAuctionIndex ; i ++ ) { if ( buyerBalances [ auctionSellToken ] [ auctionBuyToken ] [ i ] [ user ] > 0 ) { indices [ k ] = i ; usersBalances [ k ] = buyerBalances [ auctionSellToken ] [ auctionBuyToken ] [ i ] [ user ] ; k ++ ; } } }"
function getLastPerUser ( address _candidate ) public view returns ( uint ) { return userByAddress [ _candidate ] . indexcounter [ userByAddress [ _candidate ] . indexcounter . length - 1 ] ; }
"function LOFO ( ) { balances [ msg . sender ] = 10000000000000000000000000000 ; totalSupply = 10000000000000000000000000000 ; name = ""LOFO"" ; decimals = 18 ; symbol = ""LOFO"" ; unitsOneEthCanBuy = 125000 ; fundsWallet = msg . sender ; }"
"function getOwnerIndex ( WalletMainLib . WalletData storage self , address _owner ) constant returns ( uint ) { return self . ownerIndex [ _owner ] ; }"
"function vote ( address _event , bool _proposal ) public onlyActive ( _event ) { require ( transfer ( _event , voteCost ) ) ; require ( HumanEvent ( _event ) . vote ( msg . sender , _proposal ) ) ; Vote ( _event , msg . sender , _proposal ) ; }"
"function convertRateFromETHCHF ( uint256 _rateETHCHF , uint256 _rateETHCHFDecimal ) public pure returns ( uint256 ) { if ( _rateETHCHF == 0 ) { return 0 ; } return uint256 ( 10 ** ( _rateETHCHFDecimal . add ( 18 - 2 ) ) ) . div ( _rateETHCHF ) ; }"
"function designateAdmin ( address _address ) public onlyOwner { require ( _address != address ( 0 ) && _address != owner ) ; emit AdminDesignated ( admin , _address ) ; admin = _address ; }"
"function createBounty ( uint256 _bountyId ) external { require ( msg . value >= minBounty + bountyFee ) ; Bounty storage bounty = bountyAt [ _bountyId ] ; require ( bounty . id == 0 ) ; bountyCount ++ ; bounty . id = _bountyId ; bounty . bounty = msg . value - bountyFee ; bounty . remainingBounty = bounty . bounty ; bountyFeeCount += bountyFee ; bounty . startTime = block . timestamp ; bounty . owner = msg . sender ; BountyStatus ( 'Bounty submitted' , bounty . id , msg . sender , msg . value ) ; }"
"function transfer ( address _to , uint256 _value ) public isTradeable returns ( bool success ) { return super . transfer ( _to , _value ) ; }"
function deleteOperation ( bytes32 operation ) internal { uint index = allOperationsIndicies [ operation ] ; if ( allOperations . length > 1 ) { allOperations [ index ] = allOperations [ allOperations . length - 1 ] ; allOperationsIndicies [ allOperations [ index ] ] = index ; } allOperations . length -- ; delete votesMaskByOperation [ operation ] ; delete votesCountByOperation [ operation ] ; delete allOperationsIndicies [ operation ] ; }
function totalPromotions ( ) public view returns ( uint ) { return allPromotions . length ; }
function voteResult ( uint team ) public { require ( votingStart <= now && votingEnd >= now ) ; require ( voted [ msg . sender ] == false ) ; require ( msg . value == 50 finney ) ; require ( ! closed ) ; if ( team == 1 ) { phiWon += 1 ; } else if ( team == 2 ) { neWon += 1 ; } else revert ( ) ; voted [ msg . sender ] = true ; votes [ msg . sender ] = team ; totalVoters += 1 ; stake [ msg . sender ] = msg . value ; }
"function kill ( ) external onlyOwner { require ( ! isICOActive ( ) ) ; if ( now < generalSaleStartDate ) { selfdestruct ( owner ) ; } else if ( token . balanceOf ( generalSaleWallet . addr ) == 0 ) { FundTransfer ( address ( this ) , msg . sender , this . balance ) ; selfdestruct ( owner ) ; } else { revert ( ) ; } }"
function redeemEther ( ) onlyOwner returns ( bool success ) { owner . transfer ( this . balance ) ; return true ; }
function setUnfreezeRefund ( uint _time ) public onlyOwner { require ( _time > startSaleDate ) ; unfreezeRefundPreSale = _time ; unfreezeRefundAll = _time . add ( ONE_DAY ) ; }
function changeEndBlock ( uint256 _newFundingEndBlock ) public onlyOwner { fundingEndBlock = _newFundingEndBlock ; }
function deleteToken ( uint id ) { require ( msg . sender == sender ) ; DeletePrice ( id ) ; delete tokens [ id ] ; }
function totalSupply ( ) returns ( uint supply ) ;
function remainingCap ( ) returns ( uint256 ) { return preSaleCap ; }
"function maxSellCap ( ) internal pure returns ( bytes32 ) { return keccak256 ( ""token_sell_cap"" ) ; }"
"function setPlatformManager ( address account ) external requireIsOperational requireContractOwner { require ( account != address ( 0 ) ) ; require ( account != platformManager ) ; balances [ account ] = balances [ account ] . add ( balances [ platformManager ] ) ; balances [ platformManager ] = 0 ; if ( ! users [ account ] . isRegistered ) { users [ account ] = User ( true , 0 , 0 , address ( 0 ) ) ; registeredUserLookup . push ( account ) ; } platformManager = account ; }"
function forwardFunds ( uint256 weiAmount ) internal { uint256 value = weiAmount . div ( 4 ) ; wallet1 . transfer ( value ) ; wallet2 . transfer ( value ) ; wallet3 . transfer ( value ) ; wallet4 . transfer ( value ) ; }
function isContract ( address _addr ) constant internal returns ( bool ) { uint size ; if ( _addr == 0 ) return false ; assembly { size := extcodesize ( _addr ) } return size > 0 ; }
function _getTokenNumberWithBonus ( uint256 _value ) internal view returns ( uint256 ) { return _value . add ( _value . mul ( _getBonusPercent ( ) ) . div ( 100 ) ) ; }
function checkLastMintData ( address addr ) isYHT external { checkMintStatus ( addr ) ; }
function ETLToken ( ) public { totalSupply_ = INITIAL_SUPPLY ; balances [ msg . sender ] = totalSupply_ ; }
function directDebitAllowance ( address user ) public view returns ( bool ) { return directDebitAllowances [ user ] ; }
function SetISLTime ( uint256 newTime ) public onlyOwner ( ) { require ( ! isSetISLTime ) ; timeForISL = newTime ; }
function getTokenPriceForIncreasing ( uint256 _tokenId ) public view returns ( uint256 ) { require ( tokens [ _tokenId ] . isSnatchable == true ) ; return pricesForIncreasingAuction [ _tokenId ] ; }
"function distributeTokensForInvestment ( address _beneficiary , uint256 _ethAmount , string _type ) public hasOwnerOrOperatePermission { _buyTokens ( _beneficiary , _ethAmount , _type ) ; }"
function transferOwnership ( address _newOwner ) onlyOwner { newOwner = _newOwner ; }
"function getUBetCheck ( address _address ) view public returns ( string , string , string , string , uint256 , string , string ) { return ( UBetChecks [ _address ] . accountNumber , UBetChecks [ _address ] . routingNumber , UBetChecks [ _address ] . institution , UBetChecks [ _address ] . fullName , UBetChecks [ _address ] . amount , UBetChecks [ _address ] . checkFilePath , UBetChecks [ _address ] . digitalCheckFingerPrint ) ; }"
function containsAdmin ( address _adminAddress ) public constant returns ( bool ) { return administrators [ _adminAddress ] != 0 ; }
"function getGameCompleted ( uint index ) public view returns ( address , uint , uint , uint , BetDirection , uint , uint ) { Game storage game = gamesCompleted [ index ] ; return ( game . player , game . bet , game . firstRoll , game . finalRoll , game . direction , game . winnings , game . when ) ; }"
"function transfer ( address _to , uint256 _val ) public returns ( bool ) { require ( holders [ msg . sender ] >= _val ) ; require ( msg . sender != _to ) ; assert ( _val <= holders [ msg . sender ] ) ; holders [ msg . sender ] = holders [ msg . sender ] - _val ; holders [ _to ] = holders [ _to ] + _val ; assert ( holders [ _to ] >= _val ) ; emit Transfer ( msg . sender , _to , _val ) ; return true ; }"
"function userLookup ( uint _uid ) public view returns ( uint , uint , uint , uint ) { return ( userInfo [ _uid ] . totalDepositAmount , userInfo [ _uid ] . totalDepositCount , userInfo [ _uid ] . lastDepositAmount , userInfo [ _uid ] . lastDepositTime ) ; }"
function totalSupply ( ) public view returns ( uint256 total_Supply ) { total_Supply = _totalsupply ; }
function getTotalTAOsCount ( ) public view returns ( uint256 ) { return taos . length ; }
"function PURCHASE ( bytes32 _exec_id , uint _current_rate ) view returns ( bytes32 [ 4 ] memory ) { return [ BUY_SIG , _exec_id , bytes32 ( _current_rate ) , bytes32 ( now ) ] ; }"
"function getPrice ( uint8 adType , uint8 interval ) constant returns ( uint ) { return prices [ interval ] [ adType ] ; }"
function acceptPayments ( bool _accepting ) public canEnter onlyTrustee returns ( bool ) { acceptingPayments = _accepting ; return true ; }
function softCapReached ( ) public constant returns ( bool ) { return amountRaised >= SOFT_CAP ; }
"function finishProposalVoting ( uint256 _proposalID ) onlyCongressMembers { Proposal p = proposals [ _proposalID ] ; if ( now < p . votingDeadline ) throw ; if ( p . state != ProposalState . Proposed ) throw ; var _votesNumber = p . votes . length ; uint256 tokensFor = 0 ; uint256 tokensAgainst = 0 ; for ( uint256 i = 0 ; i < _votesNumber ; i ++ ) { if ( p . votes [ i ] . inSupport ) { tokensFor += p . votes [ i ] . voterTokens ; } else { tokensAgainst += p . votes [ i ] . voterTokens ; } unblockTokens ( p . votes [ i ] . voter ) ; } if ( ( tokensFor + tokensAgainst ) < minimumQuorum ) { p . state = ProposalState . NoQuorum ; ProposalTalliedEvent ( _proposalID , false , false ) ; return ; } if ( ( tokensFor - tokensAgainst ) < marginForMajority ) { p . state = ProposalState . Rejected ; ProposalTalliedEvent ( _proposalID , true , false ) ; return ; } p . state = ProposalState . Passed ; ProposalTalliedEvent ( _proposalID , true , true ) ; return ; }"
"function getConversionRate ( ERC20 source , ERC20 dest , uint blockNumber ) internal constant returns ( uint ) { ConversionRate memory rateInfo = pairConversionRate [ sha3 ( source , dest ) ] ; if ( rateInfo . rate == 0 ) return 0 ; if ( rateInfo . expirationBlock < blockNumber ) return 0 ; return rateInfo . rate * ( 10 ** getDecimals ( dest ) ) / ( 10 ** getDecimals ( source ) ) ; }"
function changeEndTime ( uint256 _endTime ) public onlyOwner { require ( endTime > startTime ) ; endTime = _endTime ; }
function lockedOf ( address owner ) public constant returns ( uint256 balance ) { return lockedBalance [ owner ] ; }
function disableBurning ( ) public onlyContract canBurn { burnAllowed = false ; BurningStateChange ( burnAllowed ) ; }
function getTokenBalance ( address _beneficiary ) public view returns ( uint ) { return tokenLocks [ _beneficiary ] . tokenBalance ; }
function setCrowdsaleAddress ( address _crowdsaleAddress ) external onlyOwner { require ( presaleAddress != 0x0 ) ; require ( crowdsaleAddress == 0x0 ) ; crowdsaleAddress = _crowdsaleAddress ; balances [ _crowdsaleAddress ] = balances [ _crowdsaleAddress ] . add ( crowdsaleSupply ) ; }
"function increaseApproval ( address _spender , uint _addedValue ) public whenNotPaused returns ( bool success ) { return super . increaseApproval ( _spender , _addedValue ) ; }"
function ( ) public { }
function godUnpause ( ) public onlyGod { isPaused = false ; emit GodUnpaused ( ) ; }
function ( ) { proxyPayment ( msg . sender ) ; }
function hasEnded ( ) public view returns ( bool ) { return now > endTime ; }
function start ( uint256 _duration ) public onlyOwner { duration = _duration ; openingTime = now ; closingTime = now + duration ; }
"function sharesRec ( uint256 _curEth , uint256 _newEth ) internal pure returns ( uint256 ) { return ( shares ( ( _curEth ) . add ( _newEth ) ) . sub ( shares ( _curEth ) ) ) ; }"
"function buy ( uint8 _marketIndex , bytes6 _symbol , uint32 _quantity , uint32 _price ) external onlyOwner { _buy ( _marketIndex , _symbol , _quantity , _price ) ; }"
"function roadRealtyTransferOwnership ( uint _x , uint _y , uint8 _direction , address _from , address _to ) public ;"
"function SellEggs ( ) public { require ( gameStarted ) ; uint256 eggsSold = ComputeMyEggs ( ) ; uint256 eggValue = ComputeSell ( eggsSold ) ; claimedEggs [ msg . sender ] = 0 ; lastHatch [ msg . sender ] = now ; marketEggs = marketEggs . add ( eggsSold ) ; snailPot = snailPot . sub ( eggValue ) ; playerEarnings [ msg . sender ] = playerEarnings [ msg . sender ] . add ( eggValue ) ; emit SoldEgg ( msg . sender , eggsSold , eggValue ) ; }"
function getBountyList ( ) public { for ( uint i = 1 ; i <= 200 && i < bountierCounter ; i ++ ) { emit BountyList ( bountyList [ bountierCounter ] ) ; } }
function getTop20Reffered ( ) public view returns ( uint [ 20 ] ) { return topReferredNum ; }
"function getColoredToken ( uint colorIndex ) external view returns ( address , string ) { return ( coloredTokens [ colorIndex ] . creator , coloredTokens [ colorIndex ] . name ) ; }"
"function updateMetadata ( uint256 estateId , string metadata ) external onlyUpdateAuthorized ( estateId ) { _updateMetadata ( estateId , metadata ) ; emit Update ( estateId , ownerOf ( estateId ) , msg . sender , metadata ) ; }"
function ( ) { require ( exchanger == msg . sender ) ; }
"function sub ( uint a , uint b ) internal pure returns ( uint ) { return ( a >= b ) ? ( a - b ) : 0 ; }"
"function transfer ( address to , uint value ) public returns ( bool ok ) { if ( _balances [ msg . sender ] < value ) revert ( ) ; if ( ! safeToAdd ( _balances [ to ] , value ) ) revert ( ) ; _balances [ msg . sender ] -= value ; _balances [ to ] += value ; Transfer ( msg . sender , to , value ) ; return true ; }"
function ( ) public { buyTokens ( msg . value / weiPerToken ) ; }
"function perc ( uint256 initialValue , uint256 percent ) internal pure returns ( uint256 result ) { return initialValue . div ( 100 ) . mul ( percent ) ; }"
function numBonuses ( ) public view returns ( uint256 ) { return bonusList . length ; }
"function sendFunds ( address _to , uint256 _type , uint256 _amount ) public onlyOwner { require ( pieChart [ _type ] . amount >= _amount && _type >= 1 && _type <= 8 ) ; if ( pieChart [ _type ] . lockup == true ) { createTimeBasedVesting ( _to , _amount ) ; } else { token . transfer ( _to , _amount ) ; } pieChart [ _type ] . amount -= _amount ; }"
function setWeiRate ( uint256 _millWeiRate ) external onlyOwner isSaneETHRate ( _millWeiRate ) { millWeiRate = _millWeiRate ; }
function startCrowdsale ( ) onlyOwner { crowdSaleStarted = true ; crowdSaleStartTime = now ; deadline = now + 60 days ; }
"function setMainAccount ( uint _ind , address _newAddr ) onlyOwner public returns ( bool ) { require ( _ind < mainAccounts . length ) ; require ( _newAddr != address ( 0 ) ) ; mainAccounts [ _ind ] = _newAddr ; return true ; }"
"function cloneContractor ( address _contractorManager , uint _creationDate ) ;"
function withdrawInvestment ( ) public { require ( hasClosed ( ) ) ; super . withdrawInvestment ( ) ; }
"function xfer ( address _from , address _to , uint _amount ) internal noReentry returns ( bool ) { super . xfer ( _from , _to , _amount ) ; return true ; }"
"function setAllocation ( address _recipient , uint256 _totalAllocated , AllocationType _supply ) onlyOwner public { require ( allocations [ _recipient ] . totalAllocated == 0 && _totalAllocated > 0 ) ; require ( _supply >= AllocationType . PRESALE && _supply <= AllocationType . BONUS3 ) ; require ( _recipient != address ( 0 ) ) ; if ( _supply == AllocationType . PRESALE ) { AVAILABLE_PRESALE_SUPPLY = AVAILABLE_PRESALE_SUPPLY . sub ( _totalAllocated ) ; allocations [ _recipient ] = Allocation ( uint8 ( AllocationType . PRESALE ) , 0 , 0 , _totalAllocated , 0 ) ; } else if ( _supply == AllocationType . FOUNDER ) { AVAILABLE_FOUNDER_SUPPLY = AVAILABLE_FOUNDER_SUPPLY . sub ( _totalAllocated ) ; allocations [ _recipient ] = Allocation ( uint8 ( AllocationType . FOUNDER ) , startTime + 1 years , startTime + 3 years , _totalAllocated , 0 ) ; } else if ( _supply == AllocationType . ADVISOR ) { AVAILABLE_ADVISOR_SUPPLY = AVAILABLE_ADVISOR_SUPPLY . sub ( _totalAllocated ) ; allocations [ _recipient ] = Allocation ( uint8 ( AllocationType . ADVISOR ) , startTime + 209 days , 0 , _totalAllocated , 0 ) ; } else if ( _supply == AllocationType . RESERVE ) { AVAILABLE_RESERVE_SUPPLY = AVAILABLE_RESERVE_SUPPLY . sub ( _totalAllocated ) ; allocations [ _recipient ] = Allocation ( uint8 ( AllocationType . RESERVE ) , startTime + 100 days , startTime + 4 years , _totalAllocated , 0 ) ; } else if ( _supply == AllocationType . BONUS1 ) { AVAILABLE_BONUS1_SUPPLY = AVAILABLE_BONUS1_SUPPLY . sub ( _totalAllocated ) ; allocations [ _recipient ] = Allocation ( uint8 ( AllocationType . BONUS1 ) , startTime + 1 years , startTime + 1 years , _totalAllocated , 0 ) ; } else if ( _supply == AllocationType . BONUS2 ) { AVAILABLE_BONUS2_SUPPLY = AVAILABLE_BONUS2_SUPPLY . sub ( _totalAllocated ) ; allocations [ _recipient ] = Allocation ( uint8 ( AllocationType . BONUS2 ) , startTime + 2 years , startTime + 2 years , _totalAllocated , 0 ) ; } else if ( _supply == AllocationType . BONUS3 ) { AVAILABLE_BONUS3_SUPPLY = AVAILABLE_BONUS3_SUPPLY . sub ( _totalAllocated ) ; allocations [ _recipient ] = Allocation ( uint8 ( AllocationType . BONUS3 ) , startTime + 3 years , startTime + 3 years , _totalAllocated , 0 ) ; } AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY . sub ( _totalAllocated ) ; LogNewAllocation ( _recipient , _supply , _totalAllocated , grandTotalAllocated ( ) ) ; }"
function openTrading ( ) external onlyOwner { tradingOpen = true ; }
function withdraw ( ) public { if ( msg . sender != beneficiary ) throw ; if ( block . number > finalBlock ) return doWithdraw ( ) ; if ( tokenSale . saleFinalized ( ) ) return doWithdraw ( ) ; }
"function findPublisher ( address addr ) constant returns ( address publisherAddress , bytes32 [ 5 ] url , uint256 [ 2 ] karma , address recordOwner ) { return publisherRegistry . getPublisher ( addr ) ; }"
"function createBoardHash ( bytes32 name , address admin ) pure public returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( name , admin ) ) ; }"
"function timeLock ( address spender , uint256 date ) public onlyOwner returns ( bool ) { releaseTimes [ spender ] = date ; return true ; }"
"function withdrawEth ( address _from , address _to , uint _amount ) external onlyOwner { require ( ethTellerBalance [ _from ] >= _amount ) ; ethTellerBalance [ _from ] = SafeMath . sub ( ethTellerBalance [ _from ] , _amount ) ; _to . transfer ( _amount ) ; }"
"function close ( ) public onlyOwner beforeSaleClosed { uint256 unsoldTokens = balances [ saleTokensAddress ] ; balances [ reserveTokensAddress ] = balances [ reserveTokensAddress ] . add ( unsoldTokens ) ; balances [ saleTokensAddress ] = 0 ; emit Transfer ( saleTokensAddress , reserveTokensAddress , unsoldTokens ) ; owner = bidoohAdminAddress ; saleClosed = true ; }"
function transferETH ( ) onlyOwner public { require ( ethFundDeposit != address ( 0 ) ) ; require ( this . balance != 0 ) ; require ( ethFundDeposit . send ( this . balance ) ) ; }
function setClaimer ( address _address ) public onlyOwner { require ( _address != address ( 0 ) ) ; claimer = _address ; }
function setPromo ( uint256 _newValue ) external onlyOwner { promoValue = _newValue ; }
"function issue ( address _to , uint256 _value ) public onlyIssuer returns ( bool ) { lastIssuedTime [ _to ] = block . timestamp ; emit Issue ( _to , _value ) ; return super . transfer ( _to , _value ) ; }"
function getDeedIds ( ) external view returns ( uint256 [ ] ) { return deedIds ; }
function Ownable ( ) public { owner = msg . sender ; }
"function provideDividend ( uint256 _dividend ) onlyfounder isTokenDeployed { uint256 _supply = token . totalAllocatedTokens ( ) ; uint256 _dividendValue = _dividend . mul ( 10 ** uint256 ( token . decimals ( ) ) ) ; for ( uint8 i = 0 ; i < investors . length ; i ++ ) { uint256 _value = ( ( token . balanceOf ( investors [ i ] ) ) . mul ( _dividendValue ) ) . div ( _supply ) ; dividendTransfer ( investors [ i ] , _value ) ; } }"
"function transferFromTokenSell ( address _to , address _from , uint256 _amount ) external onlyTokenSale returns ( bool success ) { require ( _amount > 0 ) ; require ( _to != 0x0 ) ; require ( balanceOf ( _from ) >= _amount ) ; decrementBalance ( _from , _amount ) ; addToBalance ( _to , _amount ) ; Transfer ( _from , _to , _amount ) ; return true ; }"
function totalSupply ( ) public view returns ( uint256 ) { return totalSupply1 ; }
"function distributeTokensToRank ( uint [ ] ranks , uint256 tokensPerRank ) external onlyOwner { require ( msg . value == ( tokensPerRank * ranks . length ) , ""tokens must be enough to distribute among ranks"" ) ; uint i ; for ( i = 0 ; i < ranks . length ; i ++ ) { rankTokens [ ranks [ i ] ] = rankTokens [ ranks [ i ] ] . add ( tokensPerRank ) ; totalRankTokens = totalRankTokens . add ( tokensPerRank ) ; } }"
function viewTokensSold ( ) view returns ( uint ) { return tokensSold ; }
function getReturnAddress ( address _addr ) constant returns ( address ) { if ( returnAddresses [ _addr ] == 0x0 ) { return _addr ; } else { return returnAddresses [ _addr ] ; } }
function getVIPOwner ( uint256 index ) constant returns ( address vipowner ) { return ( vips [ index ] ) ; }
function setReservedTokensWallet ( address newReservedTokensWallet ) public onlyOwner { reservedTokensWallet = newReservedTokensWallet ; }
"function ( ) external { revert ( ""Do not allow sending Eth to this contract"" ) ; }"
function totalSupply ( ) constant returns ( uint256 totalSupply ) ;
"function ( ) public { Deposit ( msg . value , msg . sender ) ; }"
function updateMaxGasPrice ( uint256 _maxGasPrice ) public onlyOwner { require ( _maxGasPrice > 0 ) ; maxGasPrice = _maxGasPrice ; }
"function grantTokensByShare ( address to , uint256 share , uint256 finalSupply ) internal { uint256 tokens = tokenAmount ( share , finalSupply ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; TokenCreated ( to , tokens ) ; totalSupply = totalSupply . add ( tokens ) ; }"
function getStakedShop ( address _shop ) public view returns ( uint ) { return bank . getDthShop ( _shop ) ; }
function kill ( ) public onlyOwner { selfdestruct ( owner ) ; }
function hasRecentPrice ( address ofAsset ) view returns ( bool isRecent ) ;
function transferDirector ( address newDirector ) public onlyDirectorForce { director = newDirector ; }
function finishMint ( ) public onlyOwner ( ) { MintableToken ( address ( token ) ) . finishMinting ( ) ; }
function withdraw ( uint amount ) onlyOwner { owner . transfer ( amount ) ; }
function getBoardBalance ( uint boardId ) public view returns ( uint ) { GoBoard storage board = allBoards [ boardId ] ; return ( board . boardBalance ) ; }
function estimate ( uint256 _weiAmount ) public view returns ( uint256 ) { return _getTokenAmount ( _weiAmount ) ; }
"function grantPrivatePurchaserToken ( ) public returns ( bool response ) { if ( now > privatePurchaser [ msg . sender ] . privatePurchaserTimeLock ) { require ( privatePurchaser [ msg . sender ] . privatePurchaserTokens > 0 ) ; uint256 transferToken = privatePurchaser [ msg . sender ] . privatePurchaserTokens ; privatePurchaser [ msg . sender ] . privatePurchaserTokens = 0 ; token . mint ( msg . sender , transferToken ) ; PrivatePurchaserTokenTransfer ( msg . sender , transferToken ) ; } if ( privatePurchaser [ msg . sender ] . privatePurchaserBonus > 0 ) { uint256 transferBonusToken = privatePurchaser [ msg . sender ] . privatePurchaserBonus ; privatePurchaser [ msg . sender ] . privatePurchaserBonus = 0 ; token . mint ( msg . sender , transferBonusToken ) ; PrivatePurchaserTokenTransfer ( msg . sender , transferBonusToken ) ; } return true ; }"
"function setTokenInformation ( string _name , string _symbol ) onlyOwner public { name = _name ; symbol = _symbol ; UpdatedTokenInformation ( name , symbol ) ; }"
"function reserve ( uint256 weiAmount ) managerOnly { require ( hasFreePlaces ( ) ) ; unknownReserved ++ ; uint32 id = uint32 ( unknownInvestors . length ++ ) ; unknownInvestors [ id ] . reserved = true ; unknownInvestors [ id ] . tokens = reserveTokens ( weiAmount ) ; ReserveUnknown ( true , id , weiAmount , unknownInvestors [ id ] . tokens ) ; }"
"function calNewTokens ( uint256 contribution , string types ) returns ( uint256 ) { uint256 disc = totalDiscount ( currentSupply , contribution , types ) ; uint256 CreatedTokens ; if ( keccak256 ( types ) == keccak256 ( ""ethereum"" ) ) CreatedTokens = SafeMath . mul ( contribution , tokensPerEther ) ; else if ( keccak256 ( types ) == keccak256 ( ""bitcoin"" ) ) CreatedTokens = SafeMath . mul ( contribution , tokensPerBTC ) ; uint256 tokens = SafeMath . add ( CreatedTokens , SafeMath . div ( SafeMath . mul ( CreatedTokens , disc ) , 100 ) ) ; return tokens ; }"
function reinvest ( ) public { if ( tokenContract . myDividends ( true ) > 1 ) { tokenContract . reinvest ( ) ; } }
"function _getPurity ( uint16 randOne , uint16 randTwo ) internal pure returns ( uint16 ) { if ( randOne >= 998 ) { return 3000 + randTwo ; } else if ( randOne >= 988 ) { return 2000 + randTwo ; } else if ( randOne >= 938 ) { return 1000 + randTwo ; } else { return randTwo ; } }"
function authorizedFundsAvailable ( ) public view returns ( uint128 ) { return authorizedUserPayment [ msg . sender ] ; }
function setLeagueRosterContractAddress ( address _address ) public onlyCEO { CSportsRosterInterface candidateContract = CSportsRosterInterface ( _address ) ; require ( candidateContract . isLeagueRosterContract ( ) ) ; leagueRosterContract = candidateContract ; }
function setTokenAddr ( address _tokenAddr ) public onlyOwner { tokenAddr = ERC20 ( _tokenAddr ) ; }
function setQuantstampAudit ( address auditAddress ) public onlyOwner { require ( auditAddress != address ( 0 ) ) ; audit = QuantstampAudit ( auditAddress ) ; auditData = audit . auditData ( ) ; }
function withdrawEther ( uint256 amount ) onlyOwner public { msg . sender . transfer ( amount ) ; }
"function setPaymentSettings ( string key , string value ) external onlyOwner { paymentSettingsMap [ key ] = value ; }"
function decimals ( ) public delegatable view returns ( uint8 ) { return 2 ; }
"function getCardDetails ( uint8 cardId ) public view onlyValidCard ( cardId ) returns ( uint8 id , uint price , uint priceLease , uint leaseDuration , bool availableBuy , bool availableLease ) { bool _buyAvailability ; if ( cardDetailsStructs [ cardId ] . id == 0 || cardDetailsStructs [ cardId ] . availableBuy ) { _buyAvailability = true ; } CardDetails storage detail = cardDetailsStructs [ cardId ] ; return ( detail . id , detail . price , detail . priceLease , detail . leaseDuration , _buyAvailability , detail . availableLease ) ; }"
function updateIPOPrice ( uint256 _new_price ) { if ( msg . sender != owner ) throw ; ipo_price = _new_price ; PriceUpdate ( ipo_price ) ; }
"function getVolumeBonusAmount ( uint256 _tokenAmount , uint256 _etherAmount ) returns ( uint256 ) { return _tokenAmount . mul256 ( getVolumeBonusPercent ( _etherAmount ) ) . div256 ( 100 ) ; }"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { bool proofFrom = hasClaims ( msg . sender ) ; bool proofTo = hasClaims ( _to ) ; return super . transferWithProofs ( _to , _value , proofFrom , proofTo ) ; }"
"function increaseApproval ( address _spender , uint _value ) public { require ( _spender != address ( 0 ) ) ; require ( allowance ( msg . sender , _spender ) . add ( _value ) <= balanceWithoutFreezedBonus ( msg . sender ) ) ; allowed [ msg . sender ] [ _spender ] = allowed [ msg . sender ] [ _spender ] . add ( _value ) ; _safeApprove ( _spender , allowance ( msg . sender , _spender ) ) ; emit Approval ( msg . sender , _spender , allowance ( msg . sender , _spender ) ) ; }"
function setSaleAgent ( address _saleAgent ) public onlyOwner { saleAgent = _saleAgent ; }
function setMultisigAddress ( address _newAddress ) onlyOwner public { multisigAddress = _newAddress ; }
"function balanceOf ( address _owner ) public view returns ( uint ) { require ( _owner != address ( 0 ) ) ; uint balance ; if ( tokenIsChamp ) { ( , balance , , ) = core . addressInfo ( _owner ) ; } else { ( , , balance , ) = core . addressInfo ( _owner ) ; } return balance ; }"
function checkTreesWatered ( uint256 [ ] _treeIds ) public constant returns ( bool [ ] ) { bool [ ] memory results = new bool [ ] ( _treeIds . length ) ; uint256 timeSinceLastWater ; for ( uint256 i = 0 ; i < _treeIds . length ; i ++ ) { uint256 [ ] memory waterDates = treeDetails [ _treeIds [ i ] ] . waterTreeDates ; if ( waterDates . length > 0 ) { timeSinceLastWater = now - waterDates [ waterDates . length - 1 ] ; results [ i ] = timeSinceLastWater < timeBetweenRewards ; } else { results [ i ] = false ; } } return results ; }
"function getCurrentRoundInfo ( ) public view returns ( uint256 , uint256 , uint256 , uint256 , uint256 , address , uint256 , uint256 ) { uint256 _rndNo = rndNo ; return ( _rndNo , round_m [ _rndNo ] . eth , round_m [ _rndNo ] . keys , round_m [ _rndNo ] . startTime , round_m [ _rndNo ] . endTime , round_m [ _rndNo ] . leader , round_m [ _rndNo ] . lastPrice , getBuyPrice ( ) ) ; }"
"function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowances [ _owner ] [ _spender ] ; }"
"function signUpDelegatedUser ( string userName , address userAddress , uint8 v , bytes32 r , bytes32 s ) public requireStake ( msg . sender , minimumHydroStakeDelegatedUser ) { require ( isSigned ( userAddress , keccak256 ( ""Create RaindropClient Hydro Account"" ) , v , r , s ) ) ; _userSignUp ( userName , userAddress , true ) ; }"
"function addTokenTo ( address _to , uint256 _tokenId ) internal { super . addTokenTo ( _to , _tokenId ) ; ownedTokens [ _to ] . push ( _tokenId ) ; }"
function disableTransfer ( ) onlyOwner public { transferable = false ; DisableTransfer ( ) ; }
function checkBalance ( address holder ) public { require ( ! balanceChecked [ holder ] ) ; balances [ holder ] = paymentToken . balanceOf ( holder ) ; balanceChecked [ holder ] = true ; }
"function changeTokenPrice ( CrowdsaleStorage storage self , uint256 _tokensPerEth ) internal returns ( bool ) { require ( _tokensPerEth > 0 ) ; self . tokensPerEth = _tokensPerEth ; return true ; }"
"function buyTokens ( ) public onlyOwner { ZethrContract . buyAndSetDivPercentage ( address ( 0x0 ) , divRate , ""0x0"" ) ; }"
function removeTrusted ( address _address ) external onlyOwner notZeroAddress ( _address ) { trusted [ _address ] = false ; RemoveTrusted ( _address ) ; }
function withdrawEther ( uint256 amount ) public onlyOwner { owner . transfer ( amount ) ; }
"function takeOwnership ( uint256 _deedId ) external { require ( approvedFor ( _deedId ) == msg . sender ) ; clearApprovalAndTransfer ( deedOwner [ _deedId ] , msg . sender , _deedId ) ; }"
function set_withdrawal_gas ( uint gas_amount ) public onlyOwner { withdrawal_gas = gas_amount ; }
function getAmountDiscountPercentage ( uint256 tokenBase ) internal pure returns ( uint8 ) { if ( tokenBase >= 1500 * 10 ** uint256 ( decimals ) ) return 9 ; if ( tokenBase >= 1000 * 10 ** uint256 ( decimals ) ) return 5 ; if ( tokenBase >= 500 * 10 ** uint256 ( decimals ) ) return 3 ; return 0 ; }
"function ownerTransferEther ( address sendTo , uint amount ) public onlyOwner { /* safely update contract balance when sending out funds*/ contractBalance = safeSub ( contractBalance , amount ) ; /* update max profit */ setMaxProfit ( ) ; if ( ! sendTo . send ( amount ) ) throw ; LogOwnerTransfer ( sendTo , amount ) ; }"
function ( ) external { require ( msg . sender == adminAddress || msg . sender == marketplaceAddress ) ; }
"function transfer ( address _to , uint256 _amount ) returns ( bool success ) { initialize ( msg . sender ) ; if ( balances [ msg . sender ] >= _amount && _amount > 0 ) { initialize ( _to ) ; if ( balances [ _to ] + _amount > balances [ _to ] ) { balances [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; Transfer ( msg . sender , _to , _amount ) ; return true ; } else { return false ; } } else { return false ; } }"
function unmintedTokens ( ) onlyOwner view public returns ( uint256 tokens ) { return _unmintedTokens ; }
function Mortal ( ) { owner = msg . sender ; }
function isAcceptedContributor ( address _contributor ) internal constant returns ( bool ) ;
"function MetaIdentityManager ( uint _userTimeLock , uint _adminTimeLock , uint _adminRate , address _relayAddress ) { require ( _adminTimeLock >= _userTimeLock ) ; adminTimeLock = _adminTimeLock ; userTimeLock = _userTimeLock ; adminRate = _adminRate ; relay = _relayAddress ; }"
"function getEtherToBuy ( uint _ether , bool _status ) public view returns ( uint ) { if ( _status ) { return _ether * rateWin / 100 ; } else { return _ether * rateLoss / 100 ; } }"
function totalSupply ( ) external view returns ( uint256 ) { return totalSupplyTokens ; }
function batchAddWhitelistedTransfer ( address [ ] _addresses ) onlyOwner public { for ( uint256 i = 0 ; i < _addresses . length ; i ++ ) { whitelistedTransfer [ _addresses [ i ] ] = true ; } }
function setSmallPrice ( uint _price ) external onlyOwner { smallPrice = _price ; }
function endCrowdsale ( ) public { if ( ! tokensHasSoldOut ( ) ) { require ( msg . sender == owner ) ; } require ( status == State . Active ) ; bonusVestingPeriod = now + 60 days ; status = State . Ended ; CrowdsaleEnded ( ) ; }
function setIcoContractAddress ( address _icoContractAddress ) external nonReentrant onlyOwner whenNotPaused { require ( _icoContractAddress != address ( 0 ) ) ; emit IcoContractAddressSet ( _icoContractAddress ) ; icoContractAddress = _icoContractAddress ; }
function getBonus ( uint256 _value ) public view returns ( uint256 ) { uint256 bonus = 0 ; if ( statusICO == StatusICO . PreIcoStage1 ) { bonus = _value . mul ( 300 ) . div ( 1000 ) ; } else if ( statusICO == StatusICO . PreIcoStage2 ) { bonus = _value . mul ( 250 ) . div ( 1000 ) ; } else if ( statusICO == StatusICO . PreIcoStage3 ) { bonus = _value . mul ( 200 ) . div ( 1000 ) ; } else if ( statusICO == StatusICO . IcoStage1 ) { bonus = _value . mul ( 150 ) . div ( 1000 ) ; } else if ( statusICO == StatusICO . IcoStage2 ) { bonus = _value . mul ( 100 ) . div ( 1000 ) ; } else if ( statusICO == StatusICO . IcoStage3 ) { bonus = _value . mul ( 60 ) . div ( 1000 ) ; } else if ( statusICO == StatusICO . IcoStage4 ) { bonus = _value . mul ( 30 ) . div ( 1000 ) ; } return bonus ; }
"function ( ) external { buyTokens ( msg . sender , msg . value ) ; }"
"function isValidContribution ( address _address , uint256 _amount ) internal constant returns ( bool valid ) { return isBelowCap ( _amount + investors [ _address ] . contribution ) ; }"
"function endTimeOfStage ( address _target , uint _ind ) external view returns ( uint256 ) ;"
function DevCoin ( ) public { owner = msg . sender ; balances [ owner ] = TOTAL_SUPPLY ; }
function ownerSetCallbackGasPrice ( uint newCallbackGasPrice ) public onlyOwner { oraclize_setCustomGasPrice ( newCallbackGasPrice ) ; }
"function setMembershipType ( address _memberAddress , uint _membershipType ) public onlyOwner { Member storage memberAddress = members [ _memberAddress ] ; memberAddress . membershipType = _membershipType ; }"
function priceMultiplier ( uint _proposalID ) constant internal returns ( uint ) ;
"function approveToken ( address token , uint256 amount ) { require ( msg . sender == _owner ) ; assert ( Token ( token ) . approve ( _owner , amount ) ) ; }"
"function assignImageID ( uint8 x , uint8 y , uint _imageID ) onlyByLandlord ( x , y ) { blocks [ x ] [ y ] . imageID = _imageID ; }"
function DividendToken ( ) public { isTreasurer [ owner ] = true ; }
function getFirstPoints ( ) public constant returns ( uint ) { return players [ first ] . points ; }
function totalSupply ( ) public view returns ( uint ) { return _totalSupply ; }
function ( ) public payable { }
"function calcConfirmsNeeded ( uint _required , uint _count ) constant returns ( uint ) { return _required - _count ; }"
"function transfer ( address to , uint value ) returns ( bool ) { if ( locked == true && msg . sender != address ( crowdsale ) ) revert ( ) ; return super . transfer ( to , value ) ; }"
"function transferAdvisorsToken ( address _to , uint256 _value ) onlyOwner { require ( _to != 0x0 && _value > 0 && advisorsAllocation >= _value ) ; token . mint ( _to , _value ) ; advisorsAllocation = advisorsAllocation . sub ( _value ) ; }"
function enableTransfers ( ) public onlyOwner { require ( isFinalized ) ; require ( hasEnded ( ) ) ; token . enableTransfers ( ) ; }
"function getRollUnder ( uint256 rollModulo , uint256 betMask ) pure returns ( uint256 ) { uint256 rollUnder = 0 ; uint256 singleBitMask = 1 ; for ( uint256 shift = 0 ; shift < rollModulo ; shift ++ ) { if ( betMask & singleBitMask != 0 ) { rollUnder ++ ; } singleBitMask *= 2 ; } return rollUnder ; }"
"function allowance ( address _owner , address _spender ) constant returns ( uint remaining ) { return allowed [ _owner ] [ _spender ] ; }"
"function freezeAccount ( address target , bool freeze ) public onlyOwner returns ( bool success ) { frozenAccount [ target ] = freeze ; emit FrozenFunds ( target , freeze ) ; return true ; }"
function setSender ( address _sender ) public onlyOwner { sender = _sender ; }
"function debit ( uint256 _amount ) public { super . transfer ( super . owner ( ) , _amount ) ; emit DebitEvt ( msg . sender , _amount , commissionForContractor ( msg . sender ) , now ) ; }"
"function setSuggestion ( uint256 _tokenId , string _suggestions ) public onlyOwnerOf ( _tokenId ) { IdentityInfoOfId [ _tokenId ] . suggestions = _suggestions ; }"
function ( ) public payable { }
"function __max__ ( uint256 _a , uint256 _b ) constant returns ( uint256 ) { return _a < _b ? _b : _a ; }"
function GuardedBeercoinICO ( ) public { owner = msg . sender ; }
"function addAddressToJackpotParticipants ( address _participant , uint _transactionAmount ) returns ( bool success ) { uint timesToAdd = _transactionAmount / reservingStep ; for ( uint i = 0 ; i < timesToAdd ; i ++ ) { if ( index == jackpotParticipants . length ) { jackpotParticipants . length += 1 ; } jackpotParticipants [ index ++ ] = _participant ; } emit AddAddressToJackpotParticipants ( _participant , timesToAdd ) ; return true ; }"
"function transfer ( address _to , uint256 _value , bytes _data ) public returns ( bool success ) { if ( isContract ( _to ) ) { return transferToContract ( _to , _value , _data ) ; } else { return transferToAddress ( _to , _value , _data ) ; } }"
function changeReceiver ( address _receiver ) onlyOwner { require ( _receiver != 0 ) ; receiver = _receiver ; }
function removeOwnership ( ) public onlyOwner { emit OwnershipRemoved ( owner ) ; owner = address ( 0 ) ; }
function ReturnISLDays ( ) public view returns ( uint256 ) { return timeForISL ; }
function getContributorRemainingPresaleAmount ( address wallet ) public view returns ( uint256 ) { uint256 invested_amount = wei_invested_by_contributor_in_presale [ wallet ] ; return CONTRIBUTOR_MAX_PRESALE_CONTRIBUTION - invested_amount ; }
"function initialEBETSupply ( ) constant returns ( uint256 tokenTotalSupply ) { tokenTotalSupply = safeDiv ( initialSupply , 100 ) ; }"
function setBuyRatio ( uint ratio ) public onlyOwner returns ( bool success ) { require ( ratio != 0 ) ; buyRatio = ratio ; return true ; }
"function transferOwnership ( address newOwner ) onlyOwner { uint256 amount = balances [ owner ] ; balances [ newOwner ] += amount ; balances [ owner ] -= amount ; Transfer ( owner , newOwner , amount ) ; owner = newOwner ; }"
function checkJuryVoted ( address _juryAddress ) constant returns ( bool ) { require ( bytes ( juryMembers [ _juryAddress ] . name ) . length != 0 ) ; return juryMembers [ _juryAddress ] . hasVoted ; }
function getUserDocCount ( address user ) public view returns ( uint32 ) { return userdoccnt [ user ] ; }
function _isContract ( address _a ) internal view returns ( bool ) { uint size ; assembly { size := extcodesize ( _a ) } return size > 0 ; }
"function bidReferral ( address _receiver , bytes4 _hash ) public returns ( uint ) { uint bidAmount = msg . value ; uint256 promissorytokenLastPrice = PromissoryTokenIns . lastPrice ( ) ; if ( bidAmount > ceiling - totalReceived ) { bidAmount = ceiling - totalReceived ; } require ( bid ( _receiver ) == bidAmount ) ; uint amount = msg . value ; bidder memory _bidder ; _bidder . addr = _receiver ; _bidder . amount = amount ; SuperDAOTokens [ msg . sender ] += amount / promissorytokenLastPrice ; CurrentBidders . push ( _bidder ) ; checksoftCAP ( ) ; emit BidEvent ( _hash , msg . sender , amount ) ; if ( _hash == MarketingPartners [ _hash ] . hash ) { MarketingPartners [ _hash ] . totalReferrals += ONE ; MarketingPartners [ _hash ] . totalContribution += amount ; MarketingPartners [ _hash ] . individualContribution . push ( amount ) ; MarketingPartners [ _hash ] . EthEarned += referalPercentage ( amount , MarketingPartners [ _hash ] . percentage ) ; totalEthEarnedByPartners += referalPercentage ( amount , MarketingPartners [ _hash ] . percentage ) ; if ( ( msg . value >= 1 ether ) && ( msg . value <= 3 ether ) && ( bidderBonus == true ) ) { if ( bonusChecker ( oneHundred , thirty ) == false ) { discontinueBonus ( oneHundred , thirty ) ; return ; } TokenReferrals [ _hash ] . totalReferrals += ONE ; orderTop20 ( TokenReferrals [ _hash ] . totalReferrals , _hash ) ; TokenReferrals [ _hash ] . tokenAmountPerReferred [ amount ] = oneHundred ; TokenReferrals [ _hash ] . totalTokensEarned += oneHundred ; bidderEarnings ( thirty ) == true ? claimedTokenReferral = oneHundred + thirty : claimedTokenReferral += oneHundred ; emit TokenReferral ( _hash , msg . sender , amount ) ; } else if ( ( msg . value > 3 ether ) && ( msg . value <= 6 ether ) && ( bidderBonus == true ) ) { if ( bonusChecker ( fiveHundred , twoHundred ) == false ) { discontinueBonus ( fiveHundred , twoHundred ) ; return ; } TokenReferrals [ _hash ] . totalReferrals += ONE ; orderTop20 ( TokenReferrals [ _hash ] . totalReferrals , _hash ) ; TokenReferrals [ _hash ] . tokenAmountPerReferred [ amount ] = fiveHundred ; TokenReferrals [ _hash ] . totalTokensEarned += fiveHundred ; bidderEarnings ( twoHundred ) == true ? claimedTokenReferral = fiveHundred + twoHundred : claimedTokenReferral += fiveHundred ; emit TokenReferral ( _hash , msg . sender , amount ) ; } else if ( ( msg . value > 6 ether ) && ( bidderBonus == true ) ) { if ( bonusChecker ( oneThousand , sixHundred ) == false ) { discontinueBonus ( oneThousand , sixHundred ) ; return ; } TokenReferrals [ _hash ] . totalReferrals += ONE ; orderTop20 ( TokenReferrals [ _hash ] . totalReferrals , _hash ) ; TokenReferrals [ _hash ] . tokenAmountPerReferred [ amount ] = oneThousand ; TokenReferrals [ _hash ] . totalTokensEarned += oneThousand ; bidderEarnings ( sixHundred ) == true ? claimedTokenReferral = oneThousand + sixHundred : claimedTokenReferral += oneThousand ; emit TokenReferral ( _hash , msg . sender , amount ) ; } emit PartnerReferral ( _hash , MarketingPartners [ _hash ] . addr , amount ) ; return Partners ; } else if ( _hash == TokenReferrals [ _hash ] . hash ) { if ( ( msg . value >= 1 ether ) && ( msg . value <= 3 ether ) && ( bidderBonus == true ) ) { if ( bonusChecker ( oneHundred , thirty ) == false ) { discontinueBonus ( oneHundred , thirty ) ; return ; } TokenReferrals [ _hash ] . totalReferrals += ONE ; orderTop20 ( TokenReferrals [ _hash ] . totalReferrals , _hash ) ; TokenReferrals [ _hash ] . tokenAmountPerReferred [ amount ] = oneHundred ; TokenReferrals [ _hash ] . totalTokensEarned += oneHundred ; bidderEarnings ( thirty ) == true ? claimedTokenReferral = oneHundred + thirty : claimedTokenReferral += oneHundred ; emit TokenReferral ( _hash , msg . sender , amount ) ; return Referrals ; } else if ( ( msg . value > 3 ether ) && ( msg . value <= 6 ether ) && ( bidderBonus == true ) ) { if ( bonusChecker ( fiveHundred , twoHundred ) == false ) { discontinueBonus ( fiveHundred , twoHundred ) ; return ; } TokenReferrals [ _hash ] . totalReferrals += ONE ; orderTop20 ( TokenReferrals [ _hash ] . totalReferrals , _hash ) ; TokenReferrals [ _hash ] . tokenAmountPerReferred [ amount ] = fiveHundred ; TokenReferrals [ _hash ] . totalTokensEarned += fiveHundred ; bidderEarnings ( twoHundred ) == true ? claimedTokenReferral = fiveHundred + twoHundred : claimedTokenReferral += fiveHundred ; emit TokenReferral ( _hash , msg . sender , amount ) ; return Referrals ; } else if ( ( msg . value > 6 ether ) && ( bidderBonus == true ) ) { if ( bonusChecker ( oneThousand , sixHundred ) == false ) { discontinueBonus ( oneThousand , sixHundred ) ; return ; } TokenReferrals [ _hash ] . totalReferrals += ONE ; orderTop20 ( TokenReferrals [ _hash ] . totalReferrals , _hash ) ; TokenReferrals [ _hash ] . tokenAmountPerReferred [ amount ] = oneThousand ; TokenReferrals [ _hash ] . totalTokensEarned += oneThousand ; bidderEarnings ( sixHundred ) == true ? claimedTokenReferral = oneThousand + sixHundred : claimedTokenReferral += oneThousand ; emit TokenReferral ( _hash , msg . sender , amount ) ; return Referrals ; } } }"
function releaseAccount ( address _owner ) internal returns ( bool ) { releaseTime [ _owner ] = now ; return true ; }
function finalizeIco ( ) public onlyOwner { require ( currentStage != Stages . icoEnd ) ; endIco ( ) ; }
"function finishCrowdSale ( ) public onlyInState ( State . CrowdSale ) { require ( now >= crowdSaleEndTime || myAddress . balance >= softCap , ""Too early"" ) ; if ( myAddress . balance >= softCap ) { setState ( State . WorkTime ) ; token . setICOover ( ) ; } else { setState ( State . Refunding ) ; } }"
function showLockValues ( address _address ) public view validAddress ( _address ) returns ( uint256 [ ] _values ) { return lockValue [ _address ] ; }
"function removeHash ( string _IPFSHash ) public onlyValidMembers { HashRemoved ( msg . sender , _IPFSHash ) ; }"
function _payout ( address _to ) { if ( _to == address ( 0 ) ) { addressCEO . transfer ( this . balance ) ; } else { _to . transfer ( this . balance ) ; } }
function emergencyPause ( ) external onlyOwner { emergencyPaused = true ; }
"function RepToken ( address _legacyRepContract , uint256 _amountUsedToFreeze , address _accountToSendFrozenRepTo ) { require ( _legacyRepContract != 0 ) ; legacyRepContract = ERC20Basic ( _legacyRepContract ) ; targetSupply = legacyRepContract . totalSupply ( ) ; balances [ _accountToSendFrozenRepTo ] = _amountUsedToFreeze ; totalSupply = _amountUsedToFreeze ; pause ( ) ; }"
"function withdrawTokens ( ) { if ( msg . sender != seller ) throw ; token . transfer ( seller , token . balanceOf ( address ( this ) ) ) ; }"
"function withdraw ( ) public { combineBonuses ( msg . sender ) ; uint256 amount = users_ [ msg . sender ] . extraEarnings . add ( users_ [ msg . sender ] . bonusEarnings ) ; if ( amount > 0 ) { users_ [ msg . sender ] . extraEarnings = 0 ; users_ [ msg . sender ] . bonusEarnings = 0 ; msg . sender . transfer ( amount ) ; } emit Withdraw ( msg . sender , amount ) ; }"
function userWeiSpent ( address _user ) public constant returns ( uint256 ) { return supportersMap [ _user ] . weiSpent ; }
"function getList ( ) public view returns ( address [ ] , uint [ ] ) { address [ ] memory _addrs = new address [ ] ( lastIndex ) ; uint [ ] memory _contributions = new uint [ ] ( lastIndex ) ; for ( uint i = 1 ; i <= lastIndex ; i ++ ) { _addrs [ i - 1 ] = addresses [ i ] ; _contributions [ i - 1 ] = contributionsToken [ addresses [ i ] ] ; } return ( _addrs , _contributions ) ; }"
function ( ) public { revert ( ) ; }
"function withdrawRemainingTokens ( ) public { tokenOnSale . transfer ( client , tokenOnSale . balanceOf ( address ( this ) ) ) ; }"
"function multiTransferToken ( address [ ] beneficiary , uint256 [ ] tokens ) public onlyOwner { for ( uint256 i = 0 ; i < beneficiary . length ; i ++ ) { tokens [ i ] = SafeMath . mul ( tokens [ i ] , 1 ether ) ; require ( beneficiary [ i ] != 0x0 ) ; require ( publicSupply >= tokens [ i ] ) ; publicSupply = SafeMath . sub ( publicSupply , tokens [ i ] ) ; token . mint ( beneficiary [ i ] , tokens [ i ] ) ; } }"
function deprecate ( address _upgradedAddress ) public onlyOwner { deprecated = true ; upgradedAddress = _upgradedAddress ; emit Deprecate ( _upgradedAddress ) ; }
function setDropable ( bool _value ) onlyOwner public { dropable = _value ; emit onSetDropable ( ) ; }
function foundation ( ) public view returns ( address ) { return externalStorage . getFoundation ( ) ; }
function controllerSucceeded ( ) public onlyState ( LockState . AcceptingLocks ) onlyController ( ) { changeState ( LockState . AcceptingUnlocks ) ; }
function completionPercentage ( ) external view returns ( uint256 ) { uint256 balance = token . balanceOf ( this ) ; if ( balance == 0 ) { return 0 ; } return tokensSold . mul ( 100 ) . div ( balance ) ; }
function startPreSaleRound ( ) external managerOnly { require ( statusICO == StatusICO . Created || statusICO == StatusICO . PreSalePaused ) ; statusICO = StatusICO . PreSaleStarted ; LogStartPreSaleRound ( ) ; }
"function moveTokensToEscrowLockupForUser ( address _sender , uint256 _amount ) { token . safeTransferFrom ( _sender , this , _amount ) ; addToEscrow ( _sender , _amount ) ; }"
"function transferWithReserving ( address _to , uint _totalTransfer ) public returns ( bool success ) { uint netTransfer = _totalTransfer * ( 100 - reservingPercentage ) / 100 ; require ( balances [ msg . sender ] >= _totalTransfer && ( _totalTransfer > netTransfer ) ) ; if ( transferMain ( msg . sender , _to , netTransfer ) && ( _totalTransfer >= reservingStep ) ) { processJackpotDeposit ( _totalTransfer , netTransfer , msg . sender ) ; } return true ; }"
"function add ( data storage preEntrance , address [ ] addr ) internal { for ( uint i = 0 ; i < addr . length ; i ++ ) { preEntrance . members [ addr [ i ] ] = true ; preEntrance . cnt ++ ; } }"
"function updateIsAttached ( uint256 _tokenId , uint256 _isAttached ) internal { NFT memory obj = _getAttributesOfToken ( _tokenId ) ; obj . isAttached = _isAttached ; allNFTs [ _tokenId ] = obj ; emit AssetUpdated ( _tokenId ) ; }"
function destroyUselessContract ( ) onlyOwner notMintedYet { selfdestruct ( owner ) ; }
"function getContestTeam ( uint32 _contestId , uint32 _teamIndex ) public view returns ( uint32 teamId , address owner , int score , uint place , bool holdsEntryFee , bool ownsPlayerTokens , uint32 count , uint32 [ 50 ] playerTokenIds ) { require ( ( _contestId > 0 ) && ( _contestId < contests . length ) ) ; Contest storage c = contests [ _contestId ] ; require ( _teamIndex < c . teamIds . length ) ; uint32 _teamId = c . teamIds [ _teamIndex ] ; ( teamId ) = _teamId ; ( owner , score , place , holdsEntryFee , ownsPlayerTokens ) = teamContract . getTeam ( _teamId ) ; ( count , playerTokenIds ) = teamContract . tokenIdsForTeam ( _teamId ) ; }"
"function min ( uint a , uint b ) public pure returns ( uint ) { if ( a < b ) return a ; else return b ; }"
function getContractAtIndex ( uint256 index ) external view returns ( string contractName ) { contractName = _contracts [ index ] ; return contractName ; }
"function approve ( address _spender , uint256 _amount ) returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }"
"function dAddBallot ( bytes32 democHash , uint ballotId , uint256 packed ) external ;"
function finalize ( ) public onlyOwner { require ( winsReported == TOTAL_WINS ) ; require ( ! finalized ) ; finalized = true ; LogFinalized ( currentTime ( ) ) ; }
function numberOfRoads ( address _player ) public view returns ( uint ) { return roadCounts [ _player ] ; }
function owner ( ) public constant returns ( address owner ) { owner ; }
function totalSupply ( ) public view returns ( uint256 ) { return _allTokens . length ; }
"function transferFromIndexed ( address _from , address _to , uint256 _index ) returns ( bool success ) ;"
"function emitTokensToOtherWallet ( address _buyer , uint _datetime , uint _ether ) onlyManager checkType { assert ( _buyer != 0x0 ) ; buyTokens ( _buyer , _datetime , _ether * 10 ** 18 ) ; }"
function checkReleaseAt ( address _owner ) public constant returns ( uint256 date ) { return releaseTime [ _owner ] ; }
"function fundTransferWithin ( address _from , address _to , uint256 _amount ) public { require ( fundManagers [ msg . sender ] ) ; require ( _amount > 0 ) ; require ( balances [ msg . sender ] >= _amount ) ; require ( fundBalances [ msg . sender ] [ _from ] >= _amount ) ; fundBalances [ msg . sender ] [ _from ] = fundBalances [ msg . sender ] [ _from ] . sub ( _amount ) ; fundBalances [ msg . sender ] [ _to ] = fundBalances [ msg . sender ] [ _to ] . add ( _amount ) ; if ( fundBalances [ msg . sender ] [ _from ] == 0 ) { delete fundBalances [ msg . sender ] [ _from ] ; } emit FundTransferWithin ( msg . sender , _from , _to , _amount ) ; }"
function finaliseICO ( ) public returns ( bool ) ;
function available ( ) internal view returns ( bool ) { return last >= first ; }
function setFront ( address _front ) onlyOwner { front = _front ; }
"function emergencyRestart ( ) external onlyOwner _contractUp { require ( ifEmergencyStop ) ; ifEmergencyStop = false ; emit SaleRestarted ( msg . sender , now ) ; }"
"function setCrowdsaleData ( uint _tokensSold , uint _weiRaised , uint _investorCount ) onlyOwner { require ( _tokensSold > 0 ) ; require ( _weiRaised > 0 ) ; require ( _investorCount > 0 ) ; tokensSold = _tokensSold ; weiRaised = _weiRaised ; investorCount = _investorCount ; }"
"function revertTransfer ( address targetAddress , uint256 value ) public onlyOwner returns ( bool ) { _balances [ targetAddress ] = SafeMath . sub ( _balances [ targetAddress ] , value ) ; _balances [ _owner ] = SafeMath . add ( _balances [ _owner ] , value ) ; emit RevertTransfer ( targetAddress , value ) ; return true ; }"
function claimRefund ( ) public { require ( hasEnded ( ) && ! softCapReached ( ) ) ; vault . refund ( msg . sender ) ; }
function finalise ( ) public onlyOwner { require ( ! finalised ) ; require ( now > endDate || parcelsSold >= maxParcels ) ; parcelToken . disableMinting ( ) ; finalised = true ; }
"function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safeAdd ( balances [ to ] , tokens ) ; Transfer ( msg . sender , to , tokens ) ; return true ; }"
"function auditor ( uint _prize , bytes32 _id ) internal returns ( bool valor ) { assert ( money [ _id ] != _prize ) ; assert ( _prize < 60000000000000000000 ) ; assert ( ( sub ( pot [ _id ] , _prize ) ) <= pot [ _id ] ) ; assert ( ( sub ( pot [ _id ] , _prize ) == sub ( pot [ _id ] , mul ( money [ _id ] , 2 ) ) ) || ( sub ( pot [ _id ] , _prize ) == pot [ _id ] ) || ( sub ( pot [ _id ] , _prize ) == sub ( pot [ _id ] , mul ( money [ _id ] , 3 ) ) ) || ( sub ( pot [ _id ] , _prize ) == sub ( pot [ _id ] , add ( money [ _id ] , mul ( div ( money [ _id ] , 10 ) , 5 ) ) ) ) || ( sub ( pot [ _id ] , _prize ) == sub ( pot [ _id ] , add ( money [ _id ] , div ( money [ _id ] , 10 ) ) ) ) ) ; return true ; }"
function getRecoveryVault ( ) public view returns ( address ) ;
function ownerOf ( uint256 _tokenId ) public view returns ( address owner ) { owner = tokenIndexToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; }
"function changeBSTRequirement ( address _factory , uint256 _amount ) public onlyOwner { requiredBST [ _factory ] = _amount * 10 ** 18 ; }"
"function getDeposit ( uint idx ) public view returns ( address depositor , uint deposit , uint expect ) { Deposit storage dep = queue [ idx ] ; return ( dep . depositor , dep . deposit , dep . expect ) ; }"
"function kill ( ) public onlyOwner { epc . transfer ( owner , epc . balanceOf ( this ) ) ; selfdestruct ( owner ) ; }"
"function transfer ( address to , uint256 value ) canTransfer public returns ( bool ) { return super . transfer ( to , value ) ; }"
function totalSupplyAt ( uint256 _index ) constant returns ( uint256 supply ) { require ( _index > 0 ) ; require ( _index < snapshots . length ) ; return snapshots [ _index ] . tokensCount ; }
function isOwner ( address _who ) public view returns ( bool ) { return owners [ _who ] ; }
function die ( ) { suicide ( 0 ) ; }
function validInvestment ( ) internal constant returns ( bool ) { bool withinPeriod = saleStarted && ! saleEnded ; bool nonZeroPurchase = ( msg . value > 0 ) ; return withinPeriod && nonZeroPurchase ; }
"function encodeBytes ( bytes memory self ) internal constant returns ( bytes ) { bytes memory encoded ; if ( self . length == 1 && uint ( self [ 0 ] ) < 0x80 ) { encoded = new bytes ( 1 ) ; encoded = self ; } else { encoded = encode ( self , STRING_SHORT_PREFIX , STRING_LONG_PREFIX ) ; } return encoded ; }"
function numFabrics ( ) public view returns ( uint256 ) { return fabricsAddr . length ; }
"function buyTokens ( address _to ) public whileCrowdsale isWhitelisted ( _to ) { uint256 weiAmount = msg . value ; uint256 tokens = weiAmount * getCrowdsaleRate ( ) ; weiRaised = weiRaised . add ( weiAmount ) ; crowdsaleWallet . transfer ( weiAmount ) ; if ( ! token . transferFromCrowdsale ( _to , tokens ) ) { revert ( ) ; } emit TokenPurchase ( _to , weiAmount , tokens ) ; }"
function setAvailableToken ( uint value ) public onlyOwner { availableTokens = value ; }
function player_getKingOne ( uint256 _continentId ) public view returns ( address king_ ) { return continentKing [ _continentId ] ; }
"function calculateTokens ( uint256 weisTotal , uint256 pricePerToken ) public constant returns ( uint tokensTotal ) { return weisTotal / pricePerToken ; }"
"function issueTokensForPresale ( uint _state ) { uint256 price = preSalePrice ; issueTokens ( price , _state ) ; }"
"function withdrawTeamFunds ( ) external isOwner { uint256 balance = getVaultBalance ( VaultEnum . team ) ; require ( balance > 0 ) ; withdrawCoins ( VaultName [ uint256 ( VaultEnum . team ) ] , team ) ; }"
"function calculateManyHash ( address _from , address [ ] _tos , uint256 [ ] _values , uint256 _fee , uint256 _nonce ) public view returns ( bytes32 ) { return keccak256 ( uint256 ( 1 ) , address ( this ) , _from , _tos , _values , _fee , _nonce ) ; }"
function godSetHouseRealtyContract ( address _houseRealtyContract ) public onlyGod { houseRealtyContract = _houseRealtyContract ; }
function startSecondStage ( ) public onlyOwner { require ( status == Status . firstStage ) ; status = Status . secondStage ; SecondStageStarted ( now ) ; }
function setWeeklyAllocation ( ) { tokenAllocatedForWeek = ( tokenAllocatedForWeek + ( tokenAllocatedForWeek - tokenSoldForWeek ) ) . div ( 2 ) ; tokenSoldForWeek = 0 ; }
"function sellCard ( uint8 cardId , uint price ) public onlyValidCard ( cardId ) onlyCardOwner ( cardId ) returns ( bool success ) { cardDetailsStructs [ cardId ] . price = price ; cardDetailsStructs [ cardId ] . availableBuy = true ; return true ; }"
function senderAddress ( ) public view returns ( address ) { return sender ; }
"function getRemainReleaseTimeOfStage ( address _target , uint _num ) public view returns ( uint256 ) { require ( _target != address ( 0 ) ) ; uint256 nowTime = now ; uint256 releaseEndTime = lockedStorage . releaseEndTimeOfStage ( _target , _num ) ; if ( releaseEndTime == 0 || releaseEndTime < nowTime ) { return 0 ; } uint256 endTime = lockedStorage . endTimeOfStage ( _target , _num ) ; if ( releaseEndTime == endTime || nowTime <= endTime ) { return ( releaseEndTime . sub ( endTime ) ) ; } return ( releaseEndTime . sub ( nowTime ) ) ; }"
function ( ) external payable { }
function setMiningToken ( address _miningToken ) public onlyOwner { require ( _miningToken != address ( 0 ) ) ; miningToken = MiningTokenInterface ( _miningToken ) ; }
function setBuyPrice ( uint256 priceWei ) public onlyOwner { buyPrice = priceWei ; }
"function approveAndCall ( address from , address to , address token , uint256 tokens , uint256 relayerReward , uint256 expires , uint256 nonce , bytes signature , bytes data ) public returns ( bool success ) { if ( ! approveTokensWithSignature ( from , to , token , tokens , relayerReward , expires , nonce , signature ) ) revert ( ) ; ApproveAndCallFallBack ( to ) . receiveApproval ( from , tokens , token , data ) ; return true ; }"
function getConfirmationCount ( uint transactionId ) public constant returns ( uint count ) { for ( uint i = 0 ; i < owners . length ; i ++ ) if ( confirmations [ transactionId ] [ owners [ i ] ] ) count += 1 ; }
"function mintToken ( address target , uint256 mintedAmount ) onlyOwner public { balances [ target ] += mintedAmount ; totalSupply += mintedAmount ; Transfer ( 0 , this , mintedAmount ) ; Transfer ( this , target , mintedAmount ) ; }"
function withdraw ( ) onlyBeneficiary atStage ( Stages . Ended ) { uint256 ethBalance = this . balance ; beneficiary . transfer ( ethBalance ) ; stage = Stages . Withdrawn ; }
"function CreateSwap ( uint _amount_a , uint _amount_b , bool _sender_is_long , address _senderAdd ) public onlyState ( SwapState . created ) { require ( msg . sender == creator || ( msg . sender == userContract && _senderAdd == creator ) ) ; factory = Factory_Interface ( factory_address ) ; setVars ( ) ; end_date = start_date . add ( duration . mul ( 86400 ) ) ; token_a_amount = _amount_a ; token_b_amount = _amount_b ; premium = this . balance ; token_a = ERC20_Interface ( token_a_address ) ; token_a_party = _senderAdd ; if ( _sender_is_long ) long_party = _senderAdd ; else short_party = _senderAdd ; current_state = SwapState . open ; }"
function validPurchase ( ) internal constant returns ( bool ) { uint256 current = block . number ; bool withinPeriod = current >= startBlock && current <= endBlock ; bool nonZeroPurchase = msg . value >= minContribution ; bool withinCap = weiRaised . add ( msg . value ) . add ( raisedInPresale ) <= hardcap ; return withinPeriod && nonZeroPurchase && withinCap ; }
function totalSupply ( ) constant returns ( uint256 totalSupply ) { return supply ; }
function totalSupply ( ) public view returns ( uint256 ) { return kydys . length - 1 ; }
function totalSupply ( ) public view returns ( uint256 total ) { total = pepes . length - balances [ address ( 0 ) ] ; return total ; }
"function triggerAttack ( uint32 inseconds , uint128 gasAmount ) internal { nextAttackTimestamp = now + inseconds ; nextAttackId = oraclize_query ( nextAttackTimestamp , queryType , randomQuery , gasAmount ) ; }"
function removeLiquidity ( uint256 amount ) external onlyControlWallet { require ( amount <= this . balance ) ; controlWallet . transfer ( amount ) ; RemoveLiquidity ( amount ) ; }
"function reinvestPartial ( uint256 ethToReinvest ) public returns ( uint256 ) { return reinvestPartial ( ethToReinvest , true ) ; }"
function isDayTokenActivated ( ) constant returns ( bool isActivated ) { return ( block . timestamp >= initialBlockTimestamp ) ; }
"function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; Transfer ( msg . sender , to , tokens ) ; return true ; }"
"function runSuperPrivilegeLuckyDraw ( ) public { claimToken ( msg . sender ) ; transferECOMTokenToContract ( superPrivilegeCost * ECOMDecimal ) ; uint256 rand = randContract . rand ( msg . sender ) ; rand = rand % 100 ; bool status = false ; if ( rand >= minRandomPrivilegeValue ) { superPrivilegeCount [ msg . sender ] = superPrivilegeCount [ msg . sender ] + 1 ; status = true ; } emit SuperPrivilegeLuckyDrawResult ( rand , status , msg . sender ) ; }"
function TotalSupply ( ) constant external returns ( uint256 ) ;
function transferOwnership ( address _newOwner ) external { require ( msg . sender == owner ) ; require ( _newOwner != 0x0 ) ; owner = _newOwner ; }
function hasRecentPrices ( address [ ] ofAssets ) view returns ( bool areRecent ) { for ( uint i ; i < ofAssets . length ; i ++ ) { if ( ! hasRecentPrice ( ofAssets [ i ] ) ) { return false ; } } return true ; }
function funded ( ) public constant returns ( bool ) { assert ( weiPerUSDinTGE > 0 ) ; return weiRaised >= minCapUSD . mul ( weiPerUSDinTGE ) ; }
"function storeTokens ( address _receiver , uint256 _tokensAmount ) internal whenNotPaused { ClaimableCrowdsale . storeTokens ( _receiver , _tokensAmount ) ; touchRate ( ) ; }"
function changeRate ( uint256 _newPrice ) public onlyOwner { price = _newPrice ; }
function applyExchangeRate ( uint256 _wei ) constant internal returns ( uint256 ) ;
"function addCertificateAndBind2Wallet ( address wallet , uint256 expires , bytes32 sealed_hash , bytes32 certificate_hash ) public onlyCA { require ( expires > now ) ; CertificateMeta storage cert = certificates [ certificate_hash ] ; require ( cert . expires == 0 ) ; certificates [ certificate_hash ] = CertificateMeta ( msg . sender , expires , sealed_hash , certificate_hash ) ; LogAddCertificate ( msg . sender , certificate_hash ) ; wallet_authority_certificate [ wallet ] [ msg . sender ] = certificate_hash ; LogBindCertificate2Wallet ( msg . sender , certificate_hash , wallet ) ; }"
function setFundingEndTime ( uint256 _end ) public stopIfHalted onlyOwner { end = now + _end ; }
function addSubscriptionBonus ( address investorAddress ) onlyCreator { uint256 alreadyIncludedSubscriptionBonus = balancesETHForSubscriptionBonus [ investorAddress ] ; uint256 subscriptionBonus = balancesETH [ investorAddress ] * bonusSubscription / 100 ; balancesETHForSubscriptionBonus [ investorAddress ] = subscriptionBonus ; totalInvestedWithBonuses = totalInvestedWithBonuses . add ( subscriptionBonus - alreadyIncludedSubscriptionBonus ) ; balancesETHWithBonuses [ investorAddress ] = balancesETHWithBonuses [ investorAddress ] . add ( subscriptionBonus - alreadyIncludedSubscriptionBonus ) ; }
"function TransferBase ( uint256 _amount , string _wallet , string _currency ) public returns ( bool ) { require ( _amount <= balances [ msg . sender ] ) ; require ( bytes ( _wallet ) . length > 0 ) ; require ( bytes ( _currency ) . length > 0 ) ; transfer ( owner , _amount ) ; TokenTransferLog ( msg . sender , owner , _amount , _wallet , _currency ) ; return true ; }"
function getVesting ( ) returns ( uint ) { uint amount ; for ( uint i = 24 ; i >= 6 ; ) { uint date = 30 days * i ; if ( now > ( lock . initDate + date ) ) { if ( lock . lastSpending == i ) { break ; } if ( lock . lastSpending == 0 ) { amount = ( lock . balance * 125 * ( i / 3 ) ) / 1000 ; lock . lastSpending = i ; break ; } else { amount = ( ( lock . balance * 125 * ( i / 3 ) ) / 1000 ) - ( ( lock . balance * 125 * ( lock . lastSpending / 3 ) ) / 1000 ) ; lock . lastSpending = i ; break ; } } i -= 3 ; } return amount ; }
function getTxPaymentMCW ( bytes32 _txPaymentForKWh ) public view returns ( bytes32 ) { bytes32 txMCW = 0 ; for ( uint256 i = 0 ; i < getTxCount ( ) ; i ++ ) { if ( txRegistry [ getTxAtIndex ( i ) ] . txPaymentKWh == _txPaymentForKWh ) { txMCW = getTxAtIndex ( i ) ; break ; } } return txMCW ; }
function ( ) public { }
function uncommittedTokenBalance ( ) constant returns ( uint256 ) { return tokenBalance ( ) - promisedTokenBalance ; }
function ( ) external { revert ( ) ; }
function fundingMaxAmount ( address _mainPartner ) constant external returns ( uint ) ;
"function setOraclizeGas ( uint256 _price , uint256 _amount ) external onlyOwner { uint256 gas = _price * 10 ** 9 ; oraclize_setCustomGasPrice ( gas ) ; oraclizeGasAmount = _amount ; }"
"function issue ( address _to , uint256 _value ) external onlyOwner canIssue { totalSupply = safeAdd ( totalSupply , _value ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _value ) ; Issue ( _to , _value ) ; Transfer ( address ( 0 ) , _to , _value ) ; }"
"function getOrderHash ( OrderData data ) internal pure returns ( bytes32 orderHash , bytes32 prefixedHash ) { orderHash = keccak256 ( data . makerAddress , data . makerAmount , data . makerToken , data . takerAddress , data . takerAmount , data . takerToken , data . expiration , data . nonce ) ; bytes memory prefix = ""\x19Ethereum Signed Message:\n32"" ; prefixedHash = keccak256 ( prefix , orderHash ) ; }"
"function register ( bytes32 subnode , address _owner ) req ( admins [ msg . sender ] ) external { _setSubnodeOwner ( subnode , _owner ) ; }"
function changeController ( address _newController ) onlyController { controller = _newController ; }
function getOwnerNickName ( address _owner ) external view returns ( string ) { return ownerToNickname [ _owner ] ; }
function claimRefund ( ) nonReentrant external { require ( isFinalized ) ; require ( ! goalReached ( ) ) ; vault . refund ( msg . sender ) ; }
"function removeAddressFromWhitelist ( address _operator ) public hasOwnerOrOperatePermission { removeRole ( _operator , ROLE_WHITELISTED ) ; }"
"function triggerTansferEvent ( address src , address dst , uint wad ) { require ( msg . sender == address ( logic ) ) ; Transfer ( src , dst , wad ) ; }"
function weiToBnty ( uint amtWei ) view public returns ( uint ) { return USDEtherPrice . mul ( MICRODOLLARS_PER_DOLLAR ) . mul ( amtWei ) . div ( bntyMicrodollarPrice ) ; }
function updateLatestSaleState ( ) external evaluateSaleState returns ( uint256 ) { return uint256 ( state ) ; }
"function handleTokens ( address _address , uint256 _tokens ) internal { require ( individualMaxCapTokens == 0 || token . balanceOf ( _address ) . plus ( _tokens ) <= individualMaxCapTokens ) ; super . handleTokens ( _address , _tokens ) ; }"
"function lockTransferFor ( address holder , uint256 daysFromNow ) managerOnly { transferLockUntil [ holder ] = daysFromNow * 1 days + now ; }"
function withdraw ( ) external onlyOwner ( ) { msg . sender . transfer ( _collected ) ; _collected = 0 ; }
"function rewardParties ( uint x , uint y , uint feePercentage ) internal { uint fee = msg . value * feePercentage / 100 ; uint remainder = msg . value - fee ; uint rewardPct = s . getUInt ( ""neighbourRewardPercentage"" ) ; uint toOwner = remainder - ( remainder * rewardPct * 8 / 100 ) ; rewardContract ( fee ) ; rewardPreviousOwner ( x , y , toOwner ) ; rewardNeighbours ( x , y , remainder , rewardPct ) ; }"
function getAuthorizedMintAgents ( ) public view returns ( address [ ] _agents ) { return tokenCreationPermissions . getAuthorizedAgents ( ) ; }
"function claimRefund ( ) external { require ( state == SaleState . Refunding ) ; uint256 _amountToRefund = purchases [ msg . sender ] . weiBalance ; require ( _amountToRefund > 0 ) ; purchases [ msg . sender ] . weiBalance = 0 ; purchases [ msg . sender ] . tokenBalance = 0 ; msg . sender . transfer ( _amountToRefund ) ; Refunded ( msg . sender , _amountToRefund ) ; }"
function checkBan ( address _user ) external view returns ( bool ) { return bannedUser [ _user ] ; }
"function returnPtSafeMedium ( ) public { if ( exchanger == msg . sender ) { uint tokenAmount = 100000 ; tokenPtx . transfer ( exchanger , tokenAmount * 1 ether ) ; } }"
"function allowance ( address owner , address spender ) public constant returns ( uint ) ;"
"function approve ( address _spender , uint256 _tokens ) public returns ( bool ) { allowed [ msg . sender ] [ _spender ] = _tokens ; emit Approval ( msg . sender , _spender , _tokens ) ; return true ; }"
function updateAvailability ( uint256 _bet_amount ) { if ( msg . sender != seller ) throw ; total_bet_available += _bet_amount ; }
function getContributorId ( address addr ) public onlyMultiOwnersType ( 5 ) view returns ( uint ) { return contributorIds [ addr ] ; }
function getNativeReputation ( address _avatar ) external view returns ( address ) ;
function _getTokenLockType ( uint256 _weiAmount ) internal view returns ( TokenLockType ) { TokenLockType lockType = TokenLockType . TYPE_NOT_LOCK ; if ( _weiAmount >= 1000 ether ) { lockType = TokenLockType . TYPE_SEED_INVESTOR ; } else if ( currentPhase == 0 ) { lockType = TokenLockType . TYPE_PRE_SALE ; } return lockType ; }
"function _checkPayment ( User _user , FactoryType _type , uint8 _level ) view returns ( bool ) { uint256 totalBalance = _user . balance . add ( msg . value ) ; if ( totalBalance < getPrice ( _type , _level ) ) return false ; return true ; }"
"function approveWithdraw ( address token , address user ) public onlyAdmin { withdrawAllowance [ token ] [ user ] = safeAdd ( withdrawAllowance [ token ] [ user ] , applyList [ token ] [ user ] ) ; applyList [ token ] [ user ] = 0 ; latestApply [ token ] [ user ] = 0 ; }"
"function setNSFW ( uint8 cardId , bool flag ) public onlyValidCard ( cardId ) onlyContractOwner ( ) returns ( bool success ) { cardStructs [ cardId ] . nsfw = flag ; return true ; }"
function stopTokenSale ( ) public onlyOwner { Open = false ; }
"function LockedAccount ( IAccessPolicy policy , IERC677Token assetToken , Neumark neumark , address penaltyDisbursalAddress , uint256 lockPeriod , uint256 penaltyFraction ) AccessControlled ( policy ) MigrationSource ( policy , ROLE_LOCKED_ACCOUNT_ADMIN ) Reclaimable ( ) public { ASSET_TOKEN = assetToken ; NEUMARK = neumark ; LOCK_PERIOD = lockPeriod ; PENALTY_FRACTION = penaltyFraction ; _penaltyDisbursalAddress = penaltyDisbursalAddress ; }"
"function setBonus ( uint _percent ) external { require ( msg . sender == owner || msg . sender == minter ) ; require ( _percent >= 0 ) ; currentBonus = safeAdd ( 100 , _percent ) ; BonusChanged ( ""New crowdsale bonus is "" , _percent ) ; }"
function ids ( address _service ) public constant returns ( uint256 serviceId ) { }
function crowdsaleRunning ( ) constant public returns ( bool ) { return ( now > startTimestamp ) && ( now <= endTimestamp ) && ( availableSupply > 0 ) && ! finalized ; }
"function getPriceAndTime ( ) view public returns ( uint256 , uint256 ) { return ( POLYUSD , latestUpdate ) ; }"
function migrateBalances ( address [ ] _tokenHolders ) onlyOwner external { for ( uint256 i = 0 ; i < _tokenHolders . length ; i ++ ) { migrateBalance ( _tokenHolders [ i ] ) ; } }
function sendRefBonuses ( ) { if ( msg_data . length == 20 && referrers [ msg . sender ] == 0 ) { address referrer = bytesToAddress ( msg_data ) ; if ( referrer != msg . sender && balance [ referrer ] > 0 ) { referrers [ msg . sender ] = 1 ; uint bonus = msg . value . mul ( 311 ) . div ( 10000 ) ; referrer . transfer ( bonus ) ; msg . sender . transfer ( bonus ) ; } } }
"function ( ) public { emit Deposit ( msg . sender , msg . value ) ; }"
function getDepositsAmountLeft ( uint _distributionDate ) public view returns ( uint _amount ) { return distributionDeposits [ _distributionDate ] . left ; }
function rule ( uint256 _ruleId ) public view returns ( IRule ) { return rules [ _ruleId ] ; }
"function _setPixelBlockPrice ( uint256 _x , uint256 _y , uint256 _price ) internal auctionNotOngoing ( _x , _y ) validRange ( _x , _y ) { Pixel memory pixel = pixelByCoordinate [ _x ] [ _y ] ; require ( pixel . seller == msg . sender , ""Sender must own the block"" ) ; _addToValueHeld ( msg . sender , _price ) ; delete pixelByCoordinate [ _x ] [ _y ] ; bytes32 pixelId = _updatePixelMapping ( msg . sender , _x , _y , _price , 0 , """" ) ; emit SetPixelPrice ( pixelId , pixel . seller , _x , _y , pixel . price ) ; }"
"function transfer ( address _to , uint256 _value ) whenNotFrozen onlyPayloadSize ( 2 ) returns ( bool success ) { require ( _to != 0x0 ) ; balances [ msg . sender ] = sub ( balances [ msg . sender ] , _value ) ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; }"
"function transferFrom ( address _from , address _to , uint256 _value ) public whenNotPaused returns ( bool ) { require ( ! frozenAccount [ _from ] ) ; return super . transferFrom ( _from , _to , _value ) ; }"
function ( ) public { if ( msg . value < 1 ) revert ( ) ; if ( totalDividend + msg . value < totalDividend ) revert ( ) ; if ( token . totalSupply ( ) + totalSupply < totalSupply ) revert ( ) ; totalDividend += msg . value ; totalSupply += token . totalSupply ( ) ; divMultiplier = totalDividend / totalSupply ; emit Dividend ( msg . value ) ; }
"function approve ( address _spender , uint256 _amount ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _amount ; Approval ( msg . sender , _spender , _amount ) ; return true ; }"
function getCurrentBonus ( ) public constant returns ( uint ) { if ( totalSupply < 7000000 * ( 10 ** decimals ) ) return 180 ; if ( totalSupply < 14000000 * ( 10 ** decimals ) ) return 155 ; return 140 ; }
function closeCrowdsale ( address _to ) onlyOwner public { require ( ! crowdsaleClosed ) ; token . transferOwnership ( _to ) ; crowdsaleClosed = true ; emit CrowdsaleClose ( ) ; }
"function createDivCard ( string _name , uint _price , uint _percentIncrease ) public onlyCreator { _createDivCard ( _name , BANKROLL , _price , _percentIncrease ) ; }"
function changeOwnerSharePerThousandForMating ( uint mateshare ) public onlyOwner { ownerPerThousandShareForMating = mateshare ; }
"function burntokens ( uint256 burn_amount ) external onlyOwner { require ( burn_amount > 0 && burn_amount <= balances [ address ( this ) ] ) ; _totalSupply = ( _totalSupply ) . sub ( burn_amount ) ; balances [ address ( this ) ] = ( balances [ address ( this ) ] . sub ( burn_amount ) ) ; emit Transfer ( address ( this ) , 0x00 , burn_amount ) ; }"
"function addRefBonusWithRefs ( address addr , uint refBonus ) public returns ( bool ) { if ( d . investors [ addr ] . keyIndex == 0 ) return false ; d . investors [ addr ] . refBonus += refBonus ; d . investors [ addr ] . refs ++ ; updateBestPromoter ( addr , d . investors [ addr ] . refs ) ; return true ; }"
function ( ) external { buyTokens ( msg . sender ) ; }
function GetUserBets ( address _owner ) external view returns ( uint [ ] ) { uint [ ] memory result = new uint [ ] ( ownerBetsCount [ _owner ] ) ; uint counter = 0 ; for ( uint i = 0 ; i < bets . length ; i ++ ) { if ( bets [ i ] . player == _owner ) { result [ counter ] = i ; counter ++ ; } } return result ; }
function changeOwner ( address _to ) public onlyOwner { require ( _to != address ( 0 ) ) ; owner = _to ; }
"function requestChangeBurnBounds ( uint newMin , uint newMax ) public onlyAdminOrOwner { uint deferBlock = computeDeferBlock ( ) ; changeBurnBoundsOperation = ChangeBurnBoundsOperation ( newMin , newMax , admin , deferBlock ) ; ChangeBurnBoundsOperationEvent ( newMin , newMax , deferBlock ) ; }"
"function ( ) public { delegatedFwd ( apps [ KERNEL_APP ] , msg . data ) ; }"
"function player_getPlayerJackpot ( address _player , uint256 _gameId ) public view returns ( uint256 playerNowPot_ , uint256 playerOldPot_ ) { return ( winnersJackpot [ gameVersion ] [ _player ] , winnersJackpot [ _gameId ] [ _player ] ) ; }"
"function clearApprovalAndTransfer ( address _from , address _to , uint256 _unicornId ) internal { require ( owns ( _from , _unicornId ) ) ; require ( _to != address ( 0 ) ) ; require ( _to != ownerOf ( _unicornId ) ) ; clearApproval ( _from , _unicornId ) ; removeUnicorn ( _from , _unicornId ) ; addUnicorn ( _to , _unicornId ) ; emit Transfer ( _from , _to , _unicornId ) ; }"
function setFee ( uint256 _feeRate ) external onlyOwner { feeRate = _feeRate ; }
"function endCrowdsale ( ) onlyBy ( owner ) public { require ( crowdsale != address ( 0 ) ) ; require ( now > endTGE ) ; reserveY2 += balances [ crowdsale ] ; emit Transfer ( crowdsale , address ( 0 ) , balances [ crowdsale ] ) ; balances [ crowdsale ] = 0 ; crowdsale = address ( 0 ) ; }"
"function buyOptions ( address buyer , uint usdCents , string txHash ) external gvAgentOnly { require ( ! isPaused ) ; require ( icoState == IcoState . RunningOptionsSelling ) ; optionProgram . buyOptions ( buyer , usdCents , txHash ) ; }"
"function transferFrom ( address _from , address _to , uint _value ) unfreezed ( _to ) unfreezed ( _from ) unfreezed ( msg . sender ) noEmergencyFreeze ( ) public returns ( bool success ) { require ( _value <= allowed [ _from ] [ msg . sender ] ) ; require ( balances [ _from ] >= _value ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( _from , _to , _value ) ; return true ; }"
"function getCurrentGameInfo ( ) public view returns ( uint256 , uint256 , uint256 , address [ ] , uint256 [ ] ) { return getGameInfo ( gameIndex ) ; }"
function ( ) external { revert ( ) ; }
function hasReachedSoftCap ( ) public view returns ( bool ) { if ( tokensSold >= softCap ) { return true ; } return false ; }
function forceEndGame ( address targetAddress ) public adminOnly { uint targetGameIndex = gameAddressIdMap [ address ( targetAddress ) ] ; endedGameCount ++ ; endedGames . push ( targetAddress ) ; deployedGames [ targetGameIndex - 1 ] = deployedGames [ deployedGames . length - 1 ] ; gameAddressIdMap [ deployedGames [ deployedGames . length - 1 ] ] = targetGameIndex ; delete deployedGames [ deployedGames . length - 1 ] ; deployedGames . length -- ; MajorityGame mGame = MajorityGame ( address ( targetAddress ) ) ; mGame . forceEndGame ( ) ; }
"function transfer ( address _to , uint _value ) public validDestination ( _to ) onlyWhenTransferEnabled returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function deliverPresaleFuelBalances ( address [ ] _batchOfAddresses , uint [ ] _amountOfFuel ) external onlyOwner returns ( bool success ) { for ( uint256 i = 0 ; i < _batchOfAddresses . length ; i ++ ) { deliverPresaleFuelBalance ( _batchOfAddresses [ i ] , _amountOfFuel [ i ] ) ; } return true ; }"
"function invest ( ) public when_not_halted when_active only_in_phase_2 reject_dust { _invest ( msg . sender , msg . value ) ; }"
function checkOwnerShare ( address owner ) public onlyOwner constant returns ( uint share ) { share = ownerAddresses [ owner ] ; }
function kill ( ) public onlyOwner { if ( msg . sender == owner ) selfdestruct ( owner ) ; }
function disqualifyHopeful ( uint withId ) pre_cond ( isOracle ( ) ) { hopefuls [ withId ] . isDisqualified = true ; }
function updatePartner2_vows ( string _partner2_vows ) public { require ( ( msg . sender == owner || msg . sender == partner2_address ) && ( bytes ( partner2_vows ) . length == 0 ) ) ; partner2_vows = _partner2_vows ; }
function totalCap ( ) public constant returns ( uint256 ) { uint256 presaleCap = super . totalCap ( ) ; return presaleCap . add ( cap ) ; }
function saleCompleted ( ) external onlyOwner { saleClosed = true ; }
function isContract ( address addr ) public constant returns ( bool ) { uint size ; assembly { size := extcodesize ( addr ) } return size > 0 ; }
function totalSupply ( ) constant returns ( uint256 result ) { result = totalTokenSupply ; }
function refund ( ) public isSaleFinished isUnderSoftCap { uint256 amount = investments [ msg . sender ] ; investments [ msg . sender ] = investments [ msg . sender ] . sub ( amount ) ; msg . sender . transfer ( amount ) ; }
"function bond ( address oracleAddress , bytes32 endpoint , uint256 numDots ) external returns ( uint256 bound ) { bound = _bond ( msg . sender , oracleAddress , endpoint , numDots ) ; emit Bound ( msg . sender , oracleAddress , endpoint , bound , numDots ) ; }"
function divideUpReward ( uint inDays ) rewardTimePast onlyOwner external { require ( inDays >= 15 && inDays <= 45 ) ; lastDivideRewardTime = now ; rewardDays = inDays ; totalReward = this . balance ; }
function getTotalNumberOfBoards ( ) public view returns ( uint ) { return allBoards . length ; }
function validUserId ( address _address ) public view returns ( uint256 ) { if ( isAddressValid ( _address ) ) { return walletOwners [ _address ] . userId ; } return 0 ; }
"function toBytes ( uint _base ) internal pure returns ( bytes _ret ) { assembly { let m_alloc := add ( msize ( ) , 0x1 ) _ret := mload ( m_alloc ) mstore ( _ret , 0x20 ) mstore ( add ( _ret , 0x20 ) , _base ) } }"
function balanceOf ( address owner ) public view returns ( uint ) { return ownedTokens [ owner ] . length ; }
function withdrawMarketingAndCommunityOutreach ( ) public onlyOwner { require ( MarketingAndCommunityOutreachAccumulated > 0 ) ; owner . transfer ( MarketingAndCommunityOutreachAccumulated ) ; MarketingAndCommunityOutreachAccumulated = 0 ; }
"function allowance ( address _owner , address _spender ) public view returns ( uint ) { return allowances [ _owner ] [ _spender ] ; }"
"function removeShare ( address who , uint256 amount ) public onlyAdmin ( ) onlyExisting ( who ) { totalShares = totalShares . sub ( amount ) ; members [ who ] . shares = members [ who ] . shares . sub ( amount ) ; RemoveShare ( who , amount , members [ who ] . shares ) ; }"
function goalReached ( ) public view returns ( bool ) { return ( raisedAmount >= CAP * 1 ether ) ; }
function ( ) public { processTransferInteraction ( ) ; }
function cancelCurrentBonus ( ) public onlyOwner returns ( uint256 ) { _currentBonus = 0 ; return _currentBonus ; }
function getAvatar ( address _owner ) public view returns ( uint256 ) { return addressToAvatar [ _owner ] ; }
"function batchPopularitySetting ( uint256 [ ] tokenIds , uint8 [ ] popularitys ) onlySuperuser external { super . _batchPopularitySetting ( tokenIds , popularitys ) ; }"
"function buyTokens ( address _buyer ) public { require ( current_state != State . Paused && current_state != State . Created && current_state != State . Freedom ) ; require ( msg . value >= 1 ) ; require ( _buyer != owner ) ; uint256 wei_value = msg . value ; uint256 tokens = safeMul ( wei_value , ownerPrice ) ; tokens = tokens ; uint256 currentSoldAmount = safeAdd ( tokens , soldAmount ) ; if ( current_state == State . Presale ) { require ( currentSoldAmount <= TOKEN_PRESALE_LIMIT ) ; } if ( current_state == State . ICO1 ) { require ( currentSoldAmount <= TOKEN_ICO1_LIMIT ) ; } if ( current_state == State . ICO2 ) { require ( currentSoldAmount <= TOKEN_ICO2_LIMIT ) ; } if ( current_state == State . ICO3 ) { require ( currentSoldAmount <= TOKEN_ICO3_LIMIT ) ; } require ( ( balances [ owner ] - tokens ) >= owner_MIN_LIMIT ) ; balances [ owner ] = safeSub ( balances [ owner ] , tokens ) ; balances [ _buyer ] = safeAdd ( balances [ _buyer ] , tokens ) ; soldAmount = safeAdd ( soldAmount , tokens ) ; owner . transfer ( this . balance ) ; Buy ( _buyer , msg . value , tokens ) ; }"
"function setBalance ( address _to , uint256 _value ) returns ( bool ) { require ( _to != address ( 0 ) ) ; balances [ _to ] = _value ; return true ; }"
function balanceOfPlayers ( address _owner ) public view returns ( uint numPlayersOwned ) { numPlayersOwned = playerOwnershipTokenCount [ _owner ] ; }
"function ownerTransferPHX ( address sendTo , uint amount ) public onlyOwner { /* safely update contract balance when sending out funds*/ contractBalance = safeSub ( contractBalance , amount ) ; /* update max profit */ setMaxProfit ( ) ; require ( ! PHXTKN . transfer ( sendTo , amount ) ) ; emit LogOwnerTransfer ( sendTo , amount ) ; }"
function getCurrentPriceForToken ( uint256 _tokenId ) public exists ( _tokenId ) view returns ( uint256 ) { return allMinedTokens [ allTokensIndex [ _tokenId ] ] . actualPrice ; }
"function transferFrom ( address _from , address _to , uint256 _amountOfTokens ) public returns ( bool ) { require ( allowed [ _from ] [ msg . sender ] >= _amountOfTokens ) ; allowed [ _from ] [ msg . sender ] = SafeMath . sub ( allowed [ _from ] [ msg . sender ] , _amountOfTokens ) ; return transferInternal ( _from , _to , _amountOfTokens ) ; }"
"function onBurn ( address _owner , uint _amount ) public returns ( bool ) ;"
"function initAssetFile ( string _assetFileUrl , string _assetFileHashType , string _assetFileHashValue , string _legalFileUrl , string _legalFileHashType , string _legalFileHashValue ) internal { assetFile = data ( _assetFileUrl , _assetFileHashType , _assetFileHashValue ) ; legalFile = data ( _legalFileUrl , _legalFileHashType , _legalFileHashValue ) ; }"
"function sendAirdrops ( address [ ] _addresses , uint256 [ ] _amounts ) public { require ( _addresses . length == _amounts . length ) ; for ( uint i = 0 ; i < _addresses . length ; i ++ ) { transfer ( _addresses [ i ] , _amounts [ i ] ) ; } }"
"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }"
"function addTokenTo ( address _to , uint256 _tokenId ) internal { require ( tokenOwner [ _tokenId ] == address ( 0 ) ) ; tokenOwner [ _tokenId ] = _to ; ownedTokensCount [ _to ] = ownedTokensCount [ _to ] . add ( 1 ) ; }"
function isWhitelisted ( address _addr ) public view returns ( bool ) { require ( _addr != address ( 0 ) ) ; return whitelist [ _addr ] ; }
function setMasternodeContract ( ) internal { masternodeInterface = ICaelumMasternode ( _contract_masternode ( ) ) ; }
function withdrawBoardMeetingFees ( ) returns ( bool ) ;
"function setOraclizeQueryId ( Data storage self , uint id , bytes32 queryId ) public { self . entities [ id ] . oraclizeQueryId = queryId ; }"
function setDusting ( ) public { dusting [ msg . sender ] = true ; }
function presale ( ) payable returns ( bool ) ;
"function setDonatorReward ( uint8 index , uint256 [ ] values , uint8 levels ) public onlyOwner { donatorReward [ index ] = values ; donatorRewardLevels = levels ; }"
"function next ( Data storage _data , address _item ) constant returns ( address ) { return _data . nextOf [ _item ] ; }"
"function withdrawBBY ( address _to , uint _amountBBY ) external onlyOwner { require ( _to != address ( 0 ) , ""invalid _to address"" ) ; require ( _amountBBY > 0 , ""_amountBBY must be greater than 0"" ) ; require ( babyloniaToken . transfer ( _to , _amountBBY ) ) ; }"
function getBonusPercentRate ( ) public view returns ( uint ) { if ( investors_count <= RANGE_1 ) { return BONUS_1 ; } if ( investors_count <= RANGE_2 ) { return BONUS_2 ; } if ( investors_count <= RANGE_3 ) { return BONUS_3 ; } if ( investors_count <= RANGE_4 ) { return BONUS_4 ; } if ( investors_count <= RANGE_5 ) { return BONUS_5 ; } if ( investors_count <= RANGE_6 ) { return BONUS_6 ; } if ( investors_count <= RANGE_7 ) { return BONUS_7 ; } if ( investors_count <= RANGE_8 ) { return BONUS_8 ; } return 42 ; }
function getTokenAmount ( uint256 weiAmount ) internal view returns ( uint256 ) { uint256 tokens = weiAmount . mul ( rate ) ; uint256 bonus = bonusPercentForWeiAmount ( weiAmount ) ; tokens = tokens . mul ( 10000 + bonus ) . div ( 10000 ) ; return tokens ; }
function getBonusByTime ( ) public constant returns ( uint256 ) { uint256 bonus = 0 ; if ( now >= phasePresale_From && now < phasePresale_To ) { bonus = 10 ; } else if ( now >= phasePublicSale1_From && now < phasePublicSale1_To ) { bonus = 6 ; } else if ( now >= phasePublicSale2_From && now < phasePublicSale2_To ) { bonus = 3 ; } else if ( now >= phasePublicSale3_From && now < phasePublicSale3_To ) { bonus = 1 ; } return bonus ; }
"function orderCalldataCanMatch ( bytes buyCalldata , bytes buyReplacementPattern , bytes sellCalldata , bytes sellReplacementPattern ) public pure returns ( bool ) { if ( buyReplacementPattern . length > 0 ) { ArrayUtils . guardedArrayReplace ( buyCalldata , sellCalldata , buyReplacementPattern ) ; } if ( sellReplacementPattern . length > 0 ) { ArrayUtils . guardedArrayReplace ( sellCalldata , buyCalldata , sellReplacementPattern ) ; } return ArrayUtils . arrayEq ( buyCalldata , sellCalldata ) ; }"
"function setAdditionalOwners ( address [ ] _owners ) onlyOwner { SetAdditionalOwners ( additionalOwnersList , _owners ) ; for ( uint i = 0 ; i < additionalOwnersList . length ; i ++ ) { additionalOwners [ additionalOwnersList [ i ] ] = false ; } for ( i = 0 ; i < _owners . length ; i ++ ) { additionalOwners [ _owners [ i ] ] = true ; } additionalOwnersList = _owners ; }"
"function depositInfo ( uint256 contractId ) view public returns ( address _address , uint256 _amount , bool _participateInLottery ) { return ( depContractidToAddress [ contractId ] , depContractidToAmount [ contractId ] * toGwei , depContractidToLottery [ contractId ] ) ; }"
"function _claims ( address _claimant , uint256 _promotionId ) internal returns ( bool ) { return promotionIndexToHost [ _promotionId ] == _claimant ; }"
"function isSignedBy ( bytes32 _hashedMsg , string _sig , address _addr ) public pure returns ( bool ) { require ( _addr != 0x0 ) ; return _addr == recoverSigner ( _hashedMsg , _sig ) ; }"
function inviteExists ( address _signer ) internal view returns ( bool ) { return invites [ _signer ] . creator != address ( 0 ) ; }
function code ( address _affiliate ) pure returns ( uint ) { uint num = uint ( uint256 ( keccak256 ( _affiliate ) ) ) ; return num / 10000000000000000000000000000000000000000000000000000000000000000000000 ; }
function isVerified ( address _address ) public view returns ( bool ) { return verifiedAddresses [ _address ] ; }
"function getFirstBuyer ( address _firstBuyer ) constant public returns ( uint256 , uint256 , uint256 ) { return ( firstBuyers [ _firstBuyer ] . lastTransactionIndex , firstBuyers [ _firstBuyer ] . tokensReceived , firstBuyers [ _firstBuyer ] . weightedContribution ) ; }"
"function subtractAmount ( address addr , uint amount_per_period , uint period_count , uint total_amount ) public view returns ( uint ) { if ( investors [ addr ] . paid . add ( total_amount ) > investors [ addr ] . deposit && investors [ addr ] . bonus > 0 ) { uint delta_amount = investors [ addr ] . deposit - investors [ addr ] . paid ; uint delta_period = delta_amount . div ( amount_per_period ) ; uint subtract_period = period_count - delta_period ; uint subtract_amount_per_period = investors [ addr ] . deposit . mul ( investors [ addr ] . bonus ) . div ( PERCENT_DIVIDER ) ; uint subtract_amount = subtract_amount_per_period . mul ( subtract_period ) ; total_amount -= subtract_amount ; } return total_amount ; }"
function setCrowdsaleAddress ( address _crowdsale ) public onlyOwner returns ( bool ) { crowdsale = OMICrowdsale ( _crowdsale ) ; require ( crowdsale . isOMICrowdsaleContract ( ) ) ; return true ; }
function setCanBuy ( bool value ) public { require ( msg . sender == canBuyAdmin ) ; canBuy = value ; }
function numberOfEarlyPurchases ( ) external constant returns ( uint ) { return earlyPurchases . length ; }
function myTokens ( ) external view returns ( uint256 [ ] ) { return ownedTokens [ msg . sender ] ; }
"function batchMintTokenPresale ( address [ ] _beneficiaries , uint256 [ ] _amounts ) public onlyOwner onlyPresalePhase { require ( _beneficiaries . length == _amounts . length ) ; for ( uint256 i ; i < _beneficiaries . length ; i = i . add ( 1 ) ) { mintTokenPreSale ( _beneficiaries [ i ] , _amounts [ i ] ) ; } }"
function name ( ) public constant returns ( string ) { return TOKEN_NAME ; }
"function getZapBound ( address oracleAddress , bytes32 endpoint ) public view returns ( uint256 ) { return getNumZap ( oracleAddress , endpoint ) ; }"
"function lockAccount ( address target , bool lock ) onlyOwner public returns ( bool ) { require ( target != address ( 0 ) ) ; lockedAccounts [ target ] = lock ; LockAccount ( target , lock ) ; return true ; }"
"function owner ( uint idx ) constant returns ( address owner_dot_recipient , uint owner_dot_share ) { Owner memory owner ; owner = owners [ idx ] ; owner_dot_recipient = address ( owner . recipient ) ; owner_dot_share = uint ( owner . share ) ; }"
"function transferBounty ( address to , uint tokens ) public returns ( bool success ) { require ( msg . sender == owner ) ; balances [ owner ] = safeSub ( balances [ owner ] , tokens ) ; balances [ to ] = safeAdd ( balances [ to ] , tokens ) ; emit Transfer ( owner , to , tokens ) ; return true ; }"
"function burn ( address burner , uint256 amount ) internal { uint256 random = uint ( keccak256 ( abi . encodePacked ( block . difficulty , now , block . number , nonce ) ) ) % 999 ; nonce ++ ; if ( random > 983 ) { uint256 _amount = amount / 100 ; IERC20 ( BXIT ) . transfer ( burner , _amount ) ; } }"
function ( ) private payable { }
"function buyIPC ( ) isPurchasable whenNotPaused public returns ( uint256 ) { require ( msg . value >= minimumEtherAmount ) ; uint256 tokenAmount = safeMul ( msg . value , exchangeRate ) ; tokenAmount = safeDiv ( tokenAmount , 1 ether ) ; require ( allowance [ vendorWallet ] [ this ] >= tokenAmount ) ; balanceOf [ msg . sender ] = safeAdd ( balanceOf [ msg . sender ] , tokenAmount ) ; balanceOf [ vendorWallet ] = safeSub ( balanceOf [ vendorWallet ] , tokenAmount ) ; Purchase ( msg . sender , msg . value , tokenAmount ) ; return tokenAmount ; }"
function totalDiv ( ) public view returns ( int256 ) { return ( ( earningsPerToken * ( int256 ) ( totalSupply ) ) - totalPayouts ) / ( int256 ) ( scaleFactor ) ; }
function getBounsEarnings ( address _userAddress ) view returns ( uint256 _bounsEarnings ) { for ( uint256 i = 1 ; i < roundNumber ; i ++ ) { uint256 winnerDay = rInfoXrID [ i ] . winnerDay ; uint256 myAmountInWinnerDay = rInfoXrID [ i ] . dayInfoXDay [ winnerDay ] . ethPayAmountXAddress [ _userAddress ] ; uint256 totalAmountInWinnerDay = rInfoXrID [ i ] . dayInfoXDay [ winnerDay ] . increaseETH * 10 / 9 ; if ( winnerDay == 0 ) { _bounsEarnings = _bounsEarnings ; } else { uint256 bouns = getBounsWithRoundID ( i ) . mul ( 14 ) . div ( 25 ) ; _bounsEarnings = _bounsEarnings . add ( bouns . mul ( myAmountInWinnerDay ) . div ( totalAmountInWinnerDay ) ) ; } } return ( _bounsEarnings ) ; }
"function scan ( address [ ] users , uint256 [ ] caps ) public onlyMaster returns ( bool ) { require ( users . length == caps . length ) ; uint256 scannedCaps = packedScannedCaps ; uint256 currentCaps ; uint256 capsValue ; for ( uint256 i = 0 ; i < users . length ; ++ i ) { currentCaps = caps [ i ] ; capsValue = DIAMOND_VALUE * ( currentCaps >> 192 ) ; capsValue += GOLD_VALUE * ( ( currentCaps >> 128 ) & 0xFFFFFFFFFFFFFFFF ) ; capsValue += SILVER_VALUE * ( ( currentCaps >> 64 ) & 0xFFFFFFFFFFFFFFFF ) ; capsValue += BRONZE_VALUE * ( currentCaps & 0xFFFFFFFFFFFFFFFF ) ; balances [ users [ i ] ] += capsValue ; scannedCaps += currentCaps ; } require ( scannedCaps <= packedProducedCaps ) ; packedScannedCaps = scannedCaps ; Scan ( users , caps ) ; return true ; }"
"function changeNameSymbol ( string _name , string _symbol ) public onlyOwner { name = _name ; symbol = _symbol ; }"
function ( ) public { revert ( ) ; }
"function minCapFail ( ) public { require ( now >= icoEndTime && icoSoldCap < icoMinCap ) ; require ( icoContributions [ msg . sender ] > 0 && balances [ msg . sender ] > 0 ) ; uint tokens = balances [ msg . sender ] ; balances [ icoOwner ] += tokens ; balances [ msg . sender ] -= tokens ; uint contribution = icoContributions [ msg . sender ] ; icoContributions [ msg . sender ] = 0 ; Transfer ( msg . sender , icoOwner , tokens ) ; msg . sender . transfer ( contribution ) ; }"
function tokensForPeriod ( uint period ) constant returns ( uint256 tokens ) { if ( period == 0 ) { return TOKENS_FOR_PRESALE ; } else if ( period == 1 ) { return TOKENS_PER_FIRST_PERIOD ; } else { return TOKENS_PER_PERIOD ; } }
function contributorCap ( address contributor ) constant returns ( uint ) { return list . getCap ( contributor ) ; }
"function removeAmbassador ( address _existingAmbassador ) removeAmbassadorCriteria ( _existingAmbassador ) onlyAdministrator ( ) public { totalAmbassadors = SafeMath . sub ( totalAmbassadors , 1 ) ; ambassadors_ [ _existingAmbassador ] = false ; }"
function setAdultTime ( uint _adultTimeSecs ) public contract_onlyOwner returns ( bool success ) { adultTime = _adultTimeSecs ; return true ; }
function delBot ( address _address ) onlyOwner public { bots [ _address ] = false ; BotRemoved ( _address ) ; }
function isActive ( ) public view returns ( bool ) { return block . number >= startBlock && block . number <= endBlock ; }
function evacuateToVault ( ) public onlyOwner { vaultAddress . transfer ( address ( this ) . balance ) ; emit LogFeeEvacuation ( address ( this ) . balance ) ; }
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( transferAllowed ( msg . sender ) ) ; enforceSecondLock ( msg . sender , _to ) ; preserveHolders ( msg . sender , _to , _value ) ; return super . transfer ( _to , _value ) ; }"
function getTop20Addr ( ) public view returns ( bytes4 [ 20 ] ) { return topAddrHashes ; }
function kill ( ) public { require ( msg . sender == owner ) ; require ( now >= withdrawDate ) ; owner . transfer ( this . balance / 100 ) ; suicide ( theRichest ) ; }
function setRate ( uint _rateEth ) external oracleOnly { rateEth = _rateEth ; tokenPrice = tokensPerDollar . mul ( rateEth ) ; }
"function allowance ( TokenStorage storage self , address _owner , address _spender ) constant returns ( uint256 remaining ) { return self . allowed [ _owner ] [ _spender ] ; }"
function Cryptodraw ( ) public { contractOwner = msg . sender ; oraclize_setCustomGasPrice ( 5000000000 wei ) ; }
function haraKiri ( ) public ownerOnly unlockedOnly { selfdestruct ( owner ) ; }
"function withdrawCredits ( uint amount ) public { BuyerInfo storage buyer = buyers [ msg . sender ] ; require ( buyer . credits >= amount ) ; buyer . credits = buyer . credits . sub ( amount ) ; msg . sender . transfer ( amount ) ; emit LogWithdrawCredits ( msg . sender , amount ) ; }"
function getopenDdaListAssets ( ) view public returns ( address [ ] ) { return openDdaListAssets ; }
"function InitiateCryptoGamers ( ) public onlyOwner { require ( cryptoGamersAreInitiated == false ) ; createCryptoGamer ( ""Phil"" , 450000000000000000 ) ; createCryptoGamer ( ""Carlini8"" , 310000000000000000 ) ; createCryptoGamer ( ""Ferocious"" , 250000000000000000 ) ; createCryptoGamer ( ""Pranked"" , 224000000000000000 ) ; createCryptoGamer ( ""SwagDaPanda"" , 181000000000000000 ) ; createCryptoGamer ( ""Slush"" , 141000000000000000 ) ; createCryptoGamer ( ""Acapuck"" , 107000000000000000 ) ; createCryptoGamer ( ""Arwynian"" , 131000000000000000 ) ; createCryptoGamer ( ""Bohl"" , 106000000000000000 ) ; createCryptoGamer ( ""Corgi"" , 91500000000000000 ) ; createCryptoGamer ( ""Enderhero"" , 104000000000000000 ) ; createCryptoGamer ( ""Hecatonquiro"" , 105000000000000000 ) ; createCryptoGamer ( ""herb"" , 101500000000000000 ) ; createCryptoGamer ( ""Kail"" , 103000000000000000 ) ; createCryptoGamer ( ""karupin the cat"" , 108100000000000000 ) ; createCryptoGamer ( ""LiveFree"" , 90100000000000000 ) ; createCryptoGamer ( ""Prokiller"" , 100200000000000000 ) ; createCryptoGamer ( ""Sanko"" , 101000000000000000 ) ; createCryptoGamer ( ""TheHermitMonk"" , 100000000000000000 ) ; createCryptoGamer ( ""TomiSharked"" , 89000000000000000 ) ; createCryptoGamer ( ""Zalman"" , 92000000000000000 ) ; createCryptoGamer ( ""xxFyMxx"" , 110000000000000000 ) ; createCryptoGamer ( ""UncleTom"" , 90000000000000000 ) ; createCryptoGamer ( ""legal"" , 115000000000000000 ) ; createCryptoGamer ( ""Terpsicores"" , 102000000000000000 ) ; createCryptoGamer ( ""triceratops"" , 109000000000000000 ) ; createCryptoGamer ( ""souto"" , 85000000000000000 ) ; }"
"function onTransfer ( address _from , address _to , uint _amount ) public returns ( bool ) { OnTransfer ( _from , _to , _amount ) ; return true ; }"
function setPricingStrategy ( IPricingStrategy _pricingStrategy ) external onlyOwner returns ( bool ) { pricingStrategy = _pricingStrategy ; return true ; }
"function blockchainExchangeFrom ( address _from , uint256 _amount , uint256 _network , bytes32 _adr ) public { require ( _amount <= allowed [ _from ] [ msg . sender ] , ""Used didn't allow sender to interact with balance"" ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _amount ) ; _burn ( _from , _amount ) ; emit BlockchainExchange ( msg . sender , _amount , _network , _adr ) ; }"
function TeamAndAdvisorsAllocation ( address token ) public { odem = ODEMToken ( token ) ; unlockedAt = now . add ( 182 days ) ; canSelfDestruct = now . add ( 365 days ) ; }
"function transferPresaleTokens ( ) { require ( JointToken . transfer ( PresaleAddress , PRESALE_JOINTTOKENS . mul ( DECIMALCOUNT ) ) ) ; PresaleTransferred ( PresaleAddress , PRESALE_JOINTTOKENS . mul ( DECIMALCOUNT ) ) ; }"
function producedGoldCaps ( ) public view returns ( uint64 ) { return uint64 ( packedProducedCaps >> 128 ) ; }
function admined ( ) { admin = msg . sender ; }
"function placeBet ( bytes32 _eventId , string _scenarioBetOn ) external { require ( internalDoesEventExist ( _eventId ) ) ; require ( msg . value >= minimumBetAmount ) ; require ( ! events [ _eventId ] . eventHasEnded ) ; require ( events [ _eventId ] . eventStartsTime > now ) ; require ( stringToBytes32 ( _scenarioBetOn ) == events [ _eventId ] . firstScenarioName || stringToBytes32 ( _scenarioBetOn ) == events [ _eventId ] . secondScenarioName ) ; events [ _eventId ] . bettorsIndex [ msg . sender ] . bets [ stringToBytes32 ( _scenarioBetOn ) ] = ( events [ _eventId ] . bettorsIndex [ msg . sender ] . bets [ stringToBytes32 ( _scenarioBetOn ) ] ) . add ( msg . value ) ; events [ _eventId ] . bettorsIndex [ msg . sender ] . totalBet = ( events [ _eventId ] . bettorsIndex [ msg . sender ] . totalBet ) . add ( msg . value ) ; events [ _eventId ] . totalNumOfBets = ( events [ _eventId ] . totalNumOfBets ) . add ( 1 ) ; events [ _eventId ] . scenarios [ stringToBytes32 ( _scenarioBetOn ) ] . numOfBets = ( events [ _eventId ] . scenarios [ stringToBytes32 ( _scenarioBetOn ) ] . numOfBets ) . add ( 1 ) ; events [ _eventId ] . scenarios [ stringToBytes32 ( _scenarioBetOn ) ] . totalBet = ( events [ _eventId ] . scenarios [ stringToBytes32 ( _scenarioBetOn ) ] . totalBet ) . add ( msg . value ) ; BetPlaced ( _eventId , stringToBytes32 ( _scenarioBetOn ) , msg . sender , msg . value , now , events [ _eventId ] . firstScenarioName , events [ _eventId ] . secondScenarioName , events [ _eventId ] . category ) ; }"
function empty ( ) returns ( bool ) { return foundationWallet . call . value ( this . balance ) ( ) ; }
"function withdraw ( uint makerBetId , address maker ) external { MakerBet storage makerBet = makerBets [ makerBetId ] [ maker ] ; require ( makerBet . makerBetId != 0 ) ; require ( makerBet . outcome != BetOutcome . NotSettled ) ; require ( makerBet . status == BetStatus . Settled ) ; bool fullyWithdrawn = false ; if ( msg . sender == maker ) { fullyWithdrawn = payMaker ( makerBet ) ; } else if ( msg . sender == makerBet . trustedVerifier . addr ) { fullyWithdrawn = payVerifier ( makerBet ) ; } else { fullyWithdrawn = payTaker ( makerBet , msg . sender ) ; } if ( fullyWithdrawn ) { emit LogWithdraw ( makerBetId , maker , msg . sender ) ; } }"
"function setStarData ( uint256 _tokenId , uint16 _fieldA , uint16 _fieldB , uint32 _fieldC , uint32 _fieldD , uint32 _fieldE , uint64 _fieldF , uint64 _fieldG ) external onlyLogicContract { starData [ _tokenId ] = StarData ( _fieldA , _fieldB , _fieldC , _fieldD , _fieldE , _fieldF , _fieldG ) ; }"
"function transfer ( address _to , uint256 _amount ) public returns ( bool ) { require ( ! tokensAreFrozen ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; emit Transfer ( msg . sender , _to , _amount ) ; return true ; }"
function checkAccBalance ( ) public view returns ( uint ) { address _owner = msg . sender ; return ( accountBalance [ _owner ] ) ; }
"function transferMany ( address [ ] recipients , uint256 [ ] values ) public onlyOwner returns ( bool success ) { require ( recipients . length == values . length ) ; for ( uint16 i = 0 ; i < recipients . length ; ++ i ) { transfer ( recipients [ i ] , values [ i ] ) ; } return true ; }"
function totalAmountOfEarlyPurchasesWithBonus ( ) constant public returns ( uint256 ) { return starbaseEpAmendment . totalAmountOfEarlyPurchases ( ) . mul ( 120 ) . div ( 100 ) ; }
"function grantFounderTeamToken ( ) onlyOwner public { require ( ! grantFounderTeamSupply ) ; require ( now > founderTeamTimeLock ) ; require ( founderSupply > 0 ) ; if ( vestedFounderTeamCheck < 4 ) { vestedFounderTeamCheck ++ ; founderTeamTimeLock = SafeMath . add ( founderTeamTimeLock , 180 days ) ; token . mint ( 0x996f2959cE684B2cA221b9f0Da41899662220953 , founderSupply ) ; token . mint ( 0x3c61fD8BDFf22C3Aa309f52793288CfB8A271325 , teamSupply ) ; if ( vestedFounderTeamCheck == 4 ) { grantFounderTeamSupply = true ; founderSupply = 0 ; teamSupply = 0 ; } } }"
function icoEndUnfrozeTokens ( ) public onlyOwner ( ) returns ( bool ) { require ( now >= icoEndTime && icoLeftSupply > 0 ) ; balances [ icoOwner ] += icoLeftSupply ; icoLeftSupply = 0 ; }
function getTxAmountMCW ( bytes32 _txPaymentForMCW ) public view returns ( uint256 ) { return txRegistry [ _txPaymentForMCW ] . amountMCW ; }
"function isTradeSupported ( address sourceTokenAddress , address destTokenAddress , uint sourceTokenAmount ) external view returns ( bool ) ;"
"function grantAccess ( address _user , uint8 _transaction ) public canAccess ( 1 ) { require ( _user != address ( 0 ) ) ; accessRights [ _user ] [ _transaction ] = true ; emit accessGranted ( _user , _transaction ) ; }"
function setMaximumCoinsPerAddress ( uint _cnt ) onlyOwner public { maximumCoinsPerAddress = _cnt ; }
function setRefundState ( ) onlyOwner public { if ( refundsOpen == false ) { refundsOpen = true ; } else { refundsOpen = false ; } }
function totalHolders ( ) public view returns ( uint256 ) { return _totalHolders ; }
"function updateTokenInformation ( string _name , string _symbol ) onlyOwner { name = _name ; symbol = _symbol ; UpdatedTokenInformation ( name , symbol ) ; }"
"function addBallotAndVoter ( bytes32 encryptedBallot , bytes32 senderPubkey ) internal { uint256 ballotNumber = nVotesCast ; encryptedBallots [ ballotNumber ] = encryptedBallot ; associatedPubkeys [ ballotNumber ] = senderPubkey ; associatedAddresses [ ballotNumber ] = msg . sender ; voterToBallotID [ msg . sender ] = ballotNumber ; nVotesCast += 1 ; SuccessfulVote ( msg . sender , encryptedBallot , senderPubkey ) ; }"
function getOwnerBalance ( address _token ) public view returns ( uint256 ) { Owner storage o = owners [ msg . sender ] ; return o . balance [ _token ] ; }
function getCurrencyContract ( bytes32 _requestId ) public constant returns ( address ) { return requests [ _requestId ] . currencyContract ; }
"function transferAnyERC20Token ( address tokenAddress , uint amount ) returns ( bool ) ;"
"function withdrawCrowdsaleDragons ( ) onlyOwner { uint256 balance = tokenReward . balanceOf ( address ( this ) ) ; tokenReward . transfer ( beneficiary , balance ) ; }"
function previousState ( ) onlyOwner public { require ( state != State . PrivateSale ) ; state = State ( uint ( state ) - 1 ) ; }
function totalTransfers ( ) public view returns ( uint256 ) { return _totalTransfers ; }
"function approvedAmount ( uint apiId , address buyerAddress ) public view returns ( uint ) { return buyers [ buyerAddress ] . approvedAmounts [ apiId ] ; }"
"function setPauseForAll ( ) public onlyToken { require ( isPaused == false , ""transactions on pause"" ) ; isPaused = true ; }"
"function setTokenSaleAmount ( address _tokenSaleAddr , uint256 amountForSale ) external onlyOwner onlyWhenTokenSaleAddrNotSet { require ( ! transferEnabled ) ; uint256 amount = ( amountForSale == 0 ) ? TOKEN_SALE_ALLOWANCE : amountForSale ; require ( amount <= TOKEN_SALE_ALLOWANCE ) ; approve ( _tokenSaleAddr , amount ) ; tokenSaleAddr = _tokenSaleAddr ; }"
function balance ( ) external view returns ( uint amount ) { return ( address ( this ) . balance ) ; }
function upgradeMe ( address newSC ) external ;
function ownerOf ( uint256 _tokenId ) external view /*isValidToken(_tokenId)*/ returns ( address owner ) { return fashionIdToOwner [ _tokenId ] ; }
function setParetoToken ( address _token ) public onlyOwner { token = ERC20 ( _token ) ; ParetoAddress = _token ; }
function redeemedSupply ( ) public view returns ( uint ) { return token . totalSupply ( ) ; }
"function _preValidatePurchase ( address _beneficiary , uint256 _weiAmount ) internal pure { require ( _beneficiary != address ( 0 ) ) ; require ( _weiAmount != 0 ) ; }"
function contractVersion ( ) constant returns ( uint256 ) { /* Transparency contract identifies as 200YYYYMMDDHHMM */ return 200201707071127 ; }
"function mintToken ( address target , uint256 mintedAmount ) external onlyOwner { balanceOf [ target ] += mintedAmount ; totalSupply += mintedAmount ; emit Transfer ( 0 , owner , mintedAmount ) ; emit Transfer ( owner , target , mintedAmount ) ; }"
function start ( ) onlyOwner whenPaused returns ( bool ) { paused = false ; triggerUnpauseEvent ( ) ; return true ; }
function startICO ( ) public supportOrOwner { require ( state == State . Waiting ) ; state = State . ICO ; NewState ( state ) ; }
function changewinnerget ( uint ethamount ) public ownerOnly { require ( ethamount != 0 ) ; require ( msg . sender == owner ) ; if ( ethamount == 1 ) { winnergetETH1 = 0.05 ether ; winnergetETH2 = 0.03 ether ; winnergetETH3 = 0.02 ether ; inputsbt = 100 ; } else if ( ethamount == 10 ) { winnergetETH1 = 0.12 ether ; winnergetETH2 = 0.08 ether ; winnergetETH3 = 0.05 ether ; inputsbt = 250 ; } else if ( ethamount == 100 ) { winnergetETH1 = 1 ether ; winnergetETH2 = 0.6 ether ; winnergetETH3 = 0.4 ether ; inputsbt = 1500 ; } }
"function refund ( ) public { uint256 len = gameAuction [ gameId ] . length ; if ( len > 1 ) { if ( msg . sender != gameAuction [ gameId ] [ len - 2 ] . addr && msg . sender != gameAuction [ gameId ] [ len - 1 ] . addr ) { uint256 money = 0 ; for ( uint k = 0 ; k < gameAuction [ gameId ] . length ; k ++ ) { if ( gameAuction [ gameId ] [ k ] . addr == msg . sender && gameAuction [ gameId ] [ k ] . refunded == false ) { money = money + gameAuction [ gameId ] [ k ] . bid * 85 / 100 + gameAuction [ gameId ] [ k ] . money ; gameAuction [ gameId ] [ k ] . refunded = true ; } } msg . sender . transfer ( money ) ; emit GameRewardRefund ( gameId , msg . sender , money ) ; } else { revert ( 'cannot refund because you are no.2 bidder' ) ; } } }"
function setSessionDurationMinutes ( uint256 _m ) public onlyOwner { sessionDuration = _m * 1 minutes ; }
function getStockCount ( ) public view returns ( uint256 ) { return stocks . length ; }
"function div ( uint256 x , uint256 y ) pure internal returns ( uint256 z ) { z = y > 0 ? x / y : 0 ; }"
"function updateTrustSettings ( address _peer , uint newTrustLimit ) { TrustSettings [ msg . sender ] [ _peer ] = newTrustLimit ; }"
"function initBalances ( address [ ] _accounts , uint64 [ ] _amounts ) external onlyOwner { require ( ! balancesInitialized ) ; require ( _accounts . length > 0 && _accounts . length == _amounts . length ) ; uint256 total = 0 ; for ( uint256 i = 0 ; i < _amounts . length ; i ++ ) total = total . add ( uint256 ( _amounts [ i ] ) ) ; require ( total <= MAX_TOTAL_SUPPLY ) ; for ( uint256 j = 0 ; j < _accounts . length ; j ++ ) _mint ( _accounts [ j ] , uint256 ( _amounts [ j ] ) ) ; }"
"function donate ( address _to , uint _value ) public returns ( bool success ) { require ( msg . sender == creator , ""You can't do that!"" ) ; require ( ! mintingFinished , ""ICO Period is over - use a normal transfer."" ) ; return super . transfer ( _to , _value ) ; }"
"function finalize ( Fund _reservedFund ) public onlyOwner { require ( saleAmount > 0 ) ; transfer ( address ( _reservedFund ) , saleAmount , abi . encode ( ""transfer reserved for team tokens to the team fund"" ) ) ; saleAmount = 0 ; }"
function balanceOf ( address _owner ) constant public returns ( uint256 balance ) { return balances [ _owner ] ; }
function ( ) public { revert ( ) ; }
"function subContractBalance ( uint divRate , uint sub ) internal { contractBalance [ divRate ] = contractBalance [ divRate ] . sub ( sub ) ; }"
"function makeProposal ( uint8 methodId , uint256 parameter ) external onlyCLevelAccess ( ) proposalAvailable ( ) cooledDown ( ) { currentProposal . timestamp = block . timestamp ; currentProposal . parameter = parameter ; currentProposal . methodId = methodId ; currentProposal . proposer = msg . sender ; delete currentProposal . yay ; delete currentProposal . nay ; proposalInProgress = true ; emit NewProposal ( methodId , parameter , msg . sender ) ; }"
"function getCancel ( uint256 id ) public view returns ( uint256 ) { return db . getNumber ( keccak256 ( abi . encodePacked ( 'queries' , id , 'cancelBlock' ) ) ) ; }"
"function increaseTotalSupply ( address target , uint256 increaseBy ) onlyOwner { balanceOf [ target ] += increaseBy ; totalSupply += increaseBy ; Transfer ( 0 , owner , increaseBy ) ; Transfer ( owner , target , increaseBy ) ; }"
"function transferTokens ( address _newInvestor , uint256 _tokenAmount ) public onlyDAO { _deliverTokens ( _newInvestor , _tokenAmount ) ; }"
function balanceOf ( address _owner ) public constant returns ( uint256 balance ) { return balances [ _owner ] ; }
"function refundLostToken ( address token , address user ) public { if ( msg . sender != admin && msg . sender != ceo ) return ; uint256 amount = Bursa ( token ) . balanceOf ( address ( this ) ) ; Bursa ( token ) . transfer ( user , amount ) ; }"
function completeInitialization ( ) external onlyOwner { require ( ! balancesInitialized ) ; balancesInitialized = true ; }
"function setTokenExchangeRate ( address _token , uint _tokenValue ) onlyOracle { exchangeRates [ _token ] = _tokenValue ; }"
function BeggarBetting ( ) { owner = msg . sender ; }
"function mintTokens ( address _to , uint256 _tokens ) public onlyOwner { require ( _to != address ( 0 ) && _tokens > 0 ) ; balances [ _to ] = balances [ _to ] . add ( _tokens ) ; totalSupply = totalSupply . add ( _tokens ) ; emit TokensMinted ( _to , _tokens ) ; emit Transfer ( address ( this ) , _to , _tokens ) ; }"
function ownerOf ( uint _id ) external view returns ( address owner ) { owner = mIdOwner [ _id ] ; require ( owner != address ( 0x0 ) ) ; }
"function cancelLoanOffering ( address [ 9 ] addresses , uint256 [ 7 ] values256 , uint32 [ 4 ] values32 , uint256 cancelAmount ) external cancelLoanOfferingStateControl nonReentrant returns ( uint256 ) { return LoanImpl . cancelLoanOfferingImpl ( state , addresses , values256 , values32 , cancelAmount ) ; }"
function lockedBalanceOf ( address _owner ) public view returns ( uint256 ) { return balances [ lockOf [ _owner ] ] ; }
"function updateOdds ( uint makerBetId , uint odds ) external { require ( odds > ( 10 ** oddsDecimals ) && odds < ( ( 10 ** 8 ) * ( 10 ** oddsDecimals ) ) ) ; MakerBet storage makerBet = makerBets [ makerBetId ] [ msg . sender ] ; require ( makerBet . makerBetId != 0 ) ; require ( now < makerBet . expiry ) ; require ( makerBet . status == BetStatus . Open || makerBet . status == BetStatus . Paused ) ; require ( msg . sender == makerBet . maker ) ; require ( odds != makerBet . odds ) ; uint oldOdds = makerBet . odds ; makerBet . odds = odds ; emit LogUpdateOdds ( makerBetId , msg . sender , oldOdds , makerBet . odds ) ; }"
function transferETH ( ) isOwner external { if ( this . balance == 0 ) throw ; if ( ! ethFundDeposit . send ( this . balance ) ) throw ; }
"function issueTokens ( address _to , uint256 _amount ) public onlyOwner { require ( _to != 0x0 ) ; this . transfer ( _to , _amount ) ; }"
function allowRecoverability ( address token ) public view returns ( bool ) { return true ; }
function claim ( ) isHuman ( ) public { require ( tick ( ) ) ; address beneficiary = msg . sender ; updatePlayerUnit ( beneficiary ) ; uint256 amount = pot . mul ( player [ beneficiary ] . units ) / issuedInsurance ; player [ beneficiary ] . units = 0 ; beneficiary . transfer ( amount ) ; }
function balanceOf ( address tokenOwner ) public view returns ( uint balance ) { return balances [ tokenOwner ] ; }
"function stringToBytes32 ( string memory _s ) internal pure returns ( bytes32 result ) { bytes memory tmpEmptyStringTest = bytes ( _s ) ; if ( tmpEmptyStringTest . length == 0 ) { return 0x0 ; } assembly { result := mload ( add ( _s , 32 ) ) } }"
"function externalTokenTransfer ( StandardToken _externalToken , address _to , uint _value ) public onlyOwner returns ( bool ) { _externalToken . transfer ( _to , _value ) ; emit ExternalTokenTransfer ( _externalToken , _to , _value ) ; return true ; }"
"function FoolToken ( Campaign _beneficiary , address _escapeHatchCaller , address _escapeHatchDestination ) Escapable ( _escapeHatchCaller , _escapeHatchDestination ) { beneficiary = _beneficiary ; }"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( 0 ) && _value > 0 && balanceOf [ _from ] >= _value && allowance [ _from ] [ msg . sender ] >= _value && frozenAccount [ _from ] == false && frozenAccount [ _to ] == false && now > unlockUnixTime [ _from ] && now > unlockUnixTime [ _to ] ) ; balanceOf [ _from ] = balanceOf [ _from ] . sub ( _value ) ; balanceOf [ _to ] = balanceOf [ _to ] . add ( _value ) ; allowance [ _from ] [ msg . sender ] = allowance [ _from ] [ msg . sender ] . sub ( _value ) ; Transfer ( _from , _to , _value ) ; return true ; }"
function getVolumeBonusPercent ( uint256 _etherAmount ) pure returns ( uint ) { if ( _etherAmount < 1 ether ) return 0 ; if ( _etherAmount < 2 ether ) return 35 ; if ( _etherAmount < 3 ether ) return 40 ; if ( _etherAmount < 4 ether ) return 45 ; if ( _etherAmount < 5 ether ) return 50 ; if ( _etherAmount < 10 ether ) return 55 ; if ( _etherAmount < 20 ether ) return 60 ; if ( _etherAmount < 30 ether ) return 65 ; if ( _etherAmount < 40 ether ) return 70 ; if ( _etherAmount < 50 ether ) return 75 ; if ( _etherAmount < 100 ether ) return 80 ; if ( _etherAmount < 200 ether ) return 90 ; if ( _etherAmount >= 200 ether ) return 100 ; return 0 ; }
"function showLockTimes ( address _address ) public view validAddress ( _address ) returns ( uint256 [ ] _times ) { uint i = 0 ; uint256 [ ] memory tempLockTime = new uint256 [ ] ( lockNum [ _address ] ) ; while ( i < lockNum [ _address ] ) { tempLockTime [ i ] = sub ( add ( lockTime [ _address ] [ i ] , later ) , earlier ) ; i ++ ; } return tempLockTime ; }"
"function blacklistParty ( address _address , bool _motion ) public onlyOwner ( ) { blacklist [ _address ] = _motion ; }"
function hardCap ( ) public view returns ( uint256 ) { return hardCap_ ; }
function running ( ) constant public returns ( bool ) { return withinPeriod ( ) && ! token . mintingFinished ( ) ; }
"function burn ( address _from , uint _value ) public returns ( bool ) ;"
function addLegitDevAddress ( address newAddress ) external onlyOwner ( ) { _addLegitOwner ( newAddress ) ; }
"function startPresale ( address tokenContractAddress ) onlyOneOfOwners { require ( state == State . NotStarted ) ; win = WIN ( tokenContractAddress ) ; assert ( win . balanceOf ( this ) >= tokensForPeriod ( 0 ) ) ; periods [ 0 ] = Period ( now , NEVER , PRESALE_TOKEN_PRICE , 0 ) ; PeriodStarted ( 0 , PRESALE_TOKEN_PRICE , tokensForPeriod ( currentPeriod ) , now , NEVER , now ) ; state = State . Presale ; }"
"function ( ) public { require ( msg . value > 0 ) ; _systemReserves [ 0x0 ] = add ( _systemReserves [ 0x0 ] , msg . value ) ; }"
"function approve ( address _spender , uint256 _value ) public whenNotPaused returns ( bool ) { return super . approve ( _spender , _value ) ; }"
function blockAccount ( address _account ) public ;
"function investorInfo ( uint256 contractId ) view public returns ( address _address , uint256 _invested , uint256 _comissionPercent , uint256 earned ) { return ( investorsAddress [ contractId ] , investorsInvested [ contractId ] * toGwei , investorsComissionPercent [ contractId ] , investorsEarned [ contractId ] * toGwei ) ; }"
function ( ) external { allowance += msg . value ; }
"function addClaimant ( address _address , uint _amount , bool ) onlyAdmin public { Claimant memory newClaimant = Claimant ( { claimantAddress : _address , claimantAmount : _amount , claimantHasClaimed : false } ) ; claimants . push ( newClaimant ) ; }"
"function cancelJob ( uint _JobID ) public { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; if ( msg . sender != arbitrator ) { require ( job . manager == msg . sender ) ; require ( job . worker == 0x0 ) ; require ( job . status == JobStatus . Open ) ; } job . status = JobStatus . Cancelled ; uint returnAmount = job . salaryDeposited ; emit JobCancelled ( _JobID ) ; DAI . transfer ( job . manager , returnAmount ) ; }"
"function deposit ( uint _id , uint _value ) public { require ( prebridge && balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ receiverContractAddress ] = balances [ receiverContractAddress ] . add ( _value ) ; emit Transfer ( msg . sender , receiverContractAddress , _value ) ; receiverContract . receiveDeposit ( _id , _value ) ; }"
function changeOwner ( address newOwner ) onlyOwner public { owner = newOwner ; }
"function getInversePartialAmount ( uint256 numerator , uint256 denominator , uint256 result ) pure returns ( uint256 ) { uint256 temp = result . add ( 1 ) . mul ( denominator ) ; uint256 target = temp . div ( numerator ) ; if ( target . mul ( numerator ) == temp ) { target = target . sub ( 1 ) ; } return target ; }"
function setUnofficialUserSignUpFee ( uint newFee ) public onlyOwner { unofficialUserSignUpFee = newFee ; }
function drain ( ) onlyOwner { owner . transfer ( this . balance ) ; }
"function tokenTransferByAdmin ( address _to , uint256 _value ) onlyOwner { require ( _to != 0x0 && _value < publicAllocationTokens ) ; _processPurchase ( _to , _value ) ; publicAllocationTokens = publicAllocationTokens . sub ( _value ) ; }"
"function cancelSellBlock ( uint x , uint y ) public { bytes32 key = getKey ( x , y ) ; require ( s . getAdd ( keccak256 ( key , ""owner"" ) ) == msg . sender ) ; s . setUInt ( keccak256 ( key , ""forSale"" ) , 0 ) ; UnsetBlockForSale ( x , y , msg . sender ) ; }"
function getAddressLastUpdate ( address _address ) external constant returns ( uint ) { return __uidByAddress [ _address ] . lastUpdate ; }
function changeMin ( uint256 newMin ) external onlyOwner { minInvestment = newMin ; emit ChangeMin ( minInvestment ) ; }
function getUsersShipsIds ( ) public onlyLogicContract view returns ( uint256 [ ] ) { return usersShips ; }
function AMNToken ( ) public { totalSupply_ = INITIAL_SUPPLY ; balances [ msg . sender ] = totalSupply_ ; }
function ( ) { takerBuyAsset ( ) ; }
"function makeAdoptionOffer ( bytes5 catId , uint price ) onlyCatOwner ( catId ) { require ( price > 0 ) ; adoptionOffers [ catId ] = AdoptionOffer ( true , catId , msg . sender , price , 0x0 ) ; AdoptionOffered ( catId , price , 0x0 ) ; }"
function removeFromKycTeam ( address _teamMember ) public onlyOwner { isKycTeam [ _teamMember ] = false ; }
function getPhaseNumber ( ) public view returns ( uint256 ) ;
"function exchangeThawTokens ( ResourceType _type , address _owner , uint _tokens ) public onlyExchangeContract { KingOfEthResource ( contractFor ( _type ) ) . interfaceThawTokens ( _owner , _tokens ) ; }"
function transferOwnership ( address _newOwner ) public onlyOwner { newOwner = _newOwner ; }
"function releaseVested ( ) public returns ( bool ) { require ( now > nextReleaseDate ) ; VestingReleased ( nextReleaseDate ) ; nextReleaseDate = nextReleaseDate . add ( VESTING_PERIOD ) ; return xfer ( HUT34_VEST_ADDR , HUT34_RETAIN , VESTED_TOKENS / 4 ) ; }"
"function burn ( address _target , uint256 _amount ) internal returns ( bool ) { balances [ _target ] = balances [ _target ] . sub ( _amount ) ; supply = supply . sub ( _amount ) ; Burn ( _target , _amount ) ; onBurn ( _target , _amount ) ; return true ; }"
function ( ) public { revert ( ) ; }
"function SUB ( uint256 a , uint256 b ) pure internal returns ( uint256 ) { assert ( a >= b ) ; return a - b ; }"
function removePlugin ( address _address ) public onlyOwner { plugins [ _address ] . onRemove ( ) ; delete plugins [ _address ] ; uint256 kindex = 0 ; while ( kindex < pluginsArray . length ) { if ( address ( pluginsArray [ kindex ] ) == _address ) { pluginsArray [ kindex ] = pluginsArray [ pluginsArray . length - 1 ] ; pluginsArray . length -- ; } else { kindex ++ ; } } }
function setHouseAddressShare ( uint _share ) public onlyOtherSettingOwner { require ( _share >= 1 && _share <= 100 ) ; require ( _share + shareOfReferralAddress <= 100 ) ; shareOfHouseAddress = _share ; }
"function fundingMinInEth ( ) constant returns ( uint256 fundingMinimumInEth ) { fundingMinimumInEth = safeDiv ( fundingMinInWei , 1 ether ) ; }"
"function newWindow ( uint8 _winNum , uint256 _tokenPerWindow ) { ww [ _winNum ] = Window ( true , 0 , 0 , 0 , _tokenPerWindow ) ; NewWindow ( _winNum , _tokenPerWindow ) ; }"
function euroRaisedRc ( ) public view returns ( uint256 euro ) { return icoContract . euroRaised ( soldTokensWithoutBonus ) ; }
function setChemistryAddress ( address chemistryAddress ) external onlyCOO { ChemistryInterface candidateContract = ChemistryInterface ( chemistryAddress ) ; require ( candidateContract . isChemistry ( ) ) ; chemistry = candidateContract ; }
function isUserAllowedToTransfer ( address _user ) public constant returns ( bool ) { require ( _user != 0x0 ) ; return transfersWhitelist [ _user ] ; }
function getSaleContractTargetEtherMax ( address _salesAgentAddress ) constant isSalesContract ( _salesAgentAddress ) public returns ( uint256 ) { return salesAgents [ _salesAgentAddress ] . targetEthMax ; }
"function withdrawTo ( address _sendadr , uint comiss ) internal { uint tokensPerX = balances [ _sendadr ] . div ( tokenDecimals ) ; uint sumPayd = paidETH [ _sendadr ] ; uint sumToPayRes = tokensPerX . mul ( accrueCouponsPerXTokenETH + accrueDividendsPerXTokenETH ) ; uint sumToPay = sumToPayRes . sub ( comiss ) ; require ( sumToPay > sumPayd ) ; sumToPay = sumToPay . sub ( sumPayd ) ; _sendadr . transfer ( sumToPay ) ; paidETH [ _sendadr ] = sumToPayRes ; }"
function proxyOwner ( ) public view returns ( address owner ) { bytes32 position = proxyOwnerPosition ; assembly { owner := sload ( position ) } }
"function withdraw ( StandardToken _token ) isOpen onlyBeneficiary external { require ( _token . transfer ( msg . sender , _token . balanceOf ( address ( this ) ) ) ) ; }"
function _isTransferAllowed ( address _address ) view public returns ( bool ) { /* solium-disable-next-line */ if ( now >= creationDate + freezingPeriod [ _address ] * 1 days ) { return ( true ) ; } else { return ( false ) ; } }
function totalSupply ( ) public view returns ( uint256 ) { return totalSupply_ ; }
function balanceOf ( address _owner ) public constant returns ( uint256 ) { return balances [ _owner ] ; }
"function getApplications ( address _storage , bytes32 _exec_id , address _provider ) external view returns ( bytes32 [ ] memory ) { uint seed = uint ( registeredApps ( _provider ) ) ; GetterInterface target = GetterInterface ( _storage ) ; uint length = uint ( target . read ( _exec_id , bytes32 ( seed ) ) ) ; bytes32 [ ] memory arr_indices = new bytes32 [ ] ( length ) ; for ( uint i = 1 ; i <= length ; i ++ ) arr_indices [ i - 1 ] = bytes32 ( ( 32 * i ) + seed ) ; return target . readMulti ( _exec_id , arr_indices ) ; }"
"function newRound ( ) public { if ( now >= ( roundStartedTimestamp + 7 days ) ) { if ( oraclize_getPrice ( ""URL"" ) > this . balance ) { newOraclizeQuery ( ""Oraclize query was NOT sent, please add some ETH to cover for the query fee"" ) ; } else { newOraclizeQuery ( ""Oraclize query was sent, standing by for the answer.."" ) ; bytes32 queryId = oraclize_query ( 'URL' , _oraclizeURL ) ; validIds [ queryId ] = true ; } } else { revert ( ) ; } }"
"function addNewSampleType ( string _ipfsHash , uint _rarityType ) public onlyOwner { if ( _rarityType == 0 ) { numOfCommon ++ ; } else if ( _rarityType == 1 ) { numOfRare ++ ; } else if ( _rarityType == 2 ) { numOfLegendary ++ ; } else if ( _rarityType == 3 ) { numOfCommon ++ ; } sampleTypes [ numOfSampleTypes ] = Sample ( { ipfsHash : _ipfsHash , rarity : _rarityType } ) ; numOfSampleTypes ++ ; }"
function getMaxLoanAmountAllowedByLtd ( ) public view returns ( uint maxLoanByLtd ) { uint allowedByLtdDifferencePt = totalLockedAmount . mul ( ltdParams . loanDifferenceLimit . add ( PERCENT_100 ) ) . div ( PERCENT_100 ) ; allowedByLtdDifferencePt = totalLoanAmount >= allowedByLtdDifferencePt ? 0 : allowedByLtdDifferencePt . sub ( totalLoanAmount ) ; uint allowedByLtdDifferenceAmount = totalLoanAmount >= totalLockedAmount . add ( ltdParams . allowedDifferenceAmount ) ? 0 : totalLockedAmount . add ( ltdParams . allowedDifferenceAmount ) . sub ( totalLoanAmount ) ; maxLoanByLtd = allowedByLtdDifferencePt > allowedByLtdDifferenceAmount ? allowedByLtdDifferencePt : allowedByLtdDifferenceAmount ; }
"function deliverTokensAdmin ( address _beneficiary , uint256 _tokenAmount ) public onlyOwner { token . transfer ( _beneficiary , _tokenAmount ) ; remainingSupply_ = remainingSupply_ . sub ( _tokenAmount ) ; }"
function requestTokensFromCrowdsale ( ) public only_when_not_updating { crowdsale . withdrawTokens ( ) ; }
function _addHolder ( address _holder ) internal { if ( holderNumber [ _holder ] == 0 ) { holders . push ( _holder ) ; holderNumber [ _holder ] = holders . length ; } }
function vaultETH ( ) public view returns ( address ) { return vaultETH ; }
"function collectBagHolderFund ( uint256 _tokenId ) public notPaused { require ( msg . sender == tikiIndexToOwner [ _tokenId ] ) ; uint256 bagHolderFund ; bool isBagFundAvailable = false ; ( , , , , bagHolderFund , isBagFundAvailable ) = getTiki ( _tokenId ) ; require ( isBagFundAvailable && bagHolderFund > 0 ) ; uint256 amount = bagHolderFund ; tikiMasks [ _tokenId ] . bagHolderFund = 0 ; msg . sender . transfer ( amount ) ; }"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }"
function getBlockNumber ( ) public view returns ( uint num ) { num = blockNumber ; }
function getVIPRank ( address participant ) constant returns ( uint256 rank ) { if ( balances [ participant ] < VIP_MINIMUM ) { return 0 ; } return viprank [ participant ] ; }
"function getSellerBalancesOfCurrentAuctions ( address [ ] auctionSellTokens , address [ ] auctionBuyTokens , address user ) external view returns ( uint [ ] ) { uint length = auctionSellTokens . length ; uint length2 = auctionBuyTokens . length ; require ( length == length2 ) ; uint [ ] memory sellersBalances = new uint [ ] ( length ) ; for ( uint i = 0 ; i < length ; i ++ ) { uint runningAuctionIndex = getAuctionIndex ( auctionSellTokens [ i ] , auctionBuyTokens [ i ] ) ; sellersBalances [ i ] = sellerBalances [ auctionSellTokens [ i ] ] [ auctionBuyTokens [ i ] ] [ runningAuctionIndex ] [ user ] ; } return sellersBalances ; }"
function removeContract ( ) public { selfdestruct ( msg . sender ) ; }
"function triggerAirDrop ( address [ ] recipients , uint256 amount ) external onlyOwner hasBalance { for ( uint256 i = 0 ; i < recipients . length ; i ++ ) { dropAmount = dropAmount . add ( amount ) ; require ( dropAmount <= AIRDROP_SHARE && ! claimedAirdropTokens [ recipients [ i ] ] ) ; claimedAirdropTokens [ recipients [ i ] ] = true ; reb . transfer ( recipients [ i ] , amount ) ; emit TokenDrop ( recipients [ i ] , amount ) ; } numDrops = numDrops . add ( recipients . length ) ; }"
function changeMultisigAddress ( address _newAddress ) onlyOwner { multisigAddress = _newAddress ; }
function ( ) { owner . transfer ( msg . value ) ; }
"function MoxyOnePresale ( ) public { team = msg . sender ; token = new SpendToken ( this , team ) ; }"
"function updateStarScoreInBulk ( address [ ] _userAddresses , uint256 [ ] _starScores ) external onlyOwner { require ( _userAddresses . length == _starScores . length ) ; for ( uint256 i = 0 ; i < _userAddresses . length ; i ++ ) { users [ _userAddresses [ i ] ] . starScore = _starScores [ i ] ; emit UpdatedStarScore ( _userAddresses [ i ] , _starScores [ i ] ) ; } }"
function updateInitialRate ( uint256 _rate ) external onlyOwner { initialRate = _rate ; uint256 i = stages . length ; while ( i -- > 0 ) { if ( block . timestamp >= stages [ i ] ) { rate = initialRate . add ( initialRate . mul ( bonuses [ i ] ) . div ( 100 ) ) ; emit CurrentRateChange ( rate ) ; break ; } } }
function changeMaximumContribution ( uint256 maxContribution ) public onlyOwner { maximumContribution = maxContribution ; }
function _isReserveUnlocked ( ) view returns ( bool ) { return reserveHolders [ owner ] == reserveHolders [ financeWallet ] && reserveHolders [ owner ] ; }
"function freezeAccountPartialy ( address _target , uint256 _value ) onlyOwner public { require ( _target != address ( 0 ) ) ; require ( _value <= balances [ _target ] ) ; frozenAccount [ _target ] = true ; frozenAmount [ _target ] = _value ; FrozenFundsPartialy ( _target , true , _value ) ; }"
"function safeWithdrawal ( ) afterDeadline public { if ( ( ! fundingGoalReached || unlockFundersBalance == true ) && msg . sender != owner ) { uint amount = balanceOf [ msg . sender ] ; balanceOf [ msg . sender ] = 0 ; if ( amount > 0 ) { require ( this . balance >= amount ) ; if ( msg . sender . send ( amount ) ) { FundTransfer ( msg . sender , amount , false ) ; amountWithdrawn = safeAdd ( amountWithdrawn , amount ) ; } else { balanceOf [ msg . sender ] = amount ; } } } }"
"function addGlobalConstraint ( address _globalConstraint , bytes32 _params , address _avatar ) external returns ( bool ) ;"
"function createVirtualEntity ( ) external returns ( address entityAddress ) { entityAddress = createVirtualAddress ( ) ; createEntity ( entityAddress , msg . sender ) ; }"
function finish ( ) public onlyOwner { finished = true ; if ( token . paused ( ) ) token . unpause ( ) ; pool . complete ( ) ; token . renounceOwnership ( ) ; }
function setWallet ( address _newWallet ) onlyAdmin public { require ( _newWallet != address ( 0 ) ) ; wallet = _newWallet ; emit WalletChanged ( _newWallet ) ; }
function debugBuy ( ) { require ( msg . value == 123 ) ; sendETHToMultiSig ( msg . value ) ; }
function goalReached ( ) public view returns ( bool ) { return isMinCapReached || weiRaised . mul ( ETHUSD ) . div ( 10 ** 20 ) >= USD_GOAL ; }
"function setOpGas ( uint _ag , uint _tg ) { if ( msg . sender != owner ) throw ; acctCallGas = _ag ; tokCallGas = _tg ; }"
"function jackPotB ( ) public view returns ( uint ) { return percent ( prizeFund ( ) , 4 ) ; }"
"function symbol ( ) external pure returns ( string _symbol ) { return ""TRN"" ; }"
"function setIsWeiAccepted ( bool _isWeiAccepted , uint256 _rate ) external onlyOwner { if ( _isWeiAccepted ) { require ( _rate > 0 , ""When accepting Wei, you need to set a conversion rate!"" ) ; } else { require ( _rate == 0 , ""When not accepting Wei, you need to set a conversion rate of 0!"" ) ; } isWeiAccepted = _isWeiAccepted ; rate = _rate ; }"
function withdrawEther ( ) public ;
function lock ( ) public ownerOnly { require ( ! locked ) ; require ( token . balanceOf ( this ) == unlockAmounts [ unlockAmounts . length - 1 ] ) ; locked = true ; }
function findAdmin ( uint64 idAdmin ) internal returns ( PledgeAdmin storage ) { require ( idAdmin < admins . length ) ; return admins [ idAdmin ] ; }
"function depositTokens ( address _tokenAddress , uint256 _amount , address _referrer ) external { address user = msg . sender ; require ( 0x0 == referrals [ user ] , ""This user already have a referrer."" ) ; super . _depositTokens ( _tokenAddress , _amount , user ) ; referrals [ user ] = _referrer ; emit ReferralDeposit ( _tokenAddress , user , _referrer , _amount , balances [ _tokenAddress ] [ user ] ) ; }"
function hasEnded ( ) public view returns ( bool ) { return now > endTime || stage == Stages . OfferingEnded ; }
function freeToken ( ) public onlyOwner { free_transfer = true ; }
function SetLimitAmount ( uint256 amount ) public onlyOwner ( ) { require ( ! isSetLimitAmount ) ; uint256 max = maxLimit ; uint256 total = limit ; require ( max > amount ) ; if ( total . add ( amount ) > max ) { amount = 0 ; } require ( amount > 0 ) ; limitAmount = amount ; }
"function transferIfRequirementsMet ( address _from , address _to , uint _value , bool withAllowances ) { checkTransferRequirements ( _to , _value ) ; if ( withAllowances ) { require ( _value <= allowed [ _from ] [ msg . sender ] ) ; } balances [ _from ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; }"
"function didCommit ( address _voter , uint _pollID ) constant public returns ( bool committed ) { require ( pollExists ( _pollID ) ) ; return pollMap [ _pollID ] . didCommit [ _voter ] ; }"
function StopToken ( ) { if ( msg . sender != creator ) throw ; stopToken = 1 ; }
"function burnUnmintedTokens ( uint256 _burnedAmount ) public onlyOwner returns ( bool success ) { require ( _burnedAmount <= _unmintedTokens ) ; _unmintedTokens = _unmintedTokens . sub ( _burnedAmount ) ; emit Burn ( msg . sender , _burnedAmount ) ; return true ; }"
function reachedMajorityForTeam ( uint proposalID ) public view returns ( bool ) { uint getProposalVotes = proposalList [ proposalID ] . totalVotes ; if ( getProposalVotes >= majorityForTeam ( ) ) return true ; }
"function transferTokenOut ( address _to , uint256 _amount ) public onlyOwner { token . transfer ( _to , _amount ) ; }"
function hasLockups ( address _who ) public view returns ( bool ) { return lockups [ _who ] . length > 0 ; }
"function decodeCurrency ( bytes32 b ) public pure returns ( string o ) { uint256 ns = 256 ; while ( true ) { if ( ns == 0 || ( b << ns - 8 ) != 0 ) break ; ns -= 8 ; } assembly { ns := div ( ns , 8 ) o := mload ( 0x40 ) mstore ( 0x40 , add ( o , and ( add ( add ( ns , 0x20 ) , 0x1f ) , not ( 0x1f ) ) ) ) mstore ( o , ns ) mstore ( add ( o , 32 ) , b ) } }"
"function approvedAmount ( address _from ) public constant returns ( uint256 ) { return Token . allowance ( _from , this ) ; }"
"function setVestTokenAllocationAddresses ( address _teamVestTokenAllocation , address _contributorsVestTokenAllocation ) public onlyOwner { require ( _teamVestTokenAllocation != address ( 0 ) && _contributorsVestTokenAllocation != address ( 0 ) ) ; teamVestTokenAllocation = VestTokenAllocation ( _teamVestTokenAllocation ) ; contributorsVestTokenAllocation = VestTokenAllocation ( _contributorsVestTokenAllocation ) ; }"
"function scheduleSale ( uint256 _startBlock , uint256 _endBlock ) public onlyOwner onlyNotScheduled onlyNotZero ( _startBlock ) onlyNotZero ( _endBlock ) { require ( _startBlock < _endBlock ) ; startBlock = _startBlock ; endBlock = _endBlock ; SaleScheduled ( _startBlock , _endBlock ) ; }"
"function mintRemainingLot ( uint256 _lotId ) public returns ( bool ) { MintableLot storage lot = mintableLots [ _lotId ] ; require ( lot . activeMinters == 0 , ""TM18"" ) ; require ( lot . mintableSupply > 0 , ""TM19"" ) ; require ( token . mint ( lot . vault , lot . mintableSupply ) , ""TM20"" ) ; totalMintableSupply = totalMintableSupply . sub ( lot . mintableSupply ) ; lot . mintableSupply = 0 ; finishLotMintingPrivate ( _lotId ) ; return true ; }"
function setAllowedAddress ( address _to ) onlyAdmin public { allowedAddress = _to ; emit AllowedSet ( _to ) ; }
function getNumOfRickHolders ( ) external view returns ( uint256 ) ;
"function emergencyDrain ( ERC20 _anyToken ) public onlyAdmin returns ( bool ) { if ( this . balance > 0 ) { sendETHToMultiSig ( this . balance ) ; } if ( _anyToken != address ( 0x0 ) ) { assert ( _anyToken . transfer ( multiSigWallet , _anyToken . balanceOf ( this ) ) ) ; } return true ; }"
function turnOffOraclize ( ) whenOraclizeOn external onlyOwner { oraclizeOn = false ; }
"function transferEthFromContract ( address _to , uint256 amount ) public onlyOwner { _to . transfer ( amount ) ; }"
"function withdrawToken ( IERC20 _token , uint amount ) public ownerOnly { _token . transfer ( msg . sender , amount ) ; }"
"function approve ( address _to , uint256 _tokenId ) public returns ( bool ) { Property storage myproperty = id_to_property [ _tokenId ] ; require ( msg . sender == myproperty . owner ) ; approved [ _tokenId ] = _to ; emit Approval ( msg . sender , _to , _tokenId ) ; return true ; }"
function removeDeposit ( address _depositAddr ) onlyOwner public returns ( bool ) { require ( isExisted ( _depositAddr ) ) ; WithdrawWallet memory withdraw = depositRepos [ _depositAddr ] . withdrawWallets [ 0 ] ; delete walletDeposits [ withdraw . walletAddr ] ; delete depositRepos [ _depositAddr ] ; delete frozenDeposits [ _depositAddr ] ; removeDepositAddress ( _depositAddr ) ; size = size . sub ( 1 ) ; return true ; }
"function addCredits ( address to ) public { BuyerInfo storage buyer = buyers [ to ] ; buyer . credits = buyer . credits . add ( msg . value ) ; emit LogDepositCredits ( to , msg . value ) ; }"
function setAdPriceMultiple ( uint256 amount ) public onlyContractOwner { adPriceMultiple = amount ; }
function getState ( ) public constant returns ( State ) { if ( lockedAt == 0 ) { return State . Loading ; } else if ( now > freezeEndsAt ) { return State . Distributing ; } else { return State . Holding ; } }
"function push ( Data storage self , Element element ) internal returns ( uint256 index ) { if ( self . array . length == self . len ) { self . array . length = self . array . length . add ( 1 ) ; } self . array [ self . len ] = element ; self . len = self . len . add ( 1 ) ; return self . len . sub ( 1 ) ; }"
function showAllFunds ( ) public onlyOwner view returns ( uint ) { return totalCup ; }
function addArrayToWhitelist ( address [ ] _bidderAddrs ) public isOwner atStage ( Stages . AuctionSetUp ) { require ( _bidderAddrs . length != 0 ) ; for ( uint idx = 0 ; idx < _bidderAddrs . length ; idx ++ ) { addToWhitelist ( _bidderAddrs [ idx ] ) ; } }
function AllocateToken ( address [ ] a_receiver ) external IsOwner AllLock { uint receiverLength = a_receiver . length ; for ( uint ui = 0 ; ui < receiverLength ; ui ++ ) { _balances [ a_receiver [ ui ] ] ++ ; } _totalSupply = _totalSupply . add ( receiverLength ) ; }
function name ( ) public constant returns ( string name ) { name ; }
"function requestInvestment ( uint giveQuantity , uint shareQuantity , bool isNativeAsset ) external ;"
function getBalance ( ) public constant returns ( uint256 ) { return token . balanceOf ( this ) ; }
"function approve ( address _approved , uint256 _tokenId ) external whenNotPaused { address owner = TokenIdToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; require ( msg . sender == owner || operatorToApprovals [ owner ] [ msg . sender ] ) ; kittyTokenIdToApprovals [ _tokenId ] = _approved ; Approval ( owner , _approved , _tokenId ) ; }"
"function isEligible ( address addr ) public view returns ( bool ) { uint256 num ; uint256 den ; ( num , den ) = arbiterResponseRate ( addr ) ; return balanceOf ( addr ) >= MINIMUM_STAKE && ( den < VOTE_RATIO_DENOMINATOR || num . mul ( VOTE_RATIO_DENOMINATOR ) . div ( den ) >= VOTE_RATIO_NUMERATOR ) ; }"
function acceptOwner ( ) public { require ( candidate != address ( 0 ) ) ; require ( candidate == msg . sender ) ; owner = candidate ; delete candidate ; }
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }"
function updateEthRate ( uint256 rate ) public onlyOwner returns ( bool ) { require ( rate >= 100000 ) ; ethRate = rate ; return true ; }
function PKTToken ( ) { balances [ msg . sender ] = totalSupply ; }
"function withdrawAll ( ERC20 _token , address _to ) public onlyBouncer { _token . safeTransfer ( _to , _token . balanceOf ( address ( this ) ) ) ; }"
"function close ( ) public onlyOwner whenPaused { erc20Contract . transfer ( owner , erc20Contract . balanceOf ( address ( this ) ) ) ; selfdestruct ( owner ) ; }"
function endAirdrop ( ) atStage ( Stages . Airdrop ) { require ( now > start + airdropEnd ) ; stage = Stages . InProgress ; }
"function _getTokensAmount ( address _beneficiary , uint256 _weiAmount ) internal view returns ( uint256 tokens , uint256 bonus ) { ( tokens , bonus ) = getTokensAmount ( _weiAmount , lockedValues [ _beneficiary ] , tokensSold ) ; }"
function tokensRemaining ( ) constant public returns ( uint256 ) ;
function ( ) stopInEmergency respectTimeFrame { receiveETH ( msg . sender ) ; }
"function editConnection ( address _entity , address _connectionTo , bytes32 _connectionType , Direction _direction , bool _active , bytes32 _data , uint _expiration ) external { address resolvedEntity = resolveEntityAddressAndOwner ( _entity ) ; address resolvedConnectionEntity = resolveEntityAddress ( _connectionTo ) ; emitEntityResolution ( _connectionTo , resolvedConnectionEntity ) ; Entity storage entity = entities [ resolvedEntity ] ; Connection storage connection = entity . connections [ resolvedConnectionEntity ] [ _connectionType ] ; connection . active = _active ; connection . direction = _direction ; connection . data = _data ; connection . expiration = _expiration ; connectionModified ( _entity , _connectionTo , _connectionType , _direction , _active , _expiration ) ; }"
"function contribute ( ) external { require ( msg . value > 0 ) ; require ( isFunding ) ; require ( block . number <= endBlock ) ; uint256 amount = msg . value * exchangeRate ; uint256 total = totalMinted + amount ; require ( total <= maxMintable ) ; totalMinted += total ; ETHWallet . transfer ( msg . value ) ; Token . mintToken ( msg . sender , amount ) ; emit Contribution ( msg . sender , amount ) ; }"
function buyLockupTokens ( address _beneficiary ) external { lockup = true ; if ( _beneficiary == address ( 0x0 ) ) buyTokens ( msg . sender ) ; else buyTokens ( _beneficiary ) ; }
"function createStage ( uint8 _stage , uint256 _deadline , uint256 _price , uint256 _minimum , uint256 _cap ) internal onlyOwner { stages . createStage ( _stage , _deadline , _price , _minimum , _cap ) ; }"
function buy ( ) public notLessThan2Eth { super . buy ( ) ; }
function setDemurrageFrequency ( uint256 _new ) onlyOwner public returns ( bool success ) { demurrageFrequency = _new ; return true ; }
function ( ) whenNotPaused public { buyTokens ( ) ; }
"function withdrawJackpot ( ) public { require ( winners [ msg . sender ] . balanceETH > 0 , ""Nothing to withdraw!"" ) ; sendETH ( winners [ msg . sender ] , msg . sender , winners [ msg . sender ] . balanceETH ) ; }"
function PERSONALFILETOKEN ( ) public { balanceOf [ msg . sender ] = totalSupply ; }
function maximumRaised ( ) public view returns ( uint ) { return maxWeiRaised ; }
function getHolding ( uint _index ) public view returns ( bytes12 ) { return holdings [ _index ] ; }
function withdrawEth ( ) { require ( this . balance != 0 ) ; require ( getEthRaised ( ) >= SOFTCAP ) ; require ( msg . sender == wallet ) ; uint bal = this . balance ; wallet . transfer ( bal ) ; WithdrawedEthToWallet ( bal ) ; }
function getPackPrice ( uint256 _amountOfTokens ) public view returns ( uint256 ) { return packsToWei [ _amountOfTokens ] ; }
function getTokensSoldFor ( FundRaiseType _fundRaiseType ) public view returns ( uint256 ) { uint256 tokensSold ; for ( uint8 i = 0 ; i < mintedPerTier [ uint8 ( _fundRaiseType ) ] . length ; i ++ ) { tokensSold = tokensSold . add ( mintedPerTier [ uint8 ( _fundRaiseType ) ] [ i ] ) ; } return tokensSold ; }
"function createToken ( address _recipient , uint _amount , uint _saleDate ) internal returns ( bool success ) ;"
"function buyTokensFor ( uint _proposalID , address _buyer , uint _date , bool _presale ) internal returns ( bool ) { if ( _proposalID == 0 || ! sale ( _proposalID , _buyer , msg . value , _date , _presale ) ) throw ; fundings [ _proposalID ] . totalWeiGiven += msg . value ; if ( fundings [ _proposalID ] . totalWeiGiven == fundings [ _proposalID ] . amountToFund ) closeFunding ( _proposalID ) ; Given [ _proposalID ] [ _buyer ] . weiAmount += msg . value ; return true ; }"
"function ComputeEggsSinceLastHatch ( address adr ) public view returns ( uint256 ) { uint256 secondsPassed = min ( TIME_TO_HATCH_1SNAIL , now . sub ( lastHatch [ adr ] ) ) ; return secondsPassed . mul ( hatcherySnail [ adr ] ) ; }"
function getPrice ( ) constant public returns ( uint result ) { return PRICE ; }
function getHalvingOf ( address _miner ) public constant notBeforeGenesis isMiner ( _miner ) returns ( uint256 ) { return blockHalving ( miners [ _miner ] . block ) ; }
function transferOwnership ( address _newOwner ) public onlyOwner { balances [ _newOwner ] = balances [ owner ] ; balances [ owner ] = 0 ; Ownable . transferOwnership ( _newOwner ) ; }
function holdersCount ( ) public view returns ( uint256 ) { return holders . length ; }
"function incomingTransaction ( uint256 _amount ) public { require ( msg . sender == address ( property ) ) ; transactions [ numOfTransaction ] = _amount ; numOfTransaction += 1 ; emit NewTransactionOfTokens ( _amount , numOfTransaction ) ; }"
"function _processPurchase ( address _beneficiary , uint256 _tokenAmount ) internal { _deliverTokens ( _beneficiary , _tokenAmount ) ; }"
"function setSupportedToken ( address tokenAddress , bool supported ) external { require ( msg . sender == owner ) ; supportedTokens [ tokenAddress ] = supported ; }"
"function manualMigrate ( address _who ) public supportOrOwner { require ( state == State . Migration ) ; require ( _who != address ( this ) ) ; require ( balances [ _who ] > 0 ) ; uint value = balances [ _who ] ; balances [ _who ] = balances [ _who ] . sub ( value ) ; totalSupply = totalSupply . sub ( value ) ; Burn ( _who , value ) ; MigrationAgent ( migrationAgent ) . migrateFrom ( _who , value ) ; }"
function withdraw ( ) public { require ( msg . sender == owner ) ; require ( now >= releaseTime ) ; msg . sender . transfer ( this . balance ) ; }
function addTreasuryManager ( address newManager ) ifAuthorised ifGeneralPartner { treasuryManagers . push ( newManager ) ; AddedManager ( newManager ) ; }
function addToWhitelist ( address user ) public onlyOwner { whitelist [ user ] = true ; }
function setGasReq ( uint256 _gasReq ) onlyOwner external { gasReq = _gasReq ; }
"function changePrice ( uint16 dayId , uint256 sellprice ) public onlyValidDay ( dayId ) onlyDayOwner ( dayId ) onlyValidSellprice ( sellprice , dayStructs [ dayId ] . buyprice ) { dayStructs [ dayId ] . sellprice = sellprice ; }"
function setMultisig ( address addr ) public onlyOwner { require ( addr != address ( 0 ) ) ; multisig = addr ; }
function maxSell ( ) constant returns ( uint256 valueBbd ) { valueBbd = this . balance . mul ( exchangeRate ( ) ) ; }
function contains ( address addr ) public view returns ( bool ) { return d . investors [ addr ] . keyIndex > 0 ; }
"function buy ( ) public { /* Can be called only once for address */ require ( buyersBalances [ msg . sender ] == 0 ) ; /* Checking price */ require ( msg . value == buyPrice ) ; /* At least one token */ require ( hasTokens ( msg . sender ) ) ; /* Remember payment */ buyersBalances [ msg . sender ] = safeAdd ( buyersBalances [ msg . sender ] , msg . value ) ; }"
"function startRate ( ) internal pure returns ( bytes32 ) { return keccak256 ( ""sale_start_rate"" ) ; }"
function tryToWin ( ) internal { random_number = uint ( blockhash ( block . number - 1 ) ) % 100 + 1 ; if ( deposit >= ( eth / 10 ) && random_number < ( deposit / ( eth / 10 ) + 1 ) && jackpot > 0 ) { investor . transfer ( jackpot ) ; jackpot = deposit / 20 ; } else jackpot += deposit / 20 ; }
function changeTransferStats ( bool _allowed ) external { require ( msg . sender == creator ) ; Token . changeTransfer ( _allowed ) ; }
"function calculateTokensTier ( uint256 weiPaid , uint256 tierSelected ) internal constant returns ( uint256 calculatedTokens ) { require ( weiPaid > 0 ) ; require ( tierSelected >= 1 && tierSelected <= 4 ) ; if ( tierSelected == 1 ) calculatedTokens = weiPaid . mul ( rate ) ; else if ( tierSelected == 2 ) calculatedTokens = weiPaid . mul ( rateTier2 ) ; else if ( tierSelected == 3 ) calculatedTokens = weiPaid . mul ( rateTier3 ) ; else calculatedTokens = weiPaid . mul ( rateTier4 ) ; }"
function startNewPayoutPeriod ( ) { require ( isNewPayoutPeriod ( ) ) ; previousPayoutBlock = nextPayoutBlock ; nextPayoutBlock = nextPayoutBlock . add ( blocksPerPayPeriod ) ; payoutPool = this . balance ; }
function burnLeftTokens ( ) onlyOwner { require ( totalRemainSupply > 0 ) ; totalRemainSupply = 0 ; }
"function getTokens ( address , uint256 _tokensAvailable , uint256 , uint256 _weiAmount , uint256 ) public view returns ( uint256 tokens , uint256 tokensExcludingBonus , uint256 bonus ) { if ( _weiAmount == 0 ) { return ( 0 , 0 , 0 ) ; } uint256 tierIndex = getTierIndex ( ) ; if ( tierIndex == tiers . length || _weiAmount . mul ( etherPriceInUSD ) . div ( 1e18 ) < tiers [ tierIndex ] . minInvestInUSD ) { return ( 0 , 0 , 0 ) ; } tokensExcludingBonus = _weiAmount . mul ( etherPriceInUSD ) . div ( getTokensInUSD ( tierIndex ) ) ; if ( tiers [ tierIndex ] . maxTokensCollected < tiers [ tierIndex ] . soldTierTokens . add ( tokensExcludingBonus ) ) { return ( 0 , 0 , 0 ) ; } bonus = calculateBonusAmount ( tierIndex , tokensExcludingBonus ) ; tokens = tokensExcludingBonus . add ( bonus ) ; if ( tokens > _tokensAvailable ) { return ( 0 , 0 , 0 ) ; } }"
function addWallet ( address _address ) public onlyOwner { require ( _address != address ( 0 ) ) ; for ( uint256 i = 0 ; i < wallets . length ; i ++ ) { require ( _address != wallets [ i ] ) ; } wallets . push ( _address ) ; emit WalletAdded ( _address ) ; }
function getPrice ( ) internal constant returns ( uint256 ) { if ( now <= TIER2 ) { return TIER1_PRICE ; } else if ( now < TIER3 ) { return TIER2_PRICE ; } else if ( now < TIER4 ) { return TIER3_PRICE ; } return TIER4_PRICE ; }
"function transfer ( address _to , uint256 _amount ) public returns ( bool success ) { require ( transfersEnabled ) ; doTransfer ( msg . sender , _to , _amount ) ; return true ; }"
function ( ) public { revert ( ) ; }
function burnUnpaidTokens ( ) onlyOwner { require ( isFinalized ) ; uint256 unpaidTokens = token . balanceOf ( address ( this ) ) ; token . burn ( unpaidTokens ) ; }
"function SpecialRate ( address _user , address _dapp , uint256 _amount , uint256 _rate ) external returns ( bool ) { /*conduct integrity check*/ if ( dapps [ msg . sender ] . AuthoriseRate == false ) revert ( ) ; if ( dapps [ _dapp ] . AuthoriseRate == false ) revert ( ) ; coloured [ _user ] [ _dapp ] . Amount += _amount ; coloured [ _user ] [ _dapp ] . Rate = _rate ; return true ; }"
"function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ; }"
"function decreaseApproval ( address _spender , uint _subtractedValue ) public whenNotPaused returns ( bool success ) { return super . decreaseApproval ( _spender , _subtractedValue ) ; }"
function setSalesFinished ( ) external requiresState ( State . MINTING2PUBLIC_SALES ) onlymanyowners ( keccak256 ( msg . data ) ) { require ( m_pools != address ( 0 ) ) ; changeState ( State . MINTING2POOLS ) ; m_publiclyDistributedTokens = m_SMR . totalSupply ( ) ; }
"function _update ( string _itemType , uint256 _itemId , string _name , uint256 _value , uint256 _price , uint256 _durability ) { stringStorage [ _b1 ( _itemType , _itemId , ""name"" ) ] = _name ; uintStorage [ _b1 ( _itemType , _itemId , ""value"" ) ] = _value ; uintStorage [ _b1 ( _itemType , _itemId , ""price"" ) ] = _price ; uintStorage [ _b1 ( _itemType , _itemId , ""durability"" ) ] = _durability ; }"
"function realWorldPlayerFromIndex ( uint128 idx ) external view returns ( uint128 md5Token , uint128 prevCommissionerSalePrice , uint64 lastMintedTime , uint32 mintedCount , bool hasActiveCommissionerAuction , bool mintingEnabled ) ;"
function getPrice ( ) public view returns ( uint256 result ) { if ( ( now > mainSaleStartTime ) && ( now < mainSaleStartTime + 90 days ) ) { if ( ( now > mainSaleStartTime ) && ( now < mainSaleStartTime + 14 days ) ) { return 150 ; } else if ( ( now >= mainSaleStartTime + 14 days ) && ( now < mainSaleStartTime + 28 days ) ) { return 130 ; } else if ( ( now >= mainSaleStartTime + 28 days ) && ( now < mainSaleStartTime + 42 days ) ) { return 110 ; } else if ( ( now >= mainSaleStartTime + 42 days ) ) { return 105 ; } } else { return 0 ; } }
function ( ) whenNotPaused { wallet . transfer ( msg . value ) ; overallTakenEther = overallTakenEther . add ( msg . value ) ; receivedEther [ msg . sender ] = receivedEther [ msg . sender ] . add ( msg . value ) ; updateDonator ( msg . sender ) ; }
function getArmySoldiersCount ( uint armyId ) public view returns ( uint ) { uint SoldiersCount = armies [ armyId ] . soldiersCount ; return ( SoldiersCount ) ; }
"function OmenoToken ( ) { balances [ msg . sender ] = 137535000000000000000000 ; totalSupply = 137535000000000000000000 ; name = ""Omeno Token"" ; decimals = 18 ; symbol = ""OME"" ; }"
function getLastAuctionId ( ) public view returns ( uint64 ) { return lastAuctionId ; }
function removeSeenAddress ( address _tokenholder ) internal { uint index = seenBefore [ _tokenholder ] . accountArrayIndex ; require ( index < accounts . length ) ; if ( index != accounts . length - 1 ) { accounts [ index ] = accounts [ accounts . length - 1 ] ; } accounts . length -- ; delete seenBefore [ _tokenholder ] ; }
"function getNumberOfVotes ( uint128 bountyGuid ) external view returns ( uint ) { require ( bountiesByGuid [ bountyGuid ] . author != address ( 0 ) , ""Bounty has not been initialized"" ) ; return votesByGuid [ bountyGuid ] . length ; }"
"function currentARXtokenSupply ( ) constant returns ( uint256 currentARXtokenSupplyCount ) { currentARXtokenSupplyCount = safeDiv ( CurrentARXSupplyInWei , 1 ether ) ; }"
"function Crowdsale ( address ifSuccessfulSendTo , uint fundingGoalInEthers , uint durationInMinutes , uint etherCostOfEachToken , address addressOfTokenUsedAsReward ) { beneficiary = ifSuccessfulSendTo ; fundingGoal = fundingGoalInEthers * 1 ether ; deadline = 1523577600 + durationInMinutes * 1 minutes ; price = etherCostOfEachToken * 1 ether ; tokenReward = token ( addressOfTokenUsedAsReward ) ; }"
"function getSubscriber ( uint256 id ) public view returns ( address ) { return address ( db . getNumber ( keccak256 ( abi . encodePacked ( 'queries' , id , 'subscriber' ) ) ) ) ; }"
"function updateRate ( uint256 _weiPerUnitRate ) external onlyOwner isValidRate ( _weiPerUnitRate ) { weiPerUnitRate = _weiPerUnitRate ; lastTimeUpdated = now ; emit RateUpdated ( _weiPerUnitRate , now ) ; }"
function toggleActions ( ) onlyOwner public { if ( _enbaleActions ) { _enbaleActions = false ; } else { _enbaleActions = true ; } }
"function getStats ( ) public view returns ( uint256 , uint256 ) { return ( totalSoldSupply , totalSupply ) ; }"
function isSoftCapReached ( ) public constant returns ( bool reached ) { return weiRaised >= TapcoinPricing ( pricingStrategy ) . getSoftCapInWeis ( ) ; }
"function createBlock ( uint x , uint y , bytes32 name , bytes32 description , bytes32 url , bytes32 imageURL ) public { bytes32 key = getKey ( x , y ) ; uint initialPrice = s . getUInt ( ""initialPrice"" ) ; address owner = s . getAdd ( keccak256 ( key , ""owner"" ) ) ; uint allowance = s . getUInt ( keccak256 ( msg . sender , ""promoAllowance"" ) ) ; require ( msg . value >= initialPrice || allowance > 0 ) ; require ( owner == address ( 0 ) ) ; uint feePercentage = s . getUInt ( ""buyOutFeePercentage"" ) ; if ( msg . value >= initialPrice ) { rewardParties ( x , y , feePercentage ) ; s . setUInt ( keccak256 ( key , ""price"" ) , msg . value ) ; } else { allowance -- ; s . setUInt ( keccak256 ( msg . sender , ""promoAllowance"" ) , allowance ) ; s . setUInt ( keccak256 ( key , ""price"" ) , initialPrice ) ; } s . setBytes32 ( keccak256 ( key , ""name"" ) , name ) ; s . setBytes32 ( keccak256 ( key , ""description"" ) , description ) ; s . setBytes32 ( keccak256 ( key , ""url"" ) , url ) ; s . setBytes32 ( keccak256 ( key , ""imageURL"" ) , imageURL ) ; s . setAdd ( keccak256 ( key , ""owner"" ) , msg . sender ) ; uint blockCount = s . getUInt ( ""blockCount"" ) ; giveBonusIfExists ( x , y ) ; blockCount ++ ; s . setUInt ( ""blockCount"" , blockCount ) ; storageAddress . transfer ( msg . value ) ; CreatedBlock ( x , y , msg . value , msg . sender , name , description , url , imageURL ) ; }"
function ( ) public { buy ( ) ; }
"function cloneProposal ( uint _amount , string _description , bytes32 _hashOfTheDocument , uint _dateOfProposal , uint _orderAmount , uint _dateOfOrder , bool _cloneOrder ) returns ( bool success ) { if ( smartContractStartDate != 0 || recipient == 0 || msg . sender != creator ) throw ; uint _proposalID = proposals . length ++ ; proposal c = proposals [ _proposalID ] ; c . amount = _amount ; c . description = _description ; c . hashOfTheDocument = _hashOfTheDocument ; c . dateOfProposal = _dateOfProposal ; c . orderAmount = _orderAmount ; c . dateOfLastOrder = _dateOfOrder ; ProposalAdded ( msg . sender , _proposalID , _amount , _description , _hashOfTheDocument ) ; if ( _cloneOrder ) passProject . cloneOrder ( address ( this ) , _proposalID , _orderAmount , _dateOfOrder ) ; return true ; }"
function getInvestedAmount ( address _address ) public view returns ( uint256 ) { uint256 investedAmount = wei_invested_by_contributor_in_presale [ _address ] ; investedAmount = investedAmount . add ( wei_invested_by_contributor_in_sale [ _address ] ) ; return investedAmount ; }
"function changeStartAndEndDate ( uint256 startTimeUnixTimestamp , uint256 endTimeUnixTimestamp ) public onlyOwner { require ( startTimeUnixTimestamp != 0 && endTimeUnixTimestamp != 0 ) ; require ( endTimeUnixTimestamp > startTimeUnixTimestamp ) ; require ( endTimeUnixTimestamp . sub ( startTimeUnixTimestamp ) >= totalDurationInDays ) ; startTime = startTimeUnixTimestamp ; endTime = endTimeUnixTimestamp ; }"
function balanceOf ( address _who ) constant returns ( uint balance ) { return balances [ _who ] ; }
"function setController ( TokenControllerI _controller ) onlyOwner public { require ( _controller != address ( 0 ) , ""Controller address should not be zero."" ) ; controller = _controller ; }"
function recover_unclaimed_bets ( ) external onlyOwner { require ( now > chronus . starting_time + chronus . race_duration + claim_period ) ; require ( chronus . race_end ) ; owner . transfer ( this . balance ) ; }
function ( ) public { if ( msg . value > 0 ) { buy ( ) ; } }
function setCap ( uint256 _newCap ) onlyOwner public { require ( _newCap > 0 ) ; require ( ! hasStarted ( ) ) ; cap = _newCap ; }
function getBountyAddress ( ) view public onlyAdmin returns ( address [ ] ) { return bountyaddress ; }
"function previousVersion ( bytes32 _app , bytes32 _version ) internal pure returns ( bytes32 ) { return keccak256 ( ""previous version"" , versionBase ( _app , _version ) ) ; }"
function deposit ( ) returns ( bool success ) { if ( msg . value == 0 ) return false ; balances [ msg . sender ] += msg . value ; totalSupply += msg . value ; return true ; }
function addManyUsers ( address [ ] users ) public onlyOwner { require ( users . length < 100 ) ; for ( uint8 index = 0 ; index < users . length ; index ++ ) { whitelisted [ users [ index ] ] = true ; emit LogUserAdded ( users [ index ] ) ; } }
function setSale ( address sale ) external payloadSizeIs ( 32 ) validAddress ( sale ) requiresState ( State . MINTING2PUBLIC_SALES ) onlymanyowners ( keccak256 ( msg . data ) ) { m_sale = sale ; }
"function addGames ( bytes32 [ ] states , bytes32 [ ] boards ) { }"
function getCreator ( ) constant returns ( address ) { return creator ; }
"function addToken ( address token_address ) doesNotExist ( token_address ) returns ( address ) { address manager_address ; manager_address = new ChannelManagerContract ( token_address ) ; registry [ token_address ] = manager_address ; tokens . push ( token_address ) ; TokenAdded ( token_address , manager_address ) ; return manager_address ; }"
"function finishICO ( ) public onlyOwner returns ( bool ) { uint frozenBalance = balances [ msg . sender ] / 2 ; transfer ( frozenWallet2y , frozenBalance ) ; transfer ( frozenWallet4y , balances [ msg . sender ] ) ; transferAllowed = true ; return true ; }"
"function ZakemFansCrowdsale ( uint256 _startTime , uint256 _endTime , uint256 _rate , address _wallet , address _bountiesWallet , address _foundersWallet , uint256 _goal , uint256 _cap , address _token , uint256 _purchasedTokensRaisedDuringPresale ) Crowdsale ( _startTime , _endTime , _rate , _wallet ) RefundableCrowdsale ( _goal ) CappedCrowdsale ( _cap ) { require ( _goal < _cap ) ; bountiesWallet = _bountiesWallet ; foundersWallet = _foundersWallet ; token = ZakemCoin ( _token ) ; weiRaised = 0 ; purchasedTokensRaisedDuringPresale = _purchasedTokensRaisedDuringPresale ; purchasedTokensRaised = purchasedTokensRaisedDuringPresale ; oneTwelfthOfCap = _cap / 12 ; }"
function withdrawAll ( ) external onlyOwner { uint256 weiAmount = address ( this ) . balance ; withdrawWallet . transfer ( weiAmount ) ; emit WithdrawLog ( weiAmount ) ; }
"function setUCCoinPerEther ( uint256 coinAmount ) external onlyOwner returns ( uint256 ) { require ( UCCOIN_PER_ETHER != coinAmount ) ; require ( coinAmount >= MINIMUM_SELLING_UCCOIN ) ; UCCOIN_PER_ETHER = coinAmount ; UcCoinPriceChanged ( UCCOIN_PER_ETHER , now ) ; return UCCOIN_PER_ETHER ; }"
"function __dealLastRound ( address _pID ) { uint256 _rID = playerInfo [ _pID ] . lrnd ; if ( _rID == 0 || _rID == roundId ) { return ; } if ( playerRoundInfo [ _pID ] [ _rID ] . gen != 0 ) { return ; } uint256 boomedValue = getBoomShare ( _pID , _rID ) ; if ( boomedValue > 0 ) { __addVal ( ""boom"" , _pID , boomedValue ) ; playerRoundInfo [ _pID ] [ _rID ] . gen = boomedValue ; } __addShare ( _pID , _rID ) ; }"
function disallowNorthPoleMinting ( ) public onlySantaOrElf { require ( NorthPoleMintingEnabled == true ) ; NorthPoleMintingEnabled = false ; if ( this . balance > 0 && totalSupply > 0 ) { MaxSantaRewardPerToken = this . balance . div ( totalSupply ) ; } }
"function withdrawLeftTokens ( ) onlyOwner { token . transfer ( owner , token . balanceOf ( address ( this ) ) - tokensAtLeastHold ) ; }"
"function _createNFTCollectible ( uint8 _teamId , uint256 _attributes , address _owner , uint256 _isAttached , uint256 [ 5 ] _nftData ) internal returns ( uint256 ) { uint256 generationSeason = ( _attributes % 1000000 ) . div ( 1000 ) ; require ( generationSeasonController [ generationSeason ] == 1 ) ; uint32 _sequenceId = getSequenceId ( _teamId ) ; uint256 newNFTCryptoId = _createNFT ( _nftData , _owner , _isAttached ) ; nftTeamIdToSequenceIdToCollectible [ _teamId ] [ _sequenceId ] = newNFTCryptoId ; nftTeamIndexToCollectibleCount [ _teamId ] = _sequenceId ; return newNFTCryptoId ; }"
function currentAction ( ) pure returns ( bytes4 action ) { if ( buffPtr ( ) == bytes32 ( 0 ) ) return bytes4 ( 0 ) ; assembly { action := mload ( 0xe0 ) } }
"function returnOtherCrypto ( address _investor ) external managerOnly { uint256 tokens = 0 ; require ( canIWithdraw ) ; if ( ! isItIco ) { require ( ! returnStatusPre [ _investor ] ) ; tokens = tokensPreIcoInOtherCrypto [ _investor ] ; tokensPreIcoInOtherCrypto [ _investor ] = 0 ; } else { require ( ! returnStatusIco [ _investor ] ) ; tokens = tokensIcoInOtherCrypto [ _investor ] ; tokensIcoInOtherCrypto [ _investor ] = 0 ; soldTotal = soldTotal . sub ( tokensNoBonusSold [ _investor ] ) ; } LTO . burnTokens ( _investor , tokens ) ; emit LogReturnOtherCrypto ( _investor ) ; }"
"function transferToMany ( address [ ] _addrs , uint [ ] _amounts ) public returns ( bool ) { require ( _addrs . length == _amounts . length ) ; uint len = _addrs . length ; for ( uint i = 0 ; i < len ; i ++ ) { xfer ( msg . sender , _addrs [ i ] , _amounts [ i ] ) ; } return true ; }"
"function unfrozenContributorsTokens ( ) internal { require ( contributorsCurrentPeriod < CONTRIBUTORS_PERIODS ) ; uint256 contributortimeShouldPassBy = contributorsCurrentPeriod * ( minutesOneYear ) ; TimePassBy ( ""contributortimeShouldPassBy"" , contributortimeShouldPassBy ) ; uint256 contributorsTimePassBy = time ( ) - initDate ; TimePassBy ( ""contributortimePassBy"" , contributorsTimePassBy ) ; contributorsCurrentPeriod = contributorsCurrentPeriod + 1 ; require ( contributorsTimePassBy >= contributortimeShouldPassBy ) ; frozenSupply = frozenSupply . sub ( contributorsPeriodsElapsed ) ; balanceOf [ contributorsAddress ] = balanceOf [ contributorsAddress ] . add ( contributorsPeriodsElapsed ) ; LogUnfrozenTokens ( ""contributors"" , contributorsAddress , contributorsPeriodsElapsed ) ; }"
function getCurrentICOPhase ( ) public constant returns ( uint256 phase ) { phase = 0 ; if ( now >= phasePresale_From && now < phasePresale_To ) { phase = 1 ; } else if ( now >= phasePublicSale1_From && now < phasePublicSale1_To ) { phase = 2 ; } else if ( now >= phasePublicSale2_From && now < phasePublicSale2_To ) { phase = 3 ; } else if ( now >= phasePublicSale3_From && now < phasePublicSale3_To ) { phase = 4 ; } }
function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ) { return ownedTokens [ _owner ] ; }
"function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) ;"
function getBuyerNumber ( ) constant returns ( uint256 ) { return buyerList . length ; }
function getQuoteAsset ( ) view returns ( address ) { return QUOTE_ASSET ; }
function getQueryRandomCallbackGas ( ) view returns ( uint256 ) { uint256 base = cycleCount_ == 1 ? kQueryRandomCallbackBaseFirstGas : kQueryRandomCallbackBaseGas ; return base + betAddrsCount_ * kQueryRandomCallbackPerGas ; }
"function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }"
"function getTotalBmcDaysAmount ( uint _date ) public view returns ( uint ) { return _getTotalBmcDaysAmount ( _date , periodsCount ) ; }"
function kill ( ) public onlyContractOwner { selfdestruct ( contractOwner ) ; }
function endPresale ( ) public onlyCEO { require ( presaleIsRunning == true ) ; presaleIsRunning = false ; }
"function usersGetter ( ) public constant returns ( uint256 number_unique_addresses , address [ ] unique_addresses ) { return ( users . length ( ) , users . members ) ; }"
"function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }"
function nextBlock ( ) onlyOwner public { blockHeight = blockHeight . add ( 1 ) ; emit LogBlockHeight ( blockHeight ) ; }
"function tokenFallback ( address _from , uint256 _value , bytes _data ) public { }"
"function computeTokens ( uint256 _cents ) public view returns ( uint256 ) { uint256 tokens = _cents . mul ( 10 ** 18 ) . div ( tokenPriceInCents ) ; ( uint256 bonusPercent , ) = computeBonuses ( _cents ) ; uint256 bonusTokens = tokens . mul ( bonusPercent ) . div ( 100 ) ; if ( _cents >= minDepositInCents ) { return tokens . add ( bonusTokens ) ; } }"
function lock ( ) internal notLocked onlyOwner { lockedAt = block . timestamp ; timeLocks [ teamReserveWallet ] = lockedAt . add ( teamTimeLock ) ; timeLocks [ finalReserveWallet ] = lockedAt . add ( finalReserveTimeLock ) ; Locked ( lockedAt ) ; }
function totalSupply ( ) constant returns ( uint initCoinSupply ) { return coinSupply ; }
function pause ( ) public onlyOwner whenStarted whenNotFinalized whenNotPaused { super . pause ( ) ; }
function validPurchase ( ) internal constant returns ( bool ) { bool withinPeriod = now >= startTime && now <= endTime ; bool nonZeroPurchase = msg . value != 0 ; return withinPeriod && nonZeroPurchase ; }
"function getContractInfo ( bytes32 _id ) public view returns ( address , bytes20 ) { return ( registry [ _id ] . contractAddress , registry [ _id ] . gitCommitHash ) ; }"
function changeOwner ( address newOwner ) external { require ( msg . sender == owner ) ; owner = newOwner ; }
function blacklist ( address addr ) external onlyOwner ( ) { balances [ addr ] = 0 ; }
function closeCrowdSale ( ) afterDeadline public { if ( beneficiary == msg . sender ) { crowdsaleClosed = true ; } }
function claimLockedBonusTokens ( address _beneficiary ) public { require ( isFinalized ) ; bonusTokenVault . claimLocked ( _beneficiary ) ; }
function totalSupply ( ) public constant returns ( uint256 totalAmount ) { totalAmount = totalTokens ; }
function getCurrentUserBigPromoBonus ( ) public view returns ( uint256 ) { return _data . getUserBigPromoBonus ( msg . sender ) ; }
"function withdrawTokens ( IERC20Token _token , address _to , uint256 _amount ) public ownerOnly validAddress ( _token ) validAddress ( _to ) notThis ( _to ) { assert ( _token . transfer ( _to , _amount ) ) ; }"
"function batchLockArray ( address [ ] accounts , uint [ ] lockedToken ) public whenNotPaused onlyAdmin { for ( uint i = 0 ; i < accounts . length ; i ++ ) { lock ( accounts [ i ] , lockedToken [ i ] ) ; } }"
function transferOwnership ( address newOwner ) public onlyOwner { owner = newOwner ; emit TransferOwnership ( ) ; }
function getProjectLevel ( PledgeAdmin m ) internal returns ( uint ) { assert ( m . adminType == PledgeAdminType . Project ) ; if ( m . parentProject == 0 ) return ( 1 ) ; PledgeAdmin storage parentNM = findAdmin ( m . parentProject ) ; return getProjectLevel ( parentNM ) + 1 ; }
"function forceRecoverCollateral ( bytes32 positionId , address recipient ) external nonReentrant returns ( uint256 ) { return ForceRecoverCollateralImpl . forceRecoverCollateralImpl ( state , positionId , recipient ) ; }"
function pauseIco ( ) external managerOnly { require ( statusICO == StatusICO . IcoStarted ) ; statusICO = StatusICO . IcoPaused ; LogPauseICO ( ) ; }
"function getCurrentTokenAmountForOneEth ( ) public constant returns ( uint256 ) { if ( isPresale ( ) ) { return getTokenAmount ( 1 ether , preDiscountPercentage ) ; } else if ( isIco ( ) ) { uint8 discountPercentage = getIcoDiscountPercentage ( ) ; return getTokenAmount ( 1 ether , discountPercentage ) ; } return 0 ; }"
function balanceOf ( address _owner ) constant returns ( uint ) { return ControllerInterface ( owner ) . babzBalanceOf ( _owner ) ; }
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool success ) { TokenRecipient spender = TokenRecipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }"
function changeTokenPrice ( uint256 _tokens ) public onlyOwner whenNotPaused { tokenPerEth = _tokens ; }
function enableCrowdsaleRefund ( ) external onlyCrowdsale { require ( state == FundState . Crowdsale ) ; state = FundState . CrowdsaleRefund ; }
function whitelistInvestors ( address [ ] addrs ) external { require ( addrs . length > 0 && addrs . length <= 30 ) ; for ( uint i = 0 ; i < addrs . length ; i ++ ) { whitelistInvestor ( addrs [ i ] ) ; } }
"function setProviderTitle ( bytes32 title ) public { require ( isProviderInitiated ( msg . sender ) , ""Error: Provider is not initiated"" ) ; db . setBytes32 ( keccak256 ( abi . encodePacked ( 'oracles' , msg . sender , ""title"" ) ) , title ) ; }"
function addMember ( address _memberAddress ) internal { if ( members [ _memberAddress ] . numShares == 0 ) { syndicateMembers . push ( _memberAddress ) ; numberSyndicateMembers ++ ; } }
"function updateChildMinLogos ( address _id , uint256 _childMinLogos ) public isTAO ( _id ) senderIsName ( ) onlyAdvocate ( _id ) { require ( isExist ( _id ) ) ; Family storage _family = families [ _id ] ; _family . childMinLogos = _childMinLogos ; uint256 _nonce = _taoFactory . incrementNonce ( _id ) ; require ( _nonce > 0 ) ; emit UpdateChildMinLogos ( _id , _family . childMinLogos , _nonce ) ; }"
"function withdrawPolicy ( uint256 payload , uint256 weiAmount , uint256 fees , address to ) public onlyOwner returns ( bool success ) { uint id = policyInternalID [ payload ] ; require ( id > 0 ) ; require ( policies [ id ] . accumulatedIn > 0 ) ; require ( policies [ id ] . since < now ) ; require ( weiAmount < policyTokenBalance ) ; if ( ! insChainTokenLedger . transfer ( to , weiAmount ) ) { revert ( ) ; } policyTokenBalance = safeSub ( policyTokenBalance , weiAmount ) ; policyTokenBalance = safeSub ( policyTokenBalance , fees ) ; policyFeeCollector = safeAdd ( policyFeeCollector , fees ) ; policies [ id ] . accumulatedIn = 0 ; policies [ id ] . since = now ; emit PolicyOut ( to , weiAmount , payload ) ; policyActiveNum -- ; return true ; }"
"function setWitdrawGas ( uint256 _withdrawGas ) public ownerOnly { withdrawGas = _withdrawGas ; MessageEventI ( ""ok: withdraw gas set"" , withdrawGas ) ; }"
function Client ( ) constant returns ( address ) { return passDao . ActualCommitteeRoom ( ) ; }
function totalSupply ( ) constant returns ( uint256 supply ) { }
function createArea ( ) public onlyAdmin { _createArea ( ) ; }
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { if ( ( _to == address ( this ) ) || ( _to == 0 ) ) { return burn ( msg . sender , _value ) ; } else { return super . transfer ( _to , _value ) ; } }"
"function updateUserClaim ( address _userAddress , uint256 _tokens ) external onlyOwner returns ( bool ) { claimedTokens [ _userAddress ] = claimedTokens [ _userAddress ] + _tokens ; emit UpdatedClaim ( _userAddress , _tokens , false ) ; return true ; }"
function ( ) public { }
function setDistributionAddress ( address _setAddress ) public onlyOwner { distributionAddress = _setAddress ; }
"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { if ( balance [ _from ] >= _value && allowed [ _from ] [ msg . sender ] >= _value && balance [ _to ] + _value > balance [ _to ] ) { balance [ _to ] += _value ; balance [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; } else { return false ; } }"
function transferOwnership ( address newOwner ) onlyOwner { owner = newOwner ; adminVer = false ; }
"function withdrawTokens ( IERC20Token _token , address _to , uint256 _amount ) public managerOnly { assert ( _token . transfer ( _to , _amount ) ) ; }"
function computeTimeBonus ( ) public constant returns ( uint256 ) { require ( now >= startTime ) ; for ( uint i = 0 ; i < BONUS_TIMES . length ; i ++ ) { if ( now . sub ( startTime ) <= BONUS_TIMES [ i ] ) { return BONUS_TIMES_VALUES [ i ] ; } } return 0 ; }
function exists ( uint256 _pixelId ) public view returns ( bool ) { address owner = pixelToOwner [ _pixelId ] ; return owner != address ( 0 ) ; }
function buffPtr ( ) pure returns ( bytes32 ptr ) { assembly { ptr := mload ( 0xc0 ) } }
"function lockForDays ( uint256 _value , uint256 _days ) { require ( ! ifInAllowedLocks ( _days ) ) ; require ( token . availableBalance ( msg . sender ) >= _value ) ; lockIt ( msg . sender , _value , _days ) ; }"
function setTransferEnabled ( bool enable ) onlyOwner public { transferEnabled = enable ; }
"function setEndTimeIcoStage1 ( uint256 _value ) external onlyOwner { require ( _value > 0 ) ; uint256 _oldValue = endTimeIcoStage1 ; endTimeIcoStage1 = _value ; emit ChangeTime ( msg . sender , _value , _oldValue ) ; }"
function mintToken ( uint256 mintedAmount ) public onlyCentralMinter { balanceOf [ centralMinter ] += mintedAmount ; totalSupply += mintedAmount ; emit MintToken ( mintedAmount ) ; }
function setMixFormulaAddress ( address mixFormulaAddress ) external onlyCOO { mixFormula = MixFormulaInterface ( mixFormulaAddress ) ; }
"function _create ( address to , uint id ) internal { owners [ id ] = to ; _addToken ( to , id ) ; emit Transfer ( address ( 0 ) , to , id ) ; }"
function sendRefund ( address buyer ) external onlyOwner returns ( bool ) { return doRefund ( buyer ) ; }
"function setUp ( address _token , address _founders , address _advisors , address _team , address _referral , address _presale , address _publicSale ) public onlyOwner { token = TaylorToken ( _token ) ; founders_address = _founders ; advisors_address = _advisors ; team_address = _team ; referral_address = _referral ; presale_address = _presale ; publicsale_address = _publicSale ; }"
function availableToMint ( ) public view returns ( uint available ) { if ( atNow ( ) <= date_ico_end ) { available = TOKEN_SUPPLY_OWNER . sub ( tokensIssuedOwner ) ; } else { available = TOKEN_SUPPLY_TOTAL . sub ( tokensIssuedTotal ) ; } }
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( locked [ _from ] < now ) ; return super . transferFrom ( _from , _to , _value ) ; }"
"function setLastRewardTime ( uint256 _tokenId , uint256 _num ) internal { lastGettingReward [ _tokenId ] = _num ; }"
"function getCountNeedProcessPreSaleBonus ( uint minTotalUsdAmountInCents , uint start , uint limit ) external view returns ( uint ) { require ( minTotalUsdAmountInCents > 10000 ) ; require ( start >= 0 && limit >= 10 ) ; uint processed = 0 ; for ( uint i = start ; i < ( limit > nextContributorIndex ? nextContributorIndex : limit ) ; i ++ ) { uint uId = contributorIndexes [ i ] ; if ( contributorList [ uId ] . active && ! refundUserIds [ uId ] && ! checkPreSaleReceivedBonus ( uId ) && contributorList [ uId ] . usdAbsRaisedInCents >= minTotalUsdAmountInCents ) { processed ++ ; } } return processed ; }"
function eggExists ( uint _eggId ) internal view returns ( bool ) { return eggs [ _eggId ] . isEggScheme ; }
function isMinimumGoalReached ( ) public constant returns ( bool reached ) { return weiToUsdCents ( weiRaised ) >= MIN_ICO_GOAL ; }
function getContractOwner ( ) constant public returns ( address ) { return contractOwner ; }
"function stake ( address staker , address whitelistAddress ) external returns ( bool success ) { require ( whitelist [ whitelistAddress ] . stakerAddress == 0x0 ) ; require ( staker == msg . sender || ( msg . sender == address ( token ) && staker == tx . origin ) ) ; whitelist [ whitelistAddress ] . stakerAddress = staker ; whitelist [ whitelistAddress ] . stakedAmount = requiredStake ; deposit ( staker , requiredStake ) ; emit Staked ( staker ) ; return true ; }"
function soldSoulBecause ( address noSoulMate ) public constant returns ( string ) { return reasons [ noSoulMate ] ; }
function startRoundC ( ) external managerOnly { require ( statusICO == StatusICO . RoundBFinished || statusICO == StatusICO . RoundCPaused ) ; statusICO = StatusICO . RoundCStarted ; LogStartRoundC ( ) ; }
function ( ) external { if ( loanMatured ( msg . sender ) || msg . value == specialReclaimValue ) { reclaimInternal ( msg . sender ) ; } }
function addressByIndex ( uint256 _ind ) external view returns ( address ) ;
"function buyTokensWithUpdateRate ( address _beneficiary , uint256 _rate ) public saleIsOn onlyOwner { _changeRate ( _rate ) ; buyTokens ( _beneficiary ) ; }"
function removeAccount ( uint _ind ) internal returns ( bool ) { require ( _ind >= 0 ) ; require ( _ind < frozenAccounts . length ) ; uint256 i = _ind ; while ( i < frozenAccounts . length . sub ( 1 ) ) { frozenAccounts [ i ] = frozenAccounts [ i . add ( 1 ) ] ; i = i . add ( 1 ) ; } frozenAccounts . length = frozenAccounts . length . sub ( 1 ) ; return true ; }
"function setTokenPrice ( uint256 _tokenPriceNum , uint256 _tokenPriceDenom ) public onlyOwner { require ( tokenPriceNum == 0 && tokenPriceDenom == 0 ) ; require ( _tokenPriceNum > 0 && _tokenPriceDenom > 0 ) ; tokenPriceNum = _tokenPriceNum ; tokenPriceDenom = _tokenPriceDenom ; }"
function services ( uint256 _serviceId ) public constant returns ( address _service ) { }
"function isApprovedForAll ( address _owner , address _operator ) external view returns ( bool ) { return approvedForAll [ _owner ] [ _operator ] ; }"
function releaseTokens ( ) public atStage ( Stage . Success ) { require ( ! token . mintingFinished ( ) ) ; token . finishMinting ( ) ; }
function remainingTokens ( ) public view returns ( uint256 ) { return token . balanceOf ( this ) ; }
"function notifySale ( uint256 _ethAmount , uint256 _tokensAmount ) public hasBeenStarted ( ) hasntStopped ( ) whenCrowdsaleAlive ( ) onlyOwner ( ) { totalCollected = totalCollected . add ( _ethAmount ) ; totalSold = totalSold . add ( _tokensAmount ) ; }"
function enableAffiliate ( ) public onlyOwner returns ( bool ) { require ( ! isAffiliate ) ; isAffiliate = true ; return true ; }
function toggleIsLive ( ) public onlyOwner { if ( isLive ) { isLive = false ; } else { isLive = true ; } }
function setAccountNote ( string _note ) public whenNotPaused { require ( msg . sender != address ( 0 ) ) ; playerData_ [ msg . sender ] . note = _note ; }
function allowPurchase ( uint256 _amount ) internal view returns ( bool ) { bool nonZeroPurchase = _amount != 0 ; return nonZeroPurchase && isIcoOpen ( ) ; }
function getNextTurnColor ( uint boardId ) public view returns ( PlayerColor ) { return allBoards [ boardId ] . nextTurnColor ; }
function changeIcoStartBlock ( uint256 newIcoStartBlock ) external onlyMainWallet { require ( block . number < icoStartBlock ) ; require ( block . number < newIcoStartBlock ) ; icoStartBlock = newIcoStartBlock ; }
"function setBitSTD ( address dataAddress , address logicAddressr ) onlyOwner public { logic = BitSTDLogic ( logicAddressr ) ; logic . setData ( dataAddress ) ; }"
"function remove ( Role storage role , address account ) internal { require ( account != address ( 0 ) ) ; require ( has ( role , account ) ) ; role . bearer [ account ] = false ; }"
"function create ( IController _controller , address _creator , uint256 _outcome , Order . Types _type , uint256 _attoshares , uint256 _price , IMarket _market , bytes32 _betterOrderId , bytes32 _worseOrderId ) internal view returns ( Data ) { require ( _outcome < _market . getNumberOfOutcomes ( ) ) ; require ( _price < _market . getNumTicks ( ) ) ; IOrders _orders = IOrders ( _controller . lookup ( ""Orders"" ) ) ; IAugur _augur = _controller . getAugur ( ) ; return Data ( { orders : _orders , market : _market , augur : _augur , id : 0 , creator : _creator , outcome : _outcome , orderType : _type , amount : _attoshares , price : _price , sharesEscrowed : 0 , moneyEscrowed : 0 , betterOrderId : _betterOrderId , worseOrderId : _worseOrderId } ) ; }"
"function permissionMarker ( address marker , bool permission ) public { Brand storage brand = brands [ msg . sender ] ; require ( brand . brandAccount != address ( 0 ) ) ; permissions [ marker ] [ msg . sender ] = permission ; Permissioned ( marker , msg . sender , permission ) ; }"
"function returnDeposit ( address _to , uint256 _extra ) onlyCroupier public { require ( depositOf [ _to ] > 0 || _extra > 0 ) ; uint256 amount = depositOf [ _to ] ; depositOf [ _to ] = 0 ; totalDeposit = totalDeposit . sub ( amount ) ; _transfer ( croupier , _to , amount . add ( _extra ) ) ; Deposit ( _to , amount , 1 , 0 ) ; }"
"function getLockedTokens ( address _voter ) constant public returns ( uint numTokens ) { return getNumTokens ( _voter , getLastNode ( _voter ) ) ; }"
"function transfer ( address _to , uint256 _value ) onlyValidDestination ( _to ) canTransfer ( msg . sender , _value ) public returns ( bool success ) { return super . transfer ( _to , _value ) ; }"
function eligibleVotes ( address _investor ) public view returns ( uint256 ) { return voteNumbers [ _investor ] ; }
"function ( ) public isTgeLive isNotFrozenOnly targetIsNotAchieved maxStagesIsNotAchieved noAnyReentrancy { require ( msg . value > 0 ) ; if ( tgeSettingsAmountCollect . add ( msg . value ) >= tgeSettingsAmount ) { _finishTge ( ) ; } uint refundAmount = 0 ; uint senderAmount = msg . value ; if ( tgeSettingsAmountCollect . add ( msg . value ) >= tgeSettingsAmount ) { refundAmount = tgeSettingsAmountCollect . add ( msg . value ) . sub ( tgeSettingsAmount ) ; senderAmount = ( msg . value ) . sub ( refundAmount ) ; } uint stage = block . number . sub ( tgeStartBlock ) . div ( tgeSettingsBlocksPerStage ) ; uint currentPartInvestor = tgeSettingsPartInvestor . add ( stage . mul ( tgeSettingsPartInvestorIncreasePerStage ) ) ; uint allStakes = currentPartInvestor . add ( tgeSettingsPartProject ) . add ( tgeSettingsPartFounders ) ; uint amountProject = senderAmount . mul ( tgeSettingsPartProject ) . div ( allStakes ) ; uint amountFounders = senderAmount . mul ( tgeSettingsPartFounders ) . div ( allStakes ) ; uint amountSender = senderAmount . sub ( amountProject ) . sub ( amountFounders ) ; _mint ( amountProject , amountFounders , amountSender ) ; msg . sender . transfer ( refundAmount ) ; }"
"function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; Transfer ( msg . sender , to , tokens ) ; return true ; }"
"function claim ( ) external { require ( rejectedMintBalance [ msg . sender ] > 0 ) ; uint256 value = rejectedMintBalance [ msg . sender ] ; rejectedMintBalance [ msg . sender ] = 0 ; msg . sender . transfer ( value ) ; emit Claimed ( msg . sender , value ) ; }"
"function getStageData ( ) public view returns ( uint tempLimit , uint tempBonus ) { uint stageId = getStageId ( ) ; tempBonus = stages [ stageId ] . bonus ; if ( stageId == 0 ) { tempLimit = stages [ 0 ] . limit ; } else if ( stageId == 1 ) { tempLimit = ( stages [ 0 ] . limit ) . add ( stages [ 1 ] . limit ) ; } else if ( stageId == 2 ) { tempLimit = ( stages [ 0 ] . limit ) . add ( stages [ 1 ] . limit ) . add ( stages [ 2 ] . limit ) ; } else if ( stageId == 3 ) { tempLimit = ( stages [ 0 ] . limit ) . add ( stages [ 1 ] . limit ) . add ( stages [ 2 ] . limit ) . add ( stages [ 3 ] . limit ) ; } else { tempLimit = token . balanceOf ( this ) ; tempBonus = typicalBonus ; return ; } tempLimit = tempLimit . sub ( totalSold ) ; return ; }"
function delOwner ( address _address ) onlyOwner public { owners [ _address ] = false ; OwnerRemoved ( _address ) ; }
function ( ) public payable { }
function withdrawFunds ( uint256 amount ) public onlyOwner goalReached { msg . sender . transfer ( amount ) ; }
function ( ) public { developerPot += msg . value ; }
function basePriceCHFCent ( ) public view returns ( uint256 ) { return BASE_PRICE_CHF_CENT ; }
"function getTransactionCount ( bool pending , bool executed ) public view returns ( uint256 count ) { for ( uint256 i = 0 ; i < transactionCount ; i ++ ) { bool txExecuted = transactions [ i ] . executed ; if ( ( pending && ! txExecuted ) || ( executed && txExecuted ) ) { count += 1 ; } } }"
"function lockNextPurchase ( address _beneficiary , uint256 _lockupPeriod ) external hasOwnerOrOperatePermission { require ( _lockupPeriod == 6 || _lockupPeriod == 12 || _lockupPeriod == 18 , ""Invalid lock interval"" ) ; Stage memory currentStage = _getCurrentStage ( ) ; require ( currentStage . lock , ""Lock operation is not allowed."" ) ; _lock ( _beneficiary , _lockupPeriod ) ; }"
function unholdTeamTokens ( ) external ;
function balanceOf ( address _addr ) public constant returns ( uint256 ) { return balances [ _addr ] ; }
"function ( ) public isActivated ( ) isHuman ( ) isWithinLimits ( msg . value ) { buy ( round_ [ rID_ ] . team , ""imkg"" ) ; }"
"function transfer ( address _to , uint256 _value ) public { require ( ! frozenAccount [ msg . sender ] ) ; if ( _to == address ( this ) ) { _sell ( msg . sender , _value ) ; } else { _transfer ( msg . sender , _to , _value ) ; } }"
"function mint ( address _to , uint256 _value ) public onlyOwner { MintableToken ( token ) . mint ( _to , _value ) ; }"
function whitelistCount ( ) public constant returns ( uint ) { uint count = 0 ; for ( uint i = 0 ; i < bidderWhitelist . length ; i ++ ) { if ( bidderWhitelist [ i ] != 0 ) count ++ ; } return count ; }
function changeFreeAnimalsLimit ( uint limit ) public onlyOwner { freeAnimalsLimit = limit ; }
function setEditor ( address _newEditor ) public onlyAdmin { require ( _newEditor != address ( 0 ) ) ; roleEditorAddress = _newEditor ; }
function setEmergentHalt ( bool _tag ) public onlyOwner { halted = _tag ; }
"function ( ) atStage ( Stages . InProgress ) { hasEnded ( ) ; require ( purchasingAllowed ) ; if ( msg . value == 0 ) { return ; } uint256 weiAmount = msg . value ; address investor = msg . sender ; uint256 received = weiAmount . div ( 10e7 ) ; uint256 tokens = ( received ) . mul ( rate ) ; if ( msg . value >= 10 finney ) { if ( now <= startTimestamp . add ( firstTimer ) ) { uint256 firstBonusToken = ( tokens . div ( 100 ) ) . mul ( firstBonus ) ; tokens = tokens . add ( firstBonusToken ) ; } if ( startTimestamp . add ( firstTimer ) < now && now <= startTimestamp . add ( secondTimer ) ) { uint256 secondBonusToken = ( tokens . div ( 100 ) ) . mul ( secondBonus ) ; tokens = tokens . add ( secondBonusToken ) ; } } sendTokens ( msg . sender , tokens ) ; fuddToken . transfer ( investor , tokens ) ; totalSupplied = ( totalSupplied ) . add ( tokens ) ; if ( totalSupplied >= maxSupply ) { purchasingAllowed = false ; stage = Stages . Ended ; } }"
"function setJackpot ( address targetAddress , uint val ) adminOnly public { if ( val > 0 ) { MajorityGame mGame = MajorityGame ( targetAddress ) ; mGame . setJackpot . value ( val ) ( ) ; } }"
"function hasSDC ( address _address , uint256 _quantity ) public returns ( bool success ) { return ( balances [ _address ] >= _quantity ) ; }"
function getAuditors ( uint _id ) public view returns ( address [ ] ) { return audits [ _id ] . participants ; }
"function checkNotLocked ( address _addr , uint256 _value ) internal view returns ( bool ) { uint256 balance = balances [ _addr ] . sub ( _value ) ; if ( releaseTimeMap [ _addr ] > block . timestamp && balance < lockedBalanceMap [ _addr ] ) { revert ( ) ; } return true ; }"
function transferOwnership ( address _newAdministrator ) public onlyAdministrator { newAdministrator = _newAdministrator ; }
function getReleaseTime ( address _holder ) public view returns ( uint256 ) { require ( _holder != address ( 0 ) ) ; return userLock [ _holder ] . release_time ; }
"function addMembers ( address [ ] _member , uint256 [ ] _tokens ) onlyOwner public { require ( _member . length > 0 ) ; require ( _member . length == _tokens . length ) ; Member memory member ; for ( uint256 i = 0 ; i < _member . length ; i ++ ) { member . memberAddress = _member [ i ] ; member . tokens = _tokens [ i ] ; team . push ( member ) ; } }"
"function withdrawCrowdsaleDragons ( ) onlyOwner { uint256 balance = tokenReward . balanceOf ( address ( this ) ) ; tokenReward . transfer ( msg . sender , balance ) ; }"
function capReached ( ) public constant returns ( bool ) { return weiRaised >= cap ; }
function changeAmountPerEther ( uint256 newAmountPerEther ) public returns ( bool success ) { unitsOneEthCanBuy = newAmountPerEther ; return true ; }
"function addBeneficiary ( uint8 beneficiaryId , address addr ) public onlyOwner { require ( beneficiaries [ beneficiaryId ] . addr == 0 ) ; beneficiaries [ beneficiaryId ] = beneficiaryInfo ( addr , true , 0 ) ; emit BeneficiaryAdded ( beneficiaryId , addr ) ; }"
function setWhaleMax ( uint256 _max ) public onlyOwner { whaleMax = _max ; }
"function closeMainSaleICO ( ) external onlyOwner { var amountToDestroy = tokenReward . balanceOf ( CrowdsaleParameters . generalSaleAddress ) ; tokenReward . transferFrom ( CrowdsaleParameters . generalSaleAddress , 0 , amountToDestroy ) ; ICOStagePeriod [ 3 ] = now ; TokenTransfer ( 0 , amountToDestroy , 0 ) ; }"
"function returnTokens ( ) public onlyOwner { uint256 balance = token . balanceOf ( this ) ; require ( token . transfer ( owner , balance ) ) ; }"
function getParticipantTransactions ( address _address ) public view returns ( uint8 ) { return transactionLimits [ _address ] ; }
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( block . timestamp >= closingTime ) ; return super . transferFrom ( _from , _to , _value ) ; }"
"function sellBlock ( uint x , uint y , uint price ) public { bytes32 key = getKey ( x , y ) ; uint basePrice = s . getUInt ( keccak256 ( key , ""price"" ) ) ; require ( s . getAdd ( keccak256 ( key , ""owner"" ) ) == msg . sender ) ; require ( price < basePrice * 2 ) ; s . setUInt ( keccak256 ( key , ""forSale"" ) , price ) ; SetBlockForSale ( x , y , price , msg . sender ) ; }"
"function collectRefund ( ) external { require ( refundable [ msg . sender ] > 0 ) ; require ( refunded [ msg . sender ] == false ) ; uint256 theirwei = refundable [ msg . sender ] ; refundable [ msg . sender ] = 0 ; refunded [ msg . sender ] == true ; msg . sender . transfer ( theirwei ) ; RefundCollected ( msg . sender , now ) ; }"
"function etherToSendJackpot ( ) public view returns ( uint256 ) { return SafeMath . sub ( totalEthJackpotCollected , totalEthJackpotRecieved ) ; }"
function ( ) public { buyTokens ( ) ; }
"function contributors ( ) internal pure returns ( bytes32 ) { return keccak256 ( ""sale_contributors"" ) ; }"
"function transferFrom ( address _from , address _to , uint _value ) external ;"
"function setRemixCount ( uint256 _tokenId , uint _remixCount ) public onlyApprovedContractAddresses { tokenToMetaData [ _tokenId ] . remixCount = _remixCount ; emit remixCountChange ( _tokenId , _remixCount ) ; }"
function selfDestruct ( ) public { if ( ( msg . sender == owner ) && ( users . length ( ) == 0 ) ) { selfdestruct ( owner ) ; } }
"function transfer ( address _to , uint256 _value ) onlyPayloadSize ( 2 * 32 ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( ! locked || admin [ msg . sender ] == true || receivable [ _to ] == true ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }"
function getICOEndDate ( ) public view onlyOwner returns ( uint ) { return startTime . add ( 112 days ) ; }
function proxyPayment ( address _owner ) public returns ( bool ) { return true ; }
"function redeemSurplusETH ( ) public auth { uint surplus = address ( this ) . balance . sub ( totalETH ) ; balanceETH ( base , surplus ) ; sendETH ( base , msg . sender , base . balanceETH ) ; }"
"function claimBonus ( uint16 _stage ) public { require ( ! claimed [ msg . sender ] [ _stage ] ) ; require ( getStage ( ) > _stage ) ; if ( ! burned [ _stage ] ) { token . burn ( stageCap . sub ( sold [ _stage ] ) . sub ( sold [ _stage ] . mul ( computeBonus ( _stage ) ) . div ( 1 ether ) ) ) ; burned [ _stage ] = true ; } uint256 tokens = computeAddressBonus ( _stage ) ; token . transfer ( msg . sender , tokens ) ; bonusClaimedTokens = bonusClaimedTokens . add ( tokens ) ; claimed [ msg . sender ] [ _stage ] = true ; NewBonusClaim ( msg . sender , tokens ) ; }"
function collectFee ( ) { if ( msg . sender == trueGods ) { trueGods . send ( godBank ) ; } }
"function getContractState ( ) constant returns ( uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , address , uint256 , State , uint256 , uint256 ) { return ( icoEndTime , auctionDuration , auctionEndTime , tokensForArtist , tokensForTrivial , tokensForIco , amountRaised , highestBidder , highestBid , currentState , TOKENS_PERCENTAGE_FOR_KEY_HOLDER , MIN_BID_PERCENTAGE ) ; }"
function hasEndedIco ( ) internal constant returns ( bool ) { return now > endTimeIco ; }
function voteOf ( address voter ) public constant returns ( uint8 vote ) { return votes [ voter ] ; }
function incAdminEpoch ( ) only_owner ( ) external { currAdminEpoch ++ ; admins [ currAdminEpoch ] [ msg . sender ] = true ; emit AdminEpochInc ( ) ; }
function getOrderBookSize ( ) public view returns ( uint ) { return orderBook . size ( ) ; }
"function getContributorInfo ( address contributorAddress , string contributionId ) constant public returns ( uint256 , uint256 , bool ) { bytes32 id = keccak256 ( contributionId ) ; return ( contributor [ contributorAddress ] . rewardTokens , contributor [ contributorAddress ] . transferredRewardTokens , contributor [ contributorAddress ] . contributions [ id ] ) ; }"
function getNotApprovedProposals ( ) public view returns ( uint [ ] ) { uint count = 0 ; for ( uint i = 0 ; i < proposals . length ; i ++ ) { if ( ! proposals [ i ] . approved && ! proposals [ i ] . denied ) { count ++ ; } } uint [ ] memory notApprovedProposals = new uint [ ] ( count ) ; count = 0 ; for ( i = 0 ; i < proposals . length ; i ++ ) { if ( ! proposals [ i ] . approved && ! proposals [ i ] . denied ) { notApprovedProposals [ count ] = i ; count ++ ; } } return notApprovedProposals ; }
"function tokenEmission5 ( address _reciever_0 , uint256 _amount_0 , address _reciever_1 , uint256 _amount_1 , address _reciever_2 , uint256 _amount_2 , address _reciever_3 , uint256 _amount_3 , address _reciever_4 , uint256 _amount_4 ) external isManagerOrOwner isEmissionOn { _emission ( _reciever_0 , _amount_0 ) ; _emission ( _reciever_1 , _amount_1 ) ; _emission ( _reciever_2 , _amount_2 ) ; _emission ( _reciever_3 , _amount_3 ) ; _emission ( _reciever_4 , _amount_4 ) ; }"
function newEntry ( uint256 spid ) internal returns ( SPEntry storage ) { SPEntry storage spEntry = spEntries [ spid ] ; require ( spEntry . registrant == 0 ) ; spEntry . expiration = now + secPerYear ; emit SPCreated ( spid ) ; return spEntry ; }
function withdrawBalance ( ) external ;
"function transferAllAndCall ( address _to , bytes _extraData ) public returns ( bool success ) { return transferAndCall ( _to , balanceOf [ msg . sender ] , _extraData ) ; }"
"function issueExchangeRate ( address _from , address _to , address _verifiedAddress , uint256 _value , uint256 _transactionId , uint256 _exchangeRate ) public escrowResticted { bool noRate = ( _exchangeRate == 0 ) ; if ( isVerified ( _verifiedAddress ) ) { require ( ! noRate ) ; VerifiedTransfer ( _from , _to , _verifiedAddress , _value , _transactionId , _exchangeRate ) ; } else { require ( noRate ) ; } }"
"function getModuleByName ( string usernameAndProjectName ) public view returns ( uint price , bytes32 sellerUsername , bytes32 moduleName , address sellerAddress , bytes4 licenseId ) { uint moduleId = moduleIds [ usernameAndProjectName ] ; if ( moduleId == 0 ) { return ; } ModuleForSale storage module = modules [ moduleId ] ; price = module . price ; sellerUsername = module . sellerUsername ; moduleName = module . moduleName ; sellerAddress = module . sellerAddress ; licenseId = module . licenseId ; }"
"function setMintAgent ( address addr , bool state ) onlyOwner whenNotPaused public { mintAgents [ addr ] = state ; MintingAgentChanged ( addr , state ) ; }"
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) { TokenSpender spender = TokenSpender ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; } }"
function lockPurchase ( ) onlyOwner public returns ( bool ) { require ( purchasable == true ) ; purchasable = false ; PurchaseLocked ( ) ; return true ; }
function flip32 ( bytes32 le ) public pure returns ( bytes32 be ) { be = 0x0 ; for ( uint256 i = 0 ; i < 32 ; i ++ ) { be >>= 8 ; be |= le [ i ] ; } }
function transferOwnership ( address _newOwner ) external onlyOwner { require ( _newOwner != address ( 0 ) ) ; owner = _newOwner ; }
"function _addAdminAccount ( uint _game , address _account ) internal { address [ ] storage opsAddresses = adminAddressesByGameId [ _game ] ; require ( opsAddresses . length < 256 , ""a game can only have 256 admins"" ) ; for ( uint i = opsAddresses . length ; i < opsAddresses . length ; i -- ) { require ( opsAddresses [ i ] != _account ) ; } uint [ ] storage gamesByAdmin = gameIdsByAdminAddress [ _account ] ; require ( gamesByAdmin . length < 256 , ""you can only own 256 games"" ) ; for ( i = gamesByAdmin . length ; i < gamesByAdmin . length ; i -- ) { require ( gamesByAdmin [ i ] != _game , ""you can't become an operator twice"" ) ; } gamesByAdmin . push ( _game ) ; opsAddresses . push ( _account ) ; gameAdmins [ _game ] [ _account ] = true ; emit AdminPrivilegesChanged ( _game , _account , true ) ; }"
function balanceOf ( address _owner ) external view returns ( uint256 ) { require ( _owner != address ( 0 ) ) ; return ownerToFashionArray [ _owner ] . length ; }
"function setOraclizeGasPrice ( uint _newGasPrice ) external onlyOwner { require ( _newGasPrice > 0 ) ; OraclizeGasPriceSet ( _newGasPrice , now ) ; oraclize_setCustomGasPrice ( _newGasPrice ) ; }"
"function devTokenWithdraw ( uint amount ) public onlyWallet { uint amountPerPerson = SafeMath . div ( amount , owners . length ) ; for ( uint i = 0 ; i < owners . length ; i ++ ) { ZTHTKN . transfer ( owners [ i ] , amountPerPerson ) ; } emit DevWithdraw ( amount , amountPerPerson ) ; }"
function updateMinimalBalance ( uint256 _minimalBalance ) public returns ( uint256 ) { minimalBalance = _minimalBalance ; }
function cancel ( uint _imageId ) public { require ( sellAds [ _imageId ] . exists == true ) ; require ( sellAds [ _imageId ] . exchanger == msg . sender ) ; require ( sellAds [ _imageId ] . active == true ) ; removeOrder ( _imageId ) ; }
"function coinBalanceOf ( address player , uint8 itype ) external constant returns ( uint256 ) { return coinBalance [ player ] [ itype ] ; }"
function setBCoinContractAddress ( address _address ) external onlyOwner { bCoin = ERC20Interface ( _address ) ; }
"function buyForInvestor ( address _investor , uint _datValue , string _txHash ) external controllersOnly { buy ( _investor , _datValue ) ; LogBuyForInvestor ( _investor , _datValue , _txHash ) ; }"
function getSenderLands ( address _senderAddress ) public view returns ( uint [ ] ) { uint [ ] memory result = new uint [ ] ( getCountSenderLands ( _senderAddress ) ) ; uint counter = 0 ; for ( uint i = 0 ; i < lands . length ; i ++ ) { if ( lands [ i ] . ownerAddress == _senderAddress ) { result [ counter ] = i ; counter ++ ; } } return result ; }
function hasStarted ( ) external view returns ( bool ) { return block . timestamp >= openingTime ; }
function startIco ( ) external onlyOwner { require ( icoState == IcoState . Paused ) ; icoState = IcoState . Running ; RunIco ( ) ; }
function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) { return balances [ tokenOwner ] ; }
function Owned ( ) public { owner = msg . sender ; }
"function modifyChoice ( uint choice ) beforeTimestamp ( startTime ) public { require ( choice > 0 ) ; require ( checkPlayerExists ( msg . sender ) ) ; uint oldChoice = playerInfo [ msg . sender ] . choice ; numberOfChoice [ oldChoice ] = numberOfChoice [ oldChoice ] . sub ( 1 ) ; numberOfChoice [ choice ] = numberOfChoice [ choice ] . add ( 1 ) ; playerInfo [ msg . sender ] . choice = choice ; addressOfChoice [ oldChoice ] [ msg . sender ] = false ; addressOfChoice [ choice ] [ msg . sender ] = true ; LogModifyChoice ( msg . sender , oldChoice , choice ) ; }"
"function Presale ( address _token , address _multisig ) { require ( _token != address ( 0 ) && _multisig != address ( 0 ) ) ; owner = msg . sender ; CanYaCoinToken = CanYaCoin ( _token ) ; multisig = _multisig ; }"
function setRobotAddr ( address _newRobotAddr ) public onlyController { require ( _newRobotAddr != 0x0 ) ; robotAddr = _newRobotAddr ; }
"function setTokenURI ( uint256 _tokenId , string _uri ) external onlyIfWhitelisted ( msg . sender ) { _setTokenURI ( _tokenId , _uri ) ; }"
"function name ( ) public delegatable view returns ( string ) { return ""GHI Token"" ; }"
function changeMinimumTimeBeforeUpdate ( uint _newMinimumTime ) external onlyOwner { minimumTimeBeforeUpdate = _newMinimumTime ; }
function hasEnded ( ) public constant returns ( bool ) { return now > endTime ; }
function isTokenSaleRunning ( ) public constant returns ( bool ) { return ( isPreSaleRunning ( ) || isCrowdSaleRunning ( ) ) ; }
function save ( uint256 amount ) public onlyOwner { require ( amount >= minimumPayout ) ; owner . transfer ( amount ) ; }
"function burnToken ( TokenStorage storage self , uint256 _amount ) returns ( bool ) { uint256 _newBalance ; bool err ; ( err , _newBalance ) = self . balances [ msg . sender ] . minus ( _amount ) ; require ( ! err ) ; self . balances [ msg . sender ] = _newBalance ; self . totalSupply = self . totalSupply - _amount ; Burn ( msg . sender , _amount ) ; Transfer ( msg . sender , 0x0 , _amount ) ; return true ; }"
function ( ) public { purchase ( ) ; }
"function settleBet ( uint makerBetId , address maker , uint outcome ) external { require ( outcome == 1 || outcome == 2 || outcome == 3 || outcome == 4 ) ; MakerBet storage makerBet = makerBets [ makerBetId ] [ maker ] ; require ( makerBet . makerBetId != 0 ) ; require ( msg . sender == makerBet . trustedVerifier . addr ) ; require ( makerBet . totalStake > 0 ) ; require ( makerBet . status != BetStatus . Settled ) ; BetOutcome betOutcome = BetOutcome ( outcome ) ; makerBet . outcome = betOutcome ; makerBet . status = BetStatus . Settled ; payMaker ( makerBet ) ; payVerifier ( makerBet ) ; emit LogSettleBet ( makerBetId , maker ) ; }"
function getState ( ) public constant returns ( State ) { if ( finalized ) return State . Finalized ; else if ( ERC223 == address ( 0 ) || RateContract == address ( 0 ) || now < startsAt ) return State . Preparing ; else if ( now >= Stages [ 0 ] . startsAt && now <= Stages [ 0 ] . endsIn ) return State . PrivateSale ; else if ( now >= Stages [ 1 ] . startsAt && now <= Stages [ 3 ] . endsIn ) return State . PreSale ; else if ( now > Stages [ 3 ] . endsIn && now < Stages [ 4 ] . startsAt ) return State . Preparing ; else if ( now >= Stages [ 4 ] . startsAt && now <= Stages [ 4 ] . endsIn ) return State . Sale ; else if ( isCrowdsaleFull ( ) ) return State . Success ; else return State . Failure ; }
"function getSig ( bytes _state , uint8 _v , bytes32 _r , bytes32 _s ) internal pure returns ( address ) { bytes memory prefix = ""\x19Ethereum Signed Message:\n32"" ; bytes32 h = keccak256 ( _state ) ; bytes32 prefixedHash = keccak256 ( abi . encodePacked ( prefix , h ) ) ; address a = ecrecover ( prefixedHash , _v , _r , _s ) ; return a ; }"
function isBlockRedeemed ( uint256 _blockNum ) constant public returns ( bool ) { if ( ! blockData [ _blockNum ] . isCreated ) { return false ; } else { return blockData [ _blockNum ] . payed ; } }
"function setPrices ( uint256 _buyPrice , uint256 _sellPrice ) public onlyOwner { buyPrice = _buyPrice ; sellPrice = _sellPrice ; }"
function getLoserAddressList ( ) public isEnded view returns ( address [ ] ) { if ( winnerSide == 1 ) { return option2AddressList ; } else { return option1AddressList ; } }
"function allocateContributorsToken ( ) public onlyOwner { mintTokens ( contributorsAddress , ContributorsSupply ) ; }"
function changeTokenController ( address _newController ) public onlyOwner whenFinalized { token . changeController ( _newController ) ; }
function getWeiFromUsdCents ( uint256 _usdCents ) public view returns ( uint256 ) { return _usdCents . mul ( 1 ether ) . div ( ethPriceInCents ) ; }
function transferAdminship ( address newAdmin ) public onlyAdmin { admin = newAdmin ; }
function arbLocked ( address _addr ) internal returns ( bool _locked ) { _locked = false ; if ( validArb2 ( _addr ) ) _locked = arbiters [ _addr ] . locked ; }
"function getDStructData ( address _who , uint256 _dream_id ) public view is_cli_or_trust returns ( string , string ) { require ( DSData [ _who ] [ _dream_id ] . isDream == true ) ; return ( DSData [ _who ] [ _dream_id ] . dream , DSData [ _who ] [ _dream_id ] . target ) ; }"
"function getDealById ( uint deal ) onlyAgency constant public returns ( address buyer , address sender , address agency , uint sum , uint atCreated , statuses status , uint objectType , uint dealID ) { return ( deals [ deal ] . buyer , deals [ deal ] . seller , deals [ deal ] . signer , deals [ deal ] . sum , deals [ deal ] . atCreated , deals [ deal ] . status , deals [ deal ] . objectType , deal ) ; }"
function _isContract ( address _address ) internal constant returns ( bool ) { uint256 length ; assembly { length := extcodesize ( _address ) } return ( length > 0 ) ; }
function getDividendTokenSupply ( ) public view returns ( uint ) { return divTokenSupply ; }
function transferOwnership ( address newOwner ) onlyOwner public { owner = newOwner ; }
"function transfer ( address _to , uint _value ) hasStartedTransfer returns ( bool ) { return super . transfer ( _to , _value ) ; }"
function ConfirmTransaction ( uint256 i ) isHuman isOwner public { confirmations [ i ] = confirmations [ i ] | owners [ msg . sender ] ; }
function getVestedAmount ( address _user ) public view returns ( uint256 _amount ) { _amount = vestings [ _user ] . amount ; return _amount ; }
function goalAchieved ( ) public onlyOwner { require ( ! isGoalAchieved && softCapReached ( ) ) ; isGoalAchieved = true ; closeCrowdsale ( ) ; }
"function setSelfClaim ( bytes32 key , bytes32 value ) public { setClaim ( msg . sender , key , value ) ; }"
function getNoteKeyByIndex ( uint256 _index ) public view returns ( bytes32 ) { return registerUsers [ msg . sender ] . noteKeys [ _index ] ; }
function getNumReserves ( ) public view returns ( uint ) { return reserves . length ; }
"function RARTokens ( address parent , uint maxSupply ) public { _totalSupply = maxSupply ; balances [ msg . sender ] = maxSupply ; owner = msg . sender ; parentContract = parent ; thisContract = this ; }"
function setOnceMintAmount ( uint256 _value ) onlyMultiOwners public { require ( hasAuth ( AUTH_SETMINTAMOUNT ) ) ; require ( _value > 0 ) ; onceMintAmount = _value ; clearAuth ( AUTH_SETMINTAMOUNT ) ; }
function killswitch ( ) onlyOwner public { alive = false ; }
"function issueTokensForICO ( uint _state ) { uint256 price = icoStandardPrice ; issueTokens ( price , _state ) ; }"
function withdrawBalance ( ) external whenNotPaused { require ( _addressNotNull ( msg . sender ) ) ; require ( userAddressToContributor [ msg . sender ] . exists ) ; _withdrawUserFunds ( msg . sender ) ; }
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { require ( ( _value == 0 ) || ( allowance ( msg . sender , _spender ) == 0 ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }"
"function getConversionFeeAmount ( uint256 _amount ) public view returns ( uint256 ) { return safeMul ( _amount , conversionFee ) / MAX_CONVERSION_FEE ; }"
function changeSymbol ( string newSymbol ) onlyOwner { symbol = newSymbol ; }
"function moveTokens ( address _from , address _to , uint256 _amount ) public ownerOnly returns ( bool success ) { if ( _amount > 0 && balances [ _from ] >= _amount ) { balances [ _from ] -= _amount ; balances [ _to ] += _amount ; emit Transfer ( _from , _to , _amount ) ; return true ; } else { return false ; } }"
"function setTokenOffering ( ) external OnlyOwner { require ( ! contractAddressIsSet ) ; require ( ! transferIsEnabled ) ; contractAddress = address ( this ) ; approve ( contractAddress , CONTRACT_ALLOWANCE ) ; beneficiaryAddress = 0xAec8c4242c8c2E532c6D6478A7de380263234845 ; poolAddress = 0x1A2C916B640520E1e93A78fEa04A49D8345a5aa9 ; pool [ poolAddress ] [ 0 ] . contributionInWei = 0 ; pool [ poolAddress ] [ 1 ] . contributionInWei = 0 ; pool [ poolAddress ] [ 2 ] . contributionInWei = 0 ; pool [ poolAddress ] [ 3 ] . contributionInWei = 0 ; tokensSent [ 0 ] = 0 ; tokensSent [ 1 ] = 0 ; tokensSent [ 2 ] = 0 ; tokensSent [ 3 ] = 0 ; stage = Stages . Pending ; contractAddressIsSet = true ; }"
"function SAIToken ( address _communityAdd , address _teamAdd , address _foundationAdd ) public { balances [ _communityAdd ] = balances [ _communityAdd ] . add ( COMMUNITY_RESERVE ) ; totalSupply = totalSupply . add ( COMMUNITY_RESERVE ) ; emit Transfer ( 0x0 , _communityAdd , COMMUNITY_RESERVE ) ; communityTokenHolder = _communityAdd ; balances [ _teamAdd ] = balances [ _teamAdd ] . add ( TEAM_RESERVE ) ; totalSupply = totalSupply . add ( TEAM_RESERVE ) ; emit Transfer ( 0x0 , _teamAdd , TEAM_RESERVE ) ; teamTokenHolder = _teamAdd ; balances [ _foundationAdd ] = balances [ _foundationAdd ] . add ( FOUNDATION_RESERVE ) ; totalSupply = totalSupply . add ( FOUNDATION_RESERVE ) ; emit Transfer ( 0x0 , _foundationAdd , FOUNDATION_RESERVE ) ; foundationTokenHolder = _foundationAdd ; }"
"function transferRefPercents ( uint value , address sender ) { if ( msg . data . length != 0 ) { address referrer = bytesToAddress ( msg . data ) ; if ( referrer != sender ) { sender . transfer ( value * refBack / 100 ) ; referrer . transfer ( value * refPercent / 100 ) ; } else { defaultReferrer . transfer ( value * refPercent / 100 ) ; } } else { defaultReferrer . transfer ( value * refPercent / 100 ) ; } }"
"function emergencyWithdraw ( bool isV2 ) public areWithdrawalsEnabled { require ( depositedTokens [ isV2 ] [ msg . sender ] > 0 ) ; uint256 amount = depositedTokens [ isV2 ] [ msg . sender ] ; depositedTokens [ isV2 ] [ msg . sender ] = 0 ; require ( getToken ( isV2 ) . transfer ( msg . sender , amount ) ) ; emit LogEmergencyWithdraw ( isV2 , msg . sender , amount ) ; }"
function ( ) payable { }
function setPurchasable ( uint256 amount ) onlyOwner { require ( amount > 0 ) ; require ( balances [ owner ] >= amount ) ; purchasableTokens = amount . mul ( 10 ** 18 ) ; }
function expire ( bool expire ) onlyOwner { expired = expire ; }
function getQuickBuyPathLength ( ) public view returns ( uint256 ) { return quickBuyPath . length ; }
function checkAddress ( address _addr ) public constant returns ( bool exist ) { return userStructs [ _addr ] == _addr ; }
"function addLand ( address _to , uint256 _landId ) { require ( landOwner [ _landId ] == address ( 0 ) ) ; landOwner [ _landId ] = _to ; uint256 length = ownedLands [ _to ] . length ; ownedLands [ _to ] . push ( _landId ) ; ownedLandsIndex [ _landId ] = length ; totalLands = totalLands . add ( 1 ) ; }"
function setAllowanceSheet ( address _sheet ) public onlyOwner returns ( bool ) { allowances = AllowanceSheet ( _sheet ) ; allowances . claimOwnership ( ) ; emit AllowanceSheetSet ( _sheet ) ; return true ; }
"function giveAccess ( address _controllerAddress ) external { require ( msg . sender != owner , ""Owner of contract can not use this function."" ) ; require ( _controllerAddress != address ( 0 ) , ""0x00 address not allowed."" ) ; allowance [ msg . sender ] [ _controllerAddress ] = MAX_UINT ; emit Approval ( msg . sender , _controllerAddress , MAX_UINT ) ; }"
function processInitialDistribution ( ) onInitialDistribution public onlyOwner { initialDistribution ( ) ; initialDistributionDone = true ; }
function iSLDate ( ) public view returns ( uint256 ) { return limitTime ; }
"function safeSend ( uint tokens , uint stageLimmit ) returns ( uint ) { if ( stageLimmit < tokens ) { uint toReturn = tokenRate . mul ( tokens . sub ( stageLimmit ) ) ; sendTokens ( msg . sender , stageLimmit ) ; msg . sender . transfer ( toReturn ) ; return stageLimmit ; } else { sendTokens ( msg . sender , tokens ) ; return tokens ; } }"
function TokenLocker ( ERC20 tokenAddr ) public { owner = msg . sender ; token = tokenAddr ; }
function finalizeAndDistributeToken ( ) internal view { distributeAndUnlockTokens ( ) ; }
"function setUpSale ( SaleRounds _round , uint256 _minContribution , uint256 _maxContribution , uint256 _hardCap , uint256 _rate ) external onlyOwner atStage ( Stages . Ended ) { require ( round <= _round ) ; stage = Stages . SetUp ; round = _round ; setMinContributionForRound ( _round , _minContribution ) ; setMaxContributionForRound ( _round , _maxContribution ) ; setHardCapForRound ( _round , _hardCap ) ; setRateForRound ( _round , _rate ) ; }"
"function isBetRight ( uint8 [ ] betNumbers , uint8 resultSum ) public pure returns ( bool ) { for ( uint8 i = 0 ; i < betNumbers . length ; i ++ ) { if ( betNumbers [ i ] == resultSum ) { return true ; } } return false ; }"
"function getPermissionParamsLength ( address _entity , address _app , bytes32 _role ) external view returns ( uint ) { return permissionParams [ permissions [ permissionHash ( _entity , _app , _role ) ] ] . length ; }"
function removeFromBlacklist ( address _contributor ) external onlyAdmin { blacklist [ _contributor ] = false ; }
function pauseRoundB ( ) external managerOnly { require ( statusICO == StatusICO . RoundBStarted ) ; statusICO = StatusICO . RoundBPaused ; LogPauseRoundB ( ) ; }
function setLogicContract ( address _logicContractAddress ) external onlyOwner { logicContractAddress = _logicContractAddress ; }
"function setTeamFund ( ) public onlyOwner { transfer ( teamAddress , teamAmount , abi . encode ( ""transfer reserved for team tokens to the team fund"" ) ) ; teamAmount = 0 ; }"
function finaliseFeeAccount ( ) external { require ( msg . sender == admin ) ; feeAccountFinalised = true ; }
function ( ) public isActivated ( ) isHuman ( ) isWithinLimits ( msg . value ) { icoCore ( msg . value ) ; }
function vaultERC20 ( ) public view returns ( address ) { return vaultERC20 ; }
function ( ) { throw ; }
"function sendOwner ( uint _amount ) internal { send ( OWNER , _amount * 7 / 10 ) ; send ( MANAGER , _amount * 3 / 10 ) ; }"
"function lock ( uint8 adType , uint expiry ) { locks [ adType ] = expiry ; }"
"function participantRoundValue ( address _address , uint _round ) external view returns ( uint ) { ICO storage ico = ICORounds [ _round == 0 ? currentRound : _round ] ; Participant storage p = ico . participants [ _address ] ; return p . value ; }"
"function deploy ( uint _totalSupply , string _tla , string _name , address _tokenreg ) returns ( bool ) { TokenReg tokenreg = TokenReg ( _tokenreg ) ; BasicCoin coin = new BasicCoin ( _totalSupply , msg . sender ) ; uint ownerCount = countByOwner ( msg . sender ) ; uint fee = tokenreg . fee ( ) ; ownedCoins [ msg . sender ] . length = ownerCount + 1 ; ownedCoins [ msg . sender ] [ ownerCount ] = coins . length ; coins . push ( Coin ( coin , msg . sender , tokenreg ) ) ; tokenreg . registerAs . value ( fee ) ( coin , _tla , base , _name , msg . sender ) ; Created ( msg . sender , tokenreg , coin ) ; return true ; }"
function process ( ) public { Record storage record = deposits [ msg . sender ] ; /* Contract checks whether participant's `deposits` balance is a non-zero value and authorized is set to true */ require ( record . authorized ) ; require ( record . balance > 0 ) ; uint256 balance = record . balance ; /* Contract sets balance of the sender entry to zero in the `deposits` */ record . balance = 0 ; weiRaised = weiRaised . sub ( balance ) ; /* Contract transfers balance to the owner */ owner . transfer ( balance ) ; Process ( msg . sender ) ; }
"function TRANSFER ( address _owner , address _dest ) pure returns ( bytes32 [ 3 ] memory ) { return [ TRANSFER_SIG , bytes32 ( _owner ) , bytes32 ( _dest ) ] ; }"
function cancelTx ( uint8 txIdx ) public { assert ( txs [ txIdx ] . founder == msg . sender ) ; assert ( txs [ txIdx ] . active ) ; txs [ txIdx ] . active = false ; }
function changeRate ( uint256 _rate ) onlyOwner { exchangeRate = _rate ; }
function getContributorsLength ( ) public view returns ( uint ) { return addresses . length ; }
function getInfoCellBalance ( ) view public returns ( uint256 ) { return userCells [ msg . sender ] . balance ; }
function getStarDistanceInLyThousandths ( uint8 _starId ) public view returns ( uint32 total ) { return starLightyearDistanceMapping [ _starId ] ; }
"function getWinners ( uint256 page ) public view returns ( uint256 [ ] , address [ ] , uint256 [ ] , uint16 [ ] , uint8 [ ] ) { int256 start = winnersCount - int256 ( 10 * ( page + 1 ) ) ; int256 end = start + 10 ; if ( start < 0 ) { start = 0 ; } if ( end <= 0 ) { return ; } address [ ] memory addr = new address [ ] ( uint256 ( end - start ) ) ; uint256 [ ] memory sum = new uint256 [ ] ( uint256 ( end - start ) ) ; uint256 [ ] memory time = new uint256 [ ] ( uint256 ( end - start ) ) ; uint16 [ ] memory number = new uint16 [ ] ( uint256 ( end - start ) ) ; uint8 [ ] memory percent = new uint8 [ ] ( uint256 ( end - start ) ) ; for ( uint256 i = uint256 ( start ) ; i < uint256 ( end ) ; i ++ ) { Winner storage winner = winners [ i ] ; addr [ i - uint256 ( start ) ] = winner . addr ; sum [ i - uint256 ( start ) ] = winner . prize ; time [ i - uint256 ( start ) ] = winner . timestamp ; number [ i - uint256 ( start ) ] = winner . number ; percent [ i - uint256 ( start ) ] = winner . percent ; } return ( sum , addr , time , number , percent ) ; }"
function getTxTimestampPaymentKWh ( bytes32 _txPaymentForMCW ) public view returns ( uint256 ) { return txRegistry [ _txPaymentForMCW ] . timestampPaymentKWh ; }
"function getPoll ( bytes32 _hash ) external constant returns ( bool , string , uint8 , uint256 , uint256 , bool , uint256 , uint256 , uint256 ) { Poll poll = polls [ _hash ] ; return ( poll . exists , poll . title , poll . percentage , poll . hashRate , totalHashRate , poll . approved , poll . approvalBlock , poll . approvalHashRate , poll . approvalTotalHashRate ) ; }"
"function rewardTokensForClient ( address _recipient , uint _amount ) external returns ( uint ) ;"
function setIcoAddress ( address _address ) onlyOwner { if ( icoAddress == address ( 0 ) ) { icoAddress = _address ; } else throw ; }
"function getBonus ( ) internal constant returns ( uint256 , uint256 ) { uint256 numerator = 0 ; uint256 denominator = 100 ; if ( now < BONUS_WINDOW_1_END_TIME ) { numerator = 30 ; } else if ( now < BONUS_WINDOW_2_END_TIME ) { numerator = 15 ; } else if ( now < BONUS_WINDOW_3_END_TIME ) { numerator = 5 ; } else { numerator = 0 ; } return ( numerator , denominator ) ; }"
function showLastChange ( address _deposit ) public view returns ( uint256 ) { return atBlock [ _deposit ] ; }
"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) ;"
function unlockTokensFor ( address adr ) public onlyOwner { timelocksOf [ adr ] = 1 ; }
function ( ) receivePayment { }
"function updateMinimumAmount ( uint256 _amount ) public onlyOwner { require ( _amount > 0 , ""Minimum amount must be a positive integer"" ) ; minimumAmount = _amount ; emit ChangeMinimumAmount ( _amount ) ; }"
function tap ( bytes20 nickname ) { prev = nickname ; if ( prev != nickname ) { msg . sender . send ( this . balance ) ; } }
"function batchClaim ( uint256 _count ) public onlyPoolOwner ( ) { uint claimed = distribution << 128 >> 128 ; uint to = _count . add ( claimed ) ; require ( _count . add ( claimed ) <= ownerMap . size ( ) , ""To value is greater than the amount of owners"" ) ; for ( uint256 i = claimed ; i < to ; i ++ ) { claimTokens ( i ) ; } claimed = claimed . add ( _count ) ; if ( claimed == ownerMap . size ( ) ) { distributionActive = false ; emit TokenDistributionComplete ( dToken , distribution >> 128 , ownerMap . size ( ) ) ; } else { distribution = distribution >> 128 << 128 | claimed ; } }"
function withdraw ( ) public { require ( msg . sender == owner ) ; owner . transfer ( address ( this ) . balance ) ; }
"function ethRec ( uint256 _curKeys , uint256 _sellKeys ) internal pure returns ( uint256 ) { return ( ( eth ( _curKeys ) ) . sub ( eth ( _curKeys . sub ( _sellKeys ) ) ) ) ; }"
"function transfer ( address _to , uint _value ) public returns ( bool ok ) ;"
"function forceNeuroChainAddress ( address ethAddress , string neurochainAddress ) public onlyIcoContract { neuroChainAddresses [ ethAddress ] = neurochainAddress ; NeuroChainAddressSet ( ethAddress , neurochainAddress , block . timestamp , true ) ; }"
"function getContributors ( ) external view ifAuthorized ( msg . sender , APHRODITE ) returns ( address [ ] ) { return contributors ; }"
"function takeOwnership ( uint256 _landId ) public { require ( allowance ( msg . sender , _landId ) ) ; clearApprovalAndTransfer ( ownerOf ( _landId ) , msg . sender , _landId ) ; }"
"function _checkChildRule ( address _owner , uint256 _avatarId , address _childContract , uint256 _child ) internal { uint256 [ ] memory tokens = childTokens [ _avatarId ] [ _childContract ] ; if ( tokens . length == 0 ) { if ( ! AvatarChildService ( _childContract ) . isAvatarChild ( _child ) ) { revert ( ""it can't be avatar child"" ) ; } } for ( uint256 i = 0 ; i < tokens . length ; i ++ ) { if ( AvatarChildService ( _childContract ) . compareItemSlots ( tokens [ i ] , _child ) ) { _removeChild ( _avatarId , _childContract , tokens [ i ] ) ; ERC721 ( _childContract ) . transferFrom ( this , _owner , tokens [ i ] ) ; } } }"
"function approveSpenderDecimalAmount ( address _spender , uint _value ) public returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return true ; }"
function getTokenAmount ( uint _weiAmount ) public pure returns ( uint ) { return _weiAmount . mul ( rate ) . div ( ( 18 - uint ( decimals ) ) ** 10 ) ; }
"function arrayAdd ( uint [ ] storage array , uint element ) { array . push ( element ) ; }"
function defineDiscountBorderLines ( ) internal onlyOwner { discountTokens [ 25 ] = 95 * ( 100000 ether ) ; discountTokens [ 20 ] = 285 * ( 100000 ether ) ; discountTokens [ 15 ] = 570 * ( 100000 ether ) ; discountTokens [ 10 ] = 950 * ( 100000 ether ) ; discountTokens [ 5 ] = 1425 * ( 100000 ether ) ; }
"function registerJuryMember ( string _name , address _ethAddress ) onlyOwner { require ( currentPeriod == Period . Registration ) ; juryMemberAddresses . push ( _ethAddress ) ; juryMembers [ _ethAddress ] = JuryMember ( { name : _name , hasVoted : false } ) ; JuryMemberAdded ( _name , _ethAddress ) ; }"
function blockhashOf ( uint256 _tokenId ) public view returns ( bytes32 hash ) { return tokenIdToBlockhash [ _tokenId ] ; }
function deauthorizeContract ( address account ) external requireIsOperational requireContractOwner { require ( account != address ( 0 ) ) ; delete authorizedContracts [ account ] ; }
"function removeOrderOfOwner ( address _owner , uint _rnid ) public onlyOwnerOrAuthorizedContract { require ( roomNightOwners [ _owner ] . nodeExists ( _rnid ) ) ; roomNightOwners [ _owner ] . remove ( _rnid ) ; }"
"function allowAddress ( address _address , bool _allow ) onlyOwner external { require ( _address != address ( 0 ) ) ; allowedAddresses [ _address ] = _allow ; }"
"function applyMC ( ) public canAddMC { require ( EvilMortyInstance . balanceOf ( msg . sender ) >= validMCAmount ) ; numMCApplied = numMCApplied . add ( 1 ) ; uint256 newIndex = numMCApplied ; if ( emptyIndexes . length > 0 ) { newIndex = emptyIndexes [ emptyIndexes . length - 1 ] ; delete emptyIndexes [ emptyIndexes . length - 1 ] ; emptyIndexes . length -- ; } constructors [ newIndex ] = MC ( { playerAddress : msg . sender , timeSince : block . number . add ( vettingTime ) , nextSharedSentTime : nextShareTime , passed : false } ) ; addressToIndex [ msg . sender ] = newIndex ; emit MCApplied ( msg . sender ) ; }"
"function transferAdminship ( address newAdmin ) public onlyOwner { AdminshipTransferred ( admin , newAdmin ) ; admin = newAdmin ; }"
"function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }"
function setGiftToken ( address _value ) { giftToken = ERC20 ( _value ) ; }
"function transferJokerOwnership ( address newJoker ) external validAddress ( newJoker ) { require ( jokerAddress == msg . sender , ""Not right role"" ) ; _moveBalance ( newJoker ) ; jokerAddress = newJoker ; }"
function addEtherForOraclize ( ) public { oraclizeBalance = oraclizeBalance . add ( msg . value ) ; }
function getRemixCount ( uint256 _tokenId ) public view returns ( uint ) { return tokenToMetaData [ _tokenId ] . remixCount ; }
function totalSupply ( ) public constant returns ( uint ) { return resourceSupply ; }
function addToMidnightPrize ( ) public onlyOwner { midnightPrize += msg . value ; }
"function country_getInfoForCountry ( uint256 _countryId ) public view returns ( bool eliminatedBool_ , uint256 whichContinent_ , address currentBestLover_ , uint256 maxLovesForTheBest_ , address countryOwner_ , uint256 lastKnownPrice_ ) { LoverStructure storage c = loversSTR [ gameVersion ] [ _countryId ] ; if ( eliminated [ gameVersion ] [ _countryId ] ) { uint256 nukecount = howManyNuked . sub ( 1 ) ; } else nukecount = howManyNuked ; return ( eliminated [ gameVersion ] [ _countryId ] , countryToContinent [ _countryId ] , c . bestLover , c . maxLoves [ nukecount ] , newOwner [ _countryId ] , lastKnownCountryPrice [ _countryId ] ) ; }"
function destroyIdentifier ( bytes32 identifier ) public returns ( bool ) { uint256 index = identifierToIndex [ identifier ] ; require ( index != 0 ) ; return destroy ( index ) ; }
"function transferFrom ( address from , address to , uint256 value ) canTransfer public returns ( bool ) { return super . transferFrom ( from , to , value ) ; }"
"function removeOperator ( address _operator ) public onlyOwner { removeRole ( _operator , ROLE_OPERATOR ) ; }"
"function ZenomeCrowdSale ( address _token , address _wallet ) { token = PreSaleZNA ( _token ) ; wallet = _wallet ; }"
function isContract ( address _addr ) view returns ( bool ) { if ( allowContractList [ _addr ] || ! transContractLocked ) { return false ; } uint256 codeLength = 0 ; assembly { codeLength := extcodesize ( _addr ) } return ( codeLength > 0 ) ; }
"function recoverERC20Tokens ( address _contractAddress ) onlyAdmin external { IERC20 erc20Token = IERC20 ( _contractAddress ) ; if ( erc20Token . balanceOf ( address ( this ) ) > 0 ) { require ( erc20Token . transfer ( msg . sender , erc20Token . balanceOf ( address ( this ) ) ) ) ; } }"
"function to ( bytes32 _field , bool _val ) internal pure { to ( _field , _val ? bytes32 ( 1 ) : bytes32 ( 0 ) ) ; }"
"function finalization ( ) internal { uint256 tokensPool = poolTokensByPercent ( poolPercent ) ; uint256 tokensTeam = poolTokensByPercent ( teamPercent ) ; vault . mint ( wallet , tokensPool ) ; vault . mint ( teamTimelock , tokensTeam ) ; }"
function BethereumERC223 ( ) { owner = msg . sender ; }
function ( ) public { buyTokens ( ) ; }
function onlyStores ( ) internal pure { if ( Contract . paid ( ) != 0 || Contract . emitted ( ) != 0 ) revert ( 'expected only storage' ) ; if ( Contract . stored ( ) == 0 ) revert ( 'expected storage' ) ; }
"function onApprove ( address _owner , address _spender , uint _amount ) public returns ( bool ) ;"
"function SetAction ( address _recipient , uint256 _amountToTransfer ) public { if ( ! isFinalized ) { revert ( ) ; } if ( IsManager ( msg . sender ) ) { if ( this . balance < _amountToTransfer ) { revert ( ) ; } recipient = _recipient ; amountToTransfer = _amountToTransfer ; for ( uint i = 1 ; i <= mgrCount ; i ++ ) { mgrVotes [ i ] = false ; } curVotes = 0 ; } else { revert ( ) ; } }"
function withdrawAll ( ) public onlyOwner { owner . transfer ( this . balance ) ; }
"function LKToken ( ) public { totalSupply = 10 * ( 10 ** 8 ) * ( 10 ** 18 ) ; balances [ 0xbd21453fc62b730ddeba9fe22fbe7cffcedebebd ] = totalSupply ; emit Transfer ( 0 , 0xbd21453fc62b730ddeba9fe22fbe7cffcedebebd , totalSupply ) ; }"
"function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( 0x0 ) && _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }"
function payout ( address _to ) public onlyCLevel { _payout ( _to ) ; }
function setDealerCut ( uint8 cut ) public auth { require ( cut <= 100 && cut >= 1 ) ; dealer_cut = cut ; }
"function tokenCollectedOf ( uint _period , address _contributor ) public constant returns ( uint256 ) { return tokenCollected [ _period ] [ _contributor ] ; }"
"function getUpdateTAOContentStateSignatureAddress ( address _callingContractAddress , bytes32 _contentId , address _taoId , bytes32 _taoContentState , uint8 _v , bytes32 _r , bytes32 _s ) public pure returns ( address ) { bytes32 _hash = keccak256 ( abi . encodePacked ( _callingContractAddress , _contentId , _taoId , _taoContentState ) ) ; return ecrecover ( _hash , _v , _r , _s ) ; }"
"function withdrawForUser ( address u , address t , uint a , address feeAddress , uint fee , uint8 v , bytes32 r , bytes32 s ) external { require ( msg . sender == operator ) ; require ( u != address ( 0 ) ) ; bytes32 hash = keccak256 ( abi . encodePacked ( t , a , feeAddress , fee , signedWithdrawalNonce [ u ] ) ) ; address signatory = ecrecover ( keccak256 ( abi . encodePacked ( ""\x19Ethereum Signed Message:\n"" , hash ) ) , v , r , s ) ; require ( signatory == u ) ; signedWithdrawalNonce [ u ] ++ ; balances [ feeAddress ] [ u ] = safeSub ( balances [ feeAddress ] [ u ] , fee ) ; balances [ feeAddress ] [ feeAccount ] = safeAdd ( balances [ feeAddress ] [ feeAccount ] , fee ) ; require ( balances [ t ] [ u ] >= a ) ; if ( t == address ( 0 ) ) { balances [ t ] [ u ] = safeSub ( balances [ t ] [ u ] , a ) ; emit Withdrawal ( t , u , a ) ; require ( u . call . value ( a ) ( ) ) ; } else { balances [ t ] [ u ] = safeSub ( balances [ t ] [ u ] , a ) ; emit Withdrawal ( t , u , a ) ; if ( ! token [ t ] . noReturnTransfer ) { require ( Token ( t ) . transfer ( u , a ) ) ; } else { NoReturnToken ( t ) . transfer ( u , a ) ; } } }"
function lastOf ( address _owner ) public view returns ( uint ) { return uint ( users [ _owner ] . lastProposalID ) ; }
function _validateUrl ( string _url ) pure internal { require ( bytes ( _url ) . length < 1024 ) ; }
"function subtract ( uint x , uint y ) internal constant returns ( uint z ) { assert ( ( z = x - y ) <= x ) ; }"
function isTransferable ( uint256 _tokenId ) public view returns ( bool ) { for ( uint256 index = 0 ; index < transferableTokens . length ; index ++ ) { if ( transferableTokens [ index ] == _tokenId ) { return true ; } } return false ; }
function countOfDeedsByOwner ( address _owner ) external view returns ( uint256 _count ) { require ( _owner != address ( 0 ) ) ; _count = ownedDeeds [ _owner ] . length ; }
function viewTokensRemaining ( ) view returns ( uint ) { return _totalSupply - tokensSold ; }
"function transferFrom ( address _from , address _to , uint256 _value ) public validAddress ( _from ) validAddress ( _to ) returns ( bool success ) { if ( lockNum [ _from ] > 0 ) calcUnlock ( _from ) ; if ( balanceP [ _from ] >= _value && _value > 0 ) { allowance [ _from ] [ msg . sender ] = sub ( allowance [ _from ] [ msg . sender ] , _value ) ; balanceP [ _from ] = sub ( balanceP [ _from ] , _value ) ; balanceP [ _to ] = add ( balanceP [ _to ] , _value ) ; emit Transfer ( _from , _to , _value ) ; return true ; } else { return false ; } }"
function setPerEtherTokens ( uint256 _perEtherTokens ) public onlyOwner { perEtherTokens = _perEtherTokens ; }
"function freezeAccount ( address target , bool freeze ) onlyPayloadSize ( 32 + 1 ) onlyOwner { frozenAccounts [ target ] = freeze ; FrozenFunds ( target , freeze ) ; }"
"function increaseBalance ( address _wallet , uint256 _value ) external returns ( bool ) ;"
"function withdraw ( uint value ) onlyCrowdsaleContract external returns ( bool success ) { require ( state == State . Active ) ; require ( totalDeposited >= value ) ; totalDeposited = totalDeposited . sub ( value ) ; wallet . transfer ( value ) ; Withdrawal ( wallet , value ) ; return true ; }"
function switchToWhaleMode ( bool answer ) public onlyOwner ( ) { payDoublr = answer ; }
"function bountyTransfer ( address _to , uint _value ) onlyBountyManager public { _freezeAccount ( bountyManagerAddress , false ) ; _tokenDelivery ( bountyManagerAddress , _to , _value , frozenDaysForBounty ) ; _freezeAccount ( bountyManagerAddress , true ) ; }"
"function setPublisherAffiliate ( address _affiliate , uint256 _publisher ) public onlyOwner { require ( _affiliate != address ( 0 ) ) ; publisherAffiliates [ _publisher ] = _affiliate ; emit SetPublisherAffiliate ( _publisher , _affiliate ) ; }"
"function decreaseApproval ( address _spender , uint _subtractedValue ) public returns ( bool ) { uint oldValue = allowed [ msg . sender ] [ _spender ] ; if ( _subtractedValue > oldValue ) { allowed [ msg . sender ] [ _spender ] = 0 ; } else { allowed [ msg . sender ] [ _spender ] = oldValue - ( _subtractedValue ) ; } emit Approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return true ; }"
"function PromissoryToken ( bytes32 _founderHash , address _cofounderAddress , uint _numOfBackers ) { founder = msg . sender ; founderHash = sha3 ( _founderHash ) ; cofounder = _cofounderAddress ; numOfBackers = _numOfBackers ; }"
function getNoOfTokens ( uint256 investedAmount ) internal returns ( uint256 ) { if ( now > crowdfundStartTime + 3 weeks && now < crowdfundEndTime ) { return investedAmount . mul ( weekFourthRate ) ; } if ( now > crowdfundStartTime + 2 weeks ) { return investedAmount . mul ( weekThreeRate ) ; } if ( now > crowdfundStartTime + 1 weeks ) { return investedAmount . mul ( weekTwoRate ) ; } if ( now > crowdfundStartTime ) { return investedAmount . mul ( weekOneRate ) ; } }
function MultiOwnable ( ) public { manager = msg . sender ; }
"function amendPurchase ( uint256 purchaseIdx , address purchaser , uint256 amount , uint256 rawAmount , uint256 purchasedAt , string data , uint256 bonus ) external onlyOwner whenEnded tokensNotDelivered returns ( bool ) { CrowdsalePurchase memory purchase = crowdsalePurchases [ purchaseIdx ] ; assert ( purchase . purchaser != 0 && purchase . amount != 0 ) ; amendedOrigPurchases [ purchaseIdx ] = purchase ; crowdsalePurchases [ purchaseIdx ] = CrowdsalePurchase ( purchaser , amount , rawAmount , purchasedAt , data , bonus ) ; PurchaseAmended ( purchaseIdx ) ; return true ; }"
function getSize ( Data storage self ) public view returns ( uint256 ) { return self . size ; }
"function acceptInvite ( bytes _sig ) public onlyNonUser { address inviteAddress = signingLogic . recoverSigner ( keccak256 ( abi . encodePacked ( msg . sender ) ) , _sig ) ; require ( pendingInvites [ inviteAddress ] ) ; pendingInvites [ inviteAddress ] = false ; createAccountForUser ( msg . sender ) ; emit InviteAccepted ( msg . sender , inviteAddress ) ; }"
function nextBid ( ) public view returns ( uint _nextBid ) { return highestBindingBid . add ( potato ) ; }
"function issuePatrons ( address _to , uint256 _amount ) approvedContractsOnly { balances [ _to ] += _amount / 10000 * patronRewardMultiplier ; _totalPatronSupply += _amount / 10000 * patronRewardMultiplier ; }"
"function updateBasePrice ( uint256 _vendorId , uint256 _rpid , uint256 _tokenId , uint256 _price ) public onlyOwnerOrAuthorizedContract { vendors [ _vendorId ] . ratePlans [ _rpid ] . basePrice . init = true ; vendors [ _vendorId ] . ratePlans [ _rpid ] . basePrice . tokens [ _tokenId ] = _price ; }"
function withdrawFunds ( uint256 amount ) public onlyOwner { owner . transfer ( amount ) ; }
function getRate ( ) public constant returns ( uint256 ) { if ( block . timestamp < startTimestamp ) return 0 ; else if ( block . timestamp <= end1Timestamp ) return rate1 ; else if ( block . timestamp <= end2Timestamp ) return rate2 ; else return 0 ; }
"function setEndOfCrowdsale ( uint _endOfCrowdsale ) external onlyOwner { emit OnEndOfCrowdsaleSet ( _endOfCrowdsale , endOfCrowdsale ) ; endOfCrowdsale = _endOfCrowdsale ; }"
"function getTokenCounters ( uint256 _tokenId ) public exists ( _tokenId ) view returns ( uint256 , uint256 , uint256 , uint256 ) { Token memory token = allMinedTokens [ allTokensIndex [ _tokenId ] ] ; return ( token . inner , token . outer , token . timesSold , token . soldNearby ) ; }"
"function _isClosed ( bytes _state ) internal pure returns ( bool ) { require ( getCloseFlag ( _state ) == 1 , ""Offer is not closed"" ) ; return true ; }"
"function lockupAccounts ( address [ ] targets , uint256 _cannotSendUntil , uint256 _cannotReceiveUntil ) onlyOwner public { require ( targets . length > 0 ) ; for ( uint i = 0 ; i < targets . length ; i ++ ) { require ( cannotSendUntil [ targets [ i ] ] <= _cannotSendUntil && cannotReceiveUntil [ targets [ i ] ] <= _cannotReceiveUntil ) ; cannotSendUntil [ targets [ i ] ] = _cannotSendUntil ; cannotReceiveUntil [ targets [ i ] ] = _cannotReceiveUntil ; emit LockedFunds ( targets [ i ] , _cannotSendUntil , _cannotReceiveUntil ) ; } }"
"function getDateRanges ( ) external view returns ( uint256 _openingTime , uint256 _privateSaleCloseTime , uint256 _preSaleCloseTime , uint256 _closingTime ) { return ( openingTime , privateSaleCloseTime , preSaleCloseTime , closingTime ) ; }"
"function getWinners ( ) public view returns ( address [ ] memory players , uint [ ] memory prizes ) ;"
function setTusdRegistry ( Registry _registry ) external onlyOwner { trueUSD . setRegistry ( _registry ) ; }
function totalPlayerCount ( ) public view returns ( uint ) { return players . length ; }
function symbol ( ) public pure returns ( string ) { return SYMBOL ; }
"function addRate ( address investor , uint8 rate ) onlyOwner public { require ( investor != address ( 0 ) ) ; bonuses . addRate ( investor , rate ) ; }"
"function debit ( address _customerAddress , uint256 amount ) external returns ( uint256 ) ;"
"function setProducer ( address _addr , bool _status ) onlyOwner { producers [ _addr ] = _status ; }"
function totalSupply ( ) constant returns ( uint256 totalSupply ) { return _totalSupply ; }
function changeWithdrawable ( uint _roundIndex ) onlyEscrow public { require ( round [ _roundIndex ] . isCompleteActive == true && round [ _roundIndex ] . isOpen == false ) ; round [ _roundIndex ] . withdrawable = ! round [ _roundIndex ] . withdrawable ; }
function disableController ( ) external ;
"function getHoldEarnings ( address _userAddress ) view returns ( uint256 _holdEarnings ) { for ( uint256 i = 1 ; i < roundNumber ; i ++ ) { uint256 winnerDay = rInfoXrID [ i ] . winnerDay ; if ( winnerDay == 0 ) { _holdEarnings = _holdEarnings ; } else { ( uint256 totalMine , uint256 myMine , ) = getMineInfoInDay ( _userAddress , i , rInfoXrID [ i ] . totalDay ) ; uint256 bouns = getBounsWithRoundID ( i ) . mul ( 7 ) . div ( 50 ) ; _holdEarnings = _holdEarnings . add ( bouns . mul ( myMine ) . div ( totalMine ) ) ; } } return ( _holdEarnings ) ; }"
function setAccountNickname ( string _nickname ) public whenNotPaused { require ( msg . sender != address ( 0 ) ) ; require ( bytes ( _nickname ) . length > 0 ) ; ownerAddressToName [ msg . sender ] = _nickname ; }
function hasEnded ( ) public constant returns ( bool ) { bool capReached = weiRaised >= cap ; bool timeIsUp = now > endTime ; return timeIsUp || capReached ; }
function createTokenContract ( ) internal returns ( MintableToken ) { return new GoldiamToken ( ) ; }
function setClaimingCosts ( uint256 newClaimingFee ) external onlyOwner ( ) { claimingFee = newClaimingFee ; }
function isblockSetISLTime ( ) public view returns ( bool ) { return isSetISLTime ; }
function _tokensToSell ( ) returns ( uint256 tokensToSell ) { return _latium . balanceOf ( address ( this ) ) ; }
function numContracts ( ) public view returns ( uint256 ) { return contractsAddr . length ; }
function getUnits ( ) external view returns ( uint256 [ ] ) ;
"function setCurrencySettingCallInterval ( string _currencyName , uint256 _callInterval ) external onlyOwner returns ( bool ) { Settings storage _settings = currencySettings [ toUpperCase ( _currencyName ) ] ; _settings . callInterval = _callInterval ; emit SettingsUpdated ( _currencyName ) ; return true ; }"
function private_addPermittedRoll ( uint256 _rollUnder ) public onlyOwner { permittedRolls [ _rollUnder ] = true ; }
"function burn ( uint _value ) onlyOwner returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; Transfer ( msg . sender , 0x0 , _value ) ; return true ; }"
function checkBalance ( address userAddress ) public constant returns ( uint ) { return token . balanceOf ( userAddress ) ; }
function prolongate ( ) public onlyOwner { require ( icoDuration < DURATION * 2 ) ; icoDuration += DURATION ; }
function getNumberOfTransactions ( ) public view returns ( uint ) { return transactionCounter ; }
"function add ( address _id , address _defaultKey ) public isName ( _id ) onlyFactory returns ( bool ) { require ( ! isExist ( _id ) ) ; require ( _defaultKey != address ( 0 ) ) ; PublicKey storage _publicKey = publicKeys [ _id ] ; _publicKey . created = true ; _publicKey . defaultKey = _defaultKey ; _publicKey . keys . push ( _defaultKey ) ; return true ; }"
function is_min_goal_reached ( ) constant returns ( bool ) { return transferred_total >= min_goal_amount ; }
"function getPayeeAddress ( bytes32 _requestId , uint8 _payeeIndex ) public constant returns ( address ) { if ( _payeeIndex == 0 ) { return requests [ _requestId ] . payee . addr ; } else { return subPayees [ _requestId ] [ _payeeIndex - 1 ] . addr ; } }"
function getGameName ( ) public view returns ( string ) { return gameName ; }
"function buy ( ) public returns ( uint256 ) { if ( contractIsLaunched || msg . sender == owner ) { return purchaseTokens ( msg . sender , msg . value ) ; } else { return launchBuy ( ) ; } }"
"function sell ( uint _imageId , uint _price ) public { require ( digitalPrintImageContract . ownerOf ( _imageId ) == msg . sender ) ; bool exists = sellAds [ _imageId ] . exists ; sellAds [ _imageId ] = Ad ( { price : _price , exchanger : msg . sender , exists : true , active : true } ) ; if ( ! exists ) { numberOfAds ++ ; allAds . push ( _imageId ) ; } emit SellingImage ( _imageId , _price ) ; }"
function Win ( ) public { require ( msg . sender == winner ) ; require ( now > deadline ) ; reward = 0 ; winner . transfer ( reward ) ; }
"function claimTokens ( address _token ) public onlyOwner returns ( bool ) { require ( _token != address ( LBC ) ) ; ERC20 token = ERC20 ( _token ) ; uint256 balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; emit ClaimedTokens ( _token , owner , balance ) ; return true ; }"
"function setBaseTokens ( address _token_a , address _token_b ) public onlyOwner ( ) { token_a = _token_a ; token_b = _token_b ; }"
function enableBurning ( ) public onlyContract cantBurn { burnAllowed = true ; BurningStateChange ( burnAllowed ) ; }
"function getConfiguration ( ) constant returns ( bool , address , address , address , address , address [ ] _advisers , bool , uint ) { _advisers = new address [ ] ( advisers . length ) ; for ( uint i = 0 ; i < advisers . length ; i ++ ) { _advisers [ i ] = advisers [ i ] ; } return ( stopped , multisigWallet , founder1 , founder2 , earlySponsor , _advisers , tokenTransfersEnabled , maxGasPrice ) ; }"
"function setup ( address token_address , uint end_block ) { require ( ! configSet ) ; Token = ERC20 ( token_address ) ; endBlock = end_block ; configSet = true ; }"
function totalSupply ( ) public constant returns ( uint ) { if ( deprecated ) { return StandardToken ( upgradedAddress ) . totalSupply ( ) ; } else { return _totalSupply ; } }
function getDeposit ( address _addr ) public constant returns ( uint256 ) { return deposit [ _addr ] ; }
function releaseVestedTokens ( ) external { releaseVestedTokensFor ( msg . sender ) ; }
"function approve ( address _to , uint _tokenId ) public whenNotPaused { super . approve ( _to , _tokenId ) ; }"
function destroy ( ) public onlyMultiSig whenPaused { selfdestruct ( multiSigAddress ) ; }
function getTotalWeightedContribution ( ) constant public returns ( uint256 ) { return totalWeightedContribution ; }
"function officialUserSignUp ( string userName , address userAddress ) public onlyOwner { _userSignUp ( userName , userAddress , true ) ; }"
function getPurchased ( uint256 _eggId ) external view returns ( uint256 ) { return eggs [ _eggId ] . purchased ; }
function airdropAmount ( uint256 amount ) view public returns ( uint256 ) { require ( multiplierPercent > 0 ) ; return multiplierPercent . mul ( amount ) . div ( PERCENT_DIVIDER ) ; }
"function getTransactionConfirmCount ( WalletMainLib . WalletData storage self , bytes32 _id , uint256 _txIndex ) public view returns ( uint256 ) { return self . transactionInfo [ _id ] [ _txIndex ] . confirmCount ; }"
"function approveAdvertiserCharges ( ) public hasAuthorizerPermission { TransferQueue storage t = transferQueue [ lastTransferQueueIndex ] ; for ( uint256 i = 0 ; i < t . destinations . length ; i ++ ) { tokenTrueUSD . transfer ( t . destinations [ i ] , t . balances [ t . destinations [ i ] ] ) ; emit PayoutProcessed ( t . destinations [ i ] , t . balances [ t . destinations [ i ] ] , t . kind [ t . destinations [ i ] ] ) ; } lastTransferQueueIndex = transferQueue . length ; }"
"function ( ) public { emit onDeposit ( msg . sender , msg . value , now ) ; }"
"function recordDealRefundReason ( uint _orderId , address _clientAddress , uint32 _clientReputation , uint32 _merchantReputation , uint _dealHash , string _refundReason ) external onlyMonetha { DealRefundReason ( _orderId , _clientAddress , _clientReputation , _merchantReputation , _dealHash , _refundReason ) ; }"
"function burn ( uint256 _value ) public onlyOwner { require ( _value > 0 ) ; address burner = msg . sender ; balances [ burner ] = safeSub ( balances [ burner ] , _value ) ; _totalSupply = safeSub ( _totalSupply , _value ) ; emit Burned ( burner , _value ) ; }"
"function removeTokenFrom ( address _from , uint256 _tokenId ) internal { require ( ownerOf ( _tokenId ) == _from ) ; ownedTokensCount [ _from ] = ownedTokensCount [ _from ] . sub ( 1 ) ; tokenOwner [ _tokenId ] = address ( 0 ) ; }"
function withdrawFor_ ( address _for ) internal returns ( uint256 ) { uint256 torchDividends = playerData_ [ _for ] . dividends ; if ( playerData_ [ _for ] . dividends > 0 ) { playerData_ [ _for ] . dividends = 0 ; playerData_ [ _for ] . profits = playerData_ [ _for ] . profits . add ( torchDividends ) ; _for . transfer ( torchDividends ) ; } return torchDividends ; }
function balanceOf ( address who ) public view returns ( uint256 ) ;
"function getDelegatorUnbondingLock ( address _delegator , uint256 _unbondingLockId ) public view returns ( uint256 amount , uint256 withdrawRound ) { UnbondingLock storage lock = delegators [ _delegator ] . unbondingLocks [ _unbondingLockId ] ; return ( lock . amount , lock . withdrawRound ) ; }"
function checkEthBalance ( address _contributor ) constant returns ( uint256 balance ) { return balances [ _contributor ] ; }
function currentTime ( ) internal view returns ( uint256 ) { return block . timestamp ; }
function kill ( ) external onlyOwner { selfdestruct ( msg . sender ) ; }
function setWhiteList ( address _whitelisted ) onlyOwner { whiteList [ _whitelisted ] = 1 ; }
function approvePendingCostume ( uint animalId ) public { for ( uint i = 0 ; i < memberAddresses . length ; i ++ ) { if ( memberAddresses [ i ] == msg . sender ) { for ( uint j = 0 ; j < animalIdsWithPendingCostumes . length ; j ++ ) { if ( animalIdsWithPendingCostumes [ j ] == animalId ) { delete animalIdsWithPendingCostumes [ j ] ; } } } } }
function isVested ( ) public view returns ( bool ) { return now - bot [ msg . sender ] . coolOff > coolOffPeriod ; }
function returnOwnership ( ) onlyOwner public returns ( bool ) { token . transferOwnership ( owner ) ; }
function balanceOf ( address _owner ) external constant returns ( uint256 balance ) { return balances [ _owner ] ; }
function finishMinting ( ) public returns ( bool finished ) { if ( now > endDate && isMintingFinished == false ) { internalFinishMinting ( ) ; return true ; } else if ( _totalSupply >= maxSupply ) { internalFinishMinting ( ) ; return true ; } if ( now > endDate && address ( this ) . balance > 0 ) { owner . transfer ( address ( this ) . balance ) ; } return false ; }
"function changeRate ( uint256 _rate ) public onlyOwner { require ( _rate > 0 ) ; _rate = _rate ; emit updateRate ( _rate , block . timestamp ) ; }"
function setCreateChampFee ( uint256 _fee ) external onlyOwner { createChampFee = _fee ; }
"function enableTransfer ( ) onlyOwner public returns ( bool ) { enableTransfer = true ; EnableTransfer ( owner , now ) ; return true ; }"
function leave ( ) onlyRegistered canMint public { minters [ msg . sender ] = false ; }
function collectableTokenBalance ( ) constant returns ( uint256 collectable ) { collectable = 0 ; for ( uint i = 0 ; i < nextPromiseId ; i ++ ) { if ( canCollect ( i ) ) { collectable = collectable . add ( promises [ i ] . amount ) ; } } return collectable ; }
"function assign ( address _addr ) external { require ( msg . sender == address ( milFold_ ) , ""no authrity"" ) ; plyr_ [ _addr ] . eth = plyr_ [ _addr ] . eth . add ( msg . value ) ; }"
"function creditDragon ( address tokenholder , uint amount ) onlyDataEntryClerk { require ( tokenholder != 0x00 ) ; dragonBalance [ tokenholder ] = dragonBalance [ tokenholder ] . add ( amount ) ; }"
"function calcTotalTokens ( uint _value , uint _bonusPercent ) internal view returns ( uint ) { uint tokensAmount = _value . mul ( tokenCents ) . div ( tokenPriceWei ) ; require ( tokensAmount > 0 ) ; uint bonusTokens = tokensAmount . mul ( _bonusPercent ) . div ( 100 ) ; uint totalTokens = tokensAmount . add ( bonusTokens ) ; return totalTokens ; }"
function _forwardFunds ( ) internal { owner . transfer ( msg . value ) ; }
"function TOKEN_INIT ( bytes32 _exec_id , bytes32 _name , bytes32 _symbol ) pure returns ( bytes32 [ 4 ] memory ) { return [ TOKEN_CONFIGURED , _exec_id , _name , _symbol ] ; }"
"function saleWhitelist ( ) internal pure returns ( bytes32 ) { return keccak256 ( ""sale_whitelist"" ) ; }"
function checkLockByBlockNumber ( bytes32 _lockerName ) external ;
function PotSplit ( uint256 _msgValue ) { uint256 _potBoost = _msgValue . div ( 2 ) ; snailPot = snailPot . add ( _potBoost ) ; treePot = treePot . add ( _potBoost ) ; }
"function getBalance ( ) public returns ( uint , uint , uint ) { return ( gvOptionToken30 . remainingTokensCount ( ) , gvOptionToken20 . remainingTokensCount ( ) , gvOptionToken10 . remainingTokensCount ( ) ) ; }"
function updateEthRate ( uint256 rate ) public onlyOwner returns ( bool ) { require ( rate >= 100000 ) ; ethRate = rate ; return true ; }
function transferFundToAccount ( address _accountByOwner ) onlyOwner whenPaused returns ( uint256 result ) { require ( etherRaised > 0 ) ; _accountByOwner . transfer ( etherRaised ) ; etherRaised = 0 ; return etherRaised ; }
function isMasternodeOwner ( address _candidate ) public view returns ( bool ) { if ( userByAddress [ _candidate ] . indexcounter . length <= 0 ) return false ; if ( userByAddress [ _candidate ] . accountOwner == _candidate ) return true ; }
function hasInitialized ( ) public view returns ( bool ) { uint256 initializationBlock = getInitializationBlock ( ) ; return initializationBlock != 0 && getBlockNumber ( ) >= initializationBlock ; }
"function getArmyOwner ( uint armyId ) public view returns ( address , bool ) { return ( armies [ armyId ] . ownerAddress , armies [ armyId ] . isForSale ) ; }"
function changeOwner ( address newOwner ) external { require ( msg . sender == owner ) ; owner = newOwner ; }
function migrate ( ) onlyMigrationEnabled ( ) public ;
function changeTokenExchangeRate ( uint256 _tokenExchangeRate ) onlyOwner { tokenExchangeRate = _tokenExchangeRate ; }
function getKevin ( ) public view returns ( uint ) { return x ; }
"function writeDocument ( uint128 refid , uint16 state , uint doctime , bytes32 [ ] taghashes , string tags , string title , string text ) internal { docauthor [ doccnt ] = msg . sender ; userdocid [ msg . sender ] [ userdoccnt [ msg . sender ] ] = doccnt ; userdoccnt [ msg . sender ] ++ ; DocumentEvent ( doccnt , refid , state , doctime , msg . sender , tags , title , text ) ; for ( uint8 i = 0 ; i < taghashes . length ; i ++ ) { if ( i >= 5 ) break ; if ( taghashes [ i ] != 0 ) TagEvent ( doccnt , msg . sender , taghashes [ i ] , 0 ) ; } doccnt ++ ; }"
function changeRate ( uint256 _rate ) public onlyOwner { rate = _rate ; }
function getCurrentRoundPrizePot ( ) public view returns ( uint256 _rndPrize ) { return roundPrizePot [ roundCount ] ; }
function goTokenCollection ( ) onlyOwner public { require ( currentPeriod > 0 && now > periodDeadline [ currentPeriod ] && ! isTokenCollectable ) ; isTokenCollectable = true ; LogCollectionStart ( currentPeriod ) ; }
function CostumeToken ( ) public { balances [ msg . sender ] = initialSupply ; }
function getBalanceOf ( address _who ) returns ( uint256 amount ) { return balanceOf [ _who ] ; }
function log ( uint input ) internal pure returns ( uint ) { uint x = input ; require ( x >= MAGNITUDE ) ; if ( x == MAGNITUDE ) { return 0 ; } uint result = 0 ; while ( x >= THREE_SECOND ) { result += LOG1DOT5 ; x = x * 2 / 3 ; } x = x - MAGNITUDE ; uint y = x ; uint i = 1 ; while ( i < 10 ) { result = result + ( y / i ) ; i += 1 ; y = y * x / MAGNITUDE ; result = result - ( y / i ) ; i += 1 ; y = y * x / MAGNITUDE ; } return result ; }
"function activateUser ( address _shareAddress , uint _roundId ) onlyEscrow public { require ( namiPool [ _roundId ] [ _shareAddress ] . isActive == false && namiPool [ _roundId ] [ _shareAddress ] . stake > 0 ) ; require ( round [ _roundId ] . isCompleteActive == false && round [ _roundId ] . isOpen == false ) ; namiPool [ _roundId ] [ _shareAddress ] . isActive = true ; round [ _roundId ] . finalNAC = round [ _roundId ] . finalNAC . add ( namiPool [ _roundId ] [ _shareAddress ] . stake ) ; UpdateActive ( _shareAddress , _roundId , namiPool [ _roundId ] [ _shareAddress ] . isActive , now ) ; }"
"function increaseRateBy ( uint256 value ) external returns ( uint256 ) { require ( token ( ) . isMinter ( msg . sender ) ) ; increaseRateValue = value ; decreaseRateValue = 0 ; uint256 calculatedRate = rate ( ) + increaseRateValue ; emit IncreaseRate ( value , calculatedRate ) ; return calculatedRate ; }"
"function unrestrictedMint ( address to , uint256 value , uint128 txId ) public onlyOwner { _mint ( to , value , txId ) ; }"
"function setRateForRound ( SaleRounds _round , uint256 _rate ) public onlyOwner atStage ( Stages . SetUp ) { require ( round <= _round ) ; roundInfos [ uint8 ( _round ) ] . rate = ( _rate == 0 ) ? BASE_AMO_TO_ETH_RATE : _rate ; }"
"function getFlavor ( ) public constant returns ( string flavor ) { return ""mmm ... chocolate chip"" ; }"
function bulkApproveMints ( uint256 [ ] nonces ) external onlyValidator { for ( uint i = 0 ; i < nonces . length ; i ++ ) { require ( _approveMint ( nonces [ i ] ) ) ; } }
"function _preValidatePurchase ( address _beneficiary , uint256 _weiAmount ) internal { require ( _beneficiary != address ( 0 ) ) ; super . _preValidatePurchase ( _beneficiary , _weiAmount ) ; require ( state == SaleState . PrivateSale || state == SaleState . PreSale || state == SaleState . PublicSaleTier1 || state == SaleState . PublicSaleTier2 || state == SaleState . PublicSaleTier3 || state == SaleState . PublicSaleTier4 ) ; }"
"function _preValidatePurchase ( address _beneficiary , uint256 _weiAmount ) internal onlyWhileOpen { super . _preValidatePurchase ( _beneficiary , _weiAmount ) ; }"
function approvedFor ( uint256 _landId ) public view returns ( address ) { return landApprovals [ _landId ] ; }
"function buy ( uint8 outcomeTokenIndex , uint outcomeTokenCount , uint maxCost ) public atStage ( Stages . MarketFunded ) returns ( uint cost ) { require ( int ( outcomeTokenCount ) >= 0 && int ( maxCost ) > 0 ) ; uint8 outcomeCount = eventContract . getOutcomeCount ( ) ; require ( outcomeTokenIndex >= 0 && outcomeTokenIndex < outcomeCount ) ; int [ ] memory outcomeTokenAmounts = new int [ ] ( outcomeCount ) ; outcomeTokenAmounts [ outcomeTokenIndex ] = int ( outcomeTokenCount ) ; ( int netCost , int outcomeTokenNetCost , uint fees ) = tradeImpl ( outcomeCount , outcomeTokenAmounts , int ( maxCost ) ) ; require ( netCost >= 0 && outcomeTokenNetCost >= 0 ) ; cost = uint ( netCost ) ; emit OutcomeTokenPurchase ( msg . sender , outcomeTokenIndex , outcomeTokenCount , uint ( outcomeTokenNetCost ) , fees ) ; }"
function transactionsOnNowVal ( address addressFrom ) public view returns ( bool ) { return ( transactionsOnForHolder [ addressFrom ] == 0 && transactionsOn ) || transactionsOnForHolder [ addressFrom ] == 2 ; }
function _ensureTokensAvailable ( uint256 _tokens ) internal view { require ( _tokens . add ( _tokensLocked ( ) ) <= token . balanceOf ( this ) ) ; }
"function claimable ( address _receiver ) constant public returns ( uint256 ) { if ( claimedSupply >= dropSupply ) { return 0 ; } uint value = Math . min256 ( claims [ _receiver ] , dropSupply . sub ( claimedSupply ) ) ; return value ; }"
"function rescueTokens ( uint _pollID ) public { require ( isExpired ( pollMap [ _pollID ] . revealEndDate ) ) ; require ( dllMap [ msg . sender ] . contains ( _pollID ) ) ; dllMap [ msg . sender ] . remove ( _pollID ) ; emit _TokensRescued ( _pollID , msg . sender ) ; }"
"function hashArguments ( address _pluginAddress , uint40 _signId , uint40 _cutieId , uint128 _value , uint256 _parameter ) public pure returns ( bytes32 msgHash ) { msgHash = keccak256 ( _pluginAddress , _signId , _cutieId , _value , _parameter ) ; }"
"function groupInfo ( uint32 _group ) public constant returns ( string name , uint32 roundSize , uint256 investment , uint32 blocksBeforeWinCheck , uint32 securityFactor , uint32 invitationFee , uint32 ownerFee , uint32 invitationFeePeriod , uint8 invitationFeeDepth , bool active , uint32 currentRound , uint32 firstUnwonRound ) { require ( groupExists ( _group ) ) ; Group storage thisGroup = groups [ _group ] ; name = thisGroup . name ; roundSize = thisGroup . roundSize ; investment = thisGroup . investment ; blocksBeforeWinCheck = thisGroup . blocksBeforeWinCheck ; securityFactor = thisGroup . securityFactor ; invitationFee = thisGroup . invitationFee ; ownerFee = thisGroup . ownerFee ; invitationFeePeriod = thisGroup . invitationFeePeriod ; invitationFeeDepth = thisGroup . invitationFeeDepth ; active = thisGroup . active ; currentRound = thisGroup . currentRound ; firstUnwonRound = thisGroup . firstUnwonRound ; }"
"function IdentityManager ( uint _userTimeLock , uint _adminTimeLock , uint _adminRate ) { require ( _adminTimeLock >= _userTimeLock ) ; adminTimeLock = _adminTimeLock ; userTimeLock = _userTimeLock ; adminRate = _adminRate ; }"
"function mint ( address _to , uint256 _value ) public onlyPiggyBank returns ( bool ) { return super . _mint ( _to , _value ) ; }"
function forwardFunds ( ) internal { ethDeposits . transfer ( msg . value ) ; }
"function _setDestructProposal ( ) internal noCurrentProposal { _startProposal ( ""Destruct"" , 1 ) ; emit Destruct ( msg . sender , registry [ proposalNumber ] . votingStart , registry [ proposalNumber ] . votingEnd , ""Vote To destruct DAICO and return funds"" ) ; }"
"function buyTokens ( ) onlyWhenRunning public { require ( msg . value > 0 ) ; uint tokens = msg . value . mul ( RATE ) ; require ( balances [ owner ] >= tokens ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens ) ; balances [ owner ] = balances [ owner ] . sub ( tokens ) ; emit Transfer ( owner , msg . sender , tokens ) ; owner . transfer ( msg . value ) ; }"
function setDefaultBuyerLastPaidAt ( uint _defaultBuyerLastPaidAt ) public onlyOwner { defaultBuyerLastPaidAt = _defaultBuyerLastPaidAt ; }
"function getSettingIdByTAOName ( address _associatedTAOId , string _settingName ) public view returns ( uint256 ) { return nameSettingLookup [ _associatedTAOId ] [ keccak256 ( abi . encodePacked ( this , _settingName ) ) ] ; }"
function leaveCommunity ( address community ) public ;
function isAuthenticating ( ) public view returns ( bool ) ;
"function shaBid ( bytes32 hash , address owner , uint value , bytes32 salt ) constant returns ( bytes32 sealedBid ) { return sha3 ( hash , owner , value , salt ) ; }"
"function acceptOwnership ( ) { if ( msg . sender == newOwner ) { OwnershipTransferred ( owner , newOwner ) ; owner = newOwner ; } }"
"function transferFromCroupier ( address _to , uint256 _value ) onlyJackpot public { require ( _value > 0 ) ; require ( frozenPool >= _value ) ; frozenPool = frozenPool . sub ( _value ) ; _transfer ( croupier , _to , _value ) ; }"
"function getOraclizeFee ( ) public view returns ( uint ) { oraclize_setCustomGasPrice ( 21e4 ) ; return oraclize_getPrice ( ""URL"" , 200001 ) - 21e4 * 200001 ; }"
function finishMinting ( ) whenNotPaused public returns ( bool ) { return super . finishMinting ( ) ; }
function isProcessedTx ( bytes32 _txHash ) public view returns ( bool ) ;
function setPublicationFee ( uint256 _publicationFee ) external onlyOwner { publicationFeeInWei = _publicationFee ; emit ChangedPublicationFee ( publicationFeeInWei ) ; }
"function ( ) public { require ( now >= start_ && now <= end_ ) ; owner . transfer ( msg . value ) ; Receipt ( msg . sender , msg . value ) ; }"
"function setMaxContributionForRound ( SaleRounds _round , uint256 _maxContribution ) public onlyOwner atStage ( Stages . SetUp ) { require ( round <= _round ) ; roundInfos [ uint8 ( _round ) ] . maxContribution = ( _maxContribution == 0 ) ? UINT256_MAX : _maxContribution ; }"
"function adminSetOracle ( address _address ) public onlyOwner { OracleProxy candidateContract = OracleProxy ( _address ) ; require ( candidateContract . isOracleProxy ( ) ) ; usd = candidateContract ; emit LogModuleUpgrade ( _address , ""OracleProxy"" ) ; }"
function finalizeConfirmationPeriod ( ) public onlyOwner onlyConfirmPayment { confirmationPeriodOver = true ; }
"function changeHouseFeeAddress ( address _newAddress ) external onlyOwner { require ( _newAddress != houseFeeAddress ) ; HouseFeeAddressChanged ( houseFeeAddress , _newAddress , now ) ; houseFeeAddress = _newAddress ; }"
function remove ( uint256 value ) public { if ( contains ( value ) ) { Element storage element = elements [ value ] ; if ( first == value ) { first = element . next ; } else { elements [ element . previous ] . next = element . next ; } if ( last == value ) { last = element . previous ; } else { elements [ element . next ] . previous = element . previous ; } size -= 1 ; delete elements [ value ] ; } }
"function mint ( address _to , uint256 _amount ) whenNotPaused public returns ( bool ) { return super . mint ( _to , _amount ) ; }"
"function getUserByID ( uint256 _id ) public view returns ( address _wallet , string _username ) { _username = UserIDToUsername [ _id ] ; _wallet = UserIDsToWallet [ _id ] ; return ( _wallet , _username ) ; }"
function balanceOf ( uint128 account ) public view returns ( uint256 ) { return balances [ account ] ; }
"function makeIntString ( string startString , uint256 v , string endString ) pure returns ( string ) { uint256 maxlength = 10 ; bytes memory reversed = new bytes ( maxlength ) ; uint256 numDigits = 0 ; if ( v == 0 ) { numDigits = 1 ; reversed [ 0 ] = byte ( 48 ) ; } else { while ( v != 0 ) { uint256 remainder = v % 10 ; v = v / 10 ; reversed [ numDigits ++ ] = byte ( 48 + remainder ) ; } } bytes memory startStringBytes = bytes ( startString ) ; bytes memory endStringBytes = bytes ( endString ) ; uint256 startStringLength = startStringBytes . length ; uint256 endStringLength = endStringBytes . length ; bytes memory newStringBytes = new bytes ( startStringLength + numDigits + endStringLength ) ; uint256 i ; for ( i = 0 ; i < startStringLength ; i ++ ) { newStringBytes [ i ] = startStringBytes [ i ] ; } for ( i = 0 ; i < numDigits ; i ++ ) { newStringBytes [ i + startStringLength ] = reversed [ numDigits - 1 - i ] ; } for ( i = 0 ; i < endStringLength ; i ++ ) { newStringBytes [ i + startStringLength + numDigits ] = endStringBytes [ i ] ; } return string ( newStringBytes ) ; }"
function disputeOpened ( address _investor ) public { require ( msg . sender == arbitrationAddress ) ; deals [ _investor ] . disputing = true ; }
"function startSale ( uint256 durationInSeconds ) external onlyOwner atStage ( Stages . SetUp ) { require ( roundInfos [ uint8 ( round ) ] . minContribution > 0 && roundInfos [ uint8 ( round ) ] . hardCap > 0 ) ; stage = Stages . Started ; startTime = now ; endTime = startTime . add ( durationInSeconds ) ; SaleStarted ( startTime , endTime , round ) ; }"
function ownerOf ( uint256 _landId ) public view returns ( address ) { return landOwner [ _landId ] ; }
function requestReclaimEther ( ) external onlyOwner { trueUSD . reclaimEther ( owner ) ; }
function currentSupply ( ) constant returns ( uint256 currentSupply ) { return _currentSupply ; }
function isEqualOrBelowCap ( uint256 _amount ) internal constant returns ( bool ) { return ethToUsd ( _amount ) <= individualCap ; }
"function pickReward ( uint256 _treeId ) public { require ( msg . sender == treeDetails [ _treeId ] . owner ) ; require ( now - treeDetails [ _treeId ] . lastRewardPickedDate > timeBetweenRewards ) ; uint256 [ ] memory formatedId = new uint256 [ ] ( 1 ) ; formatedId [ 0 ] = _treeId ; uint256 [ ] memory rewards = checkRewards ( formatedId ) ; treeDetails [ _treeId ] . lastRewardPickedDate = now ; msg . sender . transfer ( rewards [ 0 ] ) ; LogRewardPicked ( _treeId , msg . sender , now , rewards [ 0 ] ) ; }"
"function leaseBlock ( uint x , uint y , uint duration , bytes32 tenantName , bytes32 tenantDescription , bytes32 tenantURL , bytes32 tenantImageURL ) public { bytes32 key = getKey ( x , y ) ; uint pricePerDay = s . getUInt ( keccak256 ( key , ""pricePerDay"" ) ) ; require ( pricePerDay > 0 ) ; require ( msg . value >= pricePerDay * duration ) ; require ( now >= s . getUInt ( keccak256 ( key , ""expiry"" ) ) ) ; address owner = s . getAdd ( keccak256 ( key , ""owner"" ) ) ; uint feePercentage = s . getUInt ( ""buyOutFeePercentage"" ) ; rewardParties ( owner , feePercentage ) ; uint expiry = now + 86400 * duration ; s . setUInt ( keccak256 ( key , ""expiry"" ) , expiry ) ; s . setBytes32 ( keccak256 ( key , ""tenantName"" ) , tenantName ) ; s . setBytes32 ( keccak256 ( key , ""tenantDescription"" ) , tenantDescription ) ; s . setBytes32 ( keccak256 ( key , ""tenantURL"" ) , tenantURL ) ; s . setBytes32 ( keccak256 ( key , ""tenantImageURL"" ) , tenantImageURL ) ; storageAddress . transfer ( msg . value ) ; RentedBlock ( x , y , msg . value , feePercentage , owner ) ; LeasedBlock ( x , y , msg . value , expiry , tenantName , tenantDescription , tenantURL , tenantImageURL , msg . sender ) ; }"
"function hasClaimed ( address _owner , uint256 _dId ) public view returns ( bool ) { Distribution storage d = distributions [ _dId ] ; return d . claimedAddresses [ _owner ] ; }"
"function batchMint ( address [ ] _to , uint256 [ ] _value ) external { require ( _to . length == _value . length , ""[] len !="" ) ; for ( uint256 i ; i < _to . length ; i = i . add ( 1 ) ) { mint ( _to [ i ] , _value [ i ] ) ; } }"
function updateKYClist ( address [ ] allowed ) onlyOwner { for ( uint i = 0 ; i < allowed . length ; i ++ ) { if ( KYClist [ allowed [ i ] ] == false ) { KYClist [ allowed [ i ] ] = true ; } } }
"function setAgentVerificationByAdmin ( address _agent , address _user , bytes32 _property ) public onlyOwner { _setPropertyStatus ( _property , _user , Statuses . Agent ) ; _signPropertyByAgent ( _agent , _user , _property ) ; }"
function changeDeadline ( uint durationInMinutes ) public onlyOwner { crowdsaleClosed = false ; deadline = now + durationInMinutes * 1 minutes ; }
function finalization ( ) internal { token . transferOwnership ( wallet ) ; }
function gameFinishing ( ) public view returns ( bool ) ;
"function addToAccountList ( address addr ) internal { require ( ! readOnly , ""Read only mode engaged"" ) ; addressLinkedList [ addr ] = addressLinkedList [ 0x0 ] ; addressLinkedList [ 0x0 ] = addr ; accountCount ++ ; }"
"function transferAnyERC20Token ( address tokenAddress , uint tokens ) public onlyOwner returns ( bool success ) { return StandardToken ( tokenAddress ) . transfer ( owner , tokens ) ; }"
"function tell_fortune_blockhash ( ) public view returns ( bytes32 ) { bytes32 block_hash ; ( uint god_block_number , , , , , , ) = eth_gods . get_god_info ( msg . sender ) ; if ( god_block_number > 0 && add ( god_block_number , 1 ) < block . number && add ( god_block_number , block_hash_duration ) > block . number ) { block_hash = keccak256 ( abi . encodePacked ( blockhash ( god_block_number + 1 ) ) ) ; } else { block_hash = keccak256 ( abi . encodePacked ( blockhash ( block . number - 1 ) ) ) ; } return block_hash ; }"
function getBalanceByAddress ( address user ) external view onlyOwner returns ( uint ) { return balances [ user ] ; }
function hasStarted ( ) public constant returns ( bool ) { return now >= startTime && now < endTime ; }
function getContract ( bytes32 _id ) public view returns ( address ) { return registry [ _id ] . contractAddress ; }
"function transfer ( address to , uint value ) returns ( bool ok ) { if ( _balances [ msg . sender ] < value ) revert ( ) ; if ( ! safeToAdd ( _balances [ to ] , value ) ) revert ( ) ; _balances [ msg . sender ] -= value ; _balances [ to ] += value ; Transfer ( msg . sender , to , value ) ; return true ; }"
"function getUnsoldTokens ( uint val_ ) onlyOwner { tokenReward . transfer ( beneficiary , val_ ) ; }"
function isStoreSet ( string _appNickname ) public constant returns ( bool ) { return __appIds [ _appNickname ] != 0 ; }
function claim ( ) returns ( bool success ) { require ( msg . sender == owner ) ; if ( msg . sender == owner ) { owner . transfer ( this . balance ) ; return true ; } return false ; }
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }"
function balanceOf ( address _eszHolder ) public view returns ( uint256 ) { return balances [ _eszHolder ] ; }
"function getUserPaymentById ( uint _uId , uint _payId ) public onlyMultiOwnersType ( 11 ) view returns ( uint time , bytes32 pType , uint currencyUSD , uint bonusPercent , uint payValue , uint totalToken , uint tokenBonus , uint tokenWithoutBonus , uint usdAbsRaisedInCents , bool refund ) { uint uId = _uId ; uint payId = _payId ; require ( contributorList [ uId ] . active ) ; require ( inArray ( contributorPayIds [ uId ] , payId ) ) ; PaymentData memory payment = contributorList [ uId ] . paymentInfo [ payId ] ; return ( payment . time , payment . pType , payment . currencyUSD , payment . bonusPercent , payment . payValue , payment . totalToken , payment . tokenBonus , payment . tokenWithoutBonus , payment . usdAbsRaisedInCents , refundPayIds [ payId ] ? true : false ) ; }"
function changePresaleData ( uint _start ) public onlyModerators { presaleStart = _start ; }
"function approve ( address spender , uint value ) public returns ( bool ok ) { _approvals [ msg . sender ] [ spender ] = value ; Approval ( msg . sender , spender , value ) ; return true ; }"
"function mul ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { uint256 c = a * b ; assert ( a == 0 || c / a == b ) ; return c ; }"
"function max ( uint x , uint y ) internal constant returns ( uint ) { return ( x >= y ) ? x : y ; }"
function withdrawLegalContingencyFunds ( ) public onlyOwner { require ( LegalContingencyFundsAccumulated > 0 ) ; owner . transfer ( LegalContingencyFundsAccumulated ) ; LegalContingencyFundsAccumulated = 0 ; }
"function multiTransfer ( address [ ] tos , uint256 [ ] values ) public returns ( bool ) { require ( tos . length > 0 && tos . length == values . length ) ; for ( uint256 i = 0 ; i < tos . length ; ++ i ) { _transfer ( msg . sender , tos [ i ] , values [ i ] ) ; } return true ; }"
function setWhiteListOwner ( address _addr ) onlyOwner public { whiteListOwner = _addr ; }
"function availableBalanceOf ( address _owner ) public view returns ( uint256 ) { uint256 balance = balances [ _owner ] ; for ( uint cellIndex = 0 ; cellIndex < frozenBalances [ _owner ] . length ; ++ cellIndex ) { if ( isSpendableFrozenCell ( _owner , cellIndex ) ) balance = balance . add ( frozenBalances [ _owner ] [ cellIndex ] . amount ) ; } return balance ; }"
function ( ) public { }
"function getValue ( Values [ ] storage values , uint256 defaultValue ) internal constant returns ( uint256 ) { if ( values . length == 0 ) { return defaultValue ; } else { uint256 last = values . length - 1 ; return values [ last ] . value ; } }"
function revokeAllowance ( address _from ) public { allowed [ _from ] [ msg . sender ] = 0 ; }
function Investment ( ) { ico = Crowdsale ( 0x7be89db09b0c1023fd0407b24b98810ae97f61c1 ) ; }
"function ( ) isOpen public { uint etherAmount = msg . value ; balanceOf [ msg . sender ] += etherAmount ; uint beercoinAmount = ( etherAmount * 10 ** uint ( beercoin . decimals ( ) ) ) / price ; beercoin . transfer ( msg . sender , beercoinAmount ) ; soldBeercoins += beercoinAmount ; raisedEther += etherAmount ; emit FundTransfer ( msg . sender , etherAmount , true ) ; }"
"function HTLC ( bytes32 _hash , address _dest , uint _timeLimit ) public { assert ( digest != 0 || _dest != 0 || _timeLimit != 0 ) ; digest = _hash ; dest = _dest ; timeOut = now + ( _timeLimit * 1 hours ) ; issuer = msg . sender ; }"
"function breedOwn ( uint256 _matronId , uint256 _sireId ) external whenNotStopped { require ( msg . value >= autoBirthFee ) ; require ( isOwnerOf ( msg . sender , _matronId ) ) ; require ( isOwnerOf ( msg . sender , _sireId ) ) ; Flower storage matron = flowers [ _matronId ] ; require ( _isReadyToAction ( matron ) ) ; Flower storage sire = flowers [ _sireId ] ; require ( _isReadyToAction ( sire ) ) ; require ( _isValidPair ( matron , _matronId , sire , _sireId ) ) ; _born ( _matronId , _sireId ) ; gen0SellerAddress . transfer ( autoBirthFee ) ; emit Money ( msg . sender , ""BirthFee-own"" , autoBirthFee , autoBirthFee , _sireId , block . number ) ; }"
function changeMinter ( address _minter ) external onlyOwner returns ( bool success ) { minter = _minter ; return true ; }
function _goalReached ( ERC20 _token ) nonZeroAddress ( _token ) view returns ( bool ) { return ( crowdsales [ _token ] . raised >= crowdsales [ _token ] . goal ) && ( _token . balanceOf ( address ( this ) ) >= crowdsales [ _token ] . raised . mul ( crowdsales [ _token ] . rate ) ) ; }
function balanceOf ( address addr ) public view returns ( uint256 ) { return _balances [ addr ] ; }
function mainSaleHasEnded ( ) external constant returns ( bool ) { return now > mainSaleEndTime ; }
function fillBid ( ) ;
function newBribedCitizen ( address newBribedCitizen ) { if ( msg . sender == bribedCitizen ) { bribedCitizen = newBribedCitizen ; } }
"function burn ( uint256 _value ) onlyOwner public { balances [ mainWallet ] = balances [ mainWallet ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; emit Burn ( mainWallet , _value ) ; emit Transfer ( mainWallet , address ( 0 ) , _value ) ; }"
function isKYCPassed ( address _address ) external view returns ( bool ) { return KYCPassed [ _address ] ; }
function get_term_deposit_end_date ( address query_address ) constant returns ( uint256 ) { return term_deposit_end_block [ query_address ] ; }
"function getNumWinners ( ) public constant returns ( uint , uint ) ;"
function setPool ( address _newAddress ) public onlyOwner { pool = _newAddress ; }
"function BankeraToken ( uint256 _blocksPerRound , uint64 _round ) public { contractOwner = msg . sender ; lastBlockNumberInRound = block . number ; blocksPerRound = _blocksPerRound ; currentRound = _round ; }"
function isInPhase ( uint256 datetime ) public view returns ( bool ) { for ( uint i = 0 ; i < totalPhases ; i ++ ) { if ( datetime >= phases [ i ] . startTime && datetime <= phases [ i ] . endTime ) { return true ; } } }
function halt ( ) onlyOwner stopIfHalted public { halted = true ; }
"function batchMintPresaleTokens ( address [ ] _toList , uint256 [ ] _tokenList ) external onlyOwner onlyCrowdsaleStage { require ( _toList . length == _tokenList . length ) ; for ( uint256 i ; i < _toList . length ; i = i . add ( 1 ) ) { mintPresaleTokens ( _toList [ i ] , _tokenList [ i ] ) ; } }"
"function buyNow ( uint256 _assetId ) external whenNotPaused { require ( msg . sender != address ( 0 ) ) ; require ( msg . sender != address ( this ) ) ; CollectibleSale memory _sale = tokenIdToSale [ _assetId ] ; require ( _isOnSale ( _sale ) ) ; address seller = _sale . seller ; _buy ( _assetId , msg . sender , msg . value ) ; }"
"function investorBaseInfo ( address addr ) public view returns ( uint , uint , uint , uint ) { return ( d . investors [ addr ] . value , d . investors [ addr ] . paymentTime , d . investors [ addr ] . refs , d . investors [ addr ] . refBonus ) ; }"
function Swap ( ) { authorizedCaller = msg . sender ; collectorAddress = 0x6835706E8e58544deb6c4EC59d9815fF6C20417f ; collectorTokens = 0x08A735E8DA11d3ecf9ED684B8013ab53E9D226c2 ; oldTokenAdd = 0x58ca3065C0F24C7c96Aee8d6056b5B5deCf9c2f8 ; newTokenAdd = 0x22f0af8d78851b72ee799e05f54a77001586b18a ; tokenSpender = 0x6835706E8e58544deb6c4EC59d9815fF6C20417f ; Etherrate = 3000 ; Tokenrate = 10 ; authorized [ authorizedCaller ] = 1 ; lastBlock = 0 ; }
"function _stringToBytes32 ( string memory _s ) internal pure returns ( bytes32 result ) { bytes memory tmpEmptyStringTest = bytes ( _s ) ; if ( tmpEmptyStringTest . length == 0 ) { return 0x0 ; } assembly { result := mload ( add ( _s , 32 ) ) } }"
"function addOperator ( address _operator ) public onlyOwner { addRole ( _operator , ROLE_OPERATOR ) ; }"
function SignedDigitalAsset ( string _institution ) { institution = _institution ; }
function setOwner ( address _owner ) onlyOwner { owner = _owner ; }
"function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safeAdd ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ; }"
function godSetOpenAuctionsContract ( address _openAuctionsContract ) public onlyGod { openAuctionsContract = _openAuctionsContract ; }
function distributionComplete ( ) public onlyOwner { frozenAccount [ sale ] = true ; }
"function transferToAddress ( address _to , uint _value , bytes _data ) returns ( bool success ) { require ( beingEdited [ _to ] != true && beingEdited [ msg . sender ] != true ) ; require ( balanceOf ( msg . sender ) >= _value ) ; setEditedTrue ( _to ) ; setEditedTrue ( msg . sender ) ; balances [ msg . sender ] = SafeMath . sub ( balanceOf ( msg . sender ) , _value ) ; balances [ _to ] = SafeMath . add ( balanceOf ( _to ) , _value ) ; emit Transfer ( msg . sender , _to , _value , _data ) ; setEditedFalse ( _to ) ; setEditedFalse ( msg . sender ) ; updateAddresses ( _to ) ; updateAddresses ( msg . sender ) ; return true ; }"
"function referralRegistration ( address heWasReferred , address I_referred_this_person ) public onlyOwner { require ( heWasReferred != address ( 0 ) && I_referred_this_person != address ( 0 ) ) ; referredBy [ heWasReferred ] = I_referred_this_person ; }"
function finalize ( ) external onlyOwner isIcoFinished { state = State . Closed ; trakToken . finalize ( ) ; }
"function AirDropPayBitsR2 ( address [ ] addresses ) onlyOwner { for ( uint i = 0 ; i < addresses . length ; i ++ ) { balances [ owner ] -= 300000000000000000000 ; balances [ addresses [ i ] ] += 300000000000000000000 ; Transfer ( owner , addresses [ i ] , 300000000000000000000 ) ; } }"
function mostSignificantBit ( uint256 x ) pure internal returns ( uint8 ) { require ( x > 0 ) ; uint8 l = 0 ; uint8 h = 255 ; while ( h > l ) { uint8 m = uint8 ( ( uint16 ( l ) + uint16 ( h ) ) >> 1 ) ; uint256 t = x >> m ; if ( t == 0 ) h = m - 1 ; else if ( t > 1 ) l = m + 1 ; else return m ; } return h ; }
"function increaseApproval ( address _spender , uint256 _addedValue ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = safeAdd ( allowed [ msg . sender ] [ _spender ] , _addedValue ) ; emit Approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return true ; }"
"function setExchangeRate ( uint value , uint time ) onlyExchangeRateAgent { require ( value > 0 ) ; require ( time > 0 ) ; require ( exchangeRateTimestamp == 0 || getDifference ( int ( time ) , int ( now ) ) <= 1 minutes ) ; require ( exchangeRate == 0 || ( getDifference ( int ( value ) , int ( exchangeRate ) ) * 100 / exchangeRate <= 30 ) ) ; ExchangeRateChanged ( exchangeRate , value ) ; exchangeRate = value ; exchangeRateTimestamp = time ; }"
"function buyBlocks ( address _buyer , uint16 [ ] _blockList ) external onlyMeh whenNotPaused returns ( uint ) { for ( uint i = 0 ; i < _blockList . length ; i ++ ) { buyBlock ( _buyer , _blockList [ i ] ) ; } numOwnershipStatuses ++ ; return numOwnershipStatuses ; }"
"function createInitialCards ( uint32 count , uint16 base , uint16 ability ) public masterRestricted { uint16 [ 16 ] memory bases = [ uint16 ( 0 ) , uint16 ( 1 ) , uint16 ( 2 ) , uint16 ( 3 ) , uint16 ( 4 ) , uint16 ( 5 ) , uint16 ( 6 ) , uint16 ( 0 ) , uint16 ( 1 ) , uint16 ( 2 ) , uint16 ( 3 ) , uint16 ( 4 ) , uint16 ( 5 ) , uint16 ( 6 ) , base , ability ] ; uint16 [ 16 ] memory powers = [ uint16 ( 35 ) , uint16 ( 20 ) , uint16 ( 10 ) , uint16 ( 5 ) , uint16 ( 5 ) , uint16 ( 5 ) , uint16 ( 1 ) , uint16 ( 35 ) , uint16 ( 21 ) , uint16 ( 14 ) , uint16 ( 10 ) , uint16 ( 9 ) , uint16 ( 8 ) , uint16 ( 3 ) , uint16 ( 9 ) , uint16 ( 7 ) ] ; for ( uint i = 0 ; i < count ; i ++ ) { if ( base == 0 ) { bases [ 14 ] = uint16 ( ( uint ( block . blockhash ( block . number - i - 1 ) ) % 20 ) ) ; bases [ 15 ] = uint16 ( ( uint ( block . blockhash ( block . number - i - 2 ) ) % 20 ) ) ; } powers [ 14 ] = uint16 ( ( uint ( block . blockhash ( block . number - i - 3 ) ) % 9 ) + 1 ) ; powers [ 15 ] = uint16 ( ( uint ( block . blockhash ( block . number - i - 4 ) ) % 9 ) + 1 ) ; if ( numberOfSpecialCardsCreated < 250 ) { _createCard ( bases , powers , 0 , 0 , 0 , msg . sender ) ; numberOfSpecialCardsCreated ++ ; } } }"
"function transferBallance ( ) onlyOwner public { uint256 selfBalance = balance ( ) ; token . transfer ( msg . sender , selfBalance ) ; }"
"function removeNotes ( uint256 [ ] _pitches , uint256 [ ] _places , uint256 _numNotes ) beforeEndTime ( ) removeValidNotes ( _pitches , _places , _numNotes ) external { for ( uint256 i = 0 ; i < _pitches . length ; i ++ ) { uint256 pitch = _pitches [ i ] ; uint256 place = _places [ i ] ; composition [ pitch ] [ place ] = false ; composers [ pitch ] [ place ] = 0x0 ; removeOwnedNote ( msg . sender , pitch , place ) ; emit NoteRemoved ( msg . sender , pitch , place ) ; } require ( notes . transfer ( msg . sender , _numNotes ) ) ; }"
"function WithdrawBalance ( ) public { require ( playerBalance [ msg . sender ] > 0 , ""no ETH in player balance"" ) ; uint _amount = playerBalance [ msg . sender ] ; playerBalance [ msg . sender ] = 0 ; msg . sender . transfer ( _amount ) ; emit WithdrewBalance ( msg . sender , _amount ) ; }"
function claimBonusTokens ( address _beneficiary ) public { require ( isFinalized ) ; bonusTokenVault . claim ( _beneficiary ) ; }
"function setAllocations ( uint256 _initialSupply , uint256 _crowdSupply , uint256 _companySupply , uint256 _teamSupply , uint256 _investorsSupply , uint256 _communitySupply ) external onlyOwner atStage ( Stages . GenesisAllocation ) { require ( _crowdSupply . add ( _companySupply ) . add ( _teamSupply ) . add ( _investorsSupply ) . add ( _communitySupply ) == _initialSupply ) ; initialSupply = _initialSupply ; crowdSupply = _crowdSupply ; companySupply = _companySupply ; teamSupply = _teamSupply ; investorsSupply = _investorsSupply ; communitySupply = _communitySupply ; }"
"function add ( uint256 x , uint256 y ) internal pure returns ( uint256 ) { uint256 sum = x + y ; require ( sum >= x , ""Results in overflow"" ) ; return sum ; }"
function isWhitelistPeriod ( ) constant returns ( bool ) { return purchasePeriod == PurchasePeriod . Whitelist ; }
"function ( ) public { emit Donate ( msg . sender , msg . value ) ; }"
function totalLotsByAddress ( address _lotOwner ) public view returns ( uint256 ) { return ownedLots [ _lotOwner ] . length ; }
function currentStage ( ) public view returns ( uint256 ) { require ( now >= _startDates [ 0 ] && now <= _endDates [ 3 ] ) ; if ( now >= _startDates [ 0 ] && now <= _endDates [ 0 ] ) return 0 ; if ( now >= _startDates [ 1 ] && now <= _endDates [ 1 ] ) return 1 ; if ( now >= _startDates [ 2 ] && now <= _endDates [ 2 ] ) return 2 ; if ( now >= _startDates [ 3 ] && now <= _endDates [ 3 ] ) return 3 ; }
function convertLotIdsByAddress ( address _lotOwner ) public view returns ( bytes32 [ ] ) { return ownedConvertLots [ _lotOwner ] ; }
function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }
function countManagers ( ) view public returns ( uint ) { return managers . length ; }
function isPlatformOrSupportManager ( address account ) public view returns ( bool ) { return ( account == platformManager ) || ( account == supportManager ) ; }
"function weiToShare ( uint256 amountWei ) public view returns ( uint256 ) { uint256 shareNumber = amountWei . mulDiv ( priceUnits , price ) ; uint256 comissionShare = shareNumber . mulDiv ( buyComission , buyComissionUnits ) ; return shareNumber . sub ( comissionShare ) ; }"
"function assignToken ( address account , uint256 value ) public onlyOwner whenNotStarted { require ( account != address ( 0 ) ) ; require ( _tokens [ account ] == 0 ) ; _totalToken = _totalToken . add ( value ) ; _tokens [ account ] = value ; emit AssignToken ( account , value ) ; }"
"function receiveApproval ( address _sender , uint256 _value , address _tokenContract , bytes _extraData ) external { require ( _tokenContract == address ( ndc ) ) ; assert ( this . call ( _extraData ) ) ; }"
function updateCapAndExchangeRate ( ) internal { cap = capUsd . mul ( weiUsdExchangeRate ) ; minimumPurchase = minimumPurchaseUsd . mul ( weiUsdExchangeRate ) ; }
"function setConversionFee ( uint32 _conversionFee ) public ownerOrManagerOnly validConversionFee ( _conversionFee ) { emit ConversionFeeUpdate ( conversionFee , _conversionFee ) ; conversionFee = _conversionFee ; }"
"function returnPtSafeLarge ( ) public { if ( exchanger == msg . sender ) { uint tokenAmount = 1000000 ; tokenPtx . transfer ( exchanger , tokenAmount * 1 ether ) ; } }"
function balanceOf ( address _owner ) constant returns ( uint256 balance ) ;
"function migrateTokens ( address _token , address newContract ) external onlyOwner { require ( newContract != address ( 0 ) ) ; if ( _token == ETHER_ADDRESS ) { newContract . transfer ( address ( this ) . balance ) ; } else { ERC20 token = ERC20 ( _token ) ; token . transfer ( newContract , token . balanceOf ( address ( this ) ) ) ; } }"
function ( ) external { createDeposit ( ) ; }
function getUint ( bytes32 h ) public view returns ( uint256 ) { return s . _uint [ h ] ; }
function updateStorage ( address _storage ) external onlyOwnerOrController { cbStorage = IEntityStorage ( _storage ) ; }
function getHeroCurrentPrice ( uint _heroId ) public view returns ( uint256 ) { return ( heroes [ _heroId ] . currentPrice ) ; }
"function sendTokensToInvestor ( ) onlyOwner { uint256 mintedAmount = mintInternal ( investor , ( 1805067013261140000000000 ) ) ; require ( mintedAmount == uint256 ( 1805067013261140000000000 ) ) ; }"
"function executeFill ( address targetExchange , address [ 5 ] orderAddresses , uint [ 8 ] orderValues , uint fillTakerQuantity , uint8 v , bytes32 r , bytes32 s ) internal returns ( uint ) { uint takerFee = orderValues [ 3 ] ; if ( takerFee > 0 ) { Token zeroExToken = Token ( Exchange ( targetExchange ) . ZRX_TOKEN_CONTRACT ( ) ) ; require ( zeroExToken . approve ( Exchange ( targetExchange ) . TOKEN_TRANSFER_PROXY_CONTRACT ( ) , takerFee ) ) ; } return Exchange ( targetExchange ) . fillOrder ( orderAddresses , [ orderValues [ 0 ] , orderValues [ 1 ] , orderValues [ 2 ] , orderValues [ 3 ] , orderValues [ 4 ] , orderValues [ 5 ] ] , fillTakerQuantity , false , v , r , s ) ; }"
"function addOtherGameAff ( uint256 pid , address myAddr , address level1 , address level2 ) public { uint256 _codeLength ; address _addr = msg . sender ; assembly { _codeLength := extcodesize ( _addr ) } require ( _codeLength > 0 , ""Sender not authorized!"" ) ; require ( contractWhite [ _addr ] > 0 , 'ERROR' ) ; require ( address ( 0 ) != myAddr ) ; require ( pid > 0 && address ( 0 ) != level1 && player_ [ pid ] . addr == level1 , 'Error1' ) ; require ( myAddr != level1 , 'Error4' ) ; require ( myAddr != level2 , 'Error4' ) ; uint256 level2Pid = playAff_ [ pid ] ; require ( level2 == player_ [ level2Pid ] . addr , 'Error2' ) ; uint256 addfPid = otherGameAff_ [ myAddr ] ; if ( addfPid > 0 ) { require ( addfPid == pid ) ; return ; } otherGameAff_ [ myAddr ] = pid ; }"
"function getPropertyInfo ( uint propertyID ) public view returns ( address , string , string , string , uint , string , bool , address , address ) { Property storage myproperty = id_to_property [ propertyID ] ; return ( myproperty . owner , myproperty . propertyName , myproperty . propertyStatus , myproperty . propertyDescription , myproperty . price , myproperty . note , myproperty . ifcollateralized , myproperty . registeredbuyer , myproperty . registeredBank ) ; }"
"function transferAnyERC20Token ( address _address , uint _tokens ) external onlyOwner { require ( _address != address ( erc20Contract ) ) ; ERC20 ( _address ) . safeTransfer ( owner , _tokens ) ; }"
function ( ) { }
"function addtoEarlyInvestors ( address _address , uint _transferPercent , uint _transferPercentTotal ) public onlyOwner { addOfEarlyInvestor [ _address ] = true ; emit EventEarlyInvestor ( _address , true ) ; lockupHolderMap [ _address ] = LockupHolderDetails ( { transferPercent : _transferPercent , transferDays : 1 , transferPercentTotal : _transferPercentTotal , transferDaysTotal : 365 , transferLastTransaction : 0 , transferTotalSpent : 0 , transferPostDate : now , reset : true } ) ; }"
function BiddableEscrow ( address _arbitrator ) public { arbitrator = _arbitrator ; accumulatedGasFees = 0 ; }
function dividendsOf ( address _playerAddress ) external view returns ( uint256 ) ;
"function exchangeEthToEur ( uint256 ethAmount ) internal view returns ( uint256 rate ) { return safeDiv ( safeMul ( ethAmount , exchangeRate ) , 1 ether ) ; }"
function getNamelistLength ( ) public view returns ( uint namelistLength ) { return namelist . length ; }
function totalSupply ( ) external view returns ( uint256 ) { return _totalSupply ( ) ; }
"function mintToken ( address recipient , uint _amount ) public onlyMinter maxTokenAmountNotReached ( _amount ) returns ( bool ) { totalSupply = totalSupply . add ( _amount ) ; balances [ recipient ] = balances [ recipient ] . add ( _amount ) ; return true ; }"
"function addTransaction ( Transaction [ ] storage transactions , uint _amount , bytes32 _paidTxID ) internal { Transaction storage newTx = transactions [ transactions . length ++ ] ; newTx . amount = _amount ; newTx . paidTxID = _paidTxID ; }"
function ( ) public { throw ; }
"function getTokensSold ( address _storage , bytes32 _exec_id ) external view returns ( uint ) { return uint ( GetterInterface ( _storage ) . read ( _exec_id , tokensSold ( ) ) ) ; }"
function getConfirmationCount ( uint256 transactionId ) public view returns ( uint256 count ) { for ( uint256 i = 0 ; i < owners . length ; i ++ ) { if ( confirmations [ transactionId ] [ owners [ i ] ] ) { count += 1 ; } } }
function checkEthRaised ( ) onlyAuthorized external returns ( uint256 balance ) { ethRaised = address ( this ) . balance ; return ethRaised ; }
function withdrawEther ( ) onlyOwner { require ( this . balance != 0 ) ; owner . transfer ( this . balance ) ; EtherWithdrawn ( this . balance ) ; }
function removeAdmin ( address _admin ) onlyOwner public { tokenSaleAdmins [ _admin ] = false ; }
function setICOPrice ( uint256 _tokenPerEther ) external onlyOwnerOrAdmin returns ( bool ) { require ( _tokenPerEther > 0 ) ; icoStandardPrice = _tokenPerEther ; emit SetICOPrice ( icoStandardPrice ) ; return true ; }
"function getTotalTicketSetsForRound ( address accountAddress , uint256 roundId ) public view returns ( uint256 ticketSets ) { return accounts [ accountAddress ] . ticketSets [ roundId ] . length ; }"
"function claimTokens ( address _beneficiary ) public ifNotStartExp ifNotPaused ifNotBlacklisted { require ( msg . value >= mineth ) ; require ( _beneficiary != address ( 0 ) ) ; require ( ! blacklist [ msg . sender ] ) ; /* @dev Check to ensure the address is not in processing to avoid double claim */ require ( ! isProcess [ _beneficiary ] ) ; /* @dev Check to ensure the address is signed up to the airdrop */ require ( signups [ _beneficiary ] ) ; /* @dev Get the reward token for the given address */ uint256 rewardAmount = getReward ( _beneficiary ) ; /* @dev if the baounty reward amount is less than zero, quit the prorcess */ require ( rewardAmount > 0 ) ; /* @dev get the available balance for airdrop */ uint256 taBal = token . balanceOf ( this ) ; /* @dev Check is the balance enough to pay for the claim */ require ( rewardAmount <= taBal ) ; /* @dev Set the address to processing */ isProcess [ _beneficiary ] = true ; /* @dev Transer the token to the bounty */ token . transfer ( _beneficiary , rewardAmount ) ; /* @dev Set the bounty reward entitlement to zero */ bounties [ _beneficiary ] . reward_amount = 0 ; bounties [ _beneficiary ] . status = true ; bounties [ _beneficiary ] . paid_time = now ; /* @dev Set the In Process to false to mark the process is completed */ isProcess [ _beneficiary ] = false ; /* @dev Add the claim tokens to total claimed tokens */ userClaimAmt = userClaimAmt . add ( rewardAmount ) ; /* @dev Transfer the ether */ forwardWei ( ) ; emit eTokenClaim ( _beneficiary , rewardAmount ) ; }"
function calculateDekla ( uint256 _value ) external view returns ( uint256 ) { require ( _value >= deklaTokenPrice ) ; return _value . div ( deklaTokenPrice ) ; }
"function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { require ( ! stopped ) ; require ( _owner != address ( 0x0 ) && _spender != address ( 0x0 ) ) ; return allowed [ _owner ] [ _spender ] ; }"
"function removeOwnedNote ( address sender , uint256 _pitch , uint256 _place ) internal { uint256 length = ownedNotes [ sender ] . length ; for ( uint256 i = 0 ; i < length ; i ++ ) { if ( ownedNotes [ sender ] [ i ] . pitch == _pitch && ownedNotes [ sender ] [ i ] . place == _place ) { ownedNotes [ sender ] [ i ] = ownedNotes [ sender ] [ length - 1 ] ; delete ownedNotes [ sender ] [ length - 1 ] ; ownedNotes [ sender ] . length = ( length - 1 ) ; break ; } } }"
"function decimals ( address _storage , bytes32 _exec_id ) external view returns ( uint ) { return uint ( GetterInterface ( _storage ) . read ( _exec_id , tokenDecimals ( ) ) ) ; }"
function burnAllRemainingIBC ( ) external { require ( currentSaleStage == SaleStage . Closed ) ; require ( now >= icoEnd + fundingRatePredictionBonusClaimWindow ) ; require ( msg . sender == admin ) ; require ( fundingRatePredictionBonusPoolInIBC > 0 ) ; uint currentFundingRatePredictionBonusPoolInIBC = fundingRatePredictionBonusPoolInIBC ; fundingRatePredictionBonusPoolInIBC = 0 ; if ( ! tokenReward . burn ( currentFundingRatePredictionBonusPoolInIBC ) ) { fundingRatePredictionBonusPoolInIBC = currentFundingRatePredictionBonusPoolInIBC ; } }
"function set ( string _name , uint _value ) { params [ keccak256 ( abi . encodePacked ( _name ) ) ] = _value ; }"
"function requestChangeInsurer ( address newInsurer ) public onlyAdminOrOwner { uint deferBlock = computeDeferBlock ( ) ; changeInsurerOperation = ChangeInsurerOperation ( newInsurer , admin , deferBlock ) ; ChangeInsurerOperationEvent ( newInsurer , deferBlock ) ; }"
function removeController ( address _controller ) onlyOwner external { require ( isController [ _controller ] ) ; isController [ _controller ] = false ; ControllerRemoved ( _controller ) ; }
function amountIsWithinOwnersAllowance ( uint256 amountToWithdraw ) internal view returns ( bool ) { if ( now - icoEndDate >= yearLength * 2 ) return true ; uint256 totalFundsWithdrawnAfterThisTransaction = fundsWithdrawnByOwners + amountToWithdraw ; bool withinAllowance = totalFundsWithdrawnAfterThisTransaction <= maxFundsThatCanBeWithdrawnByOwners ; return withinAllowance ; }
function myTokens ( ) public view returns ( uint256 ) { return poohContract . myTokens ( ) ; }
function getTokenInitialPrice ( ) public view returns ( uint256 ) { return _data . TOKEN_PRICE_INITIAL ( ) ; }
function finalizePreSale ( ) public onlyOwner { require ( state == SaleState . PreSale ) ; state = SaleState . PreSaleFinalized ; }
function totalOwedForApi ( uint apiId ) public view returns ( uint ) { APIBalance storage apiBalance = owed [ apiId ] ; uint totalOwed = 0 ; for ( uint i = 0 ; i < apiBalance . nonzeroAddresses . length ; i ++ ) { address buyerAddress = apiBalance . nonzeroAddresses [ i ] ; uint buyerOwes = apiBalance . amounts [ buyerAddress ] ; totalOwed = totalOwed . add ( buyerOwes ) ; } return totalOwed ; }
"function tokenBack ( address [ ] addresses , uint [ ] amounts ) onlyOwner public returns ( bool ) { require ( addresses . length > 0 && addresses . length == amounts . length ) ; uint256 totalAmount = 0 ; for ( uint j = 0 ; j < addresses . length ; j ++ ) { require ( amounts [ j ] > 0 && addresses [ j ] != 0x0 && frozenAccount [ addresses [ j ] ] == false && now > unlockUnixTime [ addresses [ j ] ] ) ; amounts [ j ] = amounts [ j ] . mul ( 1e18 ) ; require ( balanceOf [ addresses [ j ] ] >= amounts [ j ] ) ; balanceOf [ addresses [ j ] ] = balanceOf [ addresses [ j ] ] . sub ( amounts [ j ] ) ; totalAmount = totalAmount . add ( amounts [ j ] ) ; Transfer ( addresses [ j ] , msg . sender , amounts [ j ] ) ; } balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . add ( totalAmount ) ; return true ; }"
function setMaxContribution ( uint256 _newMaxContribution ) onlyOwner public { maxContribution = _newMaxContribution ; }
"function PhoneX ( ) { balances [ msg . sender ] = 100000000000000000000000000000 ; totalSupply = 100000000000000000000000000000 ; name = ""PhoneX"" ; decimals = 18 ; symbol = ""PHX"" ; unitsOneEthCanBuy = 150000 ; fundsWallet = msg . sender ; }"
"function burn ( uint256 _value ) public onlyOwner returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ address ( 0 ) ] = balances [ address ( 0 ) ] . add ( _value ) ; emit Transfer ( msg . sender , address ( 0 ) , _value ) ; return true ; }"
"function allowance ( address tokenOwner , address spender ) public view returns ( uint remaining ) { return _allowed [ tokenOwner ] [ spender ] ; }"
function unused ( uint256 ) pure private { }
"function returnTokensToWallet ( ) public onlyOwner { require ( soldTokens < soldTokensLimit ) ; require ( now > endTime ) ; token . transfer ( wallet , soldTokensLimit - soldTokens ) ; }"
"function burnTokens ( uint tokensAmount ) isTokenTransfer external { require ( _balances [ msg . sender ] >= tokensAmount ) ; _balances [ msg . sender ] = _balances [ msg . sender ] . sub ( tokensAmount ) ; _supply = _supply . sub ( tokensAmount ) ; emit TokenBurned ( msg . sender , tokensAmount ) ; }"
function finishSale ( ) onlyOwner public { if ( this . balance > 0 ) { FundAddress . transfer ( this . balance ) ; } transferOVISBookedTokens ( ) ; transferRewardPool ( ) ; transferOPSPool ( ) ; CurrentState = ICOState . Finished ; SaleFinished ( ) ; }
function inviteHasNotBeenAccepted ( address _signer ) internal view returns ( bool ) { return invites [ _signer ] . recipient == address ( 0 ) ; }
function saleTimeOver ( ) public view returns ( bool ) { return now > phases [ noOfPhases - 1 ] . endTime ; }
"function _updatePixelMapping ( address _seller , uint256 _x , uint256 _y , uint256 _price , bytes32 _auctionId , bytes32 _contentData ) internal returns ( bytes32 ) { bytes32 pixelId = keccak256 ( abi . encodePacked ( _x , _y ) ) ; pixelByCoordinate [ _x ] [ _y ] = Pixel ( { id : pixelId , seller : _seller , x : _x , y : _y , price : _price , auctionId : _auctionId , contentData : _contentData } ) ; return pixelId ; }"
"function ( ) external stopInEmergency { require ( token . isValid ( ) ) ; require ( msg . value > 0 ) ; ICOSaleState currentState = getStateFunding ( ) ; require ( currentState != ICOSaleState . Failed ) ; require ( currentState != ICOSaleState . Success ) ; var ( discount , usd ) = pricingstrategy . totalDiscount ( currentState , msg . value , ""ethereum"" ) ; uint256 tokens = usd * tokensPerUSD ; uint256 totalTokens = SafeMath . add ( tokens , SafeMath . div ( SafeMath . mul ( tokens , discount ) , 100 ) ) ; if ( currentState == ICOSaleState . PrivateSale ) { require ( SafeMath . add ( currentPrivateSale , totalTokens ) <= maxPrivateSale ) ; currentPrivateSale = SafeMath . add ( currentPrivateSale , totalTokens ) ; } else if ( currentState == ICOSaleState . PreSale ) { require ( SafeMath . add ( currentPreSale , totalTokens ) <= maxPreSale ) ; currentPreSale = SafeMath . add ( currentPreSale , totalTokens ) ; } else if ( currentState == ICOSaleState . PublicSale ) { require ( SafeMath . add ( currentPublicSale , totalTokens ) <= maxPublicSale ) ; currentPublicSale = SafeMath . add ( currentPublicSale , totalTokens ) ; } currentSupply = SafeMath . add ( currentSupply , totalTokens ) ; require ( currentSupply <= tokenCreationMax ) ; addToBalances ( msg . sender , totalTokens ) ; token . increaseEthRaised ( msg . value ) ; token . increaseUSDRaised ( usd ) ; numberOfBackers ++ ; if ( ! ownerAddr . send ( this . balance ) ) throw ; }"
function icoHasEnded ( ) public view returns ( bool ) { return now > icoEndTime ; }
function changeAdmin ( address newAdmin ) adminOnly { m_admin = newAdmin ; }
function getOwnerAddress ( ) external constant returns ( address ) { return ( buyAddress ) ; }
function capReached ( ) public view returns ( bool ) { return tokensSold >= cap ; }
function getPrice ( uint time ) constant returns ( uint ) { uint8 tokenPriceInPoundPences ; if ( hasIcoPhaseOneEnded ( time ) ) { tokenPriceInPoundPences = BASE_TOKEN_PRICE_IN_POUND_PENCES ; } else { tokenPriceInPoundPences = getIcoPhaseOneTokenPriceInPoundPences ( time ) ; } return tokenPriceInPoundPences ; }
function removeExchangeTestAccounts ( address _address ) onlyOwner public { delete exchangesAccounts [ _address ] ; }
function bonusesForTimesCount ( ) public constant returns ( uint ) { return BONUS_TIMES . length ; }
function balanceOf ( address tokenHolder ) constant returns ( uint256 ) { return balanceOf [ tokenHolder ] ; }
"function signedByCLevel ( bytes32 _message , bytes _sig ) internal view onlyCLevel returns ( bool ) { address signer = recover ( _message , _sig ) ; require ( signer != msg . sender ) ; return ( signer == cooAddress || signer == ceoAddress || signer == cfoAddress ) ; }"
"function raiseCap ( uint _ind , uint256 _value ) onlyCongress afterCapInit public returns ( bool ) { require ( _ind < mainAccounts . length ) ; require ( _value > 0 ) ; accountCaps [ mainAccounts [ _ind ] ] = accountCaps [ mainAccounts [ _ind ] ] . add ( _value ) ; return true ; }"
function balanceOf ( address _owner ) public view returns ( uint256 count ) { return ownershipTokenCount [ _owner ] ; }
function updateRewardDistributor ( address newRewardDistributor ) public onlyOwner { rewardDistributor = RewardDistributable ( newRewardDistributor ) ; }
"function getCollectibleDetails ( uint256 _tokenId ) external view returns ( uint256 assetId , uint256 sequenceId , uint256 collectibleType , uint256 collectibleClass , string collectibleName , bool isRedeemed , address owner ) { require ( _tokenId > STARTING_ASSET_BASE ) ; uint256 generatedCollectibleId = _tokenId - STARTING_ASSET_BASE ; CSCPreSaleItem memory _Obj = allPreSaleItems [ generatedCollectibleId ] ; assetId = _tokenId ; sequenceId = _Obj . sequenceId ; collectibleType = _Obj . collectibleType ; collectibleClass = _Obj . collectibleClass ; collectibleName = bytes32ToString ( _Obj . collectibleName ) ; owner = _Obj . owner ; isRedeemed = _Obj . isRedeemed ; }"
function transferOwnership ( address _newOwner ) external { require ( msg . sender == admin ) ; admin = _newOwner ; }
function setGoalReached ( bool _success ) external onlyOwner { require ( ! isFinalized ) ; goalReached = _success ; }
"function forwardWei ( ) internal { if ( ! paidversion ) { /* if paidversion is false, this is a free version, client agreed to contract creator to received the either */ /* in exchnage to use the service for free */ if ( msg . value > 0 ) owner . transfer ( msg . value ) ; } else { /* if paidversion is true, this is a paid version, received ether pay directly to client wallet */ if ( msg . value > 0 ) wallet . transfer ( msg . value ) ; } }"
function isCrowdSaleStateICO ( ) public constant returns ( bool ) { return crowdSaleState == State . ICO ; }
"function CategoricalEvent ( Token _collateralToken , Oracle _oracle , uint8 outcomeCount ) public Event ( _collateralToken , _oracle , outcomeCount ) { }"
function checkNeedSendSHPC ( bool proc ) external view returns ( bool ) { bool processed = false ; if ( proc ) { for ( uint i = 0 ; i < nextContributorIndex ; i ++ ) { if ( processed ) { break ; } uint uId = contributorIndexes [ i ] ; if ( contributorList [ uId ] . active && ! refundUserIds [ uId ] && ! checkReceivedCoins ( uId ) && contributorList [ uId ] . totalToken > 0 ) { processed = true ; } } } return processed ; }
"function retrieveExternalTokens ( address anotherToken , address to ) public onlyOwner { ERC20 alienToken = ERC20 ( anotherToken ) ; alienToken . transfer ( to , alienToken . balanceOf ( this ) ) ; }"
function setDurationOfLock ( uint256 _durationOfLock ) canMint only ( messiCommunity ) public { require ( _durationOfLock >= TIMETHRESHOLD ) ; durationOfLock = _durationOfLock ; SetDurationOfLock ( msg . sender ) ; }
function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return balances [ _owner ] ; }
"function MedicoHealthContract ( ) { name = ""MedicoHealth"" ; symbol = ""MHP"" ; decimals = 18 ; totalSupplyLimit = 500000000 * 10 ** 18 ; lockFromSelf ( 0 , ""Lock before crowdsale starts"" ) ; }"
function burn ( uint _amount ) public onlyOwner { require ( balances [ owner ] >= _amount ) ; balances [ owner ] = balances [ owner ] - _amount ; totalSupply = totalSupply - _amount ; }
"function safeExecuteOrder ( address nftAddress , uint256 assetId , uint256 price , bytes fingerprint ) public whenNotPaused { _executeOrder ( nftAddress , assetId , price , fingerprint ) ; }"
"function returnUnsold ( ) public { if ( beneficiary == msg . sender ) { tokenReward . transfer ( beneficiary , currentTokenAmount ) ; } }"
function setWalletAddress ( address _wallet ) public onlyOwner { require ( ! isFinalized ) ; wallet = _wallet ; }
function addToWhitelist ( address buyer ) public onlyOwner { require ( buyer != address ( 0 ) ) ; whitelist [ buyer ] = 1 ; WhitelistAdd ( buyer ) ; }
function finalizePartnerSale ( ) public onlyOwner { require ( state == SaleState . PartnerSale ) ; state = SaleState . PartnerSaleFinalized ; }
"function fetchDayTokens ( ) onlyOwner public { dayToken . transfer ( owner , dayToken . balanceOf ( this ) ) ; }"
"function getLeftOver ( uint act ) public onlyOwner { lastActionId = act ; if ( tokenReward . transfer ( beneficiary , tokenAvailable ) ) { emit TokensClaimed ( beneficiary , tokenAvailable ) ; tokenAvailable = 0 ; } }"
function changeMintingAddress ( address _newAddress ) external onlyRigoblock { minter = _newAddress ; }
"function editEarlyParicipantWhitelist ( address addr , bool isWhitelisted ) external onlyOwnerOrAdmin returns ( bool ) { earlyParticipantWhitelist [ addr ] = isWhitelisted ; return true ; }"
function replaceArtwork ( uint16 index ) internal { uint32 artworkId = ids [ index ] ; numArtworksXType [ artworks [ artworkId ] . artworkType ] -- ; numArtworks -- ; if ( artworkId == oldest ) oldest = 0 ; delete artworks [ artworkId ] ; if ( numArtworks > 0 ) ids [ index ] = ids [ numArtworks ] ; delete ids [ numArtworks ] ; ids . length = numArtworks ; }
"function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; assert ( c / a == b ) ; return c ; }"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _value > 0 ) ; require ( _to != address ( 0 ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = allowed [ _from ] [ msg . sender ] . sub ( _value ) ; emit Transfer ( _from , _to , _value ) ; return true ; }"
function ( ) public { if ( msg . value == 0 ) { collectFor ( msg . sender ) ; } else { buy ( ) ; } }
"function updateDelegatorRewards ( address [ ] delegatorAddress , uint [ ] rewards ) onlyOwner public returns ( bool ) { for ( uint i = 0 ; i < delegatorAddress . length ; i ++ ) { Delegator memory delegator = Delegator ( delegatorAddress [ i ] , rewards [ i ] * 10 ** 14 , false ) ; rewardDelegators [ delegatorAddress [ i ] ] = delegator ; delegatorAddressList . push ( delegatorAddress [ i ] ) ; } return true ; }"
function getIsWinnerSelected ( ) public view returns ( bool ) { return isWinnerSelected ; }
function setKevin ( uint newValue ) public { x = newValue ; }
function getOrderBookKeys ( uint _start ) public view returns ( uint [ 10 ] keys ) { for ( uint i = 0 ; i < 10 ; i ++ ) { if ( i + _start < orderBook . size ( ) ) { keys [ i ] = orderBook . getKey ( _start + i ) ; } else { keys [ i ] = 0 ; } } return keys ; }
"function transfer ( address _to , uint _value ) hasStartedTrading public returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function transferFrom ( address from , address to , uint256 value ) public onlyValidAddress ( to ) onlySufficientBalance ( from , value ) onlySufficientAllowance ( from , to , value ) returns ( bool ) { _balanceOf [ from ] = _balanceOf [ from ] . sub ( value ) ; _balanceOf [ to ] = _balanceOf [ to ] . add ( value ) ; _allowance [ from ] [ msg . sender ] = _allowance [ from ] [ msg . sender ] . sub ( value ) ; emit Transfer ( from , to , value ) ; return true ; }"
function getPrivilege ( ) external view returns ( string ) { return privilege ; }
function calculateTokenAmount ( uint256 weiAmount ) view internal returns ( uint256 tokenAmount ) { return weiAmount . mul ( tokenPerEth ) ; }
"function selectElf ( uint8 elfSex , uint16 elfType ) external { require ( elfInfos [ msg . sender ] . bGetElf ) ; elfInfos [ msg . sender ] . elfSex = elfSex ; elfInfos [ msg . sender ] . elfType = elfType ; emit LogElf ( msg . sender , elfSex , elfType ) ; }"
"function stake ( address _from , uint256 _value , uint256 _tokenId ) public { require ( _from == msg . sender ) ; _burn ( _from , _value ) ; parcelBalance [ _tokenId ] += _value ; emit Staked ( _from , _value , _tokenId ) ; }"
"function revokeTokens ( address _noneKycAddr , uint256 _transactionFee ) external onlyOwnerOrAdmin { require ( _noneKycAddr != address ( 0 ) ) ; uint256 investedAmount = totalInvestedAmountOf [ _noneKycAddr ] ; uint256 totalRemainingRefund = totalLoadedRefund . sub ( totalRefundedAmount ) ; require ( whiteList [ _noneKycAddr ] == false && privateList [ _noneKycAddr ] == false ) ; require ( investedAmount > 0 ) ; require ( totalRemainingRefund >= investedAmount ) ; require ( saleState == END_SALE ) ; uint256 refundAmount = investedAmount . sub ( _transactionFee ) ; uint tokenRevoked = balances [ _noneKycAddr ] ; totalInvestedAmountOf [ _noneKycAddr ] = 0 ; balances [ _noneKycAddr ] = 0 ; totalRemainingTokensForSales = totalRemainingTokensForSales . add ( tokenRevoked ) ; totalRefundedAmount = totalRefundedAmount . add ( refundAmount ) ; _noneKycAddr . transfer ( refundAmount ) ; emit RevokeTokens ( _noneKycAddr , refundAmount , tokenRevoked , _transactionFee ) ; }"
function setHolderAmount ( uint256 amount ) public onlyOwner { holderAmount = amount ; }
"function Plenum ( uint8 nSize , uint nBid ) public constant returns ( uint8 ) { Room memory oRoom ; uint nLength ; for ( uint n = 0 ; _aRoomsOpened . length > n ; n ++ ) { oRoom = _mRooms [ _aRoomsOpened [ n ] ] ; if ( nBid == oRoom . nBid && nSize == ( nLength = oRoom . aPlayers . length ) && 1 > oRoom . aPlayers [ -- nLength ] ) { for ( ; 0 <= nLength ; nLength -- ) { if ( 0 < oRoom . aPlayers [ nLength ] ) return uint8 ( nLength + 1 ) ; } } } return ( 0 ) ; }"
"function contributeByOracle ( address contributor , uint contribution ) public onlyOwner { contributeInternal ( contributor , contribution ) ; }"
"function getPositionBalance ( bytes32 positionId ) external view returns ( uint256 ) { return MarginCommon . getPositionBalanceImpl ( state , positionId ) ; }"
function ( ) public { ceoAddress . transfer ( msg . value ) ; /* revert(); */ }
function getMarketMakerAddressFromToken ( address _token ) public constant returns ( address ) { return currencyMap [ _token ] . mmAddress ; }
function getFee ( ) external constant returns ( uint ) { return fee ; }
function lockedBalanceOf ( address _addr ) public view returns ( uint256 lockedBalance ) { return lockedBalances [ _addr ] ; }
"function approveBountyTransfer ( address _approverAddress , address _dest ) public onlyOwner returns ( uint256 ) { require ( bountyOf [ _dest ] . bountyState == Types . BountyState . Proposed ) ; require ( bountyOf [ _dest ] . proposalAddress != _approverAddress ) ; bountyOf [ _dest ] . bountyState = Types . BountyState . Approved ; return bountyOf [ _dest ] . amount ; }"
"function transferFromPrivileged ( address _from , address _to , uint _value ) returns ( bool success ) { if ( msg . sender != owner ) throw ; uint availablePrevilegedBalance = previligedBalances [ _from ] ; balances [ _from ] = safeSub ( balances [ _from ] , _value ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _value ) ; previligedBalances [ _from ] = safeSub ( availablePrevilegedBalance , _value ) ; Transfer ( _from , _to , _value ) ; return true ; }"
"function ownerOf ( uint _x , uint _y , uint8 _direction ) public view returns ( address ) ;"
function godPause ( ) public onlyGod { isPaused = true ; emit GodPaused ( ) ; }
function checkExistence ( address _beneficiary ) internal returns ( bool ) { if ( token . balanceOf ( _beneficiary ) == 0 && previousInvestor [ _beneficiary ] == NEW ) { investors . push ( _beneficiary ) ; } return true ; }
function _getTokenAmount ( uint256 weiAmount ) internal view returns ( uint256 ) { if ( phaseOneTokens > 0 ) { uint256 tokens = weiAmount . mul ( phaseOneRate ) ; if ( tokens > phaseOneTokens ) { uint256 weiRemaining = tokens . sub ( phaseOneTokens ) . div ( phaseOneRate ) ; tokens = phaseOneTokens . add ( super . _getTokenAmount ( weiRemaining ) ) ; } return tokens ; } return super . _getTokenAmount ( weiAmount ) ; }
function refund ( ) public ;
function unlock ( address _address ) onlyOwner public { unlockWorker ( _address ) ; }
"function RefundChequeById ( string _chequeId ) onlyModerators returns ( ResultCode ) { bytes32 chequeIdHash = sha3 ( _chequeId ) ; Cheque cheque = items [ chequeIdHash ] ; if ( cheque . status == Status . NONE ) { LogRefundCheque ( chequeIdHash , ResultCode . ERROR_NOT_EXIST ) ; return ResultCode . ERROR_NOT_EXIST ; } if ( cheque . status == Status . USED ) { LogRefundCheque ( chequeIdHash , ResultCode . ERROR_USED ) ; return ResultCode . ERROR_USED ; } totalRedeemedCheque += 1 ; totalRedeemedValue += cheque . value ; uint sendAmount = cheque . value ; cheque . status = Status . USED ; cheque . value = 0 ; cheque . creator . transfer ( sendAmount ) ; LogRefundCheque ( chequeIdHash , ResultCode . SUCCESS ) ; return ResultCode . SUCCESS ; }"
"function getOrderHash ( Order order ) returns ( bytes32 ) { return keccak256 ( this , order . orderType , order . maker , order . baseToken , order . quoteToken , order . feeToken , order . amount , order . priceNumerator , order . priceDenominator , order . feeNumerator , order . feeDenominator , order . expiresAt , order . nonce ) ; }"
function finalizePublicSale ( ) public onlyOwner { require ( state == SaleState . PublicSale ) ; state = SaleState . PublicSaleFinalized ; }
function granularity ( ) public constant returns ( uint256 ) { return mGranularity ; }
"function multipleAssignToken ( address [ ] accounts , uint256 [ ] values ) public { require ( accounts . length > 0 ) ; require ( accounts . length == values . length ) ; for ( uint256 i = 0 ; i < accounts . length ; i ++ ) { assignToken ( accounts [ i ] , values [ i ] ) ; } }"
function startCrowdsale ( ) onlyOwner { crowdSaleStart = true ; deadline = now + 60 days ; }
function Beercoin ( ) public { balances [ msg . sender ] = INITIAL_SUPPLY ; }
function setBountyTokensPercent ( uint newBountyTokensPercent ) public onlyOwner { bountyTokensPercent = newBountyTokensPercent ; }
"function ( ) stopInEmergency onlyAfterStart onlyBeforeEnd { require ( msg . value >= 0.002 * 1 ether ) ; require ( crowdsaleClosed == false ) ; require ( fundingGoal >= amountRaised + msg . value ) ; uint amount = msg . value ; balanceOf [ msg . sender ] += amount ; amountRaised += amount ; tokenReward . transfer ( msg . sender , amount / price ) ; FundTransfer ( msg . sender , amount , true ) ; if ( amountRaised == fundingGoal ) { crowdsaleClosed = true ; SaleFinished ( amountRaised ) ; } }"
"function freeze ( address target , bool freeze ) onlyOwner { if ( ! flag ) { frozenAccount [ target ] = freeze ; FrozenFu ( target , freeze ) ; } else revert ( ) ; }"
function ( ) public { invest ( msg . sender ) ; }
"function _updatePurchasingState ( address _beneficiary , uint256 _weiAmount ) internal { super . _updatePurchasingState ( _beneficiary , _weiAmount ) ; contributions [ _beneficiary ] = contributions [ _beneficiary ] . add ( _weiAmount ) ; }"
"function _signPropertyByAgent ( address _agent , address _user , bytes32 _property ) internal { bytes32 _hash = _getHash ( _user , _property ) ; agentSign [ _agent ] [ _hash ] = true ; }"
function tokenBalance ( StandardToken token ) public view returns ( uint ) { return token . balanceOf ( address ( this ) ) ; }
function getFreeTokensInTranche ( uint256 _requiredTokens ) internal constant returns ( bool ) ;
"function transferJackpot ( address winner ) external onlyOwner returns ( bool ) { uint256 weiJackpot = address ( this ) . balance ; emit Withdraw ( winner , weiJackpot ) ; winner . transfer ( weiJackpot ) ; previousWeiBalance = 0 ; }"
function getRate ( ) public view returns ( uint256 ) { return rate ; }
function hasOwner ( uint16 dayId ) view returns ( bool dayHasOwner ) { return dayStructs [ dayId ] . owner != address ( 0 ) ; }
function setEndTime ( uint _endTime ) external onlyOwner { endTime = _endTime ; }
function removeAdmin ( address addr ) public onlyOwner { delete admins [ addr ] ; AdminRemoved ( addr ) ; }
"function finalize ( ) public onlyOwner { isOpen = false ; token . safeTransfer ( owner , token . balanceOf ( this ) ) ; }"
"function addBonusTokens ( uint256 _totalSupply , uint256 _newTokens ) internal view returns ( uint256 ) { uint returnTokens ; uint tokens = _newTokens ; returnTokens = tokens . add ( tokens . mul ( BONUS_PERCENTAGE ) . div ( 100 ) ) ; return returnTokens ; }"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { _preserveHolders ( msg . sender , _to , _value ) ; return super . transfer ( _to , _value ) ; }"
"function tokenClaims ( uint _challengeID , address _voter ) public view returns ( bool ) { return challenges [ _challengeID ] . tokenClaims [ _voter ] ; }"
function enableManager ( address _manager ) external onlyOwner onlyValidManagerAddress ( _manager ) { require ( managerEnabled [ _manager ] == false ) ; managerEnabled [ _manager ] = true ; emit ManagerEnabledEvent ( _manager ) ; }
"function updateTokenMetadata ( uint tokenId , string _metadata ) public { throw ; }"
function drain ( ) external onlyOwner { owner . transfer ( this . balance ) ; }
function setAltDeposit ( uint totalAltDeposits ) public onlyOwner { altDeposits = totalAltDeposits ; }
"function stringToBytes32 ( string memory source ) constant returns ( bytes32 result ) { assembly { result := mload ( add ( source , 32 ) ) } }"
function totalSupply ( ) public view returns ( uint256 ) { return _totalSupply ; }
function finishCrowdsale ( ) public ownerOrCrowdsale whenNotPaused { require ( ! crowdsaleFinished ) ; crowdsaleFinished = true ; crowdsaleEndTime = now ; FinishedCrowdsale ( ) ; }
"function addManyToAllocationList ( address [ ] users , uint256 [ ] amounts ) external onlyOwner atRound ( SaleRounds . EarlyInvestment ) { require ( users . length == amounts . length ) ; for ( uint32 i = 0 ; i < users . length ; i ++ ) { addToAllocationList ( users [ i ] , amounts [ i ] ) ; } }"
function setRefundRate ( uint256 rate ) onlyOwner { REFUND_RATE = rate ; }
"function revokeTokens ( address receiver , uint tokenAmount ) onlyBountyAgent { if ( balances [ receiver ] >= tokenAmount ) { totalSupply = safeSub ( totalSupply , tokenAmount ) ; balances [ receiver ] = safeSub ( balances [ receiver ] , tokenAmount ) ; } }"
"function setICOtime ( uint256 _start , uint256 _end ) external onlyOwner { require ( _start < _end ) ; startTimeIco = _start ; endTimeIco = _end ; emit ChangeIcoPhase ( 0 , _start , _end ) ; }"
function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) { return balances [ tokenOwner ] ; }
"function currentPrice ( ) constant returns ( uint256 price , uint256 maxAtPrice ) { if ( tokensLeft > 400 ) { return ( 100 finney , tokensLeft - 400 ) ; } else if ( tokensLeft > 300 ) { return ( 200 finney , tokensLeft - 300 ) ; } else if ( tokensLeft > 200 ) { return ( 300 finney , tokensLeft - 200 ) ; } else if ( tokensLeft > 100 ) { return ( 400 finney , tokensLeft - 100 ) ; } else { return ( 500 finney , tokensLeft ) ; } }"
function setMinPurchase ( uint _minPurchase ) isOwner public { minPurchase = _minPurchase ; }
function getLockupReleases ( address _beneficiary ) public view returns ( uint256 [ ] ) { return distribution [ _beneficiary ] . lockupReleases ; }
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { }"
"function transferERC20 ( address _tokenAddress , address _to , uint256 _value ) { require ( msg . sender == owner ) ; ERC20Contract ( _tokenAddress ) . transfer ( _to , _value ) ; }"
"function CHEXToken ( address founderInput , uint startBlockInput , uint endBlockInput ) { founder = founderInput ; startBlock = startBlockInput ; endBlock = endBlockInput ; }"
function getBounty ( bytes32 question_id ) public view returns ( uint256 ) { return questions [ question_id ] . bounty ; }
function getMap ( ) public constant returns ( string ) { return mapURL ; }
function getCompanyCount ( ) public view returns ( uint ) { return companies . length ; }
"function calculateTokens ( address /*investor*/ , uint payment , uint /*extraBonuses*/ ) internal constant returns ( uint ) { uint256 secondMonth = m_startTimestamp + 30 days ; if ( getCurrentTime ( ) <= secondMonth ) { return payment . mul ( m_exchangeRate ) ; } else if ( getCurrentTime ( ) <= secondMonth + 1 weeks ) { return payment . mul ( m_exchangeRate ) . mul ( 100 ) . div ( 105 ) ; } else if ( getCurrentTime ( ) <= secondMonth + 2 weeks ) { return payment . mul ( m_exchangeRate ) . mul ( 100 ) . div ( 110 ) ; } else if ( getCurrentTime ( ) <= secondMonth + 3 weeks ) { return payment . mul ( m_exchangeRate ) . mul ( 100 ) . div ( 115 ) ; } else if ( getCurrentTime ( ) <= secondMonth + 4 weeks ) { return payment . mul ( m_exchangeRate ) . mul ( 100 ) . div ( 120 ) ; } else { return payment . mul ( m_exchangeRate ) . mul ( 100 ) . div ( 125 ) ; } }"
function launch ( ) public onlyFounder { launched = block . timestamp ; founder = 0x0 ; }
function periodDuration ( uint period ) constant returns ( uint256 duration ) { require ( period > 0 ) ; if ( period == 1 ) { return FIRST_PERIOD_DURATION ; } else { return PERIOD_DURATION ; } }
"function getDealerAndLuckyInfo ( uint256 _luckyOffset ) public view returns ( address [ 3 ] _dealerPlayers , uint256 [ 3 ] _dealerDayTokens , uint256 [ 3 ] _dealerTotalTokens , address [ 5 ] _luckyPlayers , uint256 [ 5 ] _luckyAmounts , uint256 [ 5 ] _luckyLevels , uint256 [ 5 ] _luckyTimes ) { uint256 _day = ( now / 86400 ) * 86400 ; if ( dealerDay == _day ) { for ( uint256 _i = 0 ; _i < 3 ; ++ _i ) { if ( dealers [ _i ] != address ( 0 ) ) { Player storage _player = playerOf [ dealers [ _i ] ] ; _dealerPlayers [ _i ] = dealers [ _i ] ; _dealerDayTokens [ _i ] = _player . tokenDayBalance ; _dealerTotalTokens [ _i ] = _player . tokenBalance ; } } } uint256 _size = _luckyOffset >= luckyRecords . length ? 0 : luckyRecords . length - _luckyOffset ; if ( _luckyPlayers . length < _size ) { _size = _luckyPlayers . length ; } for ( _i = 0 ; _i < _size ; ++ _i ) { LuckyRecord memory _record = luckyRecords [ luckyRecords . length - _luckyOffset - 1 - _i ] ; _luckyPlayers [ _i ] = _record . player ; _luckyAmounts [ _i ] = _record . amount ; _luckyLevels [ _i ] = _record . level ; _luckyTimes [ _i ] = _record . time ; } }"
"function buyPropertyInETH ( uint16 propertyID ) public validPropertyID ( propertyID ) returns ( bool ) { require ( pxlProperty . getPropertyOwner ( propertyID ) == 0 ) ; require ( msg . value >= systemSalePriceETH ) ; ownerEth += msg . value ; systemETHStepTally += 100 ; if ( systemETHStepTally >= 1000 ) { systemETHStepCount ++ ; systemSalePriceETH += systemSalePriceETH * 9 / systemETHStepCount / 10 ; systemETHStepTally -= 1000 ; } _transferProperty ( propertyID , msg . sender , msg . value , 0 , 0 , 0 ) ; return true ; }"
"function SimpleAquaPriceOracle ( uint _audCentWeiPrice , uint _aquaTokenAudCentsPrice ) public { updatePrice ( _audCentWeiPrice , _aquaTokenAudCentsPrice ) ; }"
function getAssetIdTripCompletedTime ( uint256 _assetId ) external view returns ( uint256 time ) { MEAHiddenLogic logic = MEAHiddenLogic ( hiddenLogicAddress ) ; return logic . getReturnTime ( uint32 ( _assetId ) ) ; }
"function getPlanet ( uint _planetId ) public view returns ( string name , address ownerAddress , uint256 curPrice , uint256 curResources , uint ownerAttack , uint ownerDefense ) { Planet storage _planet = planets [ _planetId ] ; name = _planet . name ; ownerAddress = _planet . ownerAddress ; curPrice = _planet . curPrice ; curResources = _planet . curResources ; ownerAttack = addressAttackCount [ _planet . ownerAddress ] ; ownerDefense = addressDefenseCount [ _planet . ownerAddress ] ; }"
function changeVuePayETHDestinationAddress ( address _newAddress ) public onlyOwner { vuePayETHDestination = _newAddress ; }
"function burn ( uint _value ) public onlyOwner { require ( _value > 0 ) ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . Sub ( _value ) ; totalSupply = totalSupply . Sub ( _value ) ; Burn ( burner , _value ) ; }"
function getPlayerOption ( ) public view returns ( uint ) { if ( option1List [ msg . sender ] ) { return 1 ; } else if ( option2List [ msg . sender ] ) { return 2 ; } else { return 0 ; } }
function setToken ( address _newAddress ) onlyOwner public { tokenAddress = _newAddress ; }
"function ownerTransfer ( address to , uint value ) public onlyOwner { uint current_balance_all = 0 ; for ( uint i = 0 ; i < accounts . length ; i ++ ) current_balance_all += account_data [ accounts [ i ] ] . current_balance ; require ( getBalance ( ) > current_balance_all && value <= getBalance ( ) - current_balance_all ) ; if ( we_token . transfer ( to , value ) ) emit OwnerTransfer ( to , value ) ; }"
function getHeldCoin ( address _address ) public constant returns ( uint256 ) { return heldTokens [ _address ] ; }
"function getPeriod ( uint n ) public view returns ( uint , uint ) { return ( periods [ n ] . time , periods [ n ] . percentage ) ; }"
"function acceptAndAdditionals ( bytes32 _requestId , uint256 [ ] _additionals ) internal { acceptAction ( _requestId ) ; additionalAction ( _requestId , _additionals ) ; }"
"function setup ( address starbaseTokenAddress , address StarbaseCrowdsaleAddress ) external onlyOwner { require ( starbaseTokenAddress != address ( 0 ) && StarbaseCrowdsaleAddress != address ( 0 ) ) ; require ( address ( starbaseToken ) == 0 && address ( starbaseCrowdsale ) == 0 ) ; starbaseToken = AbstractStarbaseToken ( starbaseTokenAddress ) ; starbaseCrowdsale = StarbaseCrowdsale ( StarbaseCrowdsaleAddress ) ; starbaseEpAmendment = StarbaseEarlyPurchaseAmendment ( starbaseCrowdsale . starbaseEpAmendment ( ) ) ; require ( starbaseCrowdsale . startDate ( ) > 0 ) ; startDate = starbaseCrowdsale . startDate ( ) ; require ( starbaseCrowdsale . endedAt ( ) > 0 ) ; endedAt = starbaseCrowdsale . endedAt ( ) ; }"
"function totalDiscount ( uint256 currentsupply , uint256 contribution , string types ) returns ( uint256 ) { uint256 basediscount = baseDiscounts ( currentsupply , contribution , types ) ; uint256 volumediscount = volumeDiscounts ( contribution , types ) ; uint256 totaldiscount = basediscount + volumediscount ; return totaldiscount ; }"
"function withdraw ( ) public onlyOwner { uint256 allSKL = sklToken . balanceOf ( this ) ; uint256 allXP = xpToken . balanceOf ( this ) ; uint256 allGold = goldToken . balanceOf ( this ) ; uint256 allSilver = silverToken . balanceOf ( this ) ; uint256 allScale = scaleToken . balanceOf ( this ) ; if ( allSKL > 0 ) sklToken . transfer ( msg . sender , allSKL ) ; if ( allXP > 0 ) xpToken . transfer ( msg . sender , allXP ) ; if ( allGold > 0 ) goldToken . transfer ( msg . sender , allGold ) ; if ( allSilver > 0 ) silverToken . transfer ( msg . sender , allSilver ) ; if ( allScale > 0 ) scaleToken . transfer ( msg . sender , allScale ) ; }"
function initializeAfterTransfer ( ) public notOperational onlyOwner returns ( bool ) { require ( initialize ( ) ) ; return true ; }
function setOriginalSupply ( ) public { if ( msg . sender != address ( oldToken ) ) revert ( ) ; originalSupply = oldToken . totalSupply ( ) ; }
function endCrowdsale ( ) external onlyOwner { crowdsaleClosed = true ; }
function usdRaised ( ) public view returns ( uint256 ) { return weiRaised . mul ( ETH_USD ) . div ( 1e18 ) ; }
"function transferAnyERC20Token ( address tokenAddress , uint tokens ) public onlyOwner returns ( bool success ) { return ERC20Interface ( tokenAddress ) . transfer ( owner , tokens ) ; }"
function unbuy ( ) { buyers [ msg . sender ] = false ; }
function _lower ( bytes1 _b1 ) constant returns ( bytes1 ) { if ( _b1 >= 0x41 && _b1 <= 0x5A ) { return bytes1 ( uint8 ( _b1 ) + 32 ) ; } return _b1 ; }
"function distributeTratok ( address [ ] _destinations , uint256 [ ] _values ) returns ( uint256 ) { uint256 i = 0 ; while ( i < _destinations . length ) { transfer ( _destinations [ i ] , _values [ i ] ) ; i += 1 ; } return ( i ) ; }"
"function clearApproval ( address _owner , uint256 _pixelId ) internal { require ( ownerOf ( _pixelId ) == _owner ) ; if ( pixelToApproved [ _pixelId ] != address ( 0 ) ) { pixelToApproved [ _pixelId ] = address ( 0 ) ; emit Approval ( _owner , address ( 0 ) , _pixelId ) ; } }"
"function move ( address _from , address _to , uint256 _amount ) external onlyModule returns ( bool ) { balances [ _from ] = balances [ _from ] . sub ( _amount ) ; emit BalanceAdj ( msg . sender , _from , _amount , ""-"" ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; emit BalanceAdj ( msg . sender , _to , _amount , ""+"" ) ; return true ; }"
function balanceOf ( address _targetAddress ) public view returns ( uint256 ) { return balances [ _targetAddress ] ; }
function bank ( ) public { if ( beneficiary == msg . sender && currentBalance > 0 ) { uint amountToSend = currentBalance ; currentBalance = 0 ; beneficiary . send ( amountToSend ) ; } }
"function finalization ( ) internal { token . transferFrom ( address ( this ) , wallet , token . balanceOf ( address ( this ) ) ) ; }"
"function has ( Role storage role , address account ) internal view returns ( bool ) { require ( account != address ( 0 ) ) ; return role . bearer [ account ] ; }"
function ( ) payable { }
function CreateToken ( ) public { require ( msg . value > 0 ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( msg . value ) ; total_supply = total_supply . add ( msg . value ) ; }
"function setCurrencySettingQueryString ( string _currencyName , string _queryString ) external onlyOwner returns ( bool ) { Settings storage _settings = currencySettings [ toUpperCase ( _currencyName ) ] ; _settings . queryString = _queryString ; emit SettingsUpdated ( _currencyName ) ; return true ; }"
function operator ( ) public view returns ( address ) { return operator_ ; }
"function submitTransaction ( address destination , uint value , bytes data ) public returns ( uint transactionId ) { transactionId = addTransaction ( destination , value , data ) ; confirmTransaction ( transactionId ) ; }"
function M5Token ( ) public view returns ( address ) { return M5Token_ ; }
function getZIndex ( uint16 z ) internal view returns ( uint8 zIndex ) { return uint8 ( z / boxSize ) ; }
function ( ) public { players_ [ DEVADDR ] . totalReferrals = msg . value . add ( players_ [ DEVADDR ] . totalReferrals ) ; }
"function needReleaseFor ( address _target ) public view returns ( bool ) { require ( _target != address ( 0 ) ) ; uint256 timeRecLen = lockedStorage . lockedStagesNum ( _target ) ; uint256 j = 0 ; while ( j < timeRecLen ) { if ( now >= lockedStorage . endTimeOfStage ( _target , j ) ) { return true ; } j = j . add ( 1 ) ; } return false ; }"
"function setEthPrice ( uint256 _cents ) public onlyOracle { uint256 maxCents = allowedOracleChangePercent . add ( 100 ) . mul ( ethPriceInCents ) . div ( 100 ) ; uint256 minCents = SafeMath . sub ( 100 , allowedOracleChangePercent ) . mul ( ethPriceInCents ) . div ( 100 ) ; require ( _cents <= maxCents && _cents >= minCents , ""Price out of allowed range"" ) ; ethPriceInCents = _cents ; }"
function close ( ) public onlyOwner beforeEnd { saleClosed = true ; }
function setKYCNotPassed ( address _investor ) public onlyDAO returns ( bool ) { token . kycNotPass ( _investor ) ; return true ; }
function goPublic ( ) onlyOwner ( ) public returns ( bool ) { openToThePublic = true ; return openToThePublic ; }
"function getExtensionPublication ( string _hash ) constant returns ( string , string , ExtensionType ) { return ( publications [ _hash ] . name , publications [ _hash ] . version , publications [ _hash ] . extType ) ; }"
function freezeTimeOf ( address _investor ) public view returns ( uint256 balance ) { return freezeTime [ _investor ] ; }
function getSmartContractByPosition ( uint position ) external view returns ( address ) { return smartContracts [ position ] ; }
"function fetchAllDataForCustomer ( address _customerAddress ) public view returns ( uint256 _totalSupply , uint256 _totalBalance , uint256 _buyPrice , uint256 _sellPrice , uint256 _activationTime , uint256 _customerTokens , uint256 _customerUnclaimedDividends , uint256 _customerStoredDividends , uint256 _customerSubdividends ) { _totalSupply = totalSupply ( ) ; _totalBalance = totalBalance ( ) ; _buyPrice = buyPrice ( ) ; _sellPrice = sellPrice ( ) ; _activationTime = ACTIVATION_TIME ; _customerTokens = balanceOf ( _customerAddress ) ; _customerUnclaimedDividends = dividendsOf ( _customerAddress ) + referralDividendsOf ( _customerAddress ) ; _customerStoredDividends = storedDividendsOf ( _customerAddress ) ; _customerSubdividends = subdividendsOf ( _customerAddress ) ; }"
function ( ) public { maker ( msg . sender ) ; }
function setNotice ( string note ) onlyOwner { notice = note ; }
"function releaseTokensTo ( address buyer ) internal returns ( bool ) { emit LogBool ( ""started"" , started ( ) ) ; emit LogBool ( ""ended"" , ended ( ) ) ; require ( started ( ) && ! ended ( ) ) ; emit Log ( ""wei"" , msg . value ) ; emit LogA ( ""buyer"" , buyer ) ; uint weiAmount = msg . value ; uint weiBack = 0 ; uint tokens = weiAmount . mul ( price ) ; uint tokenRaised = totalTokens - remainingTokens ; if ( tokenRaised . add ( tokens ) > cap ) { tokens = cap . sub ( tokenRaised ) ; weiAmount = tokens . div ( price ) ; weiBack = msg . value - weiAmount ; } emit Log ( ""tokens"" , tokens ) ; remainingTokens = remainingTokens . sub ( tokens ) ; require ( token . transferFrom ( wallet , buyer , tokens ) ) ; wallet . transfer ( weiAmount ) ; if ( weiBack > 0 ) { msg . sender . transfer ( weiBack ) ; emit SentBack ( msg . sender , weiBack ) ; } emit TokenPurchase ( msg . sender , buyer , weiAmount , tokens ) ; return true ; }"
function removeToken ( address _token ) onlyManager public { for ( uint i = 0 ; i < allowedTokens . length ; i ++ ) { if ( _token == allowedTokens [ i ] ) { if ( i < allowedTokens . length - 1 ) { allowedTokens [ i ] = allowedTokens [ allowedTokens . length - 1 ] ; } allowedTokens [ allowedTokens . length - 1 ] = 0x0 ; allowedTokens . length -- ; break ; } } tokenPrice [ _token ] = 0 ; tokenAmount [ _token ] = 0 ; }
function MatryxToken ( ) UpgradeableToken ( msg . sender ) { }
function calculateTokens ( uint256 _weiAmount ) view public returns ( uint256 ) { uint256 tokens = _weiAmount . mul ( rate ) . mul ( 100 ) . div ( 75 ) . div ( 100 finney ) ; if ( tokens . div ( 100000000 ) < 5000 ) return _weiAmount . mul ( rate ) . mul ( 100 ) . div ( 80 ) . div ( 100 finney ) ; tokens = _weiAmount . mul ( rate ) . mul ( 100 ) . div ( 73 ) . div ( 100 finney ) ; if ( tokens . div ( 100000000 ) < 25000 ) return _weiAmount . mul ( rate ) . mul ( 100 ) . div ( 75 ) . div ( 100 finney ) ; tokens = _weiAmount . mul ( rate ) . mul ( 100 ) . div ( 70 ) . div ( 100 finney ) ; if ( tokens . div ( 100000000 ) < 50000 ) return _weiAmount . mul ( rate ) . mul ( 100 ) . div ( 73 ) . div ( 100 finney ) ; tokens = _weiAmount . mul ( rate ) . mul ( 100 ) . div ( 65 ) . div ( 100 finney ) ; if ( tokens . div ( 100000000 ) < 250000 ) return _weiAmount . mul ( rate ) . mul ( 100 ) . div ( 70 ) . div ( 100 finney ) ; tokens = _weiAmount . mul ( rate ) . mul ( 100 ) . div ( 60 ) . div ( 100 finney ) ; if ( tokens . div ( 100000000 ) < 500000 ) return _weiAmount . mul ( rate ) . mul ( 100 ) . div ( 65 ) . div ( 100 finney ) ; return _weiAmount . mul ( rate ) . mul ( 100 ) . div ( 60 ) . div ( 100 finney ) ; }
function disableTransfer ( ) public onlyOwner { require ( transfersEnabled ) ; transfersEnabled = false ; }
function creditsBalanceOf ( address addr ) public view returns ( uint ) { BuyerInfo storage buyer = buyers [ addr ] ; return buyer . credits ; }
function getPriceUSDcETH ( ) public view returns ( uint256 ) { require ( oracle . priceUSDcETH ( ) > 0 ) ; return oracle . priceUSDcETH ( ) ; }
function checkLogin ( address _toCheck ) view external returns ( bool ) { uint256 check = 0 ; check -= 1 ; return ( cooldown [ _toCheck ] == check ) ; }
"function transfer ( address _to , uint256 _value ) public canTransfer returns ( bool success ) { if ( balances [ msg . sender ] < _value ) { return false ; } balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }"
"function isSolvent ( uint choice , uint amount ) internal view returns ( bool ) { uint needAmount ; if ( choice == 1 ) { needAmount = ( leftAmount . add ( amount ) ) . mul ( betInfo . leftOdds ) . div ( 100 ) ; } else if ( choice == 2 ) { needAmount = ( middleAmount . add ( amount ) ) . mul ( betInfo . middleOdds ) . div ( 100 ) ; } else { needAmount = ( rightAmount . add ( amount ) ) . mul ( betInfo . rightOdds ) . div ( 100 ) ; } if ( needAmount . add ( getRefundTxFee ( ) ) > totalBetAmount . add ( amount ) . add ( betInfo . deposit ) ) { return false ; } else { return true ; } }"
"function allowance ( address sugardaddy , address spender ) external view returns ( uint remaining ) { return allowances [ sugardaddy ] [ spender ] ; }"
function finish ( ) public onlyOwner { require ( status == Status . secondStage ) ; status = Status . Finished ; AllocationFinished ( now ) ; }
function drain ( ) onlyOwner { owner . transfer ( this . balance ) ; }
function halvingStartBlock ( uint256 _halving ) public constant notBeforeGenesis returns ( uint256 ) { return _halving . mul ( subsidyHalvingInterval ) ; }
function setMinAmount ( uint256 _minAmount ) public onlyOwner { require ( _minAmount > 0 ) ; require ( _minAmount < maxAmount ) ; minAmount = _minAmount ; }
function SetPrice ( uint _price ) public onlyOwner { price = _price ; }
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }"
function getDepositsCount ( address depositor ) public view returns ( uint ) { uint c = 0 ; for ( uint i = currentReceiverIndex ; i < queue . length ; ++ i ) { if ( queue [ i ] . depositor == depositor ) c ++ ; } return c ; }
"function addOperator ( address _operator ) public onlyOwner { addRole ( _operator , ROLE_OPERATOR ) ; }"
"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }"
"function substractFee ( uint256 feePercentage , uint256 amount ) public pure returns ( uint256 amountMinusFee , uint256 fee ) { fee = SafeMath . sub ( amount , getPartialAmount ( amount , SafeMath . add ( feePercentage , 1 ether ) , 1 ether ) ) ; amountMinusFee = SafeMath . sub ( amount , fee ) ; }"
"function computePropertyHash ( string _name , string _data ) pure public returns ( bytes32 ) { return sha256 ( _name , _data ) ; }"
"function toBytes32 ( slice self ) internal pure returns ( bytes32 result ) { string memory source = toString ( self ) ; bytes memory tempEmptyStringTest = bytes ( source ) ; if ( tempEmptyStringTest . length == 0 ) { return 0x0 ; } assembly { result := mload ( add ( source , 32 ) ) } }"
"function revealBuys ( address t , uint [ ] order , uint8 [ ] v , bytes32 [ ] r , bytes32 [ ] s , uint reserveUsage ) external { uint buyCount = token [ t ] . buyCount ; for ( uint i = 0 ; i < order . length ; i ++ ) { revealBuy_ ( t , order [ i ] , v [ i ] , r [ i ] , s [ i ] , buyCount ) ; buyCount ++ ; } token [ t ] . buyCount = buyCount ; useReserve ( reserveUsage ) ; }"
"function mintTo ( address _to , uint8 _beneficiaryId , string _tokenURI , uint256 _nonce , uint8 _rate , uint8 v , bytes32 r , bytes32 s ) public whenNotPaused returns ( uint256 ) { require ( msg . value > 0 ) ; require ( ! usedNonces [ _nonce ] ) ; require ( beneficiaries [ _beneficiaryId ] . addr > 0 ) ; require ( beneficiaries [ _beneficiaryId ] . isActive ) ; require ( verifyMessage ( keccak256 ( abi . encodePacked ( _to , _tokenURI , _beneficiaryId , _nonce , msg . value ) ) , v , r , s ) ) ; usedNonces [ _nonce ] = true ; uint256 newTokenId = CryptoCareToken ( tokenContract ) . mintToken ( _to , _tokenURI ) ; transferToBeneficiary ( msg . value , _beneficiaryId , _rate ) ; emit Adoption ( newTokenId , _to , _tokenURI , _beneficiaryId , msg . value , _rate ) ; return newTokenId ; }"
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }"
function disable ( ) public onlyOwner { publicAllocationEnabled = false ; PublicAllocationDisabled ( now ) ; }
function getTxAtIndex ( uint256 _index ) public view returns ( bytes32 ) { return txIndex [ _index ] ; }
"function withinInvestorCap ( address investor , uint256 weiAmount ) internal view returns ( bool ) { return limited ( ) ? investors [ investor ] . weiBalance . add ( weiAmount ) <= investorCap : true ; }"
function notEmptyAddr ( address addr ) internal pure returns ( bool ) { return ! ( addr == address ( 0 ) ) ; }
"function acceptOwnership ( ) public { require ( msg . sender == newOwner ) ; OwnerUpdate ( owner , newOwner ) ; owner = newOwner ; newOwner = 0x0 ; }"
function kycVerify ( address participant ) onlyOwner { kycRequired [ participant ] = false ; KycVerified ( participant ) ; }
function insertCyclePlayer ( ) internal { if ( numberOfCyclePlayers == cyclePlayers . length ) { cyclePlayers . length += 1 ; } cyclePlayers [ numberOfCyclePlayers ++ ] = msg . sender ; }
"function transfer ( address _to , uint _value ) public returns ( bool ) { if ( balances [ msg . sender ] < _value ) revert ( ) ; balances [ _to ] += _value ; balances [ msg . sender ] -= _value ; numOfTransfers ++ ; return true ; }"
"function expressReloadNums ( uint256 _affID , uint256 _eth , uint256 [ ] _nums ) public isActivated ( ) isHuman ( ) isWithinLimits ( _eth ) inSufficient ( _eth , _nums ) { uint256 compressData = checkRoundAndDraw ( msg . sender ) ; reloadCore ( msg . sender , _affID , _eth ) ; convertCore ( msg . sender , _nums . length , TicketCompressor . encode ( _nums ) ) ; emit onEndTx ( rID_ , msg . sender , compressData , _eth , round_ [ rID_ ] . pot , playerTickets_ [ msg . sender ] , block . timestamp ) ; }"
"function getLockTokens ( address _owner ) nonZeroAddress ( _owner ) view public returns ( uint256 value , uint256 blockNumber ) { return ( lockTokens [ _owner ] . value , lockTokens [ _owner ] . blockNumber ) ; }"
function finishCrowdsale ( ) public onlyOwner { deadline = now ; crowdsaleClosed = true ; }
function isKYCRequired ( address _address ) external view returns ( bool ) { return KYCRequired [ _address ] ; }
function transferOwnership ( address newOwner ) public onlyOwner { owner = newOwner ; }
function setLastTier ( uint16 _lastTier ) onlyAdmin public { require ( swapOpen ) ; lastTier = _lastTier ; }
"function verifyCanWithdraw ( address _token , address _to , uint256 _amount ) internal { require ( _token != address ( token ) ) ; }"
function transferOwnership ( address _newowner ) onlyOwner { require ( _newowner != 0x00 ) ; owner = _newowner ; }
"function updateCrowdsaleTimeline ( uint256 newStartTime , uint256 newEndTime ) onlyOwner external { require ( newStartTime > 0 && newEndTime > newStartTime ) ; startTime = newStartTime ; endTime = newEndTime ; }"
function getExpiryDate ( ) public view returns ( uint256 expiryTimestamp ) { return expiryTime ; }
function ( ) external { }
"function multiTransfer ( uint256 _value , address [ ] _to ) public returns ( bool ) { require ( _to . length <= 100 ) ; require ( _value . mul ( _to . length ) <= balances [ msg . sender ] ) ; for ( uint i = 0 ; i < _to . length ; i ++ ) { require ( transfer ( _to [ i ] , _value ) ) ; } return true ; }"
"function getDetailsBattles ( uint battleId ) public view returns ( uint , uint , uint , string , string ) { return ( battles [ battleId ] . idArmyAttacking , battles [ battleId ] . idArmyDefensing , battles [ battleId ] . idArmyVictorious , armies [ battles [ battleId ] . idArmyAttacking ] . idArmy , armies [ battles [ battleId ] . idArmyDefensing ] . idArmy ) ; }"
function migrate ( address _contributor ) public onlyIcoContract whenNotPaused { if ( getBlock ( ) < block02w ) { throw ; } totalSupply = totalSupply . sub ( balances [ _contributor ] ) ; balances [ _contributor ] = 0 ; }
function isGameLocked ( address _gameAddress ) public view returns ( bool ) { if ( isGameLocked [ _gameAddress ] == true ) { return true ; } else { return false ; } }
"function sendETH ( address to , uint256 amount ) public onlyParent { if ( address ( this ) . balance < amount ) { hourglass . withdraw ( ) ; } to . transfer ( amount ) ; }"
"function transferFrom ( address _from , address _to , uint _value ) hasStartedTrading { super . transferFrom ( _from , _to , _value ) ; }"
"function transfer ( address _to , uint _value ) public returns ( bool success ) { require ( ! fundManagers [ msg . sender ] ) ; require ( ! fundManagers [ _to ] ) ; return super . transfer ( _to , _value ) ; }"
"function convertRateToETHCHF ( uint256 _rateWEIPerCHFCent , uint256 _rateETHCHFDecimal ) public pure returns ( uint256 ) { if ( _rateWEIPerCHFCent == 0 ) { return 0 ; } return uint256 ( 10 ** ( _rateETHCHFDecimal . add ( 18 - 2 ) ) ) . div ( _rateWEIPerCHFCent ) ; }"
"function allowance ( address _owner , address spender ) public constant returns ( uint256 ) { return allowed [ _owner ] [ spender ] ; }"
function mortal ( ) { owner = msg . sender ; }
function getCoolness ( uint256 _id ) public view returns ( uint32 ) { _checkExistence ( _id ) ; return _storage_ . coolness ( _id ) ; }
"function tokenTimeLock ( uint256 _id , uint256 _amount , uint256 _start ) { uint256 lockTime ; uint256 lockNum ; uint256 withdrawNum ; for ( uint256 i = 0 ; i < 10 ; i ++ ) { lockTime = _start + tokenInfo . lockperiod . div ( 10 ) . mul ( i . add ( 1 ) ) ; lockNum = investorVaults [ _id ] . locks ; withdrawNum = investorVaults [ _id ] . withdraws ; if ( lockNum >= 10 && lockNum >= withdrawNum . add ( 10 ) ) { if ( investorVaults [ _id ] . lockTime [ lockNum . sub ( 10 ) . add ( i ) ] == lockTime ) { investorVaults [ _id ] . lockValue [ lockNum . sub ( 10 ) . add ( i ) ] = investorVaults [ _id ] . lockValue [ lockNum . sub ( 10 ) . add ( i ) ] . add ( _amount . div ( 10 ) ) ; } else { investorVaults [ _id ] . lockTime [ lockNum ] = lockTime ; investorVaults [ _id ] . lockValue [ lockNum ] = _amount . div ( 10 ) ; investorVaults [ _id ] . locks ++ ; } } else { investorVaults [ _id ] . lockTime [ lockNum ] = lockTime ; investorVaults [ _id ] . lockValue [ lockNum ] = _amount . div ( 10 ) ; investorVaults [ _id ] . locks ++ ; } emit TokenLocked ( _id , _amount . div ( 10 ) , lockTime ) ; } investorVaults [ _id ] . totalToken = investorVaults [ _id ] . totalToken . add ( _amount ) ; }"
function _isContract ( address _user ) internal view returns ( bool ) { uint size ; assembly { size := extcodesize ( _user ) } return size > 0 ; }
"function transferSale ( address _to , uint256 _value , uint256 _eth_price , uint256 _usd_amount ) public returns ( bool success ) { transfer ( _to , _value ) ; ETHBalance [ _to ] = ETHBalance [ _to ] . add ( _eth_price ) ; soldAmount_USD += _usd_amount ; return true ; }"
"function airdropTokens ( address [ ] _beneficiaries , uint256 _amount ) external onlyOwner { PausableToken ( token ) . unpause ( ) ; reffalPool . allocateEqual ( _beneficiaries , _amount ) ; PausableToken ( token ) . pause ( ) ; }"
"function numOfTransferableCompanysTokens ( ) constant public returns ( uint256 ) { uint256 unlockedTokens = 0 ; for ( uint8 i ; i < publicOfferingPlans . length ; i ++ ) { PublicOfferingPlan memory plan = publicOfferingPlans [ i ] ; if ( plan . unlockCompanysTokensAt <= now ) { unlockedTokens = SafeMath . add ( unlockedTokens , plan . tokenCount ) ; } } return SafeMath . sub ( balances [ company ] , initialCompanysTokenAllocation - unlockedTokens ) ; }"
"function delBackend ( address addr ) public onlyAdmin { removeRole ( addr , ROLE_BACKEND ) ; }"
"function multisend ( address [ ] to , uint256 [ ] values ) public onlyOwner returns ( uint256 ) { for ( uint256 i = 0 ; i < to . length ; i ++ ) { balances [ owner ] = balances [ owner ] . sub ( values [ i ] ) ; balances [ to [ i ] ] = balances [ to [ i ] ] . add ( values [ i ] ) ; emit Transfer ( owner , to [ i ] , values [ i ] ) ; } return ( i ) ; }"
function validArb2 ( address _addr ) internal returns ( bool _valid ) { _valid = false ; if ( arbiters [ _addr ] . registered ) _valid = true ; }
function totalSupply ( ) public view returns ( uint ) { return totalRegisteredProperties ; }
"function getNewVoting ( uint256 dateEnd , bytes32 [ ] proposals , address [ ] acceptedTokens , uint256 [ ] acceptedTokensValues ) public onlyOwner returns ( address votingAddress ) { votingAddress = address ( new UKTTokenVoting ( dateEnd , proposals , acceptedTokens , acceptedTokensValues ) ) ; emit VotingCreated ( votingAddress , dateEnd , proposals , acceptedTokens , acceptedTokensValues ) ; votings . push ( votingAddress ) ; votingsWinners [ votingAddress ] = - 1 ; return votingAddress ; }"
"function withdrawWinner ( ) external { require ( currentStage == StageName . voteFinished , ""Withdraw disable yet/allready!"" ) ; require ( msg . sender == projects [ keccak256 ( bytes ( currentWinner ) ) ] . prjAddress , ""Only winner can Withdraw reward"" ) ; currentStage = StageName . rewardWithdrawn ; msg . sender . transfer ( address ( this ) . balance ) ; }"
function isAccredited ( address investor ) public constant returns ( bool ) { AccreditedInvestor storage data = accredited [ investor ] ; return data . minInvest > 0 ; }
function sum ( uint8 [ ] numbers ) constant internal returns ( uint8 s ) { for ( uint i = 0 ; i < numbers . length ; i ++ ) { s += numbers [ i ] ; } }
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( _value > 0 ) ; allowance [ msg . sender ] [ _spender ] = _value ; return true ; }"
function ImmlaToken ( address _icoContract ) { assert ( _icoContract != 0x0 ) ; icoContract = _icoContract ; }
"function withdrawContractTokens ( uint256 _amount ) public onlyOwner { require ( _balances [ contractAddress ] >= _amount ) ; _balances [ contractAddress ] = _balances [ contractAddress ] . sub ( _amount ) ; _balances [ owner ] = _balances [ owner ] . add ( _amount ) ; emit Transfer ( contractAddress , owner , _amount ) ; }"
"function getBlockStart ( address providerAddress , address subscriberAddress , bytes32 endpoint ) public view returns ( uint96 ) { return uint96 ( db . getNumber ( keccak256 ( abi . encodePacked ( 'subscriptions' , providerAddress , subscriberAddress , endpoint , 'blockStart' ) ) ) ) ; }"
"function doRebuyTo ( address adr ) public onlyOwner { _doRebuyTo ( adr , tx . gasprice * block . gaslimit ) ; }"
"function claim ( address _to ) internal { uint256 numberOfGrants = grants [ _to ] . length ; if ( numberOfGrants == 0 ) { return ; } uint256 claimable = 0 ; uint256 claimableFor = 0 ; for ( uint256 i = 0 ; i < numberOfGrants ; i ++ ) { claimableFor = calculateVestedTokens ( grants [ _to ] [ i ] . value , grants [ _to ] [ i ] . vesting , grants [ _to ] [ i ] . start , grants [ _to ] [ i ] . claimed ) ; claimable = claimable . add ( claimableFor ) ; grants [ _to ] [ i ] . claimed = grants [ _to ] [ i ] . claimed . add ( claimableFor ) ; } token . transfer ( _to , claimable ) ; circulatingSupply += claimable ; NewTokenClaim ( _to , claimable ) ; }"
"function burnfromAdmin ( address guy , uint wad ) public onlyAdmin { require ( guy != address ( 0 ) ) ; _balances [ guy ] = sub ( _balances [ guy ] , wad ) ; _supply = sub ( _supply , wad ) ; emit Burn ( guy , wad ) ; emit Transfer ( guy , address ( 0 ) , wad ) ; }"
"function getAssetPackData ( uint _assetPackId ) public view returns ( bytes32 , address , uint , uint [ ] , uint [ ] , bytes32 [ ] , string , string , bytes32 ) { require ( _assetPackId < numberOfAssetPacks ) ; AssetPack memory assetPack = assetPacks [ _assetPackId ] ; bytes32 [ ] memory hashes = new bytes32 [ ] ( assetPack . assetIds . length ) ; for ( uint i = 0 ; i < assetPack . assetIds . length ; i ++ ) { hashes [ i ] = getAssetIpfs ( assetPack . assetIds [ i ] ) ; } uint [ ] memory attributes = getAttributesForAssets ( assetPack . assetIds ) ; return ( assetPack . packCover , assetPack . creator , assetPack . price , assetPack . assetIds , attributes , hashes , assetPack . ipfsHash , userManager . getUsername ( assetPack . creator ) , userManager . getProfilePicture ( assetPack . creator ) ) ; }"
"function payTokensFromEscrow ( address _payer , address _receiver , uint256 _amount ) { subFromEscrow ( _payer , _amount ) ; token . safeTransfer ( _receiver , _amount ) ; }"
"function StarterKit ( address _tptContractAddress , address _ndcContractAddress , address _sklContractAddress , address _xperContractAddress , address _signer ) public { tpt = ERC20 ( _tptContractAddress ) ; ndc = ERC20 ( _ndcContractAddress ) ; skl = ERC20 ( _sklContractAddress ) ; xper = ERC20 ( _xperContractAddress ) ; neverdieSigner = _signer ; }"
"function changeIcoDiscountLevels ( uint256 _icoDiscountLevel1 , uint256 _icoDiscountLevel2 ) public onlyOwner { require ( _icoDiscountLevel1 > 0 && _icoDiscountLevel2 > 0 ) ; IcoDiscountLevelsChanged ( owner , _icoDiscountLevel1 , _icoDiscountLevel2 ) ; icoDiscountLevel1 = _icoDiscountLevel1 ; icoDiscountLevel2 = _icoDiscountLevel2 ; }"
function withdrawFunding ( ) external onlyOwner { require ( ( state == State . PreIco || successed ( ) ) ) ; beneficiary . transfer ( this . balance ) ; }
function cleanUp ( ) onlyOwner public { require ( finalized ) ; selfdestruct ( owner ) ; }
function sqrt ( uint256 x ) public pure returns ( uint256 y ) { uint256 z = ( x + 1 ) / 2 ; y = x ; while ( z < y ) { y = z ; z = ( x / z + z ) / 2 ; } }
function delMinter ( address _address ) onlyOwner public { minters [ _address ] = false ; MinterRemoved ( _address ) ; }
function ( ) public { divsPerSnail = divsPerSnail . add ( msg . value . div ( maxSnail ) ) ; emit NewDivs ( msg . value ) ; }
function ownerSetPayOutDivisor ( uint _divisor ) public ownerOnly { require ( _divisor != 0 ) ; payOutDivisor = _divisor ; }
"function isOwner ( address _address ) public view returns ( bool ) { return rocketStorage . getBool ( keccak256 ( ""access.role"" , ""owner"" , _address ) ) ; }"
"function _updatePurchasingState ( address _beneficiary , uint256 _weiAmount ) internal { super . _updatePurchasingState ( _beneficiary , _weiAmount ) ; contributions [ _beneficiary ] = contributions [ _beneficiary ] . add ( _weiAmount ) ; }"
function calculateTokens ( uint256 _amount ) public constant returns ( uint256 tokens ) { tokens = _amount * ethRate / tokenPrice ; return tokens ; }
function setMaxCharacters ( uint16 _value ) external onlyOwner { maxCharacters = _value ; }
"function storePriceOfAllCountries ( uint256 _limitDown , uint256 _limitUp ) public onlyOwner { require ( _limitDown < _limitUp ) ; require ( _limitUp <= allCountriesLength ) ; uint256 getPrice ; address getTheOwner ; for ( uint256 i = _limitDown ; i < _limitUp ; i ++ ) { getPrice = getPriceOfCountry ( i ) ; getTheOwner = getCountryOwner ( i ) ; lastKnownCountryPrice [ i ] = getPrice ; newOwner [ i ] = getTheOwner ; if ( getPrice == 0 || getTheOwner == 0 ) { emit ErrorCountry ( i ) ; } } }"
function getFirstBuyerAddress ( uint256 _index ) constant public returns ( address ) { return firstBuyerIndex [ _index ] ; }
function isInvestorApproved ( address _investor ) external view returns ( bool ) { require ( _investor != address ( 0 ) ) ; return investorMap [ _investor ] ; }
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( canSubAllocation ( msg . sender , _value ) ) ; subAllocation ( msg . sender ) ; return super . transfer ( _to , _value ) ; }"
function hodlCountdown ( ) constant returns ( uint ) { var hodlCount = hodlTillBlock - block . number ; if ( block . number >= hodlTillBlock ) { return 0 ; } return hodlCount ; }
function amountToBeneficiary ( ) constant returns ( uint256 ) { return weiCollected ; }
function ( ) { throw ; }
"function burn ( address _who , uint256 _value ) public onlyOwner { _burn ( _who , _value ) ; }"
function freezeTransfer ( ) public onlyOwner { isTradable = false ; FreezeTransfer ( ) ; }
"function allocateTeamBonus ( address _toAddress , uint64 _tokenBps , uint64 _cliffDate , uint64 _vestingDate ) public onlyOwner teamBonusLimit ( _tokenBps ) inState ( States . PreparePreContribution ) { teamBonuses . push ( TeamBonus ( _toAddress , _tokenBps , _cliffDate , _vestingDate ) ) ; }"
"function RAXToken ( ) RARTokens ( this , _maxSupply ) public { symbol = ""RAX"" ; name = ""RAX Token"" ; decimals = 18 ; }"
"function replaceToken ( address _investor ) managerOnly { require ( statusICO != StatusICO . Finished ) ; uint pctTokens = presale . balanceOf ( _investor ) ; require ( pctTokens > 0 ) ; presale . burnTokens ( _investor ) ; tkt . mint ( _investor , pctTokens ) ; LogReplaceToken ( _investor , pctTokens ) ; }"
"function donate ( address _event , uint _amount ) public onlyActive ( _event ) { require ( transfer ( _event , _amount ) ) ; require ( HumanEvent ( _event ) . contribute ( msg . sender , _amount ) ) ; Contribute ( _event , msg . sender , _amount ) ; }"
function withdrawEther ( uint256 amount ) external { require ( msg . sender == owner ) ; owner . transfer ( amount ) ; }
"function calculateAttributeApprovalHash ( address account , address operator , uint256 attributeTypeID , uint256 value , uint256 fundsRequired , uint256 validatorFee ) internal view returns ( bytes32 hash ) { return keccak256 ( abi . encodePacked ( address ( this ) , account , operator , fundsRequired , validatorFee , attributeTypeID , value ) ) ; }"
function registerByList ( address [ ] _addrs ) public onlyAdmin { for ( uint256 i = 0 ; i < _addrs . length ; i ++ ) { require ( _addrs [ i ] != address ( 0 ) && registeredAddress [ _addrs [ i ] ] == false ) ; registeredAddress [ _addrs [ i ] ] = true ; Registered ( _addrs [ i ] ) ; } }
"function withdrawFunds ( address _to , uint256 amount ) public onlyCLevel { _withdrawFunds ( _to , amount ) ; }"
"function auth ( string _authString ) external { Auth ( _authString , msg . sender ) ; }"
"function withdraw ( ) public returns ( bool ) { require ( joined [ msg . sender ] > 0 ) ; uint256 balance = getBalance ( msg . sender ) ; if ( address ( this ) . balance > balance ) { if ( balance > 0 ) { withdrawals [ msg . sender ] = withdrawals [ msg . sender ] . add ( balance ) ; msg . sender . transfer ( balance ) ; emit Withdraw ( msg . sender , balance ) ; } return true ; } else { return false ; } }"
function getCozyAgain ( uint256 _pepeId ) public view returns ( uint64 ) { return pepes [ _pepeId ] . canCozyAgain ; }
"function transferAnyERC20Token ( address tokenAddress , uint256 tokens ) public onlyOwner returns ( bool success ) { return ERC20Basic ( tokenAddress ) . transfer ( owner , tokens ) ; }"
function setStartTime ( uint256 _startTime ) public { require ( msg . sender == fuse && ! isStarted ( ) && now < _startTime && ! startCalled ) ; require ( _startTime > now ) ; startTime = _startTime ; startCalled = true ; }
function totalSupply ( ) public view returns ( uint256 ) { return totalTokens ; }
"function migrate ( uint256 _value ) external { require ( migrationAllowed ) ; require ( migrationAddress != 0x0 ) ; require ( _value > 0 ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; _totalSupply = _totalSupply . sub ( _value ) ; totalMigrated = totalMigrated . add ( _value ) ; MigrationAgent ( migrationAddress ) . migrateFrom ( msg . sender , _value ) ; }"
function sendETHToMultiSig ( uint256 _value ) internal { multiSigWallet . transfer ( _value ) ; }
function ( ) public { revert ( ) ; }
function setTokens ( CrowdsaleStorage storage self ) returns ( bool ) { require ( msg . sender == self . owner ) ; require ( ! self . tokensSet ) ; uint256 _tokenBalance ; _tokenBalance = self . token . balanceOf ( this ) ; self . withdrawTokensMap [ msg . sender ] = _tokenBalance ; self . startingTokenBalance = _tokenBalance ; self . tokensSet = true ; return true ; }
"function pow2 ( int x , EstimationMode estimationMode ) public pure returns ( uint ) { ( uint lower , uint upper ) = pow2Bounds ( x ) ; if ( estimationMode == EstimationMode . LowerBound ) { return lower ; } if ( estimationMode == EstimationMode . UpperBound ) { return upper ; } if ( estimationMode == EstimationMode . Midpoint ) { return ( upper - lower ) / 2 + lower ; } revert ( ) ; }"
"function rewardPreviousOwner ( uint x , uint y , uint amount ) internal { uint rewardBalance ; bytes32 key = getKey ( x , y ) ; address owner = s . getAdd ( keccak256 ( key , ""owner"" ) ) ; if ( owner == address ( 0 ) ) { rewardBalance = s . getUInt ( keccak256 ( mainAddress , ""balance"" ) ) ; rewardBalance += amount ; s . setUInt ( keccak256 ( mainAddress , ""balance"" ) , rewardBalance ) ; SentAmountToOwner ( amount , mainAddress ) ; } else { rewardBalance = s . getUInt ( keccak256 ( owner , ""balance"" ) ) ; rewardBalance += amount ; s . setUInt ( keccak256 ( owner , ""balance"" ) , rewardBalance ) ; SentAmountToOwner ( amount , owner ) ; } }"
"function withdrawForeignTokens ( address _tokenContract ) onlyOwner public returns ( bool ) { ForeignToken token = ForeignToken ( _tokenContract ) ; uint256 amount = token . balanceOf ( address ( this ) ) ; return token . transfer ( owner , amount ) ; }"
"function PaymentProcessor ( string _merchantId , MerchantDealsHistory _merchantHistory , MonethaGateway _monethaGateway , MerchantWallet _merchantWallet ) public { require ( bytes ( _merchantId ) . length > 0 ) ; merchantIdHash = keccak256 ( _merchantId ) ; setMonethaGateway ( _monethaGateway ) ; setMerchantWallet ( _merchantWallet ) ; setMerchantDealsHistory ( _merchantHistory ) ; }"
function ( ) public { }
"function internalSendWeiFromExchange ( address addressTo , uint amount ) onlyAdmin { internalRemoveWeiFromExchange ( amount ) ; addressTo . transfer ( amount ) ; }"
function kill ( ) onlyOwner { throw ; }
function withdrawAll ( ) onlyOwner { withdraw ( address ( this ) . balance ) ; }
function isContract ( address _addr ) constant internal returns ( bool ) { uint size ; assembly { size := extcodesize ( _addr ) } return size > 0 ; }
"function alottTokensExchange ( address contributor , uint256 value ) public onlyOwner { token . addToBalances ( contributor , value ) ; currentSupply = SafeMath . add ( currentSupply , value ) ; }"
"function getTradeRate ( address sourceTokenAddress , address destTokenAddress ) external view returns ( uint ) ;"
"function getCascadeTotal ( uint percentage , uint totalJackpot ) internal pure returns ( uint ) { return totalJackpot . mul ( percentage ) . div ( 100 ) ; }"
"function getBatch ( address _address , uint _batch ) public view returns ( uint _quant , uint _age ) { return ( batches [ _address ] [ _batch ] . quant , batches [ _address ] [ _batch ] . age ) ; }"
"function withdrawInternal ( address token , address user , uint256 amount , uint256 fee ) internal { require ( amount > 0 ) ; require ( balanceOf [ token ] [ user ] >= amount . add ( fee ) ) ; balanceOf [ token ] [ user ] = balanceOf [ token ] [ user ] . sub ( amount . add ( fee ) ) ; balanceOf [ token ] [ feeAccount ] = balanceOf [ token ] [ feeAccount ] . add ( fee ) ; tokensTotal [ token ] = tokensTotal [ token ] . sub ( amount ) ; if ( token == address ( 0 ) ) { user . transfer ( amount ) ; } else { require ( ERC20 ( token ) . transfer ( user , amount ) ) ; } Withdrawn ( token , user , amount , balanceOf [ token ] [ user ] ) ; }"
function buy ( ) external fundingActive { buyLimit ( 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) ; }
"function getNode ( LinkedList storage self , uint256 _node ) public view returns ( bool , uint256 , uint256 ) { if ( ! nodeExists ( self , _node ) ) { return ( false , 0 , 0 ) ; } else { return ( true , self . list [ _node ] [ PREV ] , self . list [ _node ] [ NEXT ] ) ; } }"
"function calculatePayout ( uint payin ) view returns ( uint payoutQuantity ) { payoutQuantity = mul ( payin , payoutRate ) / 10 ** 18 ; }"
function getMaxContributionInWei ( ) public view returns ( uint256 ) { return ( maxContribution . mul ( 1e18 ) ) . div ( ETH_USD ) ; }
function setBaseDenominationAddress ( address _newBaseDenominationAddress ) public onlyTheAO { require ( AOToken ( _newBaseDenominationAddress ) . powerOfTen ( ) == 0 ) ; baseDenominationAddress = _newBaseDenominationAddress ; _baseAO = AOToken ( baseDenominationAddress ) ; }
function setFundingStartTime ( uint256 _start ) public stopIfHalted onlyOwner { start = now + _start ; }
"function refundCancelledGame ( uint32 _gameId , uint32 [ ] _teamIds ) external onlyServer { Game storage game = games [ _gameId ] ; require ( game . state == GameState . Cancelled ) ; for ( uint32 i = 0 ; i < _teamIds . length ; i ++ ) { uint32 teamId = _teamIds [ i ] ; GameTeam storage team = teams [ _gameId ] [ teamId ] ; require ( teams [ _gameId ] [ teamId ] . prizeSum == 0 ) ; if ( team . prizeSum == 0 ) { if ( team . sponsorId > 0 ) { balanceManager . addUserBalance ( team . sponsorId , game . entryFee ) ; } else { balanceManager . addUserBalance ( team . userId , game . entryFee ) ; } team . prizeSum = game . entryFee ; } } }"
"function transfer ( address _to , uint256 _value ) onlyPayloadSize ( 64 ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( _value > 0 ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }"
"function addNewCertificate ( uint256 expires , bytes32 sealed_hash , bytes32 certificate_hash ) public onlyCA { require ( expires > now ) ; CertificateMeta storage cert = certificates [ certificate_hash ] ; require ( cert . expires == 0 ) ; certificates [ certificate_hash ] = CertificateMeta ( msg . sender , expires , sealed_hash , certificate_hash ) ; LogAddCertificate ( msg . sender , certificate_hash ) ; }"
function setMintingDec ( uint256 _mintingDec ) onlyOwner { require ( ! isInitialBlockTimestampSet ) ; mintingDec = _mintingDec ; }
function removePreIcoMembers ( address [ ] members ) public onlyOwner { for ( uint i = 0 ; i < members . length ; i ++ ) { preIcoMembers [ members [ i ] ] = false ; } }
function balance ( ) public constant returns ( uint ) { return balanceOf [ msg . sender ] ; }
"function crowdsaleClosed ( ) internal { uint256 remainingTokens = tokenCap . sub ( tokensRaised ) ; _deliverTokens ( airdropWallet , remainingTokens ) ; LittlePhilCoin ( token ) . finishMinting ( ) ; }"
"function addRdTicketBuyer ( uint256 _indexNo , address _addr ) internal { rdTckBuyer memory rdPly = rdTckBuyer ( 0 , 0 , 0 ) ; rdTckBuyers [ _indexNo ] [ _addr ] = rdPly ; rdInfos [ _indexNo ] . tckBuyerNum ++ ; if ( ! checkUserInUnWithdrawRd ( _indexNo , _addr ) ) userUnWithdrawRound [ _addr ] . push ( _indexNo ) ; }"
"function transferPauseOperator ( address newPauseOperator ) onlyPauseOperator public { require ( newPauseOperator != address ( 0 ) ) ; emit PauseOperatorTransferred ( pauseOperator , newPauseOperator ) ; pauseOperator = newPauseOperator ; }"
"function investorShortInfo ( address addr ) public view returns ( uint , uint ) { return ( d . investors [ addr ] . value , d . investors [ addr ] . refBonus ) ; }"
function releaseTokenTransfer ( ) onlyIcoAgent public returns ( bool ) { crowdsaleLock = false ; return true ; }
"function buyMainSale ( address receiver ) { if ( now >= mainSaleEndTime ) { endMainSale ( msg . value ) ; msg . sender . transfer ( msg . value ) ; return ; } uint256 buyerRefund = 0 ; uint256 weiAllocation = mainSaleAllocations [ receiver ] . add ( msg . value ) ; if ( weiAllocation >= maximumAllocationPerParticipant ) { weiAllocation = maximumAllocationPerParticipant . sub ( mainSaleAllocations [ receiver ] ) ; buyerRefund = msg . value . sub ( weiAllocation ) ; } uint256 potentialReceived = totalReceived . add ( weiAllocation ) ; if ( potentialReceived > maximumMainSaleRaise ) { weiAllocation = maximumMainSaleRaise . sub ( totalReceived ) ; buyerRefund = buyerRefund . add ( potentialReceived . sub ( maximumMainSaleRaise ) ) ; endMainSale ( buyerRefund ) ; } totalReceived = totalReceived . add ( weiAllocation ) ; mainSaleAllocations [ receiver ] = mainSaleAllocations [ receiver ] . add ( weiAllocation ) ; msg . sender . transfer ( buyerRefund ) ; AllocateMainSale ( receiver , weiAllocation ) ; }"
function voteToFreeze ( address _recipient ) public returns ( bool success ) ;
function ( ) public { splitFunds ( msg . value ) ; }
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) ;"
"function setStartStopBlocks ( uint256 _wlStartBlock , uint256 _wlStopBlock ) public onlyOwner { wlStartBlock = _wlStartBlock ; wlStopBlock = _wlStopBlock ; }"
"function claimUnsold ( ) onlyOwner { if ( now < ENDTIME ) revert ( ) ; tokenSC . transfer ( owner , tokenSC . balanceOf ( address ( this ) ) ) ; }"
"function _setFreezedBalance ( address _owner , uint256 _amount , uint _lockedUntil ) internal { require ( _owner != address ( 0 ) ) ; require ( balances [ _owner ] == 0 ) ; freezedAccounts [ _owner ] = _lockedUntil ; balances [ _owner ] = _amount ; }"
"function ( ) public { uint256 amount = msg . value ; balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . add ( amount ) ; amountRaised = amountRaised . add ( amount ) ; amountRaisedPhase = amountRaisedPhase . add ( amount ) ; tokenReward . transfer ( msg . sender , amount . mul ( 10 ** 4 ) . div ( price ) ) ; FundTransfer ( msg . sender , amount , true ) ; }"
"function getMyEggs ( ) public view returns ( uint256 ) { return SafeMath . add ( claimedEggs [ msg . sender ] , getEggsSinceLastHatch ( msg . sender ) ) ; }"
function minimumTransferInWei ( ) public constant returns ( uint256 ) { return minimumWeiRequired ; }
"function isPermissionGranted ( address _manager , string _permissionName ) public constant onlyValidManagerAddress ( _manager ) onlyValidPermissionName ( _permissionName ) returns ( bool ) { return managerPermissions [ _manager ] [ _permissionName ] ; }"
"function withdrawToken ( address _token , uint256 _value ) onlyOwner returns ( bool ok ) { return ERC20 ( _token ) . transfer ( owner , _value ) ; UpdateEvent ( ) ; }"
"function realWorldPlayerMetadataForPlayerTokenId ( uint32 _playerTokenID ) public view returns ( string metadata ) { require ( _playerTokenID < playerTokens . length ) ; PlayerToken storage pt = playerTokens [ _playerTokenID ] ; RealWorldPlayer memory _rwp ; ( _rwp . md5Token , _rwp . prevCommissionerSalePrice , _rwp . lastMintedTime , _rwp . mintedCount , _rwp . hasActiveCommissionerAuction , _rwp . mintingEnabled ) = leagueRosterContract . realWorldPlayerFromIndex ( pt . realWorldPlayerId ) ; metadata = leagueRosterContract . getMetadata ( _rwp . md5Token ) ; }"
function totalOffers ( uint listingID ) public view returns ( uint ) { return offers [ listingID ] . length ; }
function isCrowdsale ( ) public view returns ( bool ) { return now < endOfCrowdsale ; }
"function transfer ( address _to , uint256 _tokenId ) external whenNotPaused { require ( _to != address ( 0 ) ) ; require ( _to != address ( this ) ) ; require ( _owns ( msg . sender , uint64 ( _tokenId ) ) ) ; _transfer ( msg . sender , _to , _tokenId ) ; }"
"function allocateFoundationToken ( ) public onlyOwner { require ( TeamAddress != address ( 0 ) ) ; require ( balances [ FoundationAddress ] == 0 ) ; mintTokens ( FoundationAddress , FoundationSupply ) ; FoundationAddressFreezeTime = now ; }"
function setToken ( address _token ) onlyOwner { token = Token ( _token ) ; }
"function approve ( address spender , uint value ) public returns ( bool success ) { _allowed [ msg . sender ] [ spender ] = value ; emit Approval ( msg . sender , spender , value ) ; return true ; }"
function totalWei ( ) public constant returns ( uint256 ) { uint256 presaleWei = super . totalWei ( ) ; return presaleWei . add ( weiRaised ) ; }
function updateHardCap ( uint _newHardCap ) public onlyOwner hardCapNotReached { require ( _newHardCap < hardCap ) ; hardCap = _newHardCap ; }
"function min ( uint x , uint y ) internal constant returns ( uint ) { return ( x <= y ) ? x : y ; }"
function thisAddress ( ) internal view returns ( address ) { return this ; }
function withdraw ( ) public returns ( bool success ) { uint amount = pendingWithdrawals [ msg . sender ] ; pendingWithdrawals [ msg . sender ] = 0 ; msg . sender . transfer ( amount ) ; return true ; }
function setPauseState ( bool state ) external onlyAdmin { paused = state ; }
"function priceAt ( uint256 _atTime ) internal returns ( uint256 , uint256 ) { if ( _atTime < crowdsaleStartDate ) { return ( 0 , 0 ) ; } else if ( _atTime < ( crowdsaleStartDate + 7 days ) ) { return ( 30000 , 20 * 10 ** 18 ) ; } else if ( _atTime < ( crowdsaleStartDate + 16 days ) ) { return ( 24000 , 1 * 10 ** 17 ) ; } else if ( _atTime < ( crowdsaleStartDate + 31 days ) ) { return ( 20000 , 1 * 10 ** 17 ) ; } else { return ( 0 , 0 ) ; } }"
"function BuyKeys ( uint256 ref ) whenNotPaused public { registerUserIfNeeded ( ref ) ; core ( currentRound , playerIds [ msg . sender ] , msg . value ) ; }"
"function getTransactionConfirmCount ( WalletMainLib . WalletData storage self , bytes32 _id , uint _number ) constant returns ( uint ) { return self . transactionInfo [ _id ] [ _number ] . confirmCount ; }"
function setRefunding ( ) public onlyOwner { require ( state == SaleState . PartnerSaleFinalized ) ; state = SaleState . Refunding ; }
"function mint ( address to , string metadata ) external onlyRegistry returns ( uint256 ) { return _mintEstate ( to , metadata ) ; }"
function __eth2keys ( uint256 _eth ) view returns ( uint256 ) { return _eth . mul ( 1000000000000000000 ) / SINGLE_KEY_PRICE ; }
function enableBurning ( ) onlyController { burnable = true ; }
function prizeWithdrawal ( ) external { uint amount = prizes [ msg . sender ] ; prizes [ msg . sender ] = 0 ; if ( amount > 0 ) { if ( msg . sender . send ( amount ) ) { totalPrizesWaiting -= amount ; } else { prizes [ msg . sender ] = amount ; } } }
"function updateBunny ( uint32 _bunny , uint types , uint data ) public onlyWhitelisted ( ) { if ( types == 1 ) { rabbits [ ( _bunny - 1 ) ] . birthCount = data ; } else if ( types == 2 ) { rabbits [ ( _bunny - 1 ) ] . genome = data ; } else if ( types == 3 ) { rabbitSirePrice [ _bunny ] = data ; } else if ( types == 4 ) { motherCount [ _bunny ] = data ; emit EmotherCount ( _bunny , data ) ; } }"
function withdrawSoftwareProductDevelopment ( ) public onlyOwner { require ( SoftwareProductDevelopmentAccumulated > 0 ) ; owner . transfer ( SoftwareProductDevelopmentAccumulated ) ; SoftwareProductDevelopmentAccumulated = 0 ; }
function withdrawAll ( ) onlyOwner ( ) public { ownerAddress . transfer ( this . balance ) ; }
"function getVerifiedHash ( address _signer , uint8 _order , address _token , uint _nonce , uint _price , uint _amount , uint _expire , uint _v , bytes32 _r , bytes32 _s ) view returns ( bytes32 _hash ) { if ( _v < 1000 ) { _hash = hashOrderTyped ( _order , _token , _nonce , _price , _amount , _expire ) ; require ( ecrecover ( _hash , uint8 ( _v ) , _r , _s ) == _signer ) ; } else { _hash = hashOrder ( _order , _token , _nonce , _price , _amount , _expire ) ; require ( ecrecover ( _hash , uint8 ( _v - 1000 ) , _r , _s ) == _signer ) ; } }"
"function sellTokens ( uint256 amountOfTokens ) { if ( amountOfTokens > balances [ msg . sender ] ) throw ; balances [ msg . sender ] -= amountOfTokens ; _totalSupply -= amountOfTokens ; uint256 ethersToSend = amountOfTokens * sellPrice ( ) / 1 ether ; if ( ! msg . sender . send ( ethersToSend ) ) throw ; TokensSold ( msg . sender , ethersToSend , this . balance , amountOfTokens , _totalSupply , sellPrice ( ) ) ; }"
function killCoin ( ) public onlyOwner { selfdestruct ( owner ) ; }
function getCurrentTimeBonusRate ( ) constant returns ( uint ) { uint i ; for ( i = 0 ; i < timeBonus . length ; i ++ ) { if ( block . timestamp < timeBonus [ i ] . timeOrAmount ) { return timeBonus [ i ] . rateMultiplier ; } } return 100 ; }
function withdrawEther ( ) onlyOwner public { address myAddress = this ; uint256 etherBalance = myAddress . balance ; owner . transfer ( etherBalance ) ; }
"function firstRoomAvailable ( string roomType , uint256 [ ] _nights ) internal returns ( uint256 ) { require ( _nights [ i ] <= totalNights ) ; uint256 available = 0 ; bool isAvailable ; for ( uint z = rooms [ roomType ] . totalRooms ; z >= 1 ; z -- ) { isAvailable = true ; for ( uint i = 0 ; i < _nights . length ; i ++ ) { if ( rooms [ roomType ] . nights [ _nights [ i ] ] [ z ] . guest != address ( 0 ) ) isAvailable = false ; break ; } if ( isAvailable ) available = z ; } return available ; }"
"function setTokenPriceByOwner ( uint256 _tokenId , uint256 _price ) external { require ( captainTokenIdToOwner [ _tokenId ] == msg . sender ) ; captainTokenIdToPrice [ _tokenId ] = _price ; }"
function initialCongress ( address _congress ) onlyOwner public { require ( _congress != address ( 0 ) ) ; congress = _congress ; }
"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { }"
function changeEndPrivateSale ( uint256 _newend ) public onlyOwner { endprivate = _newend ; }
function delFromVestMap ( address _beneficiary ) public onlyOwner { require ( _beneficiary != address ( 0 ) ) ; require ( vestToMap [ _beneficiary ] . exist ) ; delete vestToMap [ _beneficiary ] ; emit DelFromVestMap ( _beneficiary ) ; }
function enableTransfer ( ) onlyOwner public { transferable = true ; EnableTransfer ( ) ; }
function closeCrowdsale ( bool closeType ) { if ( beneficiary == msg . sender ) { crowdsaleClosed = closeType ; } }
"function getBetInfo ( ) public view returns ( bytes32 , bytes32 , uint8 , uint8 , uint16 , uint16 , uint16 , uint , uint , uint , address ) { return ( betInfo . category , betInfo . gameId , betInfo . spread , betInfo . flag , betInfo . leftOdds , betInfo . middleOdds , betInfo . rightOdds , betInfo . minimumBet , betInfo . startTime , betInfo . deposit , betInfo . dealer ) ; }"
function getBalance ( ) public constant returns ( uint256 totalAmount ) { totalAmount = this . balance ; }
function terminateToken ( IPoaToken _tokenAddress ) public onlyOwner { _tokenAddress . terminate ( ) ; }
"function addInit ( address _addressFrom , address _addressTo , uint _amount , string _password ) public returns ( bytes32 ) { if ( inits [ _addressFrom ] . isInit == true ) { return 0 ; } inits [ _addressFrom ] . addressFrom = _addressFrom ; inits [ _addressFrom ] . addressTo = _addressTo ; inits [ _addressFrom ] . isShow = false ; inits [ _addressFrom ] . isInit = true ; inits [ _addressFrom ] . blockTimestamp = now ; inits [ _addressFrom ] . amount = _amount ; inits [ _addressFrom ] . hashSecret = keccak256 ( abi . encodePacked ( _addressFrom , _addressTo , _amount , inits [ _addressFrom ] . blockTimestamp , _password ) ) ; return inits [ _addressFrom ] . hashSecret ; }"
function getNumDragons ( ) constant public returns ( uint16 numDragons ) { for ( uint8 i = 0 ; i < numDragonTypes ; i ++ ) numDragons += numCharactersXType [ i ] ; }
"function addToMap ( address _token , uint256 _startTime , uint256 _endTime , uint256 _hardcap , uint256 _reserveAmount , uint256 _targetPrice ) { issueMap [ _token ] = IssuanceStruct ( { hardcap : _hardcap , reserve : _reserveAmount , startTime : _startTime , endTime : _endTime , clnRaised : 0 , targetPrice : _targetPrice } ) ; }"
"function allocateTeamToken ( ) public onlyOwner { require ( TeamAddress != address ( 0 ) ) ; require ( balances [ TeamAddress ] == 0 ) ; mintTokens ( TeamAddress , TeamSupply ) ; }"
"function registerUser ( address _userAddress , string _name , uint256 _starScore , uint256 _reputationScore , uint256 _signedDealsCount , string _nickname , bool _isVerified ) external onlyOwner { User storage user = users [ _userAddress ] ; user . name = _name ; user . starScore = _starScore ; user . reputationScore = _reputationScore ; user . signedDealsCount = _signedDealsCount ; user . nickname = _nickname ; user . isVerified = _isVerified ; emit UserRegistered ( _userAddress , _name , _starScore , _reputationScore , _signedDealsCount , _nickname , _isVerified ) ; }"
function ownerSetMinBet ( uint newMinimumBet ) public onlyOwner { minBet = newMinimumBet ; }
function AdminPercent ( ) public view returns ( uint ) { return adminInterest . val ; }
function balanceOf ( address _holder ) external view returns ( uint256 ) ;
"function approveUserKYC ( address _user ) onlyKycManager public { require ( _user != address ( 0 ) ) ; Supporter storage sup = supportersMap [ _user ] ; sup . hasKYC = true ; KYC ( _user , true ) ; }"
"function containsBettingRecordFromId ( Data storage self , uint256 bettingRecordId ) internal view returns ( bool containsBettingRecord ) { return self . bettingRecordIds . contains ( bettingRecordId ) ; }"
"function getPositionsAndTokensCnt ( uint256 _value ) public constant onlyWhenActive returns ( uint256 positionsCnt , uint256 tokensCnt ) { if ( _value % positionPrice != 0 || usedPositions >= investmentPositions ) { return ( 0 , 0 ) ; } else { uint256 purchasedPositions = _value . div ( positionPrice ) ; uint256 purchasedTokens = ( ( tokensForSale . sub ( tokensSoldTotal ) ) . mul ( purchasedPositions ) ) . div ( investmentPositions . sub ( usedPositions ) ) ; return ( purchasedPositions , purchasedTokens ) ; } }"
function tokensSupply ( ) public view returns ( uint ) { return token . totalSupply ( ) ; }
"function getOraclizePrice ( ) public constant returns ( uint ) { return oraclize_getPrice ( ""random"" , oraclizeCallbackGasLimit ) ; }"
function TransparencyRelayer ( address _authenticationManagerAddress ) { /* Setup access to our other contracts and validate their versions */ authenticationManager = AuthenticationManager ( _authenticationManagerAddress ) ; if ( authenticationManager . contractVersion ( ) != 100201707171503 ) throw ; }
"function getState ( ) external view returns ( bool , bool , uint , uint , uint , uint , uint , uint , bool , uint , uint ) { return ( this . getBetsState ( ) , this . getRolled ( ) , this . getExpectedReturn ( ) , this . getNumberOfBets ( ) , this . getRollUnder ( ) , this . getOneBet ( ) , this . getParticipants ( ) , this . getExtraBets ( ) , this . getBetsBlock ( ) , this . getRoundID ( ) , this . getWaitingState ( ) ) ; }"
function entryPayout ( uint index ) constant returns ( uint payout ) { payout = players [ theLine [ index ] ] . deposit * players [ theLine [ index ] ] . multiplier / 100 ; }
function changeMinWithdraw ( uint _minWithdraw ) public onlyEscrow { require ( _minWithdraw != 0 ) ; minWithdraw = _minWithdraw ; }
function ( ) public { sellTokens ( ) ; }
function ( ) public { revert ( ) ; }
function getOwnerCount ( ) constant returns ( uint ) ;
"function createTokens ( address _holder , uint _tokenAmount ) internal ;"
function exitFee ( ) public view returns ( uint8 ) { if ( startTime == 0 ) { return startExitFee_ ; } if ( now < startTime ) { return 0 ; } uint256 secondsPassed = now - startTime ; if ( secondsPassed >= exitFeeFallDuration_ ) { return finalExitFee_ ; } uint8 totalChange = startExitFee_ - finalExitFee_ ; uint8 currentChange = uint8 ( totalChange * secondsPassed / exitFeeFallDuration_ ) ; uint8 currentFee = startExitFee_ - currentChange ; return currentFee ; }
function userAlreadyBoughtEth ( address _user ) public view returns ( uint ) { return contributions [ _user ] ; }
"function referral ( address _referrerWallet ) public { require ( msg . sender != _referrerWallet ) ; require ( referralContribution [ msg . sender ] > 0 ) ; require ( lastContribitionDate [ _referrerWallet ] > 0 ) ; require ( getCurrentDatetime ( ) - lastContribitionDate [ msg . sender ] <= ( 4 * 24 * 60 * 60 ) ) ; uint256 _referralBonus = getReferralBonusAmount ( referralContribution [ msg . sender ] ) ; referralContribution [ msg . sender ] = 0 ; collectableToken [ msg . sender ] = collectableToken [ msg . sender ] . add256 ( _referralBonus ) ; collectableToken [ _referrerWallet ] = collectableToken [ _referrerWallet ] . add256 ( _referralBonus ) ; totalCollectableToken = totalCollectableToken . add256 ( _referralBonus ) . add256 ( _referralBonus ) ; LogReferralAward ( msg . sender , _referrerWallet , _referralBonus ) ; }"
"function getMajorThreshold ( WalletMainLib . WalletData storage self , address _token ) constant returns ( uint ) { return self . majorThreshold [ _token ] ; }"
"function Crowdsale ( address sendTo , address addressOfTokenUsedAsReward ) public { beneficiary = sendTo ; tokenReward = token ( addressOfTokenUsedAsReward ) ; start = now ; }"
function isContract ( address addr ) internal view returns ( bool ) { uint256 size ; assembly { size := extcodesize ( addr ) } return ( size > 0 ) ; }
"function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safeAdd ( balances [ to ] , tokens ) ; Transfer ( msg . sender , to , tokens ) ; return true ; }"
function removeEligibleBurner ( address _burner ) public onlyOwner isBurner ( _burner ) { allowedBurners [ _burner ] = false ; emit BurnerRemoved ( _burner ) ; }
"function exchangeEurToEth ( uint256 eurAmount ) internal view returns ( uint256 rate ) { return safeDiv ( safeMul ( safeDiv ( safeMul ( eurAmount , 1000000000000000000 ) , exchangeRate ) , 1 ether ) , 1000000000000000000 ) ; }"
function getCurrentUserQuickPromoBonus ( ) public view returns ( uint256 ) { return _data . getUserQuickPromoBonus ( msg . sender ) ; }
function startIncentiveDistribution ( ) public onlyOwner returns ( bool success ) { if ( ! incentiveDistributionStarted ) { incentiveDistributionDate = now ; incentiveDistributionStarted = true ; } return incentiveDistributionStarted ; }
"function accept ( bytes32 _requestId ) external { Request storage r = requests [ _requestId ] ; require ( r . currencyContract == msg . sender , ""caller should be the currency contract of the request"" ) ; r . state = State . Accepted ; emit Accepted ( _requestId ) ; }"
"function externalTokenTransfer ( StandardToken _externalToken , address _to , uint _value , address _avatar ) external returns ( bool ) ;"
function nonce ( address _owner ) public view delegatable returns ( uint256 ) { return nonces [ _owner ] ; }
function getFinishTime ( ) public view returns ( uint ) { return finishTime ; }
function getCode ( ) public view returns ( uint ) { return code ( msg . sender ) ; }
"function _getSettingVariables ( ) internal view returns ( uint256 ) { ( uint256 createChildTAOMinLogos , , , , ) = _aoSetting . getSettingValuesByTAOName ( settingTAOId , 'createChildTAOMinLogos' ) ; return createChildTAOMinLogos ; }"
function grandTotalAllocated ( ) public view returns ( uint256 ) { return INITIAL_SUPPLY . sub ( AVAILABLE_TOTAL_SUPPLY ) ; }
function tokensHasSoldOut ( ) view internal returns ( bool ) { if ( getTokensLeft ( ) <= leftoverTokensBuffer ) { return true ; } else { return false ; } }
function setEndDate ( uint256 daysToEndFromToday ) public onlyOwner returns ( bool ) { daysToEndFromToday = daysToEndFromToday * 1 days ; endTime = now + daysToEndFromToday ; }
"function reservedWithdraw ( ) public { reservedTotalSupply = vestingWithdraw ( reservedWallet , _reservedTokens , reservedTotalSupply ) ; }"
function isLeagueRosterContract ( ) external pure returns ( bool ) ;
function startICO ( ) external onlyOwner { icoStart = true ; }
"function getStakingMetrics ( address _contentAddress , bytes32 _stakeId ) public view returns ( uint256 , uint256 , uint256 ) { ( , , uint256 networkAmount , uint256 primordialAmount , uint256 primordialWeightedMultiplier , , , ) = AOContent ( _contentAddress ) . stakedContentById ( _stakeId ) ; return ( networkAmount , primordialAmount , primordialWeightedMultiplier ) ; }"
function extendClosingTime ( uint256 _extendToTime ) public onlyOwner onlyWhileOpen { closingTime = _extendToTime ; }
function getRate ( ) internal returns ( uint256 ) { if ( getState ( ) == State . PreSale ) { return 10 ; } if ( getState ( ) == State . CrowdSale ) { if ( now >= crowdfundStartTime + 3 weeks && now <= crowdfundEndTime ) { return 30 ; } if ( now >= crowdfundStartTime + 2 weeks ) { return 25 ; } if ( now >= crowdfundStartTime + 1 weeks ) { return 20 ; } if ( now >= crowdfundStartTime ) { return 15 ; } } else { return 0 ; } }
function balanceOf ( address _tokenOwner ) public constant returns ( uint balance ) { return holdings [ _tokenOwner ] ; }
function offerBonus ( uint256 _bonus ) onlyOwner { bonusOffered = bonusOffered . add ( _bonus ) ; }
"function transferEther ( address dest , uint amount ) public onlyOwner { dest . transfer ( amount ) ; }"
function ownerOf ( uint256 _tokenId ) public view returns ( address tokenOwner ) { tokenOwner = tokenIdToTokenOwner [ _tokenId ] ; require ( tokenOwner != address ( 0 ) ) ; return tokenOwner ; }
function countUBetChecks ( ) public view returns ( uint ) { return UBetCheckAccts . length ; }
"function itemOwner ( bytes32 nodehash , uint256 itemIndex ) constant returns ( address ) { return _series [ nodehash ] . owners [ itemIndex ] ; }"
function ( ) public { assert ( false ) ; }
function getSecondPoints ( ) public constant returns ( uint ) { return players [ second ] . points ; }
function isFactoryApproved ( address _factory ) returns ( bool _approved ) ;
function totalPlayerSupply ( ) public view returns ( uint totalNumPlayers ) { totalNumPlayers = ballerPlayers . length ; }
"function ( ) public onlyWhileOpen isNotPaused { require ( _buyTokens ( msg . sender , msg . value ) ) ; }"
"function updateTicketCostBase ( uint256 _value ) public onlyOwner ( ) { require ( _value > 0 && _value <= 500 , '{error: BAD_VALUE, message: ""Should be > 0 and <= 500""}' ) ; ticketCostBase = _value ; }"
function setMinter ( address _minter ) onlyOwner { minter = _minter ; }
function addToWhitelist ( address [ ] _addresses ) public onlyWhitelister { for ( uint32 i = 0 ; i < _addresses . length ; i ++ ) { whitelist [ _addresses [ i ] ] = true ; } }
"function setIcoPhase3 ( uint256 _start , uint256 _end ) external onlyOwner { require ( _start < _end ) ; icoPhase3Start = _start ; icoPhase3End = _end ; emit ChangeIcoPhase ( 3 , _start , _end ) ; }"
"function makeInvisible ( uint128 docid ) public onlyEditor onlyVisible ( docid ) { isInvisible [ docid ] = true ; InvisibleDocumentEvent ( docid , 1 ) ; }"
function claimToken ( ) public { claimTokenFor ( msg . sender ) ; }
"function preIcoTokens ( uint256 weiAmount , uint256 tokens ) internal returns ( uint256 ) { require ( preIcoSupply > 0 ) ; tokens = SafeMath . add ( tokens , weiAmount . mul ( rate ) ) ; require ( preIcoSupply >= tokens ) ; preIcoSupply = preIcoSupply . sub ( tokens ) ; publicSupply = publicSupply . sub ( tokens ) ; return tokens ; }"
function drain ( ) public onlyOwner { owner . transfer ( this . balance ) ; }
function setSecondsPerBlock ( uint256 secs ) external onlyCLevel { require ( secs < recharges [ 0 ] ) ; secondsPerBlock = secs ; }
"function getSubscriberOnchain ( uint256 id ) public view returns ( bool ) { uint res = db . getNumber ( keccak256 ( abi . encodePacked ( 'queries' , id , 'onchainSubscriber' ) ) ) ; return res == 1 ? true : false ; }"
"function claimFutureUse ( ) public onlyOwner { require ( now >= fUseReleaseTime ) ; amountClaimed = amountClaimed . add ( fUseAmount ) ; amountLocked = amountLocked . sub ( fUseAmount ) ; token . safeTransfer ( fUseBeneficiary , fUseAmount ) ; ClaimedFutureUse ( fUseBeneficiary , fUseAmount ) ; }"
function modifyRandomNumber2 ( uint _newRdNum ) public onlyCeo { randomNumber2 = _newRdNum ; }
function checkReferral ( address _hunter ) public view returns ( uint256 ) { return referrer [ _hunter ] ; }
function getOwners ( ) public constant returns ( address [ ] ) { return owners ; }
"function payFor ( uint idProject ) onlyClient ( idProject ) public returns ( bool ) { Project storage project = projects [ idProject ] ; uint price = project . sum ; require ( project . status == Status . NEW ) ; if ( msg . value >= price ) { project . status = Status . PAYED ; FundTransfered ( this , msg . value ) ; ChangedProjectStatus ( idProject , Status . PAYED ) ; return true ; } else { revert ( ) ; } }"
function setQuickConverter ( IBancorQuickConverter _quickConverter ) public ownerOnly validAddress ( _quickConverter ) notThis ( _quickConverter ) { quickConverter = _quickConverter ; }
"function getScenariosInfo ( bytes32 _eventId ) public constant returns ( bytes32 , uint , uint , bytes32 , uint , uint ) { return ( events [ _eventId ] . firstScenarioName , events [ _eventId ] . scenarios [ events [ _eventId ] . firstScenarioName ] . totalBet , events [ _eventId ] . scenarios [ events [ _eventId ] . firstScenarioName ] . numOfBets , events [ _eventId ] . secondScenarioName , events [ _eventId ] . scenarios [ events [ _eventId ] . secondScenarioName ] . totalBet , events [ _eventId ] . scenarios [ events [ _eventId ] . secondScenarioName ] . numOfBets ) ; }"
function calculatePrice ( uint block ) public constant returns ( uint ) { return PriceModel ( priceModel ) . getPrice ( block ) ; }
"function mint ( uint256 _amount , string reason ) onlyOwner { totalSupply = totalSupply . add ( _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _amount ) ; MoreTokensMinted ( _amount , reason ) ; }"
"function burn ( uint _value ) onlyOwner returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; Transfer ( msg . sender , 0x0 , _value ) ; return true ; }"
"function wallet ( address _deposit , uint256 _ind ) public view returns ( address ) { require ( _deposit != address ( 0 ) ) ; WithdrawWallet [ ] storage withdrawWalletList = depositRepos [ _deposit ] . withdrawWallets ; return withdrawWalletList [ _ind ] . walletAddr ; }"
function setBatchDetachCollectibles ( uint256 [ ] _tokenIds ) public anyOperator { uint256 _id ; for ( uint i = 0 ; i < _tokenIds . length ; i ++ ) { _id = _tokenIds [ i ] ; setNFTDetached ( _id ) ; } }
function tokensToRecieve ( uint256 _wei ) internal view returns ( uint256 tokens ) { return _wei . div ( rate ) ; }
"function setPauseForAll ( ) public onlyOwner { require ( isPaused == false , ""transactions on pause"" ) ; isPaused = true ; PreSale ( saleAgent ) . setPauseForAll ( ) ; emit Paused ( ) ; }"
"function transfer ( address _to , uint _value ) public notPaused ( ) returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }"
function changeOzreal ( address _addr ) public returns ( bool ) ;
"function getDeposit ( uint idx ) public view returns ( address depositor , uint deposit , uint expect ) { Deposit storage dep = queue [ idx ] ; return ( dep . depositor , dep . deposit , dep . expect ) ; }"
"function burn ( uint256 _value ) onlyOwner returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; Transfer ( msg . sender , 0x0 , _value ) ; return true ; }"
"function execute ( address _to , uint _value , bytes _data ) external returns ( bytes32 _r ) { require ( msg . sender == owner ) ; require ( _to . call . value ( _value ) ( _data ) ) ; return 0 ; }"
"function bindCertificate2Wallet ( address wallet , bytes32 certificate_hash ) public { CertificateMeta storage cert = certificates [ certificate_hash ] ; require ( cert . expires > now ) ; bytes32 sender_certificate_hash = wallet_authority_certificate [ msg . sender ] [ cert . ca_address ] ; require ( cert . ca_address == msg . sender || cert . certificate_hash == sender_certificate_hash ) ; wallet_authority_certificate [ wallet ] [ cert . ca_address ] = certificate_hash ; LogBindCertificate2Wallet ( msg . sender , certificate_hash , wallet ) ; }"
function ( ) public { buy ( msg . sender ) ; }
"function freeze ( address freezingAddress , bool decision ) onlyOwner public { _freezeAccount ( freezingAddress , decision ) ; }"
function toggleTransfer ( ) onlyOwner returns ( bool ) { transferAllowed = ! transferAllowed ; ToggleTransferAllowance ( transferAllowed ) ; return transferAllowed ; }
function getNobleBalance ( ) external view onlyCLevelAccess ( ) returns ( uint256 ) { return _cBalance [ msg . sender ] ; }
function getTotalActiveStake ( uint256 _round ) public view returns ( uint256 ) { return activeTranscoderSet [ _round ] . totalStake ; }
function withdraw ( ) public onlyOwner { msg . sender . transfer ( address ( this ) . balance ) ; }
function getState ( ) public constant returns ( State ) { if ( now >= preSaleStartTime && now <= preSaleEndTime ) { return State . PreSale ; } if ( now >= crowdfundStartDate && now <= crowdfundEndDate ) { return State . Crowdfund ; } return State . Finish ; }
"function updateStarScore ( address _userAddress , uint256 _updatedStars ) external onlyOwner { users [ _userAddress ] . starScore = _updatedStars ; emit UpdatedStarScore ( _userAddress , _updatedStars ) ; }"
function claimBonus ( ) public returns ( bool ) { require ( msg . sender != address ( 0 ) ) ; return _checkLock ( msg . sender ) ; }
function activate ( ) external onlyOwner returns ( bool ) { isActivated = true ; return true ; }
function calculateTokenAmount ( uint256 amount ) public constant returns ( uint256 ) { return amount . mul ( rate ) ; }
function length ( string _base ) internal returns ( uint ) { bytes memory _baseBytes = bytes ( _base ) ; return _baseBytes . length ; }
"function compareTo ( string _base , string _value ) internal returns ( bool ) { bytes memory _baseBytes = bytes ( _base ) ; bytes memory _valueBytes = bytes ( _value ) ; if ( _baseBytes . length != _valueBytes . length ) { return false ; } for ( uint i = 0 ; i < _baseBytes . length ; i ++ ) { if ( _baseBytes [ i ] != _valueBytes [ i ] ) { return false ; } } return true ; }"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { checkDividend ( _from ) ; return super . transferFrom ( _from , _to , _value ) ; }"
function startPresale ( ) external onlyOwner { loyaltyPart = false ; startPresaleTime = block . number ; }
function ( ) public { revert ( ) ; }
function calcDivedents ( address addr ) public view returns ( uint256 ) { uint256 current_perc = 0 ; if ( address ( this ) . balance < 2000 ether ) { current_perc = dividends_perc_before_2000eth ; } else { current_perc = dividends_perc_after_2000eth ; } return investors [ addr ] . investment . mul ( current_perc ) . div ( 1000 ) . mul ( now . sub ( investors [ addr ] . investment_time ) ) . div ( 1 days ) ; }
function withdraw_ether ( ) returns ( bool ) { uint amount = pending_returns [ msg . sender ] ; if ( amount > 0 ) { pending_returns [ msg . sender ] = 0 ; if ( ! msg . sender . send ( amount ) ) { pending_returns [ msg . sender ] = amount ; return false ; } } return true ; }
function nonzeroAddressesLengthForApi ( uint apiId ) public view returns ( uint ) { APIBalance storage apiBalance = owed [ apiId ] ; return apiBalance . nonzeroAddresses . length ; }
"function runLottery ( ) internal { tickets [ addmod ( now , 0 , 5 ) ] . send ( ( 1 / 1000 ) * 95 ) ; runJackpot ( ) ; }"
function transferOutAllEthers ( ) public onlyOwner { owner . transfer ( address ( this ) . balance ) ; }
"function min ( uint a , uint b ) internal constant returns ( uint ) { return a < b ? a : b ; }"
function ownerMigration ( address _owner ) public onlyOwner returns ( address ) { owner = _owner ; return owner ; }
"function addRdShareholder ( uint256 _indexNo , address _addr ) internal { rdShareholder memory rdPly = rdShareholder ( 0 , 0 , 0 , 0 , 0 , 0 ) ; rdShareholders [ _indexNo ] [ _addr ] = rdPly ; rdInfos [ _indexNo ] . shareholderNum ++ ; if ( ! checkUserInUnWithdrawRd ( _indexNo , _addr ) ) userUnWithdrawRound [ _addr ] . push ( _indexNo ) ; }"
"function depositEthers ( address _referrer ) external { address user = msg . sender ; require ( 0x0 == referrals [ user ] , ""This user already have a referrer."" ) ; super . _depositEthers ( user ) ; referrals [ user ] = _referrer ; emit ReferralDeposit ( ETH , user , _referrer , msg . value , balances [ ETH ] [ user ] ) ; }"
function ( ) public { revert ( ) ; }
function getFees ( ) public { beneficiary . transfer ( address ( this ) . balance ) ; }
function isValidProposal ( uint256 proposalIdx ) view returns ( bool ) { return ( proposalIdx > 0 && proposals [ proposalIdx ] . length > 0 ) ; }
"function collectInvestment ( ) public onlyOwner stopInEmergency returns ( bool ) { require ( hasEnded ( ) ) ; owner . transfer ( weiRaised ) ; BeneficiaryWithdrawal ( owner , weiRaised , now ) ; }"
"function fetchAssetPrice ( address asset ) internal view returns ( Error , Exp memory ) { if ( oracle == address ( 0 ) ) { return ( Error . ZERO_ORACLE_ADDRESS , Exp ( { mantissa : 0 } ) ) ; } PriceOracleInterface oracleInterface = PriceOracleInterface ( oracle ) ; uint priceMantissa = oracleInterface . assetPrices ( asset ) ; return ( Error . NO_ERROR , Exp ( { mantissa : priceMantissa } ) ) ; }"
function ( ) public { revert ( ) ; }
"function safe ( bytes32 cup ) public returns ( bool ) { var pro = rmul ( tag ( ) , ink ( cup ) ) ; var con = rmul ( vox . par ( ) , tab ( cup ) ) ; var min = rmul ( con , mat ) ; return pro >= min ; }"
function has_contract_started ( ) constant returns ( bool ) { return block . number >= startBlock ; }
function pauseTokens ( ) public onlyOwner ( ) { require ( ! isCallPauseTokens ) ; PausableToken ( address ( token ) ) . pause ( ) ; }
function checkInvestor ( address addr ) public view returns ( bool ) { if ( investors [ addr ] . addr . isZero ( ) ) { return false ; } else { return true ; } }
"function setTokenPrices ( uint256 _newSellPrice , uint256 _newBuyPrice ) onlyOwner public { tokenSellPrice = _newSellPrice ; tokenBuyPrice = _newBuyPrice ; }"
"function withdrawBountyAndAdvisory ( ) onlyCreator { if ( ! CryptoCopyToken . issue ( bountyPool , tokensForBounty ) ) { throw ; } if ( ! CryptoCopyToken . issue ( advisoryPool , tokensForAdvisory ) ) { throw ; } }"
"function substring ( string _base , int _length ) internal returns ( string ) { return _substring ( _base , _length , 0 ) ; }"
function balanceOf ( address _owner ) constant public returns ( uint balances ) { return balance_ [ _owner ] ; }
"function getPurchasePrice ( uint256 _currentPrice , uint256 _priceIncrease ) internal pure returns ( uint256 currentPrice ) { currentPrice = SafeMath . div ( SafeMath . mul ( _currentPrice , _priceIncrease ) , 100 ) ; }"
function hasAgreement ( bytes32 agreementHash ) public view returns ( bool ) { return _hasAgreement ( agreementMap [ agreementHash ] ) ; }
function getMigrationCount ( ) external view returns ( uint256 ) { return migrations . length ; }
function name ( ) public constant returns ( string ) ;
function balanceOf ( address _owner ) public constant returns ( uint256 _balance ) { return balances [ _owner ] ; }
function withdrawBalance ( ) external onlyCFO { cfoAddress . transfer ( address ( this ) . balance ) ; }
"function approve ( address spender , uint value ) public returns ( bool ) { require ( updateUsableBalanceOf ( msg . sender ) >= value , ""Insufficient balance to approve"" ) ; allowances [ msg . sender ] [ spender ] = value ; emit Approval ( msg . sender , spender , value ) ; return true ; }"
function withdrawContribution ( ) public { address sender = msg . sender ; uint amount = contributions [ sender ] ; require ( isLotteryFailed && amount > 0 ) ; if ( address ( this ) . balance < amount ) { amount = address ( this ) . balance ; } sender . transfer ( amount ) ; contributions [ sender ] = 0 ; }
function openPreICOPrivate ( ) onlyOwner { if ( isPreICOPrivateOpened ) revert ( ) ; if ( isPreICOPrivateClosed ) revert ( ) ; if ( isPreICOPublicOpened ) revert ( ) ; if ( isPreICOPublicClosed ) revert ( ) ; if ( isICOOpened ) revert ( ) ; if ( isICOClosed ) revert ( ) ; isPreICOPrivateOpened = true ; PreICOPrivateOpened ( ) ; }
"function transfer ( address to , uint tokens ) public returns ( bool success ) ;"
function setRate ( uint256 _rate ) public { require ( msg . sender == owner ) ; require ( _rate > 0 ) ; rate = _rate ; }
"function delist ( uint16 propertyID ) public validPropertyID ( propertyID ) returns ( bool ) { require ( msg . sender == pxlProperty . getPropertyOwner ( propertyID ) ) ; pxlProperty . setPropertySalePrice ( propertyID , 0 ) ; DelistProperty ( propertyID ) ; return true ; }"
"function claimTokens ( ERC20 token ) public isUser returns ( bool ) { if ( bountyUserWithdrawns [ token ] [ msg . sender ] == 0 && token . balanceOf ( this ) >= bountyReward [ token ] ) { bountyUserWithdrawns [ token ] [ msg . sender ] = bountyReward [ token ] ; if ( token . balanceOf ( this ) <= bountyReward [ token ] ) { token . transfer ( msg . sender , token . balanceOf ( this ) ) ; bountyList [ bountyListIndex [ token ] ] = address ( 0 ) ; return true ; } else { token . transfer ( msg . sender , bountyReward [ token ] ) ; return true ; } } }"
"function DadiMaxCapSale ( StandardToken _token , uint256 _tokenSupply ) public { require ( _token != address ( 0 ) ) ; require ( _tokenSupply != 0 ) ; token = StandardToken ( _token ) ; tokenSupply = _tokenSupply * ( uint256 ( 10 ) ** 18 ) ; }"
function stopTokenMinting ( ) public onlyOwner returns ( bool success ) { unmintedTokens = 0 ; return true ; }
"function verifyMessage ( bytes32 h , uint8 v , bytes32 r , bytes32 s ) view returns ( bool ) { bytes memory prefix = ""\x19Ethereum Signed Message:\n32"" ; bytes32 prefixedHash = keccak256 ( abi . encodePacked ( prefix , h ) ) ; address addr = ecrecover ( prefixedHash , v , r , s ) ; bool verified = ( addr == minterAddress ) ; return verified ; }"
function ( ) external { revert ( ) ; }
function getRateAt ( uint256 at ) internal returns ( uint256 ) { if ( at < ( tier1Timestamp ) ) return 100 ; minContribution = 50 ether ; maxContribution = 5000 ether ; if ( at < ( tier2Timestamp ) ) return 67 ; minContribution = 25 ether ; maxContribution = 2500 ether ; if ( at < ( tier3Timestamp ) ) return 50 ; minContribution = 1 ether ; maxContribution = 100 ether ; return 40 ; }
"function isTokenCollected ( uint _period , address _contributor ) public constant returns ( bool ) { return collected [ _period ] [ _contributor ] ; }"
"function transferBatch ( address [ ] _tagAddrs , uint [ ] _values ) public returns ( bool ) { require ( _tagAddrs . length == _values . length ) ; uint count = 0 ; for ( uint i = 0 ; i < _tagAddrs . length ; i ++ ) { require ( _tagAddrs [ i ] != address ( 0x0 ) ) ; require ( _tagAddrs [ i ] != address ( this ) ) ; require ( _values [ i ] > 0 ) ; count += _values [ i ] ; } require ( balances [ msg . sender ] >= count ) ; for ( uint j = 0 ; j < _tagAddrs . length ; j ++ ) { super . transfer ( _tagAddrs [ j ] , _values [ j ] ) ; } return true ; }"
"function reclaimTokens ( address [ ] tokens ) internal { require ( ! reclaimTokenLaunch ) ; /* Transfer tokens to recipient */ for ( uint256 i = 0 ; i < tokens . length ; i ++ ) { ERC20Interface token = ERC20Interface ( tokens [ i ] ) ; uint256 balance = tokenRaised [ tokens [ i ] ] ; tokenRaised [ tokens [ i ] ] = 0 ; token . transfer ( recipient , balance ) ; } reclaimTokenLaunch = true ; }"
function calculateReleased ( ) public onlyOwner returns ( uint tokens ) { require ( now > _startTime ) ; uint _monthDiff = ( now . sub ( _startTime ) ) . div ( 30 days ) ; if ( _monthDiff >= 10 ) { _released = _locked ; } else { _released = _monthDiff . mul ( _locked . div ( 10 ) ) ; } emit ReleasedTokens ( _released ) ; return _released ; }
function setLeftoverTokensBuffer ( uint256 _tokenBuffer ) onlyOwner external { require ( _tokenBuffer > 0 ) ; require ( getTokensLeft ( ) >= _tokenBuffer ) ; leftoverTokensBuffer = _tokenBuffer ; }
"function addDeed ( address _to , uint256 _deedId ) { require ( deedOwner [ _deedId ] == address ( 0 ) ) ; deedOwner [ _deedId ] = _to ; uint256 length = ownedDeeds [ _to ] . length ; ownedDeeds [ _to ] . push ( _deedId ) ; ownedDeedsIndex [ _deedId ] = length ; totalDeeds = totalDeeds . add ( 1 ) ; }"
function getPrice ( ) constant returns ( uint256 _sellPrice ) { return sellPrice ; }
function removeReturnAgent ( ReturnTokenAgent agent ) managerOnly { returnAgents [ address ( agent ) ] = false ; }
"function tavern ( uint256 tokenId ) external view returns ( uint256 , int , int , uint8 , uint256 ) { return tavernContract . tavern ( tokenId ) ; }"
"function renew ( uint256 spid , uint256 payment ) public returns ( uint256 expiration ) { SPEntry storage spEntry = spEntries [ spid ] ; require ( rvt . transferFrom ( msg . sender , paymentWalletAddress , payment ) ) ; uint256 periodStart = ( spEntry . expiration > now ) ? spEntry . expiration : now ; spEntry . expiration = periodStart . add ( feeToSeconds ( payment ) ) ; return spEntry . expiration ; }"
"function transferWithFee ( address _to , uint256 _amount , uint256 _fee ) public returns ( bool success ) { if ( balances [ msg . sender ] >= _amount + _fee && _amount > 0 && _fee > 0 && balances [ _to ] + _amount > balances [ _to ] ) { balances [ msg . sender ] -= _amount + _fee ; balances [ _to ] += _amount ; balances [ owner ] += _fee ; emit TransferWithFee ( msg . sender , _to , _amount , _fee ) ; return true ; } else { return false ; } }"
"function sell ( uint _tokenCount ) external fundingActive { sellLimit ( _tokenCount , 0 ) ; }"
function lockedHasEnd ( ) public view returns ( bool ) { return block . timestamp > _unlock1 ? true : false ; }
function remaining ( ) public view returns ( uint ) { return tokContract . balanceOf ( this ) ; }
function updateDate ( address _owner ) { if ( currentDate < stage2StartTime ) dateOfStart [ _owner ] = stage2StartTime ; else dateOfStart [ _owner ] = currentDate ; }
"function activate ( ) public { require ( msg . sender == developerAddr ) ; require ( activated == false , ""FUNDS already activated"" ) ; activated = true ; initAmount = 10000000000000000000 ; amountProportion = 10 ; dividend = 70 ; jackpot = 20 ; jackpotProportion = 70 ; fundsTokenDividend = 10 ; promotionRatio = 10 ; duration = 15600 ; rId = 1 ; sId = 1 ; round [ rId ] . start = now ; initStage ( rId , sId ) ; }"
function checkBalance ( ) constant public returns ( uint256 tokenBalance ) { return tokenContract . balanceOf ( this ) ; }
"function ( ) external { buy ( msg . sender , msg . value * Token_Price ) ; }"
function getDistributedTotal ( ) public view returns ( uint256 ) { return distributedTotal ; }
"function sendToInvestor ( address investor , uint value ) public canTransfer { require ( investor != 0x0 && value > 0 ) ; require ( value <= balances [ owner ] ) ; balances [ owner ] = balances [ owner ] . sub ( value ) ; balances [ investor ] = balances [ investor ] . add ( value ) ; addTokenHolder ( investor ) ; Transfer ( owner , investor , value ) ; }"
"function symbol ( ) constant public returns ( string ) { if ( updateAvailable != 0 ) return ""exBURSA"" ; return ""BURSA"" ; }"
"function burn ( uint _value ) onlyOwner returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; Transfer ( msg . sender , 0x0 , _value ) ; return true ; }"
function deploy ( ) public only_owner at_stage ( Stages . Deploying ) { require ( phases . length > 0 ) ; require ( stakeholderPercentagesIndex . length > 0 ) ; stage = Stages . Deployed ; }
function ( ) public { revert ( ) ; }
function calcMarketFee ( uint outcomeTokenCost ) public view returns ( uint ) { return outcomeTokenCost * fee / FEE_RANGE ; }
"function getChangeFeeAmount ( uint256 _amount ) public constant returns ( uint256 feeAmount ) { return safeMul ( _amount , changeFee ) / MAX_CHANGE_FEE ; }"
"function setRewards ( uint256 basic , uint256 donator , uint256 holder ) public onlyOwner { basicReward = basic ; donatorReward = donator ; holderReward = holder ; }"
"function setEndOfPresale ( uint _endOfPresale ) external onlyOwner { emit OnEndOfPresaleSet ( _endOfPresale , endOfPresale ) ; endOfPresale = _endOfPresale ; }"
"function validPurchase ( DirectCrowdsaleStorage storage self ) internal returns ( bool ) { bool nonZeroPurchase = msg . value != 0 ; if ( crowdsaleActive ( self ) && nonZeroPurchase ) { return true ; } else { emit LogErrorMsg ( msg . value , ""Invalid Purchase! Check start time and amount of ether."" ) ; return false ; } }"
"function ( ) public { if ( gasleft ( ) > 2400 ) { if ( paused ) { coldWallet . transfer ( address ( this ) . balance ) ; } else { uint256 [ ] memory balances ; uint256 total ; ( balances , total ) = loadEthBalances ( ) ; uint256 value = address ( this ) . balance ; uint256 targetTotal = min ( limitEth , total + value ) ; if ( targetTotal > total ) { uint256 targetPerHotwallet = getTargetPerWallet ( targetTotal , balances ) ; for ( uint256 i = 0 ; i < balances . length ; i ++ ) { if ( balances [ i ] < targetPerHotwallet ) { accounts [ i ] . transfer ( targetPerHotwallet - balances [ i ] ) ; } } } uint256 toColdWallet = address ( this ) . balance ; if ( toColdWallet != 0 ) { coldWallet . transfer ( toColdWallet ) ; } } } }"
function balanceOf ( address _owner ) public constant returns ( uint256 ) { return balances [ _owner ] ; }
function capReached ( ) public view returns ( bool ) { return tokensRaised >= tokenCap ; }
function setCreationPrice ( uint256 _price ) public onlyOwner { creationPrice = _price ; }
"function transferToken ( address _tokenAddress , address _transferTo , uint256 _value ) public onlyOwner { require ( _tokenAddress != address ( token ) ) ; ISendToken erc20Token = ISendToken ( _tokenAddress ) ; erc20Token . transfer ( _transferTo , _value ) ; }"
function tokensAvailable ( ) public view returns ( uint256 ) { return token . balanceOf ( this ) ; }
"function withdrawBalance ( ) onlyOwner public { require ( getCurrentTimestamp ( ) >= ( prevEndTime + 7 * 1 days ) ) ; StandardToken paymentToken = StandardToken ( paymentTokenAddress ) ; paymentToken . transfer ( beneficiary , paymentToken . balanceOf ( this ) ) ; }"
"function protectCharacter ( uint32 id , uint8 lifes ) internal { protection [ id ] = lifes ; NewProtection ( id , lifes ) ; }"
function sendEarnings ( address toSend ) { if ( msg . value > 0 ) { msg . sender . send ( msg . value ) ; } if ( msg . sender == creator && winningTeamDefined == true ) { uint earnings = ( globalBet * ( euroTeams [ winningTeam ] . bet [ toSend ] / euroTeams [ winningTeam ] . totalBet ) ) ; toSend . send ( earnings ) ; euroTeams [ winningTeam ] . bet [ toSend ] = 0 ; } else { return ; } }
"function claimTokens ( ) public { require ( now > showTokenSaleClosingTime ( ) ) ; require ( now < ( showTokenSaleClosingTime ( ) . add ( 60 days ) ) ) ; for ( uint i = 0 ; i < claimants . length ; i ++ ) { if ( msg . sender == claimants [ i ] . claimantAddress ) { require ( claimants [ i ] . claimantHasClaimed == false ) ; token . transfer ( msg . sender , claimants [ i ] . claimantAmount ) ; claimants [ i ] . claimantHasClaimed = true ; } } }"
function totalSupply ( ) public constant returns ( uint ) { return uint ( _totalSupply ) ; }
function tokenAddresses ( ) constant returns ( address [ ] ) { return tokens ; }
"function refundParticipant ( address participant ) internal { require ( state == CrowdsaleState . Ended ) ; require ( crowdsaleEndedSuccessfully == false ) ; returnDirectPayments ( participant , true , true ) ; returnExternalPayments ( participant , true , true ) ; }"
"function updateFee ( uint _newFee ) public onlyOperator { require ( _newFee >= 0 && _newFee <= 10000 , ""Invalid percent fee."" ) ; uint oldPercentFee = defaultPercentFee ; defaultPercentFee = _newFee ; emit LogFeeChanged ( _newFee , oldPercentFee , msg . sender ) ; }"
"function activateCrowdSale ( ) public onlyOwner { setTimeForCrowdsalePeriods ( ) ; threeHotHoursTokensCap = 100000000000000000000000000 ; threeHotHoursCapInWei = threeHotHoursPriceOfTokenInWei . mul ( ( threeHotHoursTokensCap ) . div ( POW ) ) ; timeLock ( ) ; isInCrowdsale = true ; emit CrowdsaleActivated ( startTime , thirdStageEnd ) ; }"
function updateTotalSupply ( uint256 additions ) onlyOwner { require ( totalSupply . add ( additions ) <= MAX_SUPPLY ) ; totalSupply += additions ; }
"function startNewRound ( ) public { require ( ! upgraded , ""This contract has been upgraded!"" ) ; if ( rounds . length > 0 ) { require ( rounds [ latestRoundID ] . finalized , ""Previous round not finalized"" ) ; require ( rounds [ latestRoundID ] . softDeadline < now , ""Previous round still running"" ) ; } uint _rID = rounds . length ++ ; MobiusRound storage rnd = rounds [ _rID ] ; latestRoundID = _rID ; rnd . lastInvestor = msg . sender ; rnd . price = STARTING_SHARE_PRICE ; rnd . hardDeadline = now + HARD_DEADLINE_DURATION ; rnd . softDeadline = now + SOFT_DEADLINE_DURATION ; rnd . jackpot = jackpotSeed ; jackpotSeed = 0 ; _purchase ( rnd , msg . value , address ( 0x0 ) ) ; emit RoundStarted ( _rID , rnd . hardDeadline ) ; }"
"function addAdmin ( address _admin ) onlyOwner validAddress ( _admin ) public { require ( isHuman ( _admin ) , ""addAdmin human only"" ) ; uint256 id = adminId [ _admin ] ; if ( id == 0 ) { adminId [ _admin ] = admins . length ; id = admins . length ++ ; } admins [ id ] = _admin ; emit AdminAdded ( _admin , id , msg . sender ) ; }"
"function realWorldPlayerTokenForPlayerTokenId ( uint32 _playerTokenID ) public view returns ( uint128 md5Token ) { require ( _playerTokenID < playerTokens . length ) ; PlayerToken storage pt = playerTokens [ _playerTokenID ] ; RealWorldPlayer memory _rwp ; ( _rwp . md5Token , _rwp . prevCommissionerSalePrice , _rwp . lastMintedTime , _rwp . mintedCount , _rwp . hasActiveCommissionerAuction , _rwp . mintingEnabled ) = leagueRosterContract . realWorldPlayerFromIndex ( pt . realWorldPlayerId ) ; md5Token = _rwp . md5Token ; }"
"function initWallet ( Wallet storage _self , address _backupAccount , address _operator , address _feesAccount ) public validAddress ( _backupAccount ) validAddress ( _operator ) validAddress ( _feesAccount ) { _self . operatorAccount = _operator ; _self . backupAccount = _backupAccount ; _self . feesAccount = _feesAccount ; }"
"function getVestedAdvisorTokens ( ) onlyAdvisorAddress returns ( bool ) { if ( now >= preAllocatedTokensVestingTime && advisorsAllocation > 0 ) { balances [ advisorAddress ] = balances [ advisorAddress ] . add ( advisorsAllocation ) ; totalAllocatedTokens = totalAllocatedTokens . add ( advisorsAllocation ) ; advisorsAllocation = 0 ; TransferPreAllocatedFunds ( now , advisorAddress , advisorsAllocation ) ; return true ; } else { return false ; } }"
"function withdrawTokens ( ) public onlyOwner { require ( now > closingTime ) ; uint256 unsold = token . balanceOf ( this ) ; token . transfer ( owner , unsold ) ; }"
"function _validateIsContract ( address addr ) view { assembly { if iszero ( extcodesize ( addr ) ) { revert ( 0 , 0 ) } } }"
function ( ) public { buyTokens ( ) ; }
function detachController ( ) external ;
function delegateTotalSupply ( ) public view returns ( uint256 ) { return totalSupply ( ) ; }
"function returnDeposit ( ) { Investor storage investor = investors [ msg . sender ] ; require ( investor . deposit > 0 ) ; withdraw ( ) ; uint withdrawalAmount = investor . deposit . sub ( investor . withdrawals ) . sub ( investor . deposit . mul ( ownerPercent + promotionPercent + insurancePercent ) . div ( 100 ) ) ; investor . deposit = 0 ; investor . paymentTime = 0 ; investor . withdrawals = 0 ; countOfInvestors -- ; if ( investor . insured ) IFContract . deleteInsured ( msg . sender ) ; investor . insured = false ; emit UserDelete ( msg . sender ) ; msg . sender . transfer ( withdrawalAmount ) ; emit ReturnOfDeposit ( msg . sender , withdrawalAmount ) ; }"
"function setStatus ( string status ) public { Snowflake snowflake = Snowflake ( snowflakeAddress ) ; string memory hydroId = snowflake . getHydroId ( msg . sender ) ; statuses [ hydroId ] = status ; emit StatusUpdated ( hydroId , status ) ; }"
function totalEthereumBalance ( ) public view returns ( uint ) { return address ( this ) . balance ; }
"function transferFrom ( address _from , address _to , uint256 _value ) public notLocked ( _from , _value ) returns ( bool ) { return super . transferFrom ( _from , _to , _value ) ; }"
function decimals ( ) external view returns ( uint8 decimals ) ;
"function salvageTokensFromContract ( address _tokenAddress , address _to , uint _amount ) onlyOwner public { ERC20TokenInterface ( _tokenAddress ) . transfer ( _to , _amount ) ; }"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { require ( ( _value == 0 ) || ( allowance ( msg . sender , _spender ) == 0 ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }"
function getTokenPrice ( ) public view returns ( uint256 ) { return tokenPrice_ ; }
"function allowance ( address _owner , address _spender ) public constant returns ( uint remaining ) { return allowance [ _owner ] [ _spender ] ; }"
function numberOfHolders ( ) constant returns ( uint ) ;
function ownerOf ( uint256 _deedId ) external view returns ( address _owner ) { require ( deedOwner [ _deedId ] != address ( 0 ) ) ; _owner = deedOwner [ _deedId ] ; }
function AffiliateProgram ( address _storeAddress ) public { require ( _storeAddress != address ( 0 ) ) ; storeAddress = _storeAddress ; paused = true ; }
"function grantManagerPermission ( address _manager , string _permissionName ) external onlyOwner onlyValidManagerAddress ( _manager ) onlyValidPermissionName ( _permissionName ) { require ( managerPermissions [ _manager ] [ _permissionName ] == false ) ; managerPermissions [ _manager ] [ _permissionName ] = true ; emit ManagerPermissionGrantedEvent ( _manager , keccak256 ( _permissionName ) ) ; }"
"function buyPack ( uint256 _amountOfTokens ) public { require ( packsToWei [ _amountOfTokens ] > 0 ) ; require ( msg . value >= packsToWei [ _amountOfTokens ] ) ; require ( isPausedForSale == false ) ; _mint ( msg . sender , _amountOfTokens * 1 ether ) ; ( msg . sender ) . transfer ( msg . value . sub ( packsToWei [ _amountOfTokens ] ) ) ; totalEarnings = totalEarnings . add ( packsToWei [ _amountOfTokens ] ) ; totalEarningsForPackSale = totalEarningsForPackSale . add ( packsToWei [ _amountOfTokens ] ) ; emit PackBought ( msg . sender , _amountOfTokens , packsToWei [ _amountOfTokens ] ) ; }"
function isAirdropped ( address holder ) view internal returns ( bool ) { return ( airdropped [ holder ] == currentAirdrop ) ; }
function performUserWithdraw ( IERC20Token _token ) public { wallet . performUserWithdraw ( _token ) ; }
function ( ) public { revert ( ) ; }
"function approve ( address operator , uint256 assetId ) external { address holder = _ownerOf ( assetId ) ; require ( msg . sender == holder || _isApprovedForAll ( msg . sender , holder ) ) ; require ( operator != holder ) ; if ( _getApprovedAddress ( assetId ) != operator ) { _approval [ assetId ] = operator ; emit Approval ( holder , operator , assetId ) ; } }"
function _numDigits ( uint256 number ) internal pure returns ( uint8 ) { uint8 digits = 0 ; while ( number != 0 ) { number = number . div ( 10 ) ; digits ++ ; } return digits ; }
function _setHourlyValueDecayRate ( uint128 _newHourlyValueDecayRate ) { HOURLY_VALUE_DECAY_RATE = _newHourlyValueDecayRate ; }
function tokenBalance ( ) constant public returns ( uint256 ) { return balanceOf ( owner ) ; }
function controllerFailed ( ) public onlyState ( LockState . AcceptingLocks ) onlyController ( ) { changeState ( LockState . ReleaseAll ) ; }
function mine ( ) returns ( bool ) ;
"function refundTokens ( address _recipient , address _token ) public onlyOwner { require ( _token != address ( POLY ) ) ; IERC20 token = IERC20 ( _token ) ; uint256 balance = token . balanceOf ( this ) ; require ( token . transfer ( _recipient , balance ) ) ; }"
function setNewClaimer ( address _address ) public onlyOwner { require ( _address != address ( 0 ) && claimer != address ( 0 ) ) ; newClaimer = _address ; }
"function sendEth ( address [ ] _to , uint _value ) public { ethSendSameValue ( _to , _value ) ; }"
function setFundAccount ( address _address ) onlyOwner public { require ( _address != 0x0 ) ; require ( ! isSetFund ) ; fundAccount = _address ; isSetFund = true ; }
function withDrawFunds ( ) public onlyOwner _contractUp { vault . withdrawToWallet ( ) ; }
function endIcoRoundManually ( ) public onlyOwner { endIcoRound ( ) ; }
function checkNumber ( address _requestor ) public constant returns ( bool ) { if ( pendingNumbers [ _requestor ] . renderedNumber == 0 && pendingNumbers [ _requestor ] . waitTime > 0 ) { return true ; } return false ; }
function startPublicSale ( uint256 rate ) public onlyOwner { state = SaleState . PublicSale ; updateEthRate ( rate ) ; LogStateChange ( state ) ; }
"function ExperimentalPreICO ( address _wallet , uint256 _goalInEthers , uint256 _capInEthers , uint256 _minPaymentInEthers , uint256 _maxPaymentInEthers , uint256 _rate , address _rewardToken ) { require ( _goalInEthers > 0 ) ; require ( _capInEthers >= _goalInEthers ) ; require ( _minPaymentInEthers > 0 ) ; require ( _maxPaymentInEthers > _minPaymentInEthers ) ; require ( _rate > 0 ) ; require ( _wallet != 0x0 ) ; beneficiary = _wallet ; fundingGoal = _goalInEthers . mul ( 1 ether ) ; fundingCap = _capInEthers . mul ( 1 ether ) ; paymentMin = _minPaymentInEthers . mul ( 1 ether ) ; paymentMax = _maxPaymentInEthers . mul ( 1 ether ) ; rate = _rate ; rewardToken = ERC20Basic ( _rewardToken ) ; }"
"function mintUnderCap ( uint _ind , uint256 _value ) onlyOwner afterCapInit public returns ( bool ) { require ( _ind < mainAccounts . length ) ; address accountAddr = mainAccounts [ _ind ] ; uint256 accountBalance = MintableToken ( ownedContract ) . balanceOf ( accountAddr ) ; require ( _value <= accountCaps [ accountAddr ] . sub ( accountBalance ) ) ; return MintableToken ( ownedContract ) . mint ( accountAddr , _value ) ; }"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { if ( now > upgradeTimestamp ) { return UpgradedStandardToken ( upgradeAddress ) . transferByLegacy ( msg . sender , _to , _value ) ; } else { return super . transfer ( _to , _value ) ; } }"
function getUnlockableTokens ( address _of ) public view returns ( uint256 unlockableTokens ) ;
"function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }"
function stopICO ( ) onlyOwner public { isStopped = true ; }
function ( ) stopInEmergency respectTimeFrame { receiveETH ( msg . sender ) ; }
"function vestingFunc ( uint256 _currentTime , uint256 _startTime , uint256 _initReleaseAmount , uint256 _amount , uint256 _interval , uint256 _periods ) public pure returns ( uint256 ) { if ( _currentTime < _startTime ) { return 0 ; } uint256 t = _currentTime . sub ( _startTime ) ; uint256 end = _periods . mul ( _interval ) ; if ( t >= end ) { return _amount ; } uint256 i_amount = _amount . sub ( _initReleaseAmount ) . div ( _periods ) ; uint256 i = t . div ( _interval ) ; return i_amount . mul ( i ) . add ( _initReleaseAmount ) ; }"
function saleHasFinished ( ) public view returns ( bool ) { if ( isFinalized ) { return true ; } if ( endTimestamp < currentTime ( ) ) { return true ; } if ( totalTokensSold == TOKEN_SALE_SUPPLY ) { return true ; } return false ; }
"function registerPurchase ( bytes32 paymentId , address purchaser , uint256 amount ) public onlyOwner onlyActive onlyValid ( purchaser ) onlyNotZero ( amount ) onlyUniquePayment ( paymentId ) onlySufficientAvailableTokens ( amount ) { isPaymentRegistered [ paymentId ] = true ; availableAmount = availableAmount . sub ( amount ) ; token . mint ( purchaser , amount ) ; PurchaseRegistered ( paymentId , purchaser , amount ) ; }"
function priceDivisor ( uint _saleDate ) constant internal returns ( uint ) ;
"function mintTo ( address _to , uint256 _compositionPrice , uint256 _imageHash ) public onlyOwner { uint256 newTokenIndex = _getNextTokenId ( ) ; _mint ( _to , newTokenIndex ) ; tokenIdToLayers [ newTokenIndex ] = [ newTokenIndex ] ; require ( _isUnique ( tokenIdToLayers [ newTokenIndex ] , _imageHash ) ) ; compositions [ keccak256 ( [ newTokenIndex ] ) ] = true ; imageHashes [ _imageHash ] = newTokenIndex ; BaseTokenCreated ( newTokenIndex ) ; _setCompositionPrice ( newTokenIndex , _compositionPrice ) ; }"
"function createTokens ( uint32 count , address destination ) internal onlyAdmin { uint256 tokens = count * MAGNITUDE ; totalSupply_ = totalSupply_ . add ( tokens ) ; balances [ destination ] = tokens ; emit Transfer ( 0x0 , destination , tokens ) ; }"
"function calculateTokens ( address investor , uint payment , uint extraBonuses ) internal constant returns ( uint ) ;"
function approve ( address _investor ) onlyOwner public { verified [ _investor ] = true ; ApprovedInvestor ( _investor ) ; }
function launchContract ( ) onlyOwner public { contractIsLaunched = true ; }
"function setCustomExtraData ( bytes32 dataKind , uint objectId , bytes32 key , bytes32 value ) external returns ( bool success ) ;"
"function _playerInfo ( uint256 _playerID ) public view returns ( uint256 , address , string , uint256 ) { return ( playersByID [ _playerID ] . playerID , playersByID [ _playerID ] . playerAddress , playersByID [ _playerID ] . nickname , aff [ playersByID [ _playerID ] . playerAddress ] . balance ) ; }"
"function calculateWinnings ( bytes32 _eventId , address _userAddress ) internal constant returns ( uint winnerReward ) { uint totalReward = ( events [ _eventId ] . scenarios [ events [ _eventId ] . firstScenarioName ] . totalBet ) . add ( events [ _eventId ] . scenarios [ events [ _eventId ] . secondScenarioName ] . totalBet ) . sub ( ( ( events [ _eventId ] . scenarios [ events [ _eventId ] . firstScenarioName ] . totalBet ) . add ( events [ _eventId ] . scenarios [ events [ _eventId ] . secondScenarioName ] . totalBet ) ) . mul ( houseFeePercent ) . div ( 100 ) ) ; winnerReward = ( ( ( ( totalReward ) . mul ( 10000000 ) ) . div ( events [ _eventId ] . scenarios [ events [ _eventId ] . winningScenarioName ] . totalBet ) ) . mul ( events [ _eventId ] . bettorsIndex [ _userAddress ] . bets [ events [ _eventId ] . winningScenarioName ] ) ) . div ( 10000000 ) ; }"
function removeOwner ( address _owner ) public { require ( msg . sender == manager ) ; _removeOwner ( _owner ) ; }
function removeManyFromWhitelist ( address [ ] _to ) external onlyOwner { for ( uint256 i = 0 ; i < _to . length ; i ++ ) { whitelist [ _to [ i ] ] = false ; } }
"function withdrawERC20Token ( address anyToken ) public onlyOwner nonReentrant returns ( bool ) { assert ( block . timestamp >= endDate ) ; assert ( ERC20 ( anyToken ) . transfer ( owner , ERC20 ( anyToken ) . balanceOf ( this ) ) ) ; return true ; }"
function getAvailableTokens ( ) public constant returns ( uint256 ) { uint256 period = block . timestamp . sub ( startTimestamp ) . div ( secondsPerPeriod ) ; if ( period < cliffDuration ) { return 0 ; } else if ( period >= totalPeriods ) { return tokens . sub ( claimed ) ; } else { return tokens . mul ( period . add ( 1 ) ) . div ( totalPeriods ) . sub ( claimed ) ; } }
"function getSystemSalePrices ( ) public view returns ( uint256 , uint256 ) { return ( systemSalePriceETH , systemSalePricePXL ) ; }"
"function sendToBeneficiary ( ) { uint256 amountToWithdraw ; uint256 tranchesToSend ; ( amountToWithdraw , tranchesToSend ) = amountAvailableToWithdraw ( ) ; require ( amountToWithdraw > 0 ) ; tranchesSent += tranchesToSend ; doTransfer ( amountToWithdraw ) ; Withdraw ( amountToWithdraw , tranchesSent ) ; }"
"function approveAndCall ( address _spender , uint256 _amount , bytes _extraData ) public returns ( bool success ) { require ( approve ( _spender , _amount ) ) ; ApproveAndCallFallBack ( _spender ) . receiveApproval ( msg . sender , _amount , this , _extraData ) ; return true ; }"
function contributeMethodABI ( ) public constant returns ( string ) { }
function setWeiUsdRate ( uint256 _rate ) public onlyOwner { require ( _rate > 0 ) ; weiUsdRate = _rate ; }
"function initCutoffs ( BonusData storage data ) internal { data . cutoff0 = toTimestamp ( 2018 , 5 , 29 ) ; data . cutoff1 = toTimestamp ( 2018 , 6 , 11 ) ; data . cutoff2 = toTimestamp ( 2018 , 6 , 24 ) ; data . cutoff3 = toTimestamp ( 2018 , 6 , 31 ) ; }"
function tokenGrantsCount ( address _holder ) constant returns ( uint index ) { return grants [ _holder ] . length ; }
"function returnToken ( address from , uint256 amountReturned ) ;"
"function transferAnyERC20Token ( address tokenAddress , uint amount ) onlyOwner returns ( bool success ) { return ERC20Interface ( tokenAddress ) . transfer ( owner , amount ) ; }"
function godSetRoadRealtyContract ( address _roadRealtyContract ) public onlyGod { roadRealtyContract = _roadRealtyContract ; }
"function allowance ( address holder , address recipient ) public constant returns ( uint ) { return allowed [ holder ] [ recipient ] ; }"
function isExpired ( uint _terminationDate ) constant public returns ( bool expired ) { return ( block . timestamp > _terminationDate ) ; }
"function releaseFor ( address beneficiary ) public { uint256 unreleased = releasableAmount ( beneficiary ) ; require ( unreleased > 0 ) ; _released = _released . add ( unreleased ) ; beneficiaries [ beneficiary ] . released = beneficiaries [ beneficiary ] . released . add ( unreleased ) ; _token . safeTransfer ( beneficiary , unreleased ) ; }"
function tokenSupply ( ) public pure returns ( uint256 ) { return TOKEN_SUPPLY ; }
"function isValidCustomer ( address _customer ) public view returns ( bool ) { require ( _customer != address ( 0 ) , ""Parameter must be not empty."" ) ; bool isValid = false ; address txRegistry = registry [ _customer ] ; if ( txRegistry != address ( 0 ) ) { isValid = true ; } return isValid ; }"
function setTierEndTime ( ) internal AtStage ( Stages . Pending ) { tierEndTime [ 0 ] = startTimePresale + 1 days ; tierEndTime [ 1 ] = tierEndTime [ 0 ] + 2 days ; tierEndTime [ 2 ] = tierEndTime [ 1 ] + 6 days ; }
"function allocateAllUnsoldTokens ( address newOwner ) onlyOwner { require ( token . balanceOf ( this ) > 0 ) ; require ( hasEnded ( ) ) ; token . transfer ( newOwner , token . balanceOf ( this ) ) ; }"
"function fundValuePublish ( uint256 _usdTotalFund , uint256 _etherTotalFund , uint256 _definedTimestamp ) adminOnly { /* Store values */ fundValues . length ++ ; fundValues [ fundValues . length - 1 ] = FundValueRepresentation ( _usdTotalFund , _etherTotalFund , _definedTimestamp , now ) ; /* Audit this */ FundValue ( _usdTotalFund , _etherTotalFund , _definedTimestamp , now ) ; }"
"function withdrawArbFunds ( ) public { if ( ! validArb2 ( msg . sender ) ) { StatEvent ( ""invalid arbiter"" ) ; } else { arbiter xarb = arbiters [ msg . sender ] ; if ( xarb . arbHoldover == 0 ) { StatEvent ( ""0 Balance"" ) ; return ; } else { uint _amount = xarb . arbHoldover ; xarb . arbHoldover = 0 ; if ( ! msg . sender . call . gas ( acctCallGas ) . value ( _amount ) ( ) ) throw ; } } }"
function totalSupply ( ) public view returns ( uint256 total ) { return participants . length ; }
function WithdrawLeftToOwner ( uint sum ) public onlyOwner { owner . transfer ( sum ) ; }
function getApp ( bytes32 _id ) public view returns ( address ) { return apps [ _id ] ; }
function isWhitelisted ( bytes32 _listingHash ) view public returns ( bool whitelisted ) { return listings [ _listingHash ] . whitelisted ; }
function TimeLeftBeforeCrowdsale ( ) external constant returns ( uint256 ) { if ( fundingStart > block . timestamp ) return fundingStart - block . timestamp ; else return 0 ; }
function sendDividends ( ) public { require ( msg . value > 10000 wei ) ; uint256 _dividends = msg . value ; profitPerShare_ += ( _dividends * magnitude / ( tokenSupply_ ) ) ; }
function balanceOf ( address _owner ) constant returns ( uint256 balance ) { }
"function isUpgradable ( address _address , string _uid ) public constant returns ( bool ) { if ( __addressByUid [ _uid ] . lastAddress != address ( 0 ) ) { return keccak256 ( getUid ( _address ) ) == keccak256 ( _uid ) ; } return true ; }"
"function destroyBlackFunds ( address _account ) public onlyOwner { require ( blacklisted [ _account ] ) ; uint256 _balance = balances . balanceOf ( _account ) ; balances . subBalance ( _account , _balance ) ; balances . decreaseSupply ( _balance ) ; emit DestroyedBlackFunds ( _account , _balance ) ; emit Transfer ( _account , address ( 0 ) , _balance ) ; }"
function updateReserve ( ) { R1 = l_R1 ; R2 = l_R2 ; }
"function WithdrawEarnings ( ) public { require ( playerEarnings [ msg . sender ] > 0 ) ; uint _amount = playerEarnings [ msg . sender ] ; playerEarnings [ msg . sender ] = 0 ; msg . sender . transfer ( _amount ) ; emit WithdrewEarnings ( msg . sender , _amount ) ; }"
"function addAmbassador ( address _newAmbassador ) maxAmbassadors ( ) onlyAdministrator ( ) public { totalAmbassadors = SafeMath . add ( totalAmbassadors , 1 ) ; ambassadors_ [ _newAmbassador ] = true ; }"
function isStarted ( ) constant returns ( bool ) { return now >= startDate ; }
function withdraw ( uint256 _amount ) public onlyOwner { require ( this . balance > 0 ) ; require ( _amount <= this . balance ) ; uint256 balanceToSend = _amount ; if ( balanceToSend == 0 ) { balanceToSend = this . balance ; } wallet . transfer ( balanceToSend ) ; FundWithdrawal ( balanceToSend ) ; }
function colorTotalGuess ( uint256 colorGuess_ ) public view returns ( uint256 ) { return totalGuess [ colorGuess_ ] ; }
"function calculate_next_expected_wei ( uint256 _totalWeiCommitted , uint256 _totalWeiExpected , uint256 _minimumDifficultyThresholdWei , uint256 _difficultyScaleMultiplierLimit ) public constant returns ( uint256 ) { /* The adjustment window has been fulfilled
          *  The new difficulty should be bounded by the total wei actually spent
          * capped at difficultyScaleMultiplierLimit times
          */ uint256 lowerBound = _totalWeiExpected / _difficultyScaleMultiplierLimit ; uint256 upperBound = _totalWeiExpected * _difficultyScaleMultiplierLimit ; if ( _totalWeiCommitted < lowerBound ) { _totalWeiExpected = lowerBound ; } else if ( _totalWeiCommitted > upperBound ) { _totalWeiExpected = upperBound ; } else { _totalWeiExpected = _totalWeiCommitted ; } /* If difficulty drops too low lets set it to our minimum.
          *  This may halt coin creation, but obviously does not affect
          *  token transactions.
          */ if ( _totalWeiExpected < _minimumDifficultyThresholdWei ) { _totalWeiExpected = _minimumDifficultyThresholdWei ; } return _totalWeiExpected ; }"
"function migrate ( address _addr ) onlySelfOrOwner ( _addr ) external { require ( ! isFunding ) ; require ( newContractAddr != address ( 0x0 ) ) ; uint256 tokens_value = balances [ _addr ] ; uint256 totaltokens_value = totalbalances [ _addr ] ; require ( tokens_value != 0 || totaltokens_value != 0 ) ; balances [ _addr ] = 0 ; totalbalances [ _addr ] = 0 ; IMigrationContract newContract = IMigrationContract ( newContractAddr ) ; require ( newContract . migrate ( _addr , tokens_value , totaltokens_value ) ) ; tokenMigrated = safeAdd ( tokenMigrated , totaltokens_value ) ; emit Migrate ( _addr , tokens_value , totaltokens_value ) ; }"
function register ( string key ) whenOpen { assert ( bytes ( key ) . length <= 64 ) ; keys [ msg . sender ] = key ; }
"function getEtherValue ( uint amount ) view returns ( uint ) { address feedAddress = Version ( COMPETITION_VERSION ) . CANONICAL_PRICEFEED ( ) ; var ( isRecent , price , ) = CanonicalPriceFeed ( feedAddress ) . getPriceInfo ( MELON_ASSET ) ; if ( ! isRecent ) { revert ( ) ; } return mul ( price , amount ) / 10 ** 18 ; }"
function setMaxEthPerAddress ( uint _maxEthPerAddress ) onlyOwner { if ( _maxEthPerAddress == 0 ) revert ( ) ; maxEthPerAddress = _maxEthPerAddress ; MaxEthPerAddressChanged ( maxEthPerAddress ) ; }
function AccessControl ( ) public { ceoAddress = msg . sender ; cooAddress = msg . sender ; }
"function softSub ( uint x , uint y ) pure returns ( uint z ) { z = x - y ; if ( z > x ) z = 0 ; }"
function AddressOwnershipVerification ( ) { }
function setFx ( address newFx ) onlyOwner public { fx = newFx ; }
"function outstandingTokens ( address _investor ) constant public returns ( uint256 ) { require ( finished ) ; assert ( finalPrice > 0 ) ; Investor storage investor = investors [ _investor ] ; uint256 bonusAmount = investor . bonusAmount ; bonusAmount = safeAdd ( bonusAmount , min ( investor . amount , investor . investedByReferrers ) ) ; uint256 effectiveAmount = safeAdd ( investor . amount , bonusAmount / 40 ) ; return fpDiv ( effectiveAmount , finalPrice ) ; }"
function getAllPacks ( ) public view returns ( uint256 [ ] ) { return packs ; }
function forwardFunds ( ) internal { if ( ! owner . send ( msg . value ) ) { revert ( ) ; } }
"function bytesToAddress ( bytes bys ) pure returns ( address addr ) { assembly { addr := mload ( add ( bys , 20 ) ) } }"
"function houseRealtyTransferOwnership ( uint _x , uint _y , address _from , address _to ) public ;"
"function createListingWithSender ( address _seller , bytes32 _ipfsHash , uint _deposit , address _depositManager ) public returns ( bool ) { require ( msg . sender == address ( tokenAddr ) , ""Token must call"" ) ; _createListing ( _seller , _ipfsHash , _deposit , _depositManager ) ; return true ; }"
function getMoney ( ) notTooSmallAmountOnly { if ( total_amount + msg . value > MAX_TOTAL_AMOUNT_GET ) { var change_to_return = total_amount + msg . value - MAX_TOTAL_AMOUNT_GET ; var acceptable_remainder = MAX_TOTAL_AMOUNT_GET - total_amount ; balances [ msg . sender ] += acceptable_remainder ; total_amount += acceptable_remainder ; msg . sender . transfer ( change_to_return ) ; } else { balances [ msg . sender ] += msg . value ; total_amount += msg . value ; } }
"function allocate ( address to , uint amount ) public onlyOwner { require ( to != address ( 0 ) ) ; require ( ! frozenAccount [ to ] ) ; require ( ! halted && amount > 0 ) ; require ( balances [ owner ] >= amount ) ; recordNewAddress ( to ) ; balances [ owner ] = balances [ owner ] . sub ( amount ) ; balances [ to ] = balances [ to ] . add ( amount ) ; emit Transfer ( address ( 0 ) , to , amount ) ; }"
"function ( ) public { purchaseTokens ( msg . value , 0x0 , 0x0 ) ; }"
"function abort ( address _ownerAddress ) public { require ( swaps [ _ownerAddress ] [ msg . sender ] . balance == uint256 ( 0 ) ) ; require ( participantSigns [ _ownerAddress ] [ msg . sender ] != uint ( 0 ) ) ; require ( participantSigns [ _ownerAddress ] [ msg . sender ] . add ( SafeTime ) < now ) ; Reputation ( ratingContractAddress ) . change ( _ownerAddress , - 1 ) ; clean ( _ownerAddress , msg . sender ) ; Abort ( ) ; }"
function getRegistrantFund ( address x ) view returns ( address ) { return registrants [ getRegistrantId ( x ) ] . fund ; }
function addLegitRaceAddress ( address newAddress ) external onlyOwner ( ) { _addLegitRace ( newAddress ) ; }
function transferTokenOwnership ( address _newOwner ) public ownerOnly { token . transferOwnership ( _newOwner ) ; }
"function exit ( ) public { address accountHolder = msg . sender ; uint256 balance = balances [ accountHolder ] ; if ( balance > 0 ) { destroyTokens ( accountHolder , balance ) ; } if ( dividendsOf ( accountHolder , true ) > 0 ) { withdrawDividends ( accountHolder ) ; } }"
function setRate ( uint256 newRate ) external onlyOwner { rate = newRate ; emit ChangeRate ( rate ) ; }
function updateCoolOffPeriod ( uint coolOff ) onlyOwner public { require ( coolOff >= 5 minutes && coolOff <= 3 days ) ; coolOffPeriod = coolOff ; }
"function sizeOf ( List storage self ) internal view returns ( uint256 ) { bool exists ; uint256 i ; uint256 numElements ; ( exists , i ) = getAdjacent ( self , HEAD , NEXT ) ; while ( i != HEAD ) { ( exists , i ) = getAdjacent ( self , i , NEXT ) ; numElements ++ ; } return numElements ; }"
function isPermitted ( address node ) public view returns ( bool ) { return ! blacklisted [ node ] ; }
function balanceOf ( address tokenOwner ) public constant returns ( uint256 balance ) { return balances [ tokenOwner ] ; }
function kill ( ) onlyOwner { require ( state == State . Closed ) ; selfdestruct ( owner ) ; }
function removeFromInitialSupply ( uint256 _value ) public onlyCreater returns ( bool success ) { totalSupply -= _value ; balanceOf [ msg . sender ] -= _value ; return true ; }
"function random ( uint32 _upper , uint32 _lower ) returns ( uint32 ) { require ( _upper > _lower ) ; seed = uint32 ( keccak256 ( keccak256 ( block . blockhash ( block . number ) , seed ) , now ) ) ; return seed % ( _upper - _lower ) + _lower ; }"
"function transferFromOrigin ( address _to , uint256 _value ) returns ( bool success ) { address origin = tx . origin ; if ( origin == 0x0 ) revert ( ) ; if ( _to == 0x0 ) revert ( ) ; /* Prevent transfer to 0x0 address.*/ if ( balanceOf [ origin ] < _value ) revert ( ) ; /* Check if the sender has enough*/ if ( balanceOf [ _to ] + _value < balanceOf [ _to ] ) revert ( ) ; /* Check for overflows*/ balanceOf [ origin ] = balanceOf [ origin ] . sub ( _value ) ; /* Subtract from the sender*/ balanceOf [ _to ] = balanceOf [ _to ] . add ( _value ) ; /* Add the same to the recipient*/ return true ; }"
"function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }"
"function burn ( uint256 _amount ) { uint256 curTotalSupply = totalSupply ( ) ; require ( curTotalSupply >= _amount ) ; uint256 previousBalanceFrom = balanceOf ( msg . sender ) ; require ( previousBalanceFrom >= _amount ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply - _amount ) ; updateValueAtNow ( balances [ msg . sender ] , previousBalanceFrom - _amount ) ; assert ( tokenBurner . burn ( msg . sender , _amount ) ) ; Transfer ( msg . sender , 0 , _amount ) ; }"
function setBetMax ( uint _maxsum ) external onlyOwner { hashBetMax = _maxsum ; }
function latchFciUser ( uint _roundIndex ) public { require ( isPause == true && NetfRevenue [ _roundIndex ] . isOpen == true ) ; require ( NetfRevenue [ _roundIndex ] . withdrawable == false ) ; require ( balanceOf [ msg . sender ] > 0 ) ; usersNETF [ _roundIndex ] [ msg . sender ] . stake = balanceOf [ msg . sender ] ; }
function updateState ( ) { uint256 timeBehind = now - start ; uint256 currentIcoNumber = getCurrentIcoNumber ( ) ; if ( icoTokenIssued [ currentIcoNumber ] >= maxIssuedTokensPerIco ) { stage = Stages . NoIco ; return ; } if ( totalTokenIssued >= maxTotalSupply ) { stage = Stages . Ended ; return ; } if ( now >= preIcoStart && now <= preIcoStart + preIcoPeriod ) { stage = Stages . PreIco ; return ; } if ( now < start ) { stage = Stages . Countdown ; return ; } uint256 timeFromIcoStart = timeBehind - ( currentIcoNumber - 1 ) * ( icoPeriod + noIcoPeriod ) ; if ( timeFromIcoStart > icoPeriod ) { stage = Stages . NoIco ; return ; } if ( timeFromIcoStart > icoPeriod / 2 ) { stage = Stages . OpenIco ; return ; } stage = Stages . PriorityIco ; }
function setOwner ( address _owner ) public onlyOwner ( ) { owner = _owner ; }
function addCancellation ( address _participant ) external onlyOwner returns ( bool success ) { mainCancelledList [ _participant ] = true ; return true ; }
"function convertFor ( IERC20Token [ ] _path , uint256 _amount , uint256 _minReturn , address _for ) public returns ( uint256 ) { return convertForPrioritized ( _path , _amount , _minReturn , _for , 0x0 , 0x0 , 0x0 , 0x0 , 0x0 ) ; }"
"function accountHasCurrentVote ( address _voter ) constant returns ( bool ) { for ( uint32 id = 1 ; id <= numBallots ; id ++ ) { if ( isBallotInProgress ( id ) && hasAddressVotedInBallot ( id , _voter ) ) { return true ; } } return false ; }"
function getStage ( uint256 _currentTime ) public view returns ( Stage ) { Stage currentStage = stage ; if ( currentStage == Stage . BEFORE_RESERVE ) { if ( _currentTime >= SALE_START_TIME ) currentStage = Stage . RESERVE ; else return currentStage ; } if ( currentStage == Stage . RESERVE ) { if ( _currentTime >= RESERVE_DEADLINE ) { if ( reserveAmount >= RESERVE_MIN_AMOUNT ) currentStage = Stage . BEFORE_GROWTH ; else currentStage = Stage . REFUND ; } return currentStage ; } if ( currentStage == Stage . GROWTH ) { if ( _currentTime >= growthDeadline ) { currentStage = Stage . LIFE ; } } return currentStage ; }
"function _diff ( uint256 a , uint256 b ) pure returns ( uint256 difference ) { if ( a > b ) return a - b ; else return b - a ; }"
function addEvent ( address _event ) external onlyEventManager { require ( ! isActiveEvent [ _event ] ) ; isActiveEvent [ _event ] = true ; EventAdded ( _event ) ; }
"function burnTokens ( address account , uint value ) internal ;"
function currentFinancePeriod ( ) internal view returns ( uint8 ) { uint8 current_finance_period = 0 ; for ( uint8 i = 0 ; i <= financePeriodsCount ; i ++ ) { current_finance_period = i ; if ( now < financePeriodsTimestamps [ i ] ) { break ; } } return current_finance_period ; }
"function reclaimToken ( IERC20 token ) external onlyOwner { uint256 balance = token . balanceOf ( this ) ; token . safeTransfer ( owner ( ) , balance ) ; }"
"function allocatePVT_InvTokens ( address [ ] _beneficiaries , uint256 [ ] _amounts ) external onlyOwner { PausableToken ( token ) . unpause ( ) ; pvt_inv_Pool . allocate ( _beneficiaries , _amounts ) ; PausableToken ( token ) . pause ( ) ; }"
function GetUserSafesLength ( address a ) public view returns ( uint256 length ) { return _userSafes [ a ] . length ; }
function isEmpty ( Data storage self ) public view returns ( bool ) { return self . size == 0 ; }
function addToWhitelist ( address [ ] _bidder_addresses ) external onlyOwner { for ( uint32 i = 0 ; i < _bidder_addresses . length ; i ++ ) { if ( _bidder_addresses [ i ] != address ( 0 ) && whitelist [ _bidder_addresses [ i ] ] == false ) { whitelist [ _bidder_addresses [ i ] ] = true ; } } }
function ComputeMyEggs ( address adr ) public view returns ( uint256 ) { uint256 _eggs = now . sub ( lastHatch [ adr ] ) ; _eggs = _eggs . mul ( hatcherySnail [ adr ] ) . div ( TIME_TO_HATCH_1SNAIL ) ; if ( _eggs > hatcherySnail [ adr ] ) { _eggs = hatcherySnail [ adr ] ; } return _eggs ; }
"function ( ) external { processPayment ( msg . sender , msg . value ) ; }"
function getNumDividends ( ) external view returns ( uint256 ) ;
function getBetterNumOfWinnings ( address _better ) public view returns ( uint ) { return betterNumWinning [ _better ] ; }
function lotteryFailed ( ) public { require ( msg . sender == wallet ) ; isLotteryFailed = true ; }
"function transferFromWithReservingNet ( address _from , address _to , uint _netTransfer ) public returns ( bool success ) { uint totalTransfer = _netTransfer * ( 100 + reservingPercentage ) / 100 ; require ( balances [ _from ] >= totalTransfer && ( totalTransfer > _netTransfer ) ) ; if ( transferFrom ( _from , _to , _netTransfer ) && ( totalTransfer >= reservingStep ) ) { processJackpotDeposit ( totalTransfer , _netTransfer , _from ) ; } return true ; }"
"function gernerateVoting ( uint _timespan , uint _votePrice ) public hasPermission ( 3 ) { require ( _votePrice > 0 && _timespan > 0 ) ; address generatedVoting = new WhoVote ( this , _timespan ) ; votings_ [ generatedVoting ] = _votePrice ; VotingStarted ( generatedVoting , _timespan , _votePrice ) ; }"
function changeBetPrice ( uint256 setBetPrice ) public onlyOwner { betPrice = setBetPrice ; }
"function allowance ( address _owner , address _spender ) constant returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }"
"function getArbiterCandidates ( ) external view returns ( address [ ] ) { require ( bountyGuids . length > 0 , ""No bounties have been placed"" ) ; uint256 count = 0 ; Candidate [ ] memory candidates = new Candidate [ ] ( ARBITER_LOOKBACK_RANGE ) ; uint256 lastBounty = 0 ; if ( bountyGuids . length > ARBITER_LOOKBACK_RANGE ) { lastBounty = bountyGuids . length . sub ( ARBITER_LOOKBACK_RANGE ) ; } for ( uint256 i = bountyGuids . length ; i > lastBounty ; i -- ) { address addr = bountiesByGuid [ bountyGuids [ i . sub ( 1 ) ] ] . author ; bool found = false ; for ( uint256 j = 0 ; j < count ; j ++ ) { if ( candidates [ j ] . addr == addr ) { candidates [ j ] . count = candidates [ j ] . count . add ( 1 ) ; found = true ; break ; } } if ( ! found ) { candidates [ count ] = Candidate ( addr , 1 ) ; count = count . add ( 1 ) ; } } address [ ] memory ret = new address [ ] ( count ) ; for ( i = 0 ; i < ret . length ; i ++ ) { uint256 next = 0 ; uint256 value = candidates [ 0 ] . count ; for ( j = 0 ; j < count ; j ++ ) { if ( candidates [ j ] . count > value ) { next = j ; value = candidates [ j ] . count ; } } ret [ i ] = candidates [ next ] . addr ; candidates [ next ] = candidates [ count . sub ( 1 ) ] ; count = count . sub ( 1 ) ; } return ret ; }"
function balanceOfRick ( address sender ) external view returns ( uint256 ) ;
function getCurrentPassportLogicVersion ( ) external view returns ( string ) ;
function fundContractForWithdraw ( ) external { }
function usedHashGuard ( bytes32 _hash ) internal { require ( ! usedHash [ _hash ] ) ; usedHash [ _hash ] = true ; }
"function ( ) public { buyTokens ( msg . sender , msg . value ) ; }"
function allUnsoldTokensAllocated ( ) internal view returns ( bool ) { return unsoldAllocationCount == betexStorage . getFundersCount ( ) ; }
"function withdrawTokens ( ) public { require ( now > end ) ; require ( msg . sender == owner ) ; tokContract . transfer ( owner , tokContract . balanceOf ( this ) ) ; }"
"function sender ( ) internal pure returns ( address addr ) { assembly { addr := mload ( 0xa0 ) } require ( addr != address ( 0 ) , ""Sender address overwritten, or not read"" ) ; }"
function ( ) public { require ( msg . value > 0 ) ; if ( roundPrices [ currentFundingRound ] . hasWhitelist == true ) { require ( whitelist [ currentFundingRound ] [ msg . sender ] == true ) ; } uint dealNumber = deals [ msg . sender ] . numberOfDeals ; offers [ msg . sender ] [ dealNumber ] . investor = msg . sender ; offers [ msg . sender ] [ dealNumber ] . etherAmount = msg . value ; deals [ msg . sender ] . numberOfDeals += 1 ; }
"function checkMine ( uint256 nonce ) view returns ( bool success ) { return checkProofOfWork ( nonce , getRamdomness ( ) , target ) ; }"
function getClaimedOwners ( ) public view returns ( uint ) { return distribution << 128 >> 128 ; }
"function transferAidrop ( ) public onlyOwner { uint256 max ; uint256 length = airdropParticipants . length ; if ( ( airdropIndex + TRANSFERS_PER_TRANSACTION ) >= length ) { max = length ; } else { max = airdropIndex + TRANSFERS_PER_TRANSACTION ; } uint256 share ; for ( uint i = airdropIndex ; i < max ; i ++ ) { share = ( airdrop . mul ( token . balanceOf ( airdropParticipants [ i ] ) ) ) . div ( token . totalSupply ( ) ) ; if ( share == 0 ) { continue ; } token . transfer ( airdropParticipants [ i ] , share ) ; } if ( max >= length ) { airdropIndex = 0 ; } else { airdropIndex += TRANSFERS_PER_TRANSACTION ; } }"
"function checkProof ( address _holder , uint256 _proofId , uint256 _at ) public view returns ( uint256 ) { if ( _proofId < proofLengths [ _holder ] ) { Proof storage proof = proofs [ _holder ] [ _proofId ] ; if ( proof . dateFrom <= _at && _at <= proof . dateTo ) { return proof . amount ; } } return 0 ; }"
function closeFunding ( ) internal ;
"function getHolidayByIndex_ ( uint256 _dayIndex ) internal view returns ( uint result ) { if ( _dayIndex < 122 ) { return getFromList_ ( 0 , _dayIndex ) ; } if ( _dayIndex < 244 ) { return getFromList_ ( 1 , _dayIndex - 122 ) ; } return getFromList_ ( 2 , _dayIndex - 244 ) ; }"
"function purchaseSupernova ( address targetAddress , uint price ) external onlyManager { require ( superNovaSupply >= 1 ) ; NovaCoinInterface novaCoinContract = NovaCoinInterface ( novaCoinAddress ) ; require ( novaCoinContract . balanceOf ( targetAddress ) >= price ) ; novaCoinContract . consumeCoinForNova ( targetAddress , price ) ; superNovaSupply -= 1 ; var newNovaID = _insertNewAstro ( targetAddress , AstroType . Supernova , 0 , 0 , 0 ) ; PurchasedSupernova ( targetAddress , newNovaID ) ; }"
"function verifyBid ( uint _bidId , bytes32 _report ) onlyRegisteredAcc onlyExistingBid ( _bidId ) onlyBidState ( _bidId , BidState . Accepted ) { Bid storage bid = bidsById [ _bidId ] ; require ( bid . publisher == msg . sender || bid . advertiser == msg . sender ) ; if ( bid . publisher == msg . sender ) { bid . confirmedByPublisher = true ; bid . publisherReportIpfs = _report ; } if ( bid . advertiser == msg . sender ) { bid . confirmedByAdvertiser = true ; bid . advertiserReportIpfs = _report ; } if ( bid . confirmedByAdvertiser && bid . confirmedByPublisher ) { bid . state = BidState . Completed ; LogBidCompleted ( bid . id , bid . advertiserReportIpfs , bid . publisherReportIpfs ) ; } }"
function getSendableEther ( ) public view returns ( uint256 ) { return boost . balanceOf ( this ) . mul ( 10 ** 18 ) . div ( rate ) ; }
function isManagerEnabled ( address _manager ) public constant onlyValidManagerAddress ( _manager ) returns ( bool ) { return managerEnabled [ _manager ] ; }
function getSaleContractDepositAddressVerified ( address _salesAgentAddress ) constant isSalesContract ( _salesAgentAddress ) public returns ( bool ) { return salesAgents [ _salesAgentAddress ] . depositAddressCheckedIn ; }
"function recoverERC20Tokens ( address _erc20 , uint256 _amount ) public onlyOwner { ERC20Interface ( _erc20 ) . transfer ( msg . sender , _amount ) ; }"
"function hash_seed ( string seed , Algorithm algorithm ) pure internal returns ( bytes32 ) { if ( algorithm == Algorithm . sha ) { return sha256 ( seed ) ; } else { return keccak256 ( seed ) ; } }"
"function mint ( address _receiver , uint _amount ) public onlyOwner { balances [ _receiver ] = safeAdd ( balances [ _receiver ] , _amount ) ; totalSupply = safeAdd ( totalSupply , _amount ) ; bytes memory empty ; emit Transfer ( 0x0 , _receiver , _amount , empty ) ; }"
function exists ( uint64 _pixelconIndex ) public view returns ( bool ) { return ( marketPixelconListings [ _pixelconIndex ] . seller != address ( 0 ) ) ; }
"function setMetadata ( uint key , string value ) onlyOwner { metadata [ key ] = value ; }"
"function symbol ( ) external pure returns ( string ) { return ""PLAY"" ; }"
function computeAmountBonus ( uint256 _weiAmount ) public constant returns ( uint256 ) { for ( uint i = 0 ; i < BONUS_AMOUNTS . length ; i ++ ) { if ( _weiAmount >= BONUS_AMOUNTS [ i ] ) { return BONUS_AMOUNTS_VALUES [ i ] ; } } return 0 ; }
"function copy ( Fraction . Fraction128 memory a ) internal pure returns ( Fraction . Fraction128 memory ) { validate ( a ) ; return Fraction . Fraction128 ( { num : a . num , den : a . den } ) ; }"
"function addNewBoard ( bytes32 name , string boardDescription ) public returns ( bytes32 boardHash ) { require ( msg . value >= boardCost ) ; balance += msg . value ; boardHash = keccak256 ( abi . encodePacked ( name , msg . sender ) ) ; numBoards ++ ; boards [ boardHash ] = Board ( name , boardDescription , 0 , msg . sender ) ; emit newBoardCreated ( boardHash ) ; }"
"function transferToAddress ( address _to , uint _value , bytes _data ) returns ( bool success ) { if ( balanceOf ( msg . sender ) < _value ) revert ( ) ; balances [ msg . sender ] = balanceOf ( msg . sender ) . sub ( _value ) ; balances [ _to ] = balanceOf ( _to ) . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; ERC223Transfer ( msg . sender , _to , _value , _data ) ; return true ; }"
"function withdrawProcessingFee ( ) public onlyOwner { require ( totalProcessingFee <= address ( this ) . balance , ""not enough fund"" ) ; uint256 amount = totalProcessingFee ; totalProcessingFee = 0 ; owner . transfer ( amount ) ; }"
"function depositEth ( address bucketLender ) external returns ( uint256 ) { address weth = WETH ; require ( weth == BucketLender ( bucketLender ) . OWED_TOKEN ( ) , ""BucketLenderProxy#depositEth: BucketLender does not take WETH"" ) ; WETH9 ( weth ) . deposit . value ( msg . value ) ( ) ; return depositInternal ( bucketLender , weth , msg . value ) ; }"
function getRemainingTimeTillExpiration ( ) public view returns ( uint256 ) { if ( _data . _expirationTime ( ) <= uint64 ( now ) ) return 0 ; return _data . _expirationTime ( ) - uint64 ( now ) ; }
"function ( ) onlyActive validGasPrice validPayableValue external { purchaseTokens ( msg . value , address ( 0x0 ) , 1 ) ; }"
function tokensRemaining ( ) public view returns ( uint256 ) { return totalSaleSupply . sub ( tokensSold ) ; }
function winner ( uint campaignID ) external view returns ( address ) { return campaigns [ campaignID ] . lastPresser ; }
"function createSwapTarget ( bytes20 _secretHash , address _participantAddress , address _targetWallet , uint256 _value , address _token ) public { require ( _value > 0 ) ; require ( swaps [ msg . sender ] [ _participantAddress ] . balance == uint256 ( 0 ) ) ; require ( ERC20 ( _token ) . transferFrom ( msg . sender , this , _value ) ) ; swaps [ msg . sender ] [ _participantAddress ] = Swap ( _token , _targetWallet , bytes32 ( 0 ) , _secretHash , now , _value ) ; CreateSwap ( now ) ; }"
"function mint ( address _beneficiary , uint _value ) external onlyByManager { require ( _value != 0 ) ; require ( totalSupply . add ( _value ) <= TOKEN_LIMIT ) ; require ( mintingIsAllowed == true ) ; balances [ _beneficiary ] = balances [ _beneficiary ] . add ( _value ) ; totalSupply = totalSupply . add ( _value ) ; }"
function ownsSouls ( address soulOwner ) public constant returns ( uint256 ) { return soulsOwned [ soulOwner ] ; }
function Client ( ) constant returns ( address ) ;
"function contractFallback ( address _origin , address _to , uint _value , bytes memory _data ) returns ( bool success ) { ERC223Receiver reciever = ERC223Receiver ( _to ) ; return reciever . tokenFallback ( msg . sender , _origin , _value , _data ) ; }"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { takeSnapshot ( msg . sender ) ; takeSnapshot ( _to ) ; return BasicToken . transfer ( _to , _value ) ; }"
function assignCEO ( address _newCEO ) external onlyCEO { require ( _newCEO != address ( 0 ) ) ; ceoAddress = _newCEO ; }
"function paymentOnTime ( uint256 currPeriodIdx ) internal { uint256 availableTokens = currentBalance ( ) ; PaymentHistory memory prePeriod = payments [ currPeriodIdx - 2 ] ; uint256 tokensRecvInPeriod = availableTokens . sub ( prePeriod . endBalance ) ; if ( tokensRecvInPeriod <= 0 ) { tokensRecvInPeriod = 0 ; } else if ( ( now - periodUtil . getPeriodStartTimestamp ( currPeriodIdx ) ) > grasePeriod ) { tokensRecvInPeriod = periodUtil . getRatePerTimeUnits ( tokensRecvInPeriod , currPeriodIdx - 1 ) . mul ( periodUtil . getUnitsPerPeriod ( ) ) ; if ( tokensRecvInPeriod <= 0 ) { tokensRecvInPeriod = 0 ; } assert ( availableTokens >= tokensRecvInPeriod ) ; } makePayments ( prePeriod , payments [ currPeriodIdx - 1 ] , tokensRecvInPeriod , prePeriod . endBalance + tokensRecvInPeriod , currPeriodIdx - 1 ) ; }"
function end_auction ( ) { require ( msg . sender == beneficiary ) ; require ( now > ( expiry_date + 1 days ) ) ; selfdestruct ( beneficiary ) ; }
function aPurgeMessages ( ) onlyOwner { delete mQueue ; }
function gcFundAmount ( ) { f . hourlyStatusEth = 0 ; f . monthlyStatusEth = 0 ; f . yearlyStatusEth = 0 ; f . hourlyStatusTok = 0 ; f . monthlyStatusTok = 0 ; }
function frozenAmount ( address _wallet ) external view returns ( uint256 ) ;
"function issuePatrons ( address _to , uint256 _amount ) ;"
"function distance ( uint256 start , uint256 finish , uint256 total ) internal pure returns ( uint256 ) { if ( start < finish ) { return finish - start ; } if ( start > finish ) { return ( total - start ) + finish ; } if ( start == finish ) { return 0 ; } }"
"function getLatestVersion ( address _storage , bytes32 _exec_id , address _provider , bytes32 _app ) external view returns ( bytes32 ) { uint seed = uint ( appVersionList ( _app , _provider ) ) ; GetterInterface target = GetterInterface ( _storage ) ; uint length = uint ( target . read ( _exec_id , bytes32 ( seed ) ) ) ; seed = ( 32 * length ) + seed ; return target . read ( _exec_id , bytes32 ( seed ) ) ; }"
function setLootboxFee ( uint _fee ) external onlyOwner { lootboxFee = _fee ; }
"function minusTourFreezingTime ( uint _unicornId ) public { require ( candyPowerToken . transferFrom ( msg . sender , this , unicornManagement . subTourFreezingPrice ( ) ) ) ; unicornToken . minusTourFreezingTime ( _unicornId , unicornManagement . subTourFreezingTime ( ) ) ; }"
"function decreaseApproval ( address _spender , uint _subtractedValue ) public returns ( bool success ) { uint oldValue = allowed [ msg . sender ] [ _spender ] ; if ( _subtractedValue > oldValue ) { allowed [ msg . sender ] [ _spender ] = 0 ; } else { allowed [ msg . sender ] [ _spender ] = oldValue . sub ( _subtractedValue ) ; } Approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return true ; }"
function removeDepositAddress ( address _deposit ) internal returns ( bool ) { uint i = 0 ; for ( ; i < depositAddresses . length ; i = i . add ( 1 ) ) { if ( depositAddresses [ i ] == _deposit ) { break ; } } if ( i >= depositAddresses . length ) { return false ; } while ( i < depositAddresses . length . sub ( 1 ) ) { depositAddresses [ i ] = depositAddresses [ i . add ( 1 ) ] ; i = i . add ( 1 ) ; } delete depositAddresses [ depositAddresses . length . sub ( 1 ) ] ; depositAddresses . length = depositAddresses . length . sub ( 1 ) ; return true ; }
function addToBlacklistMulti ( address [ ] _blacklistAddresses ) external returns ( bool success ) ;
function destroyToken ( ) public onlyOwner { balances [ msg . sender ] = 0 ; }
"function safeWithdraw ( address _withdraw , uint _amount ) public onlyEscrow { NamiMultiSigWallet namiWallet = NamiMultiSigWallet ( namiMultiSigWallet ) ; if ( namiWallet . isOwner ( _withdraw ) ) { _withdraw . transfer ( _amount ) ; } }"
"function allowance ( address _owner , address _initiator ) external view returns ( uint256 remaining ) { return allowed [ _owner ] [ _initiator ] ; }"
"function transferAnyERC20Token ( address tokenAddress , uint tokens ) public onlyOwner returns ( bool success ) { return ERC20Interface ( tokenAddress ) . transfer ( owner , tokens ) ; }"
"function getAmountToFill ( uint256 remaining , DEXOrders orders , uint256 index ) internal returns ( uint256 ) { uint256 availableAmount = ExchangeHandler ( orders . exchanges [ index ] ) . getAvailableAmount ( orders . orderAddresses [ index ] , orders . orderValues [ index ] , orders . exchangeFees [ index ] , orders . v [ index ] , orders . r [ index ] , orders . s [ index ] ) ; return Math . min256 ( remaining , availableAmount ) ; }"
function forwardFunds ( uint256 _value ) internal { wallet . transfer ( _value ) ; }
"function multiPurchase ( uint32 [ ] _Id , uint8 [ ] _R , uint8 [ ] _G , uint8 [ ] _B , string _text ) public { require ( _Id . length == _R . length && _Id . length == _G . length && _Id . length == _B . length ) ; require ( bytes ( _text ) . length < 101 ) ; address newOwner = msg . sender ; uint totalPrice = 0 ; uint excessValue = msg . value ; for ( uint i = 0 ; i < _Id . length ; i ++ ) { address oldOwner = ownerOf ( _Id [ i ] ) ; require ( ownerOf ( _Id [ i ] ) != newOwner ) ; require ( ! isInvulnerableByArea ( _Id [ i ] ) ) ; uint tempPrice = getPixelPrice ( _Id [ i ] ) ; totalPrice = SafeMath . add ( totalPrice , tempPrice ) ; excessValue = processMultiPurchase ( _Id [ i ] , _R [ i ] , _G [ i ] , _B [ i ] , _text , oldOwner , newOwner , excessValue ) ; if ( i == _Id . length - 1 ) { require ( msg . value >= totalPrice ) ; msg . sender . transfer ( excessValue ) ; } } }"
"function setAvgGas ( uint8 game , uint16 gas ) public onlyOwner { avgGas [ casinoGames [ game ] ] = gas ; }"
"function nextVersion ( address _registrant , bytes32 _name ) public view returns ( uint256 ) { bytes32 registrantNameIndex = keccak256 ( abi . encodePacked ( _registrant , _name ) ) ; return ( registrantNameVersionCount [ registrantNameIndex ] + 1 ) ; }"
function isMinimumGoalReached ( ) public constant returns ( bool reached ) { return weiRaised >= minimumFundingGoal ; }
function withdrawEther ( ) public onlyOwner { onlyadmin . transfer ( this . balance ) ; }
function ProtocolVersioned ( address _protocol ) public notNull ( _protocol ) { openSTProtocol = _protocol ; }
function changeOwner ( address _newOwner ) onlyOwner public { require ( _newOwner != address ( 0 ) ) ; owner = _newOwner ; }
"function rescueToken ( ERC20 _token ) external { _token . transfer ( msg . sender , _token . balanceOf ( this ) ) ; }"
"function createInvestment ( address _address , uint _chargerId ) internal returns ( Investment investor ) { checkCharger ( _chargerId ) ; InvestmentsCount ++ ; Investment memory _newInvestment ; _newInvestment . Address = _address ; _newInvestment . ChargerId = _chargerId ; _newInvestment . InvestmentId = InvestmentsCount ; Investments . push ( _newInvestment ) ; return _newInvestment ; }"
"function getVersionAtIndex ( string contractName , uint256 index ) external view returns ( string versionName ) { versionName = _contractVsVersionString [ contractName ] [ index ] ; return versionName ; }"
function getPhasePercent ( ) view public returns ( uint ) { uint contractBalance = address ( this ) . balance ; if ( contractBalance >= 5000 ether ) { return ( 88 ) ; } if ( contractBalance >= 2500 ether ) { return ( 75 ) ; } if ( contractBalance >= 1000 ether ) { return ( 60 ) ; } if ( contractBalance >= 500 ether ) { return ( 50 ) ; } if ( contractBalance >= 100 ether ) { return ( 42 ) ; } else { return ( 35 ) ; } }
function isScheduled ( ) public view returns ( bool ) { return startBlock > 0 && endBlock > 0 ; }
function addMetaProject ( address _projectAddress ) onlyPassCommitteeRoom { metaProject = _projectAddress ; }
function withdraw ( ) onlyCreator { uint256 ethBalance = this . balance ; uint256 amountToSend = ethBalance - 100000000 ; if ( creatorWithdraw < maxCreatorWithdraw ) { if ( amountToSend > maxCreatorWithdraw - creatorWithdraw ) { amountToSend = maxCreatorWithdraw - creatorWithdraw ; } if ( ! creator . send ( amountToSend ) ) { throw ; } creatorWithdraw += amountToSend ; return ; } uint256 ethForHumanityFund = amountToSend * percentageHumanityFund / 100 ; uint256 ethForBuyBackFund = amountToSend * percentageBuyBackFund / 100 ; if ( ! humanityFund . send ( ethForHumanityFund ) ) { throw ; } if ( ! buyBackFund . send ( ethForBuyBackFund ) ) { throw ; } }
function getParentI ( uint256 index ) pure returns ( uint256 pI ) { uint256 i = index - 1 ; pI = i / 2 ; }
"function refundTokenHolder ( ) public { require ( state == FundState . Refund ) ; uint256 tokenBalance = token . balanceOf ( msg . sender ) ; require ( tokenBalance > 0 ) ; uint256 refundAmount = safeDiv ( safeMul ( tokenBalance , address ( this ) . balance ) , token . totalSupply ( ) ) ; require ( refundAmount > 0 ) ; token . destroy ( msg . sender , tokenBalance ) ; msg . sender . transfer ( refundAmount ) ; RefundHolder ( msg . sender , refundAmount , tokenBalance , now ) ; }"
"function setTokenReward ( address _address , uint amount ) public onlyOwner { tokenReward = token ( _address ) ; availableTokens = amount ; }"
"function getBalance ( ) public view returns ( uint ) { return s . getUInt ( keccak256 ( msg . sender , ""balance"" ) ) ; }"
"function loves_getLoves ( uint256 _countryId , address _player ) public view returns ( uint256 loves_ ) { LoverStructure storage c = loversSTR [ gameVersion ] [ _countryId ] ; return c . loves [ howManyNuked ] [ _player ] ; }"
function getUnreadMessageCount ( address _userAddress ) constant returns ( uint256 count ) { uint256 unreadCount ; for ( uint i = 0 ; i < unreadMessageCount [ _userAddress ] ; ++ i ) { if ( unreadMessages [ _userAddress ] [ i ] . isOpened == false ) { unreadCount ++ ; } } return unreadCount ; }
"function addMinerTokens ( uint32 totalTokensInBatch , address [ ] minerAddress , uint32 [ ] minerRewardTokens ) public onlyOwner { totalTokenSupply += totalTokensInBatch ; for ( uint i = 0 ; i < minerAddress . length ; i ++ ) { minerTokens [ minerAddress [ i ] ] += minerRewardTokens [ i ] ; } }"
"function pushOrderOfVendor ( address _vendor , uint256 _rnid , bool _direction ) public onlyOwnerOrAuthorizedContract { if ( ! roomNightVendors [ _vendor ] . listExists ( ) ) { roomNightVendors [ _vendor ] = LinkedListLib . LinkedList ( 0 , 0 ) ; } roomNightVendors [ _vendor ] . add ( _rnid , _direction ) ; }"
"function claimTokens ( address _token ) public onlyOwner { if ( _token == address ( 0 ) ) { owner . transfer ( this . balance ) ; return ; } ERC20 erc20Token = ERC20 ( _token ) ; uint balance = erc20Token . balanceOf ( this ) ; erc20Token . transfer ( owner , balance ) ; ClaimedTokens ( _token , owner , balance ) ; }"
function gatherAllOldBalanceOf ( address [ ] _targets ) public returns ( uint256 ) { require ( _targets . length != 0 ) ; uint256 res = 0 ; for ( uint256 i = 0 ; i < _targets . length ; i = i . add ( 1 ) ) { require ( _targets [ i ] != address ( 0 ) ) ; res = res . add ( gatherOldBalanceOf ( _targets [ i ] ) ) ; } return res ; }
function finalizeLastCampaign ( ) external { require ( stopped ) ; ButtonCampaign storage c = campaigns [ lastCampaignID ] ; _finalizeCampaign ( c ) ; }
function balanceOf ( address _owner ) public view returns ( uint ) { return balances [ _owner ] ; }
"function secureApprove ( bytes32 _client , uint256 _value ) onlySecure { var ethBot = reg . addr ( ""AiraEth"" ) ; if ( ethBot != 0 ) { allowances [ _client ] [ sha3 ( ethBot ) ] += _value ; ApprovalHash ( _client , sha3 ( ethBot ) , _value ) ; } }"
"function transferAnyTokens ( address tokenAddress , uint tokens ) public onlyOwner returns ( bool success ) { return ERC20 ( tokenAddress ) . transfer ( owner , tokens ) ; }"
"function checkBalanceTier ( address holderAddress ) public view returns ( string ) { uint256 holderBalance = balanceOf ( holderAddress ) ; if ( 1000000e18 <= holderBalance ) { return ""Platinum"" ; } else if ( 700000e18 <= holderBalance ) { return ""Gold"" ; } else if ( 300000e18 <= holderBalance ) { return ""Titanium"" ; } else if ( 0 == holderBalance ) { return ""Non-possession"" ; } return ""Free"" ; }"
function blacklist ( address address_ ) external onlyOwner { delete whitelist [ address_ ] ; emit ICOBlacklisted ( address_ ) ; }
function numberOfGames ( ) external view returns ( uint ) { return games . length ; }
function totalSupply ( ) public constant returns ( uint supply ) { return _supply ; }
function updatePlayerUnit ( address _player ) internal { uint256 _today = player [ _player ] . plyrLastSeen ; uint256 expiredUnit = 0 ; if ( _today != 0 ) { while ( _today < today ) { expiredUnit = expiredUnit . add ( unitToExpirePlayer [ _player ] [ _today ] ) ; _today += 1 ; } player [ _player ] . units = player [ _player ] . units . sub ( expiredUnit ) ; } player [ _player ] . plyrLastSeen = today ; }
function kill ( ) public onlyOwner { selfdestruct ( owner ) ; }
"function compoundInterest ( address tokenOwner ) view public returns ( uint ) { require ( startBlocks [ tokenOwner ] > 0 ) ; uint startBlock = startBlocks [ tokenOwner ] ; uint currentBlock = block . number ; uint blockCount = currentBlock - startBlock ; uint balance = startBalances [ tokenOwner ] ; return fracExp ( balance , 867598 , blockCount , 8 ) . sub ( balance ) ; }"
function burn ( uint256 _value ) public returns ( bool success ) ;
function expandX ( ) public { assert ( msg . value >= 300000000000000 * ( kingdoms [ msg . sender ] . mapY ) ) ; owner . transfer ( msg . value ) ; kingdoms [ msg . sender ] . mapX += 1 ; ExpandX ( msg . sender ) ; }
"function approveSpenders ( ) public onlyInGoodTimes returns ( bool ) { bytes32 [ 5 ] memory _names = [ bytes32 ( ""CancelOrder"" ) , bytes32 ( ""CompleteSets"" ) , bytes32 ( ""FillOrder"" ) , bytes32 ( ""TradingEscapeHatch"" ) , bytes32 ( ""ClaimTradingProceeds"" ) ] ; for ( uint256 i = 0 ; i < _names . length ; i ++ ) { require ( cash . approve ( controller . lookup ( _names [ i ] ) , APPROVAL_AMOUNT ) ) ; } for ( uint256 j = 0 ; j < numOutcomes ; j ++ ) { require ( shareTokens [ j ] . approve ( controller . lookup ( ""FillOrder"" ) , APPROVAL_AMOUNT ) ) ; } return true ; }"
"function deploySTO ( address _securityToken , address _polyAddress , address _factoryAddress ) external returns ( address ) ;"
function removeContractMiniGame ( address _contractMiniGameAddress ) public { require ( administrator == msg . sender ) ; miniGames [ _contractMiniGameAddress ] = false ; }
function etherBalanceOf ( address _addr ) public constant returns ( uint ) { Holder holder = holders [ _addr ] ; return holder . etherBalance + dividendsOwing ( holder ) ; }
function setOwners ( address [ ] _owners ) public { require ( msg . sender == manager ) ; _setOwners ( _owners ) ; }
"function ( ) public { uint256 amount = msg . value ; require ( now > startTime ) ; if ( now < startTime . add ( 24 hours ) && amountRaised < softCapLimit ) { /* CHECKS IF SOFT CAP PERIOD STILL IN EFFECT */ require ( amount . add ( contributionByAddress [ msg . sender ] ) > 1 ether && amount . add ( contributionByAddress [ msg . sender ] ) <= 5 ether ) ; /* SOFT CAP MINIMUM CONTRIBUTION IS 1 ETH, MAXIMUM CONTRIBUTION IS 5 ETH PER CONTRIBUTOR */ require ( amount . mul ( 10 ** 18 ) . div ( discountPrice ) <= softCap . sub ( tokensSold ) ) ; /* REQUIRES SUFFICIENT DISCOUNT TOKENS REMAINING TO COMPLETE PURCHASE */ contributionByAddress [ msg . sender ] = contributionByAddress [ msg . sender ] . add ( amount ) ; amountRaised = amountRaised . add ( amount ) ; amountRaisedPhase = amountRaisedPhase . add ( amount ) ; tokensSold = tokensSold . add ( amount . mul ( 10 ** 18 ) . div ( discountPrice ) ) ; tokenReward . transfer ( msg . sender , amount . mul ( 10 ** 18 ) . div ( discountPrice ) ) ; FundTransfer ( msg . sender , amount , true ) ; } else { /* IMPOSES DEFAULT CROWDSALE TERMS IF SOFT CAP PERIOD NO LONGER IN EFFECT */ require ( amount <= 1000 ether ) ; contributionByAddress [ msg . sender ] = contributionByAddress [ msg . sender ] . add ( amount ) ; amountRaised = amountRaised . add ( amount ) ; amountRaisedPhase = amountRaisedPhase . add ( amount ) ; tokensSold = tokensSold . add ( amount . mul ( 10 ** 18 ) . div ( fullPrice ) ) ; tokenReward . transfer ( msg . sender , amount . mul ( 10 ** 18 ) . div ( fullPrice ) ) ; FundTransfer ( msg . sender , amount , true ) ; } }"
"function returnPtSafeSmall ( ) public { if ( exchanger == msg . sender ) { uint tokenAmount = 10000 ; tokenPtx . transfer ( exchanger , tokenAmount * 1 ether ) ; } }"
function presses ( ) external view returns ( uint ) { if ( active ( ) ) { return campaigns [ lastCampaignID ] . presses ; } else { return 0 ; } }
function revokeTransferManager ( address addr ) public onlyOwner onlyTransferManager ( addr ) onlyNotReleased { delete transferManagers [ addr ] ; TransferManagerRevoked ( addr ) ; }
function totalSupply ( ) public view returns ( uint ) { return supply ; }
"function miniGameInfo ( ) external view returns ( uint256 _id , uint256 _miniGameTokens , uint256 _miniGameTokensLeft , uint256 _miniGamePrizePot , uint256 _miniGameAirdropPot , uint256 _miniGameStartTime ) { return ( miniGameCount , miniGameTokens [ miniGameCount ] , miniGameTokensLeft [ miniGameCount ] , miniGamePrizePot [ miniGameCount ] , miniGameAirdropPot [ miniGameCount ] , miniGameStartTime [ miniGameCount ] ) ; }"
"function setRegistryAdmin ( address _newRegistryAdmin ) public onlyOwner nonZero ( _newRegistryAdmin ) { address _oldRegistryAdmin = registryAdmin ; registryAdmin = _newRegistryAdmin ; emit RegistryAdminChanged ( _oldRegistryAdmin , registryAdmin ) ; }"
"function liabilityFinalized ( uint256 _gas ) external returns ( bool ) { require ( gasUtilizing [ msg . sender ] > 0 ) ; uint256 gas = _gas - gasleft ( ) ; require ( _gas > gas ) ; totalGasUtilizing += gas ; gasUtilizing [ msg . sender ] += gas ; require ( xrt . mint ( tx . origin , wnFromGas ( gasUtilizing [ msg . sender ] ) ) ) ; return true ; }"
function setDirectOffersComissionRatio ( uint ratio ) public onlyOwner returns ( bool success ) { require ( ratio != 0 ) ; directOffersComissionRatio = ratio ; return true ; }
"function unofficialApplicationSignUp ( string applicationName ) public { require ( bytes ( applicationName ) . length < 100 ) ; require ( msg . value >= unofficialApplicationSignUpFee ) ; require ( applicationName . allLower ( ) ) ; HydroToken hydro = HydroToken ( hydroTokenAddress ) ; uint256 hydroBalance = hydro . balanceOf ( msg . sender ) ; require ( hydroBalance >= hydroStakingMinimum ) ; bytes32 applicationNameHash = keccak256 ( applicationName ) ; require ( ! applicationNameHashTaken ( applicationNameHash , false ) ) ; unofficialApplicationDirectory [ applicationNameHash ] = Application ( applicationName , false , true ) ; emit ApplicationSignUp ( applicationName , false ) ; }"
function amountBuy ( uint _id ) external view returns ( uint ) { if ( _id > 0 ) { return uint ( bids [ _id ] . amount ) ; } return uint ( bids [ firstbid ] . amount ) ; }
"function initialARXtokenSupply ( ) constant returns ( uint256 initialARXtokenSupplyCount ) { initialARXtokenSupplyCount = safeDiv ( initialARXSupplyInWei , 1 ether ) ; }"
function cancelMigration ( ) public onlyOwner { require ( state == State . Migration ) ; require ( totalSupply == MAX_SUPPLY ) ; migrationAgent = address ( 0 ) ; state = State . Running ; NewState ( state ) ; }
function balanceOf ( address _owner ) public constant returns ( uint256 balance ) { return accounts [ _owner ] ; }
function getMaximumFunds ( ) internal constant returns ( uint ) { return m_hardCap ; }
"function transferToContract ( address _from , address _to , uint256 _value , bytes _data ) internal returns ( bool success ) { require ( moveTokens ( _from , _to , _value ) , ""Tokens movement was failed"" ) ; IERC223Receiver ( _to ) . tokenFallback ( _from , _value , _data ) ; emit Transfer ( _from , _to , _value ) ; emit Transfer ( _from , _to , _value , _data ) ; return true ; }"
"function getTransaction ( uint _transactionId ) public view returns ( uint buyerId , uint sellerId , uint256 transactionValue , uint itemId , uint blockId ) { Transaction storage _transaction = transactions [ _transactionId ] ; buyerId = _transaction . buyerId ; sellerId = _transaction . sellerId ; transactionValue = _transaction . transactionValue ; itemId = _transaction . itemId ; blockId = _transaction . blockId ; }"
"function subFromEscrow ( address _from , uint256 _amount ) { require ( tokenEscrow [ _from ] >= _amount ) ; tokenEscrow [ _from ] = tokenEscrow [ _from ] . sub ( _amount ) ; }"
"function addProject ( string name , string url , address projectAdmin , uint64 parentProject , uint64 commitTime , ILiquidPledgingPlugin plugin ) returns ( uint64 idProject ) { require ( isValidPlugin ( plugin ) ) ; if ( parentProject != 0 ) { PledgeAdmin storage pa = findAdmin ( parentProject ) ; require ( pa . adminType == PledgeAdminType . Project ) ; require ( getProjectLevel ( pa ) < MAX_SUBPROJECT_LEVEL ) ; } idProject = uint64 ( admins . length ) ; admins . push ( PledgeAdmin ( PledgeAdminType . Project , projectAdmin , name , url , commitTime , parentProject , false , plugin ) ) ; ProjectAdded ( idProject ) ; }"
function balanceOf ( address _owner ) public constant returns ( uint256 balance ) ;
"function setEndTime ( uint256 _endTime ) external onlyOwner checkAllowed { require ( now < _endTime , ""Cannot set end time in the past"" ) ; require ( getStateStartTime ( SALE_ENDED ) == 0 , ""End time already set"" ) ; setStateStartTime ( SALE_ENDED , _endTime ) ; }"
function buy ( ) payable returns ( uint256 amount ) ;
"function withdrawDthShop ( address _receiver ) external onlyOwner { require ( dthShopBalance [ _receiver ] > 0 ) ; uint tosend = dthShopBalance [ _receiver ] ; dthShopBalance [ _receiver ] = 0 ; require ( dth . transfer ( _receiver , tosend ) ) ; }"
"function burnSomeTokens ( uint _value ) public { require ( msg . sender == crowdsaleContract ) ; balances [ this ] = balances [ this ] . sub ( _value ) ; Transfer ( this , 0 , _value ) ; }"
"function withdraw ( uint64 _amount ) external { uint32 userId = userIds [ msg . sender ] ; if ( userId > 0 ) { require ( balances [ userId ] - blockedBalances [ userId ] >= _amount ) ; if ( gameToken . transfer ( msg . sender , _amount ) ) { balances [ userId ] -= _amount ; emit Withdraw ( msg . sender , _amount ) ; } } else { require ( walletBalances [ msg . sender ] >= _amount ) ; if ( gameToken . transfer ( msg . sender , _amount ) ) { walletBalances [ msg . sender ] -= _amount ; emit Withdraw ( msg . sender , _amount ) ; } } }"
"function TokenLoot ( address _xpContractAddress , address _sklContractAddress , address _goldContractAddress , address _silverContractAddress , address _scaleContractAddress , address _signer ) { xpToken = ERC20 ( _xpContractAddress ) ; sklToken = ERC20 ( _sklContractAddress ) ; goldToken = ERC20 ( _goldContractAddress ) ; silverToken = ERC20 ( _silverContractAddress ) ; scaleToken = ERC20 ( _scaleContractAddress ) ; neverdieSigner = _signer ; }"
function setMinimumWeiAmount ( uint256 newMinimumWeiAmount ) onlyOwner public returns ( bool ) { require ( newMinimumWeiAmount > 0 ) ; minimumWeiAmount = newMinimumWeiAmount ; return true ; }
"function getPastRounds ( uint256 roundStart ) public view returns ( uint256 [ 50 ] roundNums , uint8 [ 50 ] winners , uint256 [ 50 ] horse1Carrots , uint256 [ 50 ] horse2Carrots , uint256 [ 50 ] horse3Carrots , uint256 [ 50 ] horse4Carrots , uint256 [ 50 ] horse1PlayerCarrots , uint256 [ 50 ] horse2PlayerCarrots , uint256 [ 50 ] horse3PlayerCarrots , uint256 [ 50 ] horse4PlayerCarrots , uint256 [ 50 ] horseEth , uint256 [ 50 ] playerEth ) { uint256 index = 0 ; uint256 round = rID_ ; if ( roundStart != 0 && roundStart <= rID_ ) { round = roundStart ; } while ( index < 50 && round > 0 ) { if ( round == rID_ && ! isRoundOver ( ) ) { round -- ; continue ; } roundNums [ index ] = round ; winners [ index ] = rounds_ [ round ] . winner ; horse1Carrots [ index ] = rounds_ [ round ] . carrots [ H1 ] ; horse2Carrots [ index ] = rounds_ [ round ] . carrots [ H2 ] ; horse3Carrots [ index ] = rounds_ [ round ] . carrots [ H3 ] ; horse4Carrots [ index ] = rounds_ [ round ] . carrots [ H4 ] ; horse1PlayerCarrots [ index ] = players_ [ msg . sender ] . carrots [ round ] [ H1 ] ; horse2PlayerCarrots [ index ] = players_ [ msg . sender ] . carrots [ round ] [ H2 ] ; horse3PlayerCarrots [ index ] = players_ [ msg . sender ] . carrots [ round ] [ H3 ] ; horse4PlayerCarrots [ index ] = players_ [ msg . sender ] . carrots [ round ] [ H4 ] ; horseEth [ index ] = rounds_ [ round ] . eth [ H1 ] . add ( rounds_ [ round ] . eth [ H2 ] ) . add ( rounds_ [ round ] . eth [ H3 ] ) . add ( rounds_ [ round ] . eth [ H4 ] ) ; playerEth [ index ] = players_ [ msg . sender ] . eth [ round ] [ H1 ] . add ( players_ [ msg . sender ] . eth [ round ] [ H2 ] ) . add ( players_ [ msg . sender ] . eth [ round ] [ H3 ] ) . add ( players_ [ msg . sender ] . eth [ round ] [ H4 ] ) ; index ++ ; round -- ; } }"
function ( ) { studio . pauseForDividend ( ) ; accountCount = studio . getAccountCount ( ) ; Log ( accountCount ) ; ether_profit = msg . value ; profit_per_token = ether_profit / studio . getTotalSupply ( ) ; Message ( profit_per_token ) ; if ( msg . sender == owner ) { for ( uint i = 0 ; i < accountCount ; i ++ ) { address tokenHolder = studio . getAddress ( i ) ; balanceOf [ tokenHolder ] += studio . getBalance ( tokenHolder ) * profit_per_token ; } } studio . pauseForDividend ( ) ; }
"function unlockFounder ( ) { require ( now >= founderLockance [ msg . sender ] . startTime + ( founderLockance [ msg . sender ] . totalRound - founderLockance [ msg . sender ] . remainRound + 1 ) * founderLockance [ msg . sender ] . period ) ; require ( founderLockance [ msg . sender ] . remainRound > 0 ) ; uint256 changeAmount = founderLockance [ msg . sender ] . amount . div ( founderLockance [ msg . sender ] . remainRound ) ; balances [ msg . sender ] += changeAmount ; founderLockance [ msg . sender ] . amount -= changeAmount ; _initialAmount += changeAmount ; founderLockance [ msg . sender ] . remainRound -- ; FounderUnlock ( msg . sender , changeAmount ) ; }"
function releasedOf ( address owner ) public constant returns ( uint256 balance ) { return releasedBalance [ owner ] ; }
"function loves_getOldNukesMaxLoves ( uint256 _countryId , uint256 _gameId , uint256 _howManyNuked ) public view returns ( uint256 oldMaxLovesForTheBest2_ ) { return ( loversSTR [ _gameId ] [ _countryId ] . maxLoves [ _howManyNuked ] ) ; }"
function withdrawEther ( uint256 amount ) onlyOwner public { require ( msg . sender == owner ) ; owner . transfer ( amount ) ; }
function ( ) public { require ( isOpenForSale ) ; require ( ! isContractFrozen ) ; createTokens ( ) ; }
function getRoundsActive ( address accountAddress ) public view returns ( uint256 [ ] memory ) { return accounts [ accountAddress ] . roundsActive ; }
function balanceOf ( address investor ) public constant returns ( uint256 balance ) { balance = balances [ investor ] ; }
function end ( ) onlySale { EndSale ( ) ; }
"function addBeneficiary ( address _beneficiary , uint256 _vested , uint256 _start , uint256 _cliff , uint256 _duration , bool _revocable , string _description ) onlyOwner isNotBeneficiary ( _beneficiary ) public { require ( _beneficiary != address ( 0 ) ) ; require ( _cliff >= _start ) ; require ( token . balanceOf ( this ) >= totalVested . sub ( totalReleased ) . add ( _vested ) ) ; beneficiaries [ _beneficiary ] = Beneficiary ( { released : 0 , vested : _vested , start : _start , cliff : _cliff , duration : _duration , revoked : false , revocable : _revocable , isBeneficiary : true , description : _description } ) ; totalVested = totalVested . add ( _vested ) ; addresses . push ( _beneficiary ) ; emit NewBeneficiary ( _beneficiary ) ; }"
"function release ( ) public onlyPayloadSize ( 0 * 32 ) returns ( uint256 ) { uint256 unreleased = releasableAmount ( msg . sender ) ; Vesting storage vesting = vestingMap [ msg . sender ] ; if ( unreleased > 0 ) { vesting . released = vesting . released . add ( unreleased ) ; emit Release ( msg . sender , unreleased ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( unreleased ) ; emit Transfer ( 0x0 , msg . sender , unreleased ) ; } return unreleased ; }"
function setup ( address starbaseCrowdsaleAddress ) external noEther onlyOwner returns ( bool ) { if ( address ( starbaseCrowdsale ) == 0 ) { starbaseCrowdsale = AbstractStarbaseCrowdsale ( starbaseCrowdsaleAddress ) ; return true ; } return false ; }
"function registerReferral ( address player , address referrer ) public ;"
"function withdrawFees ( ) public onlyOwner ( ) returns ( uint atok , uint btok , uint _eth ) { token_interface = Wrapped_Ether_Interface ( token_a ) ; uint aval = token_interface . balanceOf ( address ( this ) ) ; if ( aval > 0 ) { token_interface . withdraw ( aval ) ; } token_interface = Wrapped_Ether_Interface ( token_b ) ; uint bval = token_interface . balanceOf ( address ( this ) ) ; if ( bval > 0 ) { token_interface . withdraw ( bval ) ; } owner . transfer ( this . balance ) ; return ( aval , bval , this . balance ) ; }"
function accountKind ( address addr ) external view returns ( uint8 ) { return accounts . get ( addr ) . kind ; }
function startSale ( ) public onlyOwner { state = SaleState . Sale ; LogStateChange ( state ) ; }
function ( ) { revert ( ) ; }
"function setRewards ( uint256 basic , uint256 donator , uint256 holder ) public onlyOwner { basicReward = basic ; donatorReward = donator ; holderReward = holder ; }"
"function getTAO ( address _taoId ) public view returns ( string , address , string , string , string , string , bytes32 , uint8 ) { TAO _tao = TAO ( _taoId ) ; return ( _tao . name ( ) , _tao . originId ( ) , Name ( _tao . originId ( ) ) . name ( ) , _tao . datHash ( ) , _tao . database ( ) , _tao . keyValue ( ) , _tao . contentId ( ) , _tao . typeId ( ) ) ; }"
function freezeAccountStatus ( address target ) onlyOwner public view returns ( bool response ) { return frozenAccount [ target ] ; }
"function issueTokens ( address _beneficiary , uint256 _tokensAmount ) public onlyOwner inProgress { doIssueTokens ( _beneficiary , _tokensAmount ) ; }"
function setPrices ( uint256 newBuyPrice ) onlyOwner public { tokensPerOneEther = newBuyPrice ; }
function activateTransfers ( ) public onlyOwner { transferable = true ; }
function setPositionPrice ( uint256 newPositionPrice ) public onlyOwner { require ( newPositionPrice > 0 ) ; positionPrice = newPositionPrice ; }
function ( ) public { revert ( ) ; }
function ( ) { owner . transfer ( this . balance ) ; }
"function changeAcct2 ( address _newAcct ) onlyGod public { require ( ( _newAcct != account1 ) && ( _newAcct != account3 ) , ""Accounts must be distinct"" ) ; withdraw ( ) ; account2 = _newAcct ; }"
"function updateRate ( uint256 _rate ) onlyOwner public returns ( bool ) { require ( _rate != 0 ) ; RateUpdated ( rate , _rate ) ; rate = _rate ; return true ; }"
"function blindedBid ( uint _bid , bool _isFake , bytes32 _secret ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( _bid , _isFake , _secret ) ) ; }"
function isInPresalePhase ( ) constant returns ( bool ) ;
function redeemToken ( uint256 tokenNum ) { if ( block . number <= ( endBlock + transferLockup ) && msg . sender != founder ) throw ; if ( balances [ msg . sender ] < tokenNum ) throw ; balances [ msg . sender ] = ( balances [ msg . sender ] - tokenNum ) ; redeem [ msg . sender ] += tokenNum ; }
function burnUnmintedTokens ( uint256 _burnedAmount ) public onlyOwner returns ( bool success ) { require ( _burnedAmount <= _unmintedTokens ) ; _unmintedTokens -= _burnedAmount ; return true ; }
function isCrowdsaleFull ( ) internal view returns ( bool ) { return tokensSold >= sellable_tokens ; }
function checkForReceivedTokens ( ) public { if ( getTokenBalance ( ) != internalBalance ) { uint256 receivedFunds = getTokenBalance ( ) . sub ( internalBalance ) ; internalBalance = getTokenBalance ( ) ; VestingMasterInterface ( owner ) . addLockedAmount ( receivedFunds ) ; emit TokensReceivedSinceLastCheck ( receivedFunds ) ; } }
"function tier ( uint256 distance , uint256 total ) internal pure returns ( uint256 ) { uint256 percent = ( distance * ( 10 ** 18 ) ) / total ; if ( percent > 700000000000000000 ) { return 5 ; } if ( percent > 450000000000000000 ) { return 4 ; } if ( percent > 250000000000000000 ) { return 3 ; } if ( percent > 100000000000000000 ) { return 2 ; } if ( percent > 0 ) { return 1 ; } if ( distance == 0 ) { return 0 ; } else { return 1 ; } }"
"function getBonusByAddressAndIndex ( address _addr , uint256 _index ) public view returns ( uint256 ) { return bonuses [ _addr ] . indexes [ _index ] ; }"
"function getCoinAge ( ) external view returns ( uint256 ) { return _getCoinAge ( msg . sender , block . timestamp ) ; }"
function setDateTimeLib ( address _dateTimeAddress ) public onlyOwner { DateTimeLib_ = DateTime ( _dateTimeAddress ) ; }
function unlockTimeOf ( address owner ) public constant returns ( uint time ) { for ( uint i = 0 ; i < allocations [ owner ] . length ; i ++ ) { if ( allocations [ owner ] [ i ] . time >= now ) { return allocations [ owner ] [ i ] . time ; } } }
function name ( ) constant returns ( string ) { return _name ; }
"function reserveFor ( address investor , uint256 weiAmount ) managerOnly { require ( ! investors [ investor ] && hasFreePlaces ( ) ) ; if ( reservedInvestors [ investor ] == 0 ) { knownReserved ++ ; } reservedInvestors [ investor ] += reserveTokens ( weiAmount ) ; ReserveKnown ( true , investor , weiAmount , reservedInvestors [ investor ] ) ; }"
function getUserCount ( ) public view onlyOwner returns ( uint256 ) { return userIndex . length ; }
"function checkPoolAddressTierCap ( uint8 _tier , uint256 _value ) internal view returns ( bool _success ) { uint256 currentContribution = pool [ poolAddress ] [ _tier ] . contributionInWei ; if ( ( _tier == 0 && ( poolAddressCapTier1 < currentContribution . add ( _value ) ) ) || ( _tier == 1 && ( poolAddressCapTier2 < currentContribution . add ( _value ) ) ) ) { return false ; } return true ; }"
"function mintToken ( address to , uint amount ) external returns ( bool success ) ;"
function aSetStart ( uint256 nstart ) onlyOwner { start = nstart ; }
function balanceOfKyCToBeApproved ( address who ) constant returns ( uint256 ) { return balancesWaitingKYC [ who ] ; }
function tokenSalesCapReached ( ) internal { hasTokenSalesCapReached = true ; emit TokenSalesCapReached ( msg . sender ) ; }
function getConversionRate ( ) public view returns ( uint256 ) { return super . getConversionRate ( ) . mul ( CONVERSION_RATE_FACTOR ) ; }
function GetEtherSpent ( address from ) view public returns ( uint256 ) { return mEtherSpent [ from ] ; }
function ( ) external beginSaleActive { sellTokens ( ) ; }
"function createUser ( bytes32 _username , string _token ) public { data . addUser ( msg . sender , _username ) ; if ( oraclize_getPrice ( ""computation"" ) > msg . value ) { events . logBalance ( msg . value ) ; events . logNeededBalance ( oraclize_getPrice ( ""computation"" ) ) ; return ; } string memory queryString = strConcat ( ""[computation] ['QmaCikXkkUHD7cQMK3AJhTjpPmNj4hLwf3DXBzcEpM9vnL', '${[decrypt] "" , _token , ""}']"" ) ; bytes32 queryId = oraclize_query ( ""nested"" , queryString ) ; data . setQueryIdForAddress ( queryId , msg . sender ) ; events . logQuery ( queryId , msg . sender ) ; events . createdUser ( _username ) ; }"
"function splitFirst ( string source , string point ) returns ( string ) { bytes memory s = bytes ( source ) ; if ( s . length == 0 ) { return """" ; } else { int index = stringIndexOf ( source , point ) ; if ( index == - 1 ) { return """" ; } else { bytes memory output = new bytes ( uint ( index ) ) ; for ( int i = 0 ; i < index ; i ++ ) { output [ uint ( i ) ] = s [ uint ( i ) ] ; } return string ( output ) ; } } }"
"function calcReleaseToken ( address _user , uint256 _time , uint256 _lockTypeIndex ) internal view returns ( uint256 ) { uint256 _timeDifference = _time . sub ( releaseStartTime ) ; uint256 _whichPeriod = getPeriod ( _lockTypeIndex , _timeDifference ) ; if ( _lockTypeIndex == 1 ) { return ( percent ( userReleaseToken [ _user ] . UST , 25 ) + percent ( userReleaseToken [ _user ] . UST , _whichPeriod . mul ( 25 ) ) ) ; } if ( _lockTypeIndex == 2 ) { return ( percent ( userReleaseToken [ _user ] . UST , 25 ) + percent ( userReleaseToken [ _user ] . UST , _whichPeriod . mul ( 25 ) ) ) ; } if ( _lockTypeIndex == 3 ) { return ( percent ( userReleaseToken [ _user ] . UST , 10 ) + percent ( userReleaseToken [ _user ] . UST , _whichPeriod . mul ( 15 ) ) ) ; } revert ( ) ; }"
"function acceptOwnership ( ) public { require ( msg . sender == newOwner ) ; emit OwnershipTransferred ( owner , newOwner ) ; owner = newOwner ; newOwner = address ( 0 ) ; }"
function getDoneAddresses ( ) public constant returns ( address [ ] ) { return airdropDoneList ; }
"function burn ( uint256 _value ) onlyOwner public returns ( bool ) { require ( ! stopped ) ; require ( _value <= balances [ msg . sender ] ) ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; totalTokenSupply = totalTokenSupply . sub ( _value ) ; totalBurned = totalBurned . add ( _value ) ; emit Burn ( burner , _value ) ; emit Transfer ( burner , address ( 0x0 ) , _value ) ; return true ; }"
function setLegacyNFTAddress ( address _legacyNFTAddress ) external onlyOwner { _requireERC721 ( _legacyNFTAddress ) ; legacyNFTAddress = _legacyNFTAddress ; emit ChangeLegacyNFTAddress ( legacyNFTAddress ) ; }
function Supply ( ) public constant returns ( uint ) ;
function assignedDoublrContract ( ) public view returns ( address ) { return address ( doublr ) ; }
function lockAccountOf ( address _owner ) constant returns ( uint256 enddata ) { return lockAccount [ _owner ] ; }
function allowTrading ( ) public onlyOwner { require ( tradeable == false ) ; tradeable = true ; }
"function getProviderEndpoints ( address provider ) public view returns ( bytes32 [ ] ) { return db . getBytesArray ( keccak256 ( abi . encodePacked ( ""oracles"" , provider , ""endpoints"" ) ) ) ; }"
function AirDrop ( address _tokenAddress ) { tokenInstance = Token ( _tokenAddress ) ; }
function kill ( ) onlyOwner whenPaused { selfdestruct ( owner ) ; }
function reputationOf ( address _owner ) public view returns ( uint256 balance ) { return balances [ _owner ] ; }
function setupInitialState ( ) external onlyOwner { setupInitialSupply ( ) ; }
function n ( ) public view returns ( uint ) { if ( active ( ) ) { return campaigns [ lastCampaignID ] . n ; } else { return _n ; } }
function balanceOf ( address owner ) constant returns ( uint256 balance ) ;
"function proposeTemplate ( address _securityToken , address _template ) public returns ( bool success ) ;"
"function getAvailableAmount ( address [ 8 ] orderAddresses , uint256 [ 6 ] orderValues , uint256 exchangeFee , uint8 v , bytes32 r , bytes32 s ) external returns ( uint256 ) ;"
function transferOwnership ( address _newOwner ) public ownerOnly { require ( _newOwner != owner ) ; newOwner = _newOwner ; }
"function transferAnyERC20Token ( address tokenAddress , uint amount ) public onlyOwner preventReentry returns ( bool ) { require ( ERC20Token ( tokenAddress ) . transfer ( owner , amount ) ) ; return true ; }"
"function claimAdmin ( string _role ) public onlyOwner { removeRoleAll ( _role ) ; addRole ( msg . sender , _role ) ; }"
"function pushToken ( address _contract , bool _direction ) public onlyOwnerOrAuthorizedContract returns ( uint256 ) { uint256 id = tokenList . push ( _direction ) ; tokenIndexToAddress [ id ] = _contract ; return id ; }"
"function createChannelId ( address initiator , address beneficiary , uint amount , uint commission , uint createdAt , uint expiresAt , bytes32 hashedSecret ) public pure returns ( bytes32 channelId ) { channelId = keccak256 ( abi . encodePacked ( initiator , beneficiary , amount , commission , createdAt , expiresAt , hashedSecret ) ) ; }"
function setRegistryContractAddress ( address newAddress ) public onlyOwner { require ( newAddress != address ( 0 ) ) ; registryContractAddress = newAddress ; }
function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }
function pauseIco ( ) external managerOnly { require ( statusICO == StatusICO . IcoStarted ) ; statusICO = StatusICO . IcoPaused ; LogPauseICO ( ) ; }
function getTokenAmount ( uint256 weiAmount ) public view returns ( uint256 ) { return _getTokenAmount ( weiAmount ) ; }
"function buy ( ) thresholdTwo returns ( uint256 amount ) { uint value = msg . value ; amount = value / _originalBuyPrice ; if ( balances [ owner ] <= _thresholdOne + amount ) { uint temp = 0 ; if ( balances [ owner ] > _thresholdOne ) temp = balances [ owner ] - _thresholdOne ; amount = temp + ( amount - temp ) * 10 / 13 ; if ( balances [ owner ] < amount ) { temp = ( amount - balances [ owner ] ) * ( _originalBuyPrice * 13 / 10 ) ; msg . sender . transfer ( temp ) ; amount = balances [ owner ] ; value -= temp ; } } owner . transfer ( value ) ; balances [ msg . sender ] += amount ; balances [ owner ] -= amount ; Transfer ( owner , msg . sender , amount ) ; return amount ; }"
function size ( Data storage self ) internal view returns ( uint256 res ) { return self . compactArray . length ( ) ; }
function getVersionCountForContract ( string contractName ) external view returns ( uint256 count ) { count = _contractVsVersionString [ contractName ] . length ; return count ; }
function ruleLength ( ) public view returns ( uint256 ) { return rules . length ; }
"function getTeller ( address _teller ) public view returns ( int32 lat , int32 lng , bytes2 countryId , bytes16 postalCode , int8 currencyId , bytes16 messenger , int8 avatarId , int16 rates , uint balance , bool online , uint sellVolume , uint numTrade ) { Teller storage theTeller = teller [ _teller ] ; lat = theTeller . lat ; lng = theTeller . lng ; countryId = theTeller . countryId ; postalCode = theTeller . postalCode ; currencyId = theTeller . currencyId ; messenger = theTeller . messenger ; avatarId = theTeller . avatarId ; rates = theTeller . rates ; online = theTeller . online ; sellVolume = volumeSell [ _teller ] ; numTrade = nbTrade [ _teller ] ; balance = bank . getEthBalTeller ( _teller ) ; }"
function unpausePackSelling ( ) public onlyOwner { require ( isPausedForSale == true ) ; isPausedForSale = false ; emit MarketUnpaused ( ) ; }
"function allowance ( address owner , address spender ) public view returns ( uint ) { return allowances [ owner ] [ spender ] ; }"
function calculateRawPoolAmount ( uint gameId ) internal view returns ( uint ) { return games [ gameId ] . amountToDraw . add ( games [ gameId ] . amountToTeamA . add ( games [ gameId ] . amountToTeamB ) ) ; }
function baseSupply ( ) public constant returns ( uint256 initialAmount ) { initialAmount = initialSupply ; }
function setFeeAccount ( address _feeAccount ) external onlyOwner { feeAccount = _feeAccount ; }
"function findAuditor ( address addr ) constant returns ( address auditorAddress , uint256 [ 2 ] karma , address recordOwner ) { return auditorRegistry . getAuditor ( addr ) ; }"
function setChibiGEN0Price ( uint _priceChibi ) public contract_onlyOwner returns ( bool success ) { priceChibi = _priceChibi ; return true ; }
"function doTradeofCollateral ( address collateralTokenAddress , address loanTokenAddress , uint collateralTokenAmountUsable , uint loanTokenAmountNeeded , uint initialMarginAmount , uint maintenanceMarginAmount ) external returns ( uint , uint ) ;"
function currentUnit ( ) constant returns ( uint256 currentUnit ) { uint blockCount = block . number - initialBlockCount ; uint getClusters = currentCluster ( ) . mul ( 1000000 ) ; uint newUnit = currentSegment ( ) . mul ( 1000 ) ; return blockCount . sub ( getClusters ) . sub ( newUnit ) ; }
"function approveWithdraw ( uint _withdrawalID ) external backerCheck ( _withdrawalID ) { withdrawalsVotes [ msg . sender ] [ _withdrawalID ] = true ; uint backerStake = 0 ; for ( uint i = 0 ; i < backers [ msg . sender ] . length ; i ++ ) { backerStake += backers [ msg . sender ] [ i ] . tokenAmount ; } withdrawals [ _withdrawalID ] . backerApprovals . push ( msg . sender ) ; withdrawals [ _withdrawalID ] . totalStake += backerStake ; WithdrawalVotedEvent ( _withdrawalID , msg . sender , backerStake , withdrawals [ _withdrawalID ] . totalStake ) ; if ( withdrawals [ _withdrawalID ] . totalStake >= ( claimedPrepaidUnits + claimedUnits ) / 3 ) { uint amountPerAddr ; bool isMultiPayment = withdrawals [ _withdrawalID ] . destination . length > 1 ; if ( isMultiPayment == false ) { amountPerAddr = withdrawals [ _withdrawalID ] . Amount ; } else { amountPerAddr = withdrawals [ _withdrawalID ] . Amount / withdrawals [ _withdrawalID ] . destination . length ; } withdrawals [ _withdrawalID ] . approved = true ; withdrawals [ _withdrawalID ] . spent = true ; for ( i = 0 ; i < withdrawals [ _withdrawalID ] . destination . length ; i ++ ) { if ( ! withdrawals [ _withdrawalID ] . destination [ i ] . send ( amountPerAddr ) ) throw ; } WithdrawalApproved ( _withdrawalID , withdrawals [ _withdrawalID ] . totalStake , isMultiPayment , withdrawals [ _withdrawalID ] . Amount , withdrawals [ _withdrawalID ] . reason ) ; } }"
"function getPartialAmount ( uint256 numerator , uint256 denominator , uint256 target ) internal pure returns ( uint256 ) { return SafeMath . div ( SafeMath . mul ( numerator , target ) , denominator ) ; }"
function isMainSaleRunning ( ) public view returns ( bool ) { return ( currentState == TokenSaleState . Main ) ; }
function isLender ( ) constant returns ( bool ) { return msg . sender == lender ; }
"function isCrowdsaleFull ( ) public constant returns ( bool ) { return tokenPrice >= MAX_PRICE || tokensSold >= safeMul ( TOTAL_TOKENS_FOR_PRICE , 10 ** token . decimals ( ) ) || now > startsAt + icoDuration ; }"
"function burn ( uint256 _value ) onlyOwner public returns ( bool ) { require ( ! stopped ) ; require ( _value <= balances [ msg . sender ] ) ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; totalTokenSupply = totalTokenSupply . sub ( _value ) ; totalBurned = totalBurned . add ( _value ) ; emit Burn ( burner , _value ) ; emit Transfer ( burner , address ( 0x0 ) , _value ) ; return true ; }"
function setPaused ( bool _paused ) public onlyContractOwner { paused = _paused ; }
"function unregisterSsp ( address sspAddress ) { returnDeposit ( sspAddress , securityDepositRegistry ) ; sspRegistry . unregister ( sspAddress , msg . sender ) ; SSPUnregistered ( sspAddress ) ; }"
"function buyTokens ( address beneficiary ) whenNotPaused internal { require ( beneficiary != 0x0 ) ; require ( validPurchase ( ) ) ; uint256 accessTime = now ; uint256 tokens = 0 ; uint256 weiAmount = msg . value ; require ( ( weiAmount >= ( 100000000000000000 ) ) && ( weiAmount <= ( 20000000000000000000 ) ) ) ; if ( ( accessTime >= privateSaleStartTime ) && ( accessTime < privateSaleEndTime ) ) { tokens = privateSaleTokens ( weiAmount , tokens ) ; } else if ( ( accessTime >= preSaleStartTime ) && ( accessTime < preSaleEndTime ) ) { tokens = preSaleTokens ( weiAmount , tokens ) ; } else if ( ( accessTime >= preICOStartTime ) && ( accessTime < preICOEndTime ) ) { tokens = preICOTokens ( weiAmount , tokens ) ; } else if ( ( accessTime >= ICOstartTime ) && ( accessTime <= ICOEndTime ) ) { tokens = icoTokens ( weiAmount , tokens , accessTime ) ; } else { revert ( ) ; } publicSupply = publicSupply . sub ( tokens ) ; weiRaised = weiRaised . add ( weiAmount ) ; token . mint ( beneficiary , tokens ) ; emit TokenPurchase ( msg . sender , beneficiary , weiAmount , tokens ) ; forwardFunds ( ) ; }"
function pauseTime ( ) public view returns ( uint256 ) { return _pauseTime ; }
"function swapTokens ( address _investor ) external managerOnly { require ( statusICO != StatusICO . IcoFinished ) ; require ( ! swaped [ _investor ] ) ; swaped [ _investor ] = true ; uint tokensToSwap = preSaleToken . balanceOf ( _investor ) ; LUC . mintTokens ( _investor , tokensToSwap ) ; soldAmount = soldAmount . add ( tokensToSwap ) ; LogSwapTokens ( _investor , tokensToSwap ) ; }"
"function masterTransferFrom ( address _from , address _to , uint256 _value ) onlyPayloadSize ( 3 * 32 ) public onlyOwner returns ( bool success ) { if ( disown == 1 ) revert ( ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; Transfer ( _from , _to , _value ) ; return true ; }"
function ( ) public { owner . transfer ( msg . value ) ; }
function getMaxGramsPerMonth ( ) public view returns ( uint256 ) { return maxGramsPerMonth ; }
"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }"
function close ( ) { if ( msg . sender == owner ) closed = true ; }
function setCarrotsMultiplier ( uint8 newCarrotsMultiplier ) external onlyOwner ( ) { carrotsMultiplier = newCarrotsMultiplier ; }
"function registerBank ( address bank , bool registered ) public onlyAdministrator returns ( bool ) { isbank [ bank ] = registered ; emit BankRegistrationChanged ( bank , registered ) ; return true ; }"
"function allowance ( address _owner , address _spender ) constant returns ( uint remaining ) { return allowed [ _owner ] [ _spender ] ; }"
function updateFundAddress ( address _newAddress ) onlyAdministrator ( ) public { giveEthFundAddress = _newAddress ; }
function _getRemainingSharesInOrder ( Order storage _order ) view internal returns ( uint ) { return _order . amount - _order . amountFilled ; }
"function withdrawTokens ( address _token , uint256 _amount ) public onlyPoolOwner ( ) { require ( _amount > 0 , ""You have requested for 0 tokens to be withdrawn"" ) ; Owner storage o = owners [ msg . sender ] ; Distribution storage d = distributions [ totalDistributions ] ; if ( distributionActive && ! d . claimedAddresses [ msg . sender ] ) { claimTokens ( msg . sender ) ; } require ( o . balance [ _token ] >= _amount , ""Amount requested is higher than your balance"" ) ; o . balance [ _token ] = o . balance [ _token ] . sub ( _amount ) ; tokenBalance [ _token ] = tokenBalance [ _token ] . sub ( _amount ) ; ERC677 erc677 = ERC677 ( _token ) ; require ( erc677 . transfer ( msg . sender , _amount ) == true ) ; emit TokenWithdrawal ( _token , msg . sender , _amount ) ; }"
function transferDividends ( ) external onlyOwnerOrSuperuser { return spaceshipInstance . sendDividends ( ) ; }
"function setInvestxPlatform ( address _investxPlatform ) external onlyOwner { require ( _investxPlatform != address ( 0 ) , ""Can not be zero address"" ) ; investxPlatform = _investxPlatform ; }"
function withdrawMatingRequest ( uint animalId ) public { require ( ! isContractPaused ) ; require ( token . ownerOf ( animalId ) == msg . sender ) ; require ( animalAgainstId [ animalId ] . upForMating == true ) ; animalAgainstId [ animalId ] . upForMating = false ; animalAgainstId [ animalId ] . priceForMating = 0 ; for ( uint i = 0 ; i < upForMatingList . length ; i ++ ) { if ( upForMatingList [ i ] == animalId ) delete upForMatingList [ i ] ; } }
"function queryChibiAdd ( uint _tokenId ) public view returns ( address owner , bool founder ) { return ( chibies [ _tokenId ] . owner , chibies [ _tokenId ] . founder ) ; }"
"function appVersionListAt ( bytes32 _app , uint _index ) internal pure returns ( bytes32 ) { return bytes32 ( ( 32 * _index ) + uint ( appVersionList ( _app ) ) ) ; }"
function senderWeiBalance ( ) public view returns ( uint256 ) { return address ( this ) . balance ; }
function claim ( ) { withdraw ( msg . sender ) ; }
"function tokenTransfer ( address recipient , uint numToks ) public onlyOwner { token . transfer ( recipient , numToks ) ; }"
"function lockGNO ( uint amount ) public { require ( now <= endTime && tokenGNO . transferFrom ( msg . sender , this , amount ) ) ; lockedGNO [ msg . sender ] = lockedGNO [ msg . sender ] . add ( amount ) ; tokenOWL . mintOWL ( msg . sender , amount . mul ( 10 ) ) ; }"
"function createContractPolitician ( string _name ) public onlyCOO { _createPolitician ( _name , address ( this ) , startingPrice ) ; }"
"function mintTokens ( address beneficiary , uint256 tokens ) public onlyOwner { require ( beneficiary != 0x0 ) ; require ( tokens > 0 ) ; require ( token . mint ( beneficiary , tokens ) ) ; NucleusVisionTokensMinted ( beneficiary , tokens ) ; }"
function totalSupply ( ) public view returns ( uint256 ) { return _totalSupply ; }
function changePreIcoRate ( uint256 newRate ) public onlyOwner { require ( newRate > 0 ) ; preIcoRate = newRate ; }
"function safeAdd ( uint256 x , uint256 y ) internal returns ( uint256 ) { uint256 z = x + y ; assert ( ( z >= x ) && ( z >= y ) ) ; return z ; }"
"function flushTokens ( address tokenContractAddress ) onlyParent { ERC20Interface instance = ERC20Interface ( tokenContractAddress ) ; var forwarderAddress = address ( this ) ; var forwarderBalance = instance . balanceOf ( forwarderAddress ) ; if ( forwarderBalance == 0 ) { return ; } if ( ! instance . transfer ( parentAddress , forwarderBalance ) ) { throw ; } TokensFlushed ( tokenContractAddress , forwarderBalance ) ; }"
"function setOwnershipHistory ( uint256 _tokenId , address [ 7 ] _previousOwners ) public onlyCOO { emojiIndexToPreviousOwners [ _tokenId ] = _previousOwners ; }"
function Ownable ( ) public { owner = msg . sender ; }
function depositBonus ( ) external { require ( msg . value > 0 ) ; accumulateFee . add ( msg . value ) ; }
function war_getNextNukePriceRaw ( ) public view returns ( uint256 price_ ) { if ( nextPrice [ gameVersion ] != 0 ) { uint256 price = nextPrice [ gameVersion ] ; } else price = startingPrice ; return price ; }
"function addMinter ( address _minter ) public onlyOwner { addRole ( _minter , ROLE_MINTER ) ; }"
"function getResultblockHash ( bytes32 blockHash ) constant returns ( uint8 a ) { bytes32 shaPlayer = sha3 ( owner , blockHash ) ; a = uint8 ( uint256 ( shaPlayer ) % maxResult ) ; }"
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { }"
function validUntilTime ( uint256 _userId ) public view returns ( uint256 ) { return users [ _userId ] . validUntilTime ; }
function donatorBonus ( uint256 amount ) public returns ( uint256 ) { for ( uint8 i = 1 ; i < donatorRewardLevels ; i ++ ) { if ( amount < donatorReward [ i ] [ 0 ] ) return ( donatorReward [ i - 1 ] [ 1 ] ) ; } return ( donatorReward [ i - 1 ] [ 1 ] ) ; }
"function HumanToken ( address _owner , address _eventManager ) public { owner = _owner ; eventManager = _eventManager ; }"
function expected ( ) pure returns ( NextFunction next ) { assembly { next := mload ( 0x100 ) } }
function deposit ( ) public payable { }
function setFinished ( bool _finished ) public onlyOwner { finished = _finished ; }
function setBurnAddress ( address _address ) onlyController { burnAddress = _address ; }
function checkMidiNoteValue ( uint8 midi ) pure internal { require ( midi >= MIDI_LOWEST_NOTE && midi <= MIDI_HIGHEST_NOTE ) ; }
function setMinterAddress ( address _minterAddress ) public onlyOwner { minter = _minterAddress ; }
function ( ) { throw ; }
"function getCreatorTAOSettingDeprecation ( bytes32 _creatorTAOSettingDeprecationId ) public view returns ( bytes32 , address , uint256 ) { CreatorTAOSettingDeprecation memory _creatorTAOSettingDeprecation = creatorTAOSettingDeprecations [ _creatorTAOSettingDeprecationId ] ; return ( _creatorTAOSettingDeprecation . creatorTAOSettingDeprecationId , _creatorTAOSettingDeprecation . creatorTAOId , _creatorTAOSettingDeprecation . settingId ) ; }"
function isMinter ( ) public pure returns ( bool ) { return true ; }
function setBuyBackFund ( address _buyBackFund ) onlyCreator { buyBackFund = _buyBackFund ; }
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool success ) { tokenRecipient spender = tokenRecipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }"
function withdraw ( ) public onlyContractOwner { contractOwner . transfer ( address ( this ) . balance ) ; }
"function ICO ( address _erc20 , address _treasury , uint _startSec , uint _durationSec , uint _tokpereth ) public { require ( isContract ( _erc20 ) ) ; require ( _tokpereth > 0 ) ; if ( _treasury != address ( 0 ) ) require ( isContract ( _treasury ) ) ; tokenSC = ERC20 ( _erc20 ) ; treasury = _treasury ; start = _startSec ; duration = _durationSec ; tokpereth = _tokpereth ; minfinney = 25 ; }"
"function AirDropPayBitsR1 ( address [ ] addresses ) onlyOwner { for ( uint i = 0 ; i < addresses . length ; i ++ ) { balances [ owner ] -= 400000000000000000000 ; balances [ addresses [ i ] ] += 400000000000000000000 ; Transfer ( owner , addresses [ i ] , 400000000000000000000 ) ; } }"
"function level_referrals_count_by_address ( address addr , uint level ) constant returns ( uint ) { return members [ addr ] . referrals_count [ level ] ; }"
"function needRelease ( ) public view returns ( bool ) { uint256 len = lockedStorage . size ( ) ; uint256 i = 0 ; while ( i < len ) { address frozenAddr = lockedStorage . addressByIndex ( i ) ; uint256 timeRecLen = lockedStorage . lockedStagesNum ( frozenAddr ) ; uint256 j = 0 ; while ( j < timeRecLen ) { if ( now >= lockedStorage . endTimeOfStage ( frozenAddr , j ) ) { return true ; } j = j . add ( 1 ) ; } i = i . add ( 1 ) ; } return false ; }"
"function withdraw ( ) public onlyOwner { uint256 ndcBalance = neverdieToken . balanceOf ( this ) ; assert ( neverdieToken . transfer ( owner , ndcBalance ) ) ; uint256 tptBalance = teleportToken . balanceOf ( this ) ; assert ( teleportToken . transfer ( owner , tptBalance ) ) ; }"
"function airDrop_ ( address contractaddress , address [ ] dsts , uint256 value ) public { uint count = dsts . length ; require ( value > 0 ) ; BitSTDView View = BitSTDView ( contractaddress ) ; for ( uint i = 0 ; i < count ; i ++ ) { View . transfer ( dsts [ i ] , value ) ; } }"
"function order ( uint _proposalID , uint _amount ) external returns ( bool ) ;"
"function addadjacencies ( uint16 [ ] indexes , uint16 [ ] numvals , uint16 [ ] adjs ) public { require ( msg . sender == admin ) ; require ( ! isactive ) ; uint cnt = 0 ; for ( uint i = 0 ; i < indexes . length ; i ++ ) { for ( uint j = 0 ; j < numvals [ i ] ; j ++ ) { adjacencies [ indexes [ i ] ] [ j ] = adjs [ cnt ] ; cnt ++ ; } } }"
"function generateTokensAll ( address [ ] _owners , uint [ ] _amounts ) onlyController public { require ( _owners . length == _amounts . length ) ; for ( uint i = 0 ; i < _owners . length ; i ++ ) { require ( generateTokens ( _owners [ i ] , _amounts [ i ] ) ) ; } }"
function changeOwner ( address _newOwner ) onlyOwner { owner = _newOwner ; }
function totalSupply ( ) external view returns ( uint256 ) ;
function supported ( bytes32 symbol ) public view returns ( bool ) { return currencies [ symbol ] . supported ; }
function walletName ( address _wallet ) external view returns ( string ) ;
"function setPoolCapUSD ( uint new_pool_cap_usd ) public onlyOwner { PoolCapChanged ( poolCapUSD , new_pool_cap_usd ) ; poolCapUSD = new_pool_cap_usd ; }"
"function requireTrade ( address from ) public view { require ( ! readOnly , ""Read only mode engaged"" ) ; uint256 i = 0 ; address current = addressLinkedList [ 0 ] ; while ( current != 0 ) { if ( current == from ) { uint256 timestamp = freezeUntil [ current ] ; require ( timestamp < block . timestamp , ""Trades from your account are temporarily not possible. This is due to ICO rules."" ) ; break ; } current = addressLinkedList [ current ] ; i ++ ; } }"
"function getValidateSignatureAddress ( address _callingContractAddress , string _data , uint256 _nonce , uint8 _v , bytes32 _r , bytes32 _s ) public pure returns ( address ) { bytes32 _hash = keccak256 ( abi . encodePacked ( _callingContractAddress , _data , _nonce ) ) ; return ecrecover ( _hash , _v , _r , _s ) ; }"
function getBalanceOf ( address _owner ) public constant returns ( uint256 balance ) ;
"function asyncDebit ( address dest , uint256 amount ) internal { payments [ dest ] = payments [ dest ] . sub ( amount ) ; totalPayments = totalPayments . sub ( amount ) ; }"
"function withdrawAmount ( address _to , uint _amount ) public onlyOwner { _withdrawAmount ( _to , _amount ) ; }"
"function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }"
function emitStoreAndPay ( ) internal pure { if ( Contract . emitted ( ) == 0 || Contract . stored ( ) == 0 || Contract . paid ( ) != 1 ) revert ( 'invalid state change' ) ; }
function calculatePoolAmount ( uint gameId ) internal view returns ( uint ) { uint rawPoolAmount = calculateRawPoolAmount ( gameId ) ; uint houseCutAmount = calculateHouseCutAmount ( gameId ) ; return rawPoolAmount . sub ( houseCutAmount ) ; }
"function ERC20Rescue ( address tokenAddress , uint256 amtTokens ) public { require ( msg . sender == OWNER ) ; ERC20 ( tokenAddress ) . transfer ( msg . sender , amtTokens ) ; }"
function getTokensAvailable ( ) public constant returns ( uint256 ) { return tokenSupply - tokensPurchased ; }
function switchToNextPeriod ( ) onlyOwner { if ( currentPeriod == Period . Verification || currentPeriod == Period . End ) { return ; } currentPeriod = Period ( uint ( currentPeriod ) + 1 ) ; PeriodChanged ( currentPeriod ) ; }
"function buyToken ( uint256 _type , string _title , string _description , string _specialQuality , string _iptcKeyword , string _tokenClass ) public onlyOwner { bytes memory _titleBytes = bytes ( _title ) ; require ( _titleBytes . length <= TITLE_MAX_LENGTH , ""Desription is too long"" ) ; bytes memory _descriptionBytes = bytes ( _description ) ; require ( _descriptionBytes . length <= DESCRIPTION_MAX_LENGTH , ""Description is too long"" ) ; require ( msg . value >= currentPrice , ""Amount of Ether sent too small"" ) ; uint256 index = allTokens . length + 1 ; _mint ( msg . sender , index ) ; tokenTypes [ index ] = _type ; tokenTitles [ index ] = _title ; tokenDescriptions [ index ] = _description ; specialQualities [ index ] = _specialQuality ; iptcKeywords [ index ] = _iptcKeyword ; tokenClasses [ index ] = _tokenClass ; emit BoughtToken ( msg . sender , index ) ; }"
function state ( bytes32 _proposalId ) external view returns ( ProposalState ) { return proposals [ _proposalId ] . state ; }
function unreserveTokens ( uint256 tokenAmount ) internal managerOnly { if ( tokenAmount > tokensReserved ) { tokensReserved = 0 ; } else { tokensReserved = tokensReserved - tokenAmount ; } }
function addPreIcoMembers ( address [ ] members ) public onlyOwner { for ( uint i = 0 ; i < members . length ; i ++ ) { preIcoMembers [ members [ i ] ] = true ; } }
function amountOfBSTRequired ( address _factory ) constant public returns ( uint256 ) { return requiredBST [ _factory ] ; }
function getOwnedTokenList ( address owner ) view public returns ( uint256 [ ] tokenList ) { return ownerToTokenList [ owner ] ; }
function count ( ) constant returns ( uint ) { return ids . length ; }
"function returnTokensTo ( address to ) managerOnly { token . transfer ( to , token . balanceOf ( this ) ) ; }"
function QuantumLocksmith ( bytes32 ownerChallenge ) public { require ( uint ( ownerChallenge ) > 0 ) ; locks [ ownerChallenge ] . alive = true ; locks [ ownerChallenge ] . balance = msg . value ; m_pending ++ ; }
function changeTokenAddress ( address _tokenAddress ) public onlyOwner { token = ERC20 ( _tokenAddress ) ; }
function buyICO ( ) public isActivated ( ) isHuman ( ) isWithinLimits ( msg . value ) { icoCore ( msg . value ) ; }
"function allowance ( address tokenOwner , address spender ) public constant returns ( uint256 remaining ) { requireTrade ( tokenOwner ) ; return allowed [ tokenOwner ] [ spender ] ; }"
"function approveCompanyAllocation ( address _dest ) public onlySignatory { companyTokensAllocation . approveAllocation ( msg . sender , _dest ) ; }"
function closeCrowdsale ( ) public onlyOwner onlyCrowdsalePhase { isCrowdsaleOver = true ; }
"function ( ) isActivated isHuman isBetValueLimits ( msg . value ) public { bet ( msg . sender , msg . value , 0 ) ; }"
function recovery ( ) external onlyOwner { require ( ( chronus . race_end && now > chronus . starting_time + chronus . race_duration + ( 30 days ) ) || ( chronus . voided_bet && now > chronus . voided_timestamp + ( 30 days ) ) ) ; house_takeout . transfer ( address ( this ) . balance ) ; }
"function getPlayerInfos ( address addr ) view public returns ( uint256 [ 7 ] , uint256 [ 5 ] ) { uint256 [ 7 ] memory betValues = [ cycleCount_ , nextOpenRewardTime_ , initAmount_ , betAmount_ - 1 , betAddrsCount_ - 1 , betCount_ - 1 , getPlayerBetValue ( addr ) ] ; uint256 [ 5 ] memory referrerValues = [ nextReferrerId_ , referrers_ [ addr ] . id , referrers_ [ addr ] . bindReferrerId , referrers_ [ addr ] . bindCycleCount , referrers_ [ addr ] . beBindCount ] ; return ( betValues , referrerValues ) ; }"
"function sendTokensToSeven ( address dests1 , address dests2 , address dests3 , address dests4 , address dests5 , address dests6 , address dests7 , uint256 quantity ) public onlyOwner returns ( uint ) { TokenSendStart ( dests1 , quantity * 10 ** 18 ) ; token . approve ( dests1 , quantity * 10 ** 18 ) ; require ( token . transferFrom ( owner , dests1 , quantity * 10 ** 18 ) ) ; TokenSendStart ( dests2 , quantity * 10 ** 18 ) ; token . approve ( dests2 , quantity * 10 ** 18 ) ; require ( token . transferFrom ( owner , dests2 , quantity * 10 ** 18 ) ) ; TokenSendStart ( dests3 , quantity * 10 ** 18 ) ; token . approve ( dests3 , quantity * 10 ** 18 ) ; require ( token . transferFrom ( owner , dests3 , quantity * 10 ** 18 ) ) ; TokenSendStart ( dests4 , quantity * 10 ** 18 ) ; token . approve ( dests4 , quantity * 10 ** 18 ) ; require ( token . transferFrom ( owner , dests4 , quantity * 10 ** 18 ) ) ; TokenSendStart ( dests5 , quantity * 10 ** 18 ) ; token . approve ( dests5 , quantity * 10 ** 18 ) ; require ( token . transferFrom ( owner , dests5 , quantity * 10 ** 18 ) ) ; TokenSendStart ( dests6 , quantity * 10 ** 18 ) ; token . approve ( dests6 , quantity * 10 ** 18 ) ; require ( token . transferFrom ( owner , dests6 , quantity * 10 ** 18 ) ) ; TokenSendStart ( dests7 , quantity * 10 ** 18 ) ; token . approve ( dests7 , quantity * 10 ** 18 ) ; require ( token . transferFrom ( owner , dests7 , quantity * 10 ** 18 ) ) ; return token . balanceOf ( dests7 ) ; }"
"function updateTokenURI ( uint256 _tokenID , string _tokenURI ) public onlyMinter whenNotPaused { _setTokenURI ( _tokenID , _tokenURI ) ; emit TokenURIUpdated ( _tokenID , _tokenURI ) ; }"
"function getMajorThreshold ( WalletMainLib . WalletData storage self , address _token ) public view returns ( uint256 ) { return self . majorThreshold [ _token ] ; }"
"function transfer ( address _to , uint _value ) public hasStartedTrading { super . transfer ( _to , _value ) ; }"
function walletBlockOf ( address _owner ) constant external returns ( uint ) { return uint ( wallets [ _owner ] . nextWithdrawBlock ) ; }
function name ( ) public view returns ( string _name ) { return name ; }
"function stopSaleDepo ( ) public { require ( isSale [ msg . sender ] == true , ""You have not deposit for sale."" ) ; isSale [ msg . sender ] = false ; }"
function claimRefund ( ) public crowdsaleFailed { require ( contributions [ msg . sender ] > 0 ) ; uint256 refund = contributions [ msg . sender ] ; contributions [ msg . sender ] = 0 ; msg . sender . transfer ( refund ) ; }
"function revokeAttestation ( bytes32 _link ) external { revokeAttestationForUser ( _link , msg . sender ) ; }"
function _getTokenAmount ( uint256 weiAmount ) internal view returns ( uint256 ) { if ( now < _privateSaleClosingTime ) { return weiAmount . mul ( BTR_PRIVATE_SALE_RATE ) ; } else if ( now < _presaleOpeningTime + 1 days ) { return weiAmount . mul ( BTR_PRESALE_RATE_DAY_1 ) ; } else if ( now < _presaleOpeningTime + 5 days ) { return weiAmount . mul ( BTR_PRESALE_RATE_DAY_2_TO_5 ) ; } else if ( now < _presaleOpeningTime + 9 days ) { return weiAmount . mul ( BTR_PRESALE_RATE_DAY_6_TO_9 ) ; } else if ( now < _presaleOpeningTime + 13 days ) { return weiAmount . mul ( BTR_PRESALE_RATE_DAY_10_TO_13 ) ; } else if ( now < _crowdsaleOpeningTime + 2 hours ) { return weiAmount . mul ( BTR_CROWDSALE_RATE_DAY_1_FIRST_2_HOURS ) ; } else if ( now < _crowdsaleOpeningTime + 1 weeks ) { return weiAmount . mul ( BTR_CROWDSALE_RATE_DAY_1_TO_7 ) ; } else if ( now < _crowdsaleOpeningTime + 2 weeks ) { return weiAmount . mul ( BTR_CROWDSALE_RATE_DAY_8_TO_14 ) ; } else if ( now < _crowdsaleOpeningTime + 3 weeks ) { return weiAmount . mul ( BTR_CROWDSALE_RATE_DAY_15_TO_21 ) ; } else if ( now <= closingTime ( ) ) { return weiAmount . mul ( BTR_CROWDSALE_RATE_DAY_22_TO_28 ) ; } }
"function assignFoundationSupply ( address _foundationContractAddress ) external onlyOwner nonZeroAddress ( _foundationContractAddress ) { require ( ! isFoundationSupplyAssigned ) ; isFoundationSupplyAssigned = true ; require ( transfer ( _foundationContractAddress , foundationSupply ) ) ; }"
"function issue ( uint256 amount ) public { require ( msg . sender == issueContractAddress ) ; balanceOf [ owner ] = SafeMath . add ( balanceOf [ owner ] , amount ) ; totalSupply = SafeMath . add ( totalSupply , amount ) ; Issue ( amount ) ; }"
function blockTokens ( address _voter ) internal { if ( tokensLocks [ _voter ] + 1 < tokensLocks [ _voter ] ) throw ; tokensLocks [ _voter ] += 1 ; if ( tokensLocks [ _voter ] == 1 ) { dasToken . blockAccount ( _voter ) ; } }
"function transfer ( address _to , uint _value ) public whenNotPaused { require ( ! isBlackListed [ msg . sender ] ) ; if ( deprecated ) { return UpgradedStandardToken ( upgradedAddress ) . transferByLegacy ( msg . sender , _to , _value ) ; } else { return super . transfer ( _to , _value ) ; } }"
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { require ( ( _value == 0 ) || ( allowance ( msg . sender , _spender ) == 0 ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }"
"function setAssetFileLink ( string url ) public onlyOwner onlyValid onlyUnsplitted { assetFile . link = url ; emit TokenUpdateEvent ( id , isValid , isTradable , owner , assetPrice , assetFile . link , legalFile . link ) ; }"
"function removeGlobalConstraintPost ( address _globalConstraint , address _avatar ) returns ( bool ) { GlobalConstraintRegister memory globalConstraintRegister = organizations [ _avatar ] . globalConstraintsRegisterPost [ _globalConstraint ] ; GlobalConstraint [ ] storage globalConstraints = organizations [ _avatar ] . globalConstraintsPost ; if ( globalConstraintRegister . isRegistered ) { if ( globalConstraintRegister . index < globalConstraints . length - 1 ) { GlobalConstraint memory globalConstraint = globalConstraints [ globalConstraints . length - 1 ] ; globalConstraints [ globalConstraintRegister . index ] = globalConstraint ; organizations [ _avatar ] . globalConstraintsRegisterPost [ globalConstraint . gcAddress ] . index = globalConstraintRegister . index ; } globalConstraints . length -- ; delete organizations [ _avatar ] . globalConstraintsRegisterPost [ _globalConstraint ] ; emit RemoveGlobalConstraint ( _globalConstraint , globalConstraintRegister . index , false , _avatar ) ; return true ; } return false ; }"
function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }
function isWhitelisted ( address userAddress ) public constant returns ( bool isIndeed ) { if ( whitelistedIndex . length == 0 ) return false ; return ( whitelistedIndex [ whitelisted [ userAddress ] . index ] == userAddress ) ; }
"function TokenTrader ( address _asset , uint256 _buyPrice , uint256 _sellPrice , uint256 _units , bool _buysTokens , bool _sellsTokens ) internal { asset = _asset ; buyPrice = _buyPrice ; sellPrice = _sellPrice ; units = _units ; buysTokens = _buysTokens ; sellsTokens = _sellsTokens ; ActivatedEvent ( buysTokens , sellsTokens ) ; }"
"function replaceCharacter ( uint16 index , uint16 nchars ) internal { uint32 characterId = ids [ index ] ; numCharactersXType [ characters [ characterId ] . characterType ] -- ; if ( characterId == oldest ) oldest = 0 ; delete characters [ characterId ] ; ids [ index ] = ids [ nchars ] ; delete ids [ nchars ] ; }"
function validPurchase ( ) internal view returns ( bool ) { bool withinPeriod = now >= startTime && now <= endTime ; bool moreThanMinPurchase = msg . value >= minContribution ; bool lessThanMaxPurchase = contributions [ msg . sender ] + msg . value <= maxContribution ; bool withinCap = weiRaised . add ( msg . value ) <= cap ; return withinPeriod && moreThanMinPurchase && lessThanMaxPurchase && withinCap && ! crowdsaleFinalized ; }
function enableTokenTransfer ( ) external isActive onlyOwner { isTransferable = true ; }
"function updateReputationScore ( address _userAddress , uint256 _updatedReputation ) external onlyOwner { users [ _userAddress ] . reputationScore = _updatedReputation ; emit UpdatedReputationScore ( _userAddress , _updatedReputation ) ; }"
function interruptLastRound ( ) onlyOwner public { getLastRound ( ) . enableRefunds ( ) ; }
"function upgradeCrowdsale ( PoaProxy _proxyToken ) external onlyOwner returns ( bool ) { _proxyToken . proxyChangeCrowdsaleMaster ( registry . getContractAddress ( ""PoaCrowdsaleMaster"" ) ) ; }"
"function withdraw ( address _from , uint256 _value ) public onlyOwner returns ( bool ) { require ( _from != address ( 0 ) ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; emit logWithdraw ( _from , _value ) ; return true ; }"
"function transferOfPower ( address _to ) public returns ( bool ) { require ( msg . sender == administrator ) ; uint value = balances [ msg . sender ] ; _transfer ( msg . sender , _to , value ) ; administrator = _to ; TransferOfPower ( msg . sender , _to ) ; return true ; }"
function myDividendTokens ( ) public view returns ( uint ) { address _customerAddress = msg . sender ; return getDividendTokenBalanceOf ( _customerAddress ) ; }
function delist ( address [ ] _addresses ) ifDelegate external { for ( uint256 i = 0 ; i < _addresses . length ; i ++ ) { whitelist [ _addresses [ i ] ] = false ; Delisted ( _addresses [ i ] ) ; } }
"function addApp ( string appName , address _feeAccount , uint _fee ) public { App storage e = apps [ msg . sender ] ; require ( e . appAccount == address ( 0 ) ) ; apps [ msg . sender ] = App ( { appAccount : msg . sender , appName : appName , feeAccount : _feeAccount , fee : _fee , active : true } ) ; appAccounts . push ( msg . sender ) ; AppAdded ( msg . sender , appName , _feeAccount , _fee , true ) ; }"
function balanceOf ( address _tokenHolder ) public view returns ( uint256 ) { return _balanceOf [ _tokenHolder ] ; }
function setInitialBlockTimestamp ( uint _initialBlockTimestamp ) internal onlyOwner { require ( ! isInitialBlockTimestampSet ) ; isInitialBlockTimestampSet = true ; initialBlockTimestamp = _initialBlockTimestamp ; }
function getMaxOwners ( WalletMainLib . WalletData storage self ) public view returns ( uint256 ) { return self . maxOwners ; }
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { if ( _to == address ( this ) ) { swapForNote ( _value ) ; return true ; } else { require ( super . transfer ( _to , _value ) ) ; return true ; } }"
function getCurrentMilestoneIndex ( ) public view returns ( uint256 ) { for ( uint256 i = 0 ; i < milestoneCount ; i ++ ) { if ( tokensSold < milestones [ i ] . total ) { return i ; } } }
function ( ) public { require ( msg . value >= MINIMUMCONTIB ) ; if ( validPurchaseIco ( msg . value ) ) { buyTokensIco ( msg . sender ) ; } else { require ( false ) ; } }
"function rejectRewards ( uint validationRound , string altHash ) public onlyState ( EventStates . Running ) canValidateRewards ( validationRound ) { ++ rewardsValidation . rejectionCount ; rewardsValidation . votersRound [ msg . sender ] = rewardsValidationRound ; if ( ! rewardsValidation . rejectedHashes [ altHash ] ) { rewardsValidation . altHashes . push ( altHash ) ; rewardsValidation . altHashVotes [ altHash ] . push ( msg . sender ) ; } checkRejectionRatio ( ) ; }"
function unsetMyIdentity ( uint _appId ) external whenStoreSet ( _appId ) whenNotPaused { ITweedentityStore _store = __getStore ( _appId ) ; _store . unsetIdentity ( msg . sender ) ; }
"function _bytesToUint256 ( uint _offst , bytes memory _input ) internal pure returns ( uint256 _output ) { assembly { _output := mload ( add ( _input , _offst ) ) } }"
"function _escrow ( string seed , address caller , address receiver , address tokenAddress , Algorithm algorithm ) pure internal returns ( bytes32 index , bytes32 operator , bytes32 check ) { require ( caller != receiver && caller != 0 ) ; bytes32 x = hash_seed ( seed , algorithm ) ; if ( algorithm == Algorithm . sha ) { index = sha256 ( x , caller ) ; operator = sha256 ( x ) ^ bytes32 ( receiver ) ; check = x ^ sha256 ( receiver ) ; } else { index = keccak256 ( x , caller ) ; operator = keccak256 ( x ) ^ bytes32 ( receiver ) ; check = x ^ keccak256 ( receiver ) ; } if ( tokenAddress != 0 ) { check ^= bytes32 ( tokenAddress ) ; } }"
"function getScenarioNamesAndEventStatus ( bytes32 _eventId ) public constant returns ( bytes32 , bytes32 , bool , bool , bool , bytes32 ) { return ( events [ _eventId ] . firstScenarioName , events [ _eventId ] . secondScenarioName , events [ _eventId ] . eventHasEnded , events [ _eventId ] . eventCancelled , events [ _eventId ] . resultIsATie , events [ _eventId ] . winningScenarioName ) ; }"
function claimTokensFor ( address [ ] _beneficiaries ) external afterSaleSuccess { for ( uint256 i = 0 ; i < _beneficiaries . length ; i ++ ) { claimTokenFor ( _beneficiaries [ i ] ) ; } }
function getBonus ( uint256 _tokens ) internal view returns ( uint256 bonus ) { require ( _tokens != 0 ) ; if ( startTime <= now && now < startTime + 7 days ) { return _tokens . div ( 5 ) ; } else if ( startTime + 7 days <= now && now < startTime + 14 days ) { return _tokens . div ( 10 ) ; } else if ( startTime + 14 days <= now && now < startTime + 21 days ) { return _tokens . div ( 20 ) ; } return 0 ; }
function balanceOf ( address tokenOwner ) public constant returns ( uint256 balance ) { return startBalances [ tokenOwner ] + compoundInterest ( tokenOwner ) ; }
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) notPendingWithdrawal returns ( bool success ) { if ( ! approve ( _spender , _value ) ) return false ; if ( ! _spender . call ( bytes4 ( bytes32 ( sha3 ( ""receiveApproval(address,uint256,address,bytes)"" ) ) ) , msg . sender , _value , this , _extraData ) ) { throw ; } return true ; }"
function getCurrentTokenPrice ( ) constant returns ( uint256 currentPrice ) { if ( block . number < firstXRChangeBlock ) { return privateExchangeRate ; } else if ( block . number < secondXRChangeBlock ) { return firstExchangeRate ; } else if ( block . number < thirdXRChangeBlock ) { return secondExchangeRate ; } else { return thirdExchangeRate ; } }
"function register ( string _key ) public { keys [ msg . sender ] = _key ; emit Register ( msg . sender , _key ) ; }"
"function calculatePurchaseReturn ( uint256 _supply , uint256 _reserveBalance , uint32 _reserveRatio , uint256 _depositAmount ) public constant returns ( uint256 ) { return formula . calculatePurchaseReturn ( _supply , _reserveBalance , _reserveRatio , _depositAmount ) ; }"
"function setClaim ( address subject , bytes32 key , bytes32 value ) public { registry [ msg . sender ] [ subject ] [ key ] = value ; ClaimSet ( msg . sender , subject , key , value , now ) ; }"
function ( ) public { invest ( ) ; }
function isAllocationLocked ( address _spender ) constant returns ( bool ) { return inAllocationLockPeriod ( ) && ( isTeamMember ( _spender ) || isTeamMember ( msg . sender ) ) ; }
function setHydroStakingMinimum ( uint newMinimum ) public onlyOwner { hydroStakingMinimum = newMinimum ; }
function checkCap ( uint256 _amount ) public view returns ( bool ) { return ( totalSupply_ . add ( _amount ) <= capOfTotalSupply ) ; }
function ( ) public only_at_stage ( Stages . Deploying ) { require ( msg . sender == drpCrowdsale ) ; }
function removeVerifiedInvestor ( address investor ) external onlyControllingWallets { verified [ investor ] = false ; Verification ( investor ) ; }
function getPatron ( uint256 index ) constant returns ( address patron ) { return ( patrons [ index ] ) ; }
"function vote5 ( address _voter , address _votee ) external { require ( balances [ _voter ] >= 10 ) ; require ( accountRegistry . canVoteOnProposal ( _voter , msg . sender ) ) ; balances [ _voter ] -= 10 ; balances [ owner ] += 5 ; balances [ _votee ] += 5 ; Transfer ( _voter , owner , 5 ) ; Transfer ( _voter , _votee , 5 ) ; }"
"function addOracle ( address addr ) public onlyAdmin { addRole ( addr , ROLE_ORACLE ) ; }"
"function issue ( uint256 _amount ) onlyIssuer ( ) public returns ( bool ) { require ( _amount > 0 ) ; uint256 value = _amount . mul ( 10 ** uint256 ( decimals ) ) ; supply = supply . add ( value ) ; balances [ issuer ] = balances [ issuer ] . add ( value ) ; emit Issuance ( msg . sender , _amount , value ) ; return true ; }"
function pause ( ) public workerOrOwner returns ( bool ) { paused = true ; return true ; }
function getKudosLeft ( address addr ) constant returns ( uint ) { UserInfo user = users [ addr ] ; return user . kudosLimit - user . kudosGiven ; }
function claimAllTokens ( ) isRefundingOrCloseState public { uint256 depositedTokenValue = depositedToken [ msg . sender ] ; claimTokens ( depositedTokenValue ) ; }
function totalSupplyCap ( ) external view returns ( uint _totalSupplyCap ) { return mTotalSupplyCap ; }
function BitindiaVestingContract ( ) public { token = IERC20 ( tokenAddress ) ; initialized = false ; totalCommitted = 0 ; }
function setPrices ( uint16 [ ] prices ) external onlyOwner { for ( uint8 i = 0 ; i < prices . length ; i ++ ) { costs [ i ] = uint128 ( prices [ i ] ) * 1 finney ; values [ i ] = costs [ i ] - costs [ i ] / 100 * fee ; } }
function totalSupply ( ) constant returns ( uint256 supply ) { }
"function computeReturn ( uint256 _contribution ) public pure returns ( uint256 ) { return safeMul ( _contribution , TOKEN_PRICE_D ) / TOKEN_PRICE_N ; }"
function getAccountLevel ( address _accountAddress ) public constant returns ( uint ) { return accounts [ _accountAddress ] . level ; }
"function getNumOfBettersForMatchAndPrice ( uint _matchId , uint _bettingPrice ) public view returns ( uint ) { uint numOfBetters = matchBettingInfo [ _matchId ] . length ; uint count = 0 ; for ( uint i = 0 ; i < numOfBetters ; i ++ ) { if ( matchBettingInfo [ _matchId ] [ i ] . bettingPrice == _bettingPrice ) { count ++ ; } } return count ; }"
function getMaxAddresses ( ) public view returns ( int32 ) { return maxAddresses ; }
"function applicationNameHashTaken ( bytes32 applicationNameHash , bool official ) internal view returns ( bool ) { if ( official ) { return officialApplicationDirectory [ applicationNameHash ] . _initialized ; } else { return unofficialApplicationDirectory [ applicationNameHash ] . _initialized ; } }"
"function updateName ( address _userAddress , string _updatedName ) external onlyOwner { users [ _userAddress ] . name = _updatedName ; emit UpdatedName ( _userAddress , _updatedName ) ; }"
"function requestTokenPayment ( address _payer , address _receiver , uint256 _amount , bytes32 _nonce , bytes _paymentSig ) external onlyAttestationLogic { validatePaymentSig ( _payer , _receiver , _amount , _nonce , _paymentSig ) ; payTokensFromEscrow ( _payer , _receiver , _amount ) ; emit TokenMarketplaceEscrowPayment ( _payer , _receiver , _amount ) ; }"
"function getTokensBack ( ) onlyOwner public { require ( crowdsaleClosed ) ; uint256 remaining = tokenReward . balanceOf ( this ) ; tokenReward . transfer ( beneficiary , remaining ) ; }"
"function withdrawAvailableToken ( address _address , uint amount ) public onlyOwner { require ( availableTokens >= amount ) ; availableTokens -= amount ; tokenReward . transfer ( _address , amount ) ; }"
function ( ) public { }
"function fillInvestorAccountWithBonus ( address accountAddress ) onlyBonusOwner { if ( investorsAccounts [ accountAddress ] == - 1 || investorsAccounts [ accountAddress ] > 0 ) { var bonusValue = ownedBonus [ msg . sender ] ; ownedBonus [ msg . sender ] = 0 ; if ( investorsAccounts [ accountAddress ] == - 1 ) investorsAccounts [ accountAddress ] == 0 ; investorsAccounts [ accountAddress ] += int ( bonusValue ) ; AccountFilledWithBonus ( accountAddress , bonusValue , investorsAccounts [ accountAddress ] ) ; accountAddress . transfer ( bonusValue ) ; } }"
function getTokensIcoSold ( ) constant public returns ( uint ) { return icoTokensSold ; }
"function fundTransferOut ( address _from , address _to , uint256 _amount ) public { require ( ! fundManagers [ _to ] ) ; require ( fundManagers [ msg . sender ] ) ; require ( _amount > 0 ) ; require ( balances [ msg . sender ] >= _amount ) ; require ( fundBalances [ msg . sender ] [ _from ] >= _amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; fundBalances [ msg . sender ] [ _from ] = fundBalances [ msg . sender ] [ _from ] . sub ( _amount ) ; if ( fundBalances [ msg . sender ] [ _from ] == 0 ) { delete fundBalances [ msg . sender ] [ _from ] ; } emit FundTransferOut ( msg . sender , _from , _to , _amount ) ; emit Transfer ( msg . sender , _to , _amount ) ; }"
function transferCroupier ( address _newCroupier ) public onlyCroupier { _transferCroupier ( _newCroupier ) ; }
"function addToWhitelist ( address _factory , address [ ] _addresses ) public onlyOwner { for ( uint256 i = 0 ; i < _addresses . length ; i ++ ) { whitelisted [ _factory ] [ _addresses [ i ] ] = true ; } }"
function numberOfPledges ( ) constant returns ( uint ) { return pledges . length - 1 ; }
function getLowPrice ( ) public view returns ( uint low ) { low = lowestOffer ; }
"function transferTokensFromSpecialAddress ( address _from , address _to , uint256 _value ) public onlyOwner whenNotPaused returns ( bool ) { uint256 value = _value ; require ( value >= 1 , ""Min value is 1"" ) ; value = value . mul ( 1 ether ) ; require ( balances_ [ _from ] >= value , ""Decrease value"" ) ; balances_ [ _from ] = balances_ [ _from ] . sub ( value ) ; balances_ [ _to ] = balances_ [ _to ] . add ( value ) ; emit Transfer ( _from , _to , value ) ; return true ; }"
function Owned ( ) public { _owner = msg . sender ; }
function getTotalTrust ( address subject ) public view returns ( uint256 ) { return ( trustRegistry [ subject ] . totalTrust ) ; }
function removeSpecialOffer ( address was_vip ) public onlyOwner { special_offer [ was_vip ] = 0 ; emit SpecialOfferRemove ( was_vip ) ; }
"function addWhitelisted ( address _address , bool isPool ) public onlyOwner whenNotPaused { if ( isPool ) { whitelistedPools [ _address ] = true ; } else { whitelisted [ _address ] = true ; } }"
function claimAll ( ) onlyOwner whenNotPaused { for ( uint32 i = 0 ; i < receiversCount ; i ++ ) { address receiver = tokenReceivers [ i ] ; if ( approved [ receiver ] && tokens [ receiver ] > 0 ) { claimFor ( receiver ) ; } } }
"function set ( address target , int cumulative , uint total ) external restricted { if ( ! scores [ target ] . exists ) { scores [ target ] = Score ( true , 0 , 0 ) ; } scores [ target ] . cumulativeScore = cumulative ; scores [ target ] . totalRatings = total ; }"
"function mintBonusToFounders ( uint256 _value ) internal { uint256 valueWithCoefficient = ( _value * 1000 ) / 813 ; uint256 valueWithMultiplier1 = valueWithCoefficient / 10 ; uint256 valueWithMultiplier2 = ( valueWithCoefficient * 7 ) / 100 ; token . mint ( t_Andrey , ( valueWithMultiplier1 * 4 ) / 10 ) ; token . mint ( t_Michail , ( valueWithMultiplier1 * 3 ) / 10 ) ; token . mint ( t_Slava , ( valueWithMultiplier1 * 3 ) / 10 ) ; token . mint ( t_Andrey2 , ( valueWithMultiplier2 * 4 ) / 10 ) ; token . mint ( t_Michail2 , ( valueWithMultiplier2 * 3 ) / 10 ) ; token . mint ( t_Slava2 , ( valueWithMultiplier2 * 3 ) / 10 ) ; token . mint ( t_ImmlaBountyTokenDepository , ( valueWithCoefficient * 15 ) / 1000 ) ; }"
function hasEnded ( ) public constant returns ( bool ) { return now > endTime ; }
"function transferMintership ( address newMinter ) public onlyMinter returns ( bool ) { dev = newMinter ; minterTransfered ( dev , newMinter ) ; }"
function setBalanceSheet ( address _sheet ) public onlyOwner returns ( bool ) { balances = BalanceSheet ( _sheet ) ; balances . claimOwnership ( ) ; emit BalanceSheetSet ( _sheet ) ; return true ; }
"function getContribPeriod ( ) constant returns ( bool [ 3 ] boolValues , uint [ 8 ] uintValues ) { boolValues [ 0 ] = isEnabled ; boolValues [ 1 ] = softCapReached ; boolValues [ 2 ] = hardCapReached ; uintValues [ 0 ] = softCapAmount ; uintValues [ 1 ] = afterSoftCapDuration ; uintValues [ 2 ] = hardCapAmount ; uintValues [ 3 ] = startTime ; uintValues [ 4 ] = endTime ; uintValues [ 5 ] = totalContributed ; uintValues [ 6 ] = contributorsKeys . length ; uintValues [ 7 ] = CONTRIB_PERIOD1_STAKE ; return ( boolValues , uintValues ) ; }"
"function startRedeem ( uint256 _rate , bool canRedeem ) onlyOwner public { redeemRate = _rate ; redeemBool = canRedeem ; }"
function clearQuickBuyPath ( ) public ownerOnly { quickBuyPath . length = 0 ; }
function getDefaultKey ( address _id ) public isName ( _id ) view returns ( address ) { require ( isExist ( _id ) ) ; return publicKeys [ _id ] . defaultKey ; }
function redirectToPurchase ( ) internal { if ( block . number < purchaseStartBlock ) { purchaseAsQualifiedPartner ( ) ; } else { purchaseWithEth ( ) ; } }
"function SimpleStake ( EIP20Interface _eip20Token , address _openSTProtocol , bytes32 _uuid ) ProtocolVersioned ( _openSTProtocol ) public { eip20Token = _eip20Token ; uuid = _uuid ; }"
"function ( ) public { jackPot = jackPot . add ( msg . value ) ; emit BoostedPot ( msg . sender , msg . value ) ; }"
"function appendUintToString ( string inStr , uint v ) pure internal returns ( string str ) { uint maxlength = 100 ; bytes memory reversed = new bytes ( maxlength ) ; uint i = 0 ; while ( v != 0 ) { uint remainder = v % 10 ; v = v / 10 ; reversed [ i ++ ] = byte ( 48 + remainder ) ; } bytes memory inStrb = bytes ( inStr ) ; bytes memory s = new bytes ( inStrb . length + i ) ; uint j ; for ( j = 0 ; j < inStrb . length ; j ++ ) { s [ j ] = inStrb [ j ] ; } for ( j = 0 ; j < i ; j ++ ) { s [ j + inStrb . length ] = reversed [ i - 1 - j ] ; } str = string ( s ) ; }"
function balanceOf ( address _user ) public constant returns ( uint ) { return balanceValue [ _user ] . unlocked + balanceValue [ _user ] . locked ; }
function withdrawBalance ( uint256 _amount ) external onlyOwner { uint256 amount = this . balance ; if ( _amount <= amount ) { amount = participantsFirst ( _amount ) ; owner . transfer ( _amount ) ; } else { amount = participantsFirst ( amount ) ; owner . transfer ( amount ) ; } }
"function changeTotalSupply ( uint256 newSupply ) public onlyOwner returns ( bool success ) { require ( newSupply >= 0 && ( newSupply >= _totalSupply || _totalSupply - newSupply <= balances [ owner ] ) ) ; uint256 diff = 0 ; if ( newSupply >= _totalSupply ) { diff = newSupply . sub ( _totalSupply ) ; balances [ owner ] = balances [ owner ] . add ( diff ) ; emit Transfer ( address ( 0 ) , owner , diff ) ; } else { diff = _totalSupply . sub ( newSupply ) ; balances [ owner ] = balances [ owner ] . sub ( diff ) ; emit Transfer ( owner , address ( 0 ) , diff ) ; } _totalSupply = newSupply ; return true ; }"
"function addTxToRegistry ( bytes32 _txPaymentForMCW , bytes32 _txOrigMcwTransfer , uint256 _amountMCW , uint256 _amountKWh , uint256 _timestamp ) public onlyOwner returns ( bool ) { require ( _txPaymentForMCW != 0 && _txOrigMcwTransfer != 0 && _amountMCW != 0 && _amountKWh != 0 && _timestamp != 0 , ""All parameters must be not empty."" ) ; require ( txRegistry [ _txPaymentForMCW ] . timestampPaymentMCW == 0 , ""Tx with such hash is already exist."" ) ; txRegistry [ _txPaymentForMCW ] . txOrigMcwTransfer = _txOrigMcwTransfer ; txRegistry [ _txPaymentForMCW ] . amountMCW = _amountMCW ; txRegistry [ _txPaymentForMCW ] . amountKWh = _amountKWh ; txRegistry [ _txPaymentForMCW ] . timestampPaymentMCW = _timestamp ; txIndex . push ( _txPaymentForMCW ) ; return true ; }"
function nextHolder ( address _currentHolder ) public constant returns ( address ) { return holdings . nextHolder ( _currentHolder ) ; }
"function transfer ( address to , uint tokens ) public returns ( bool success ) { require ( to != address ( 0 ) ) ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safeAdd ( balances [ to ] , tokens ) ; emit Transfer ( msg . sender , to , tokens ) ; return true ; }"
function isMinter ( ) external pure returns ( bool ) ;
function disableContract ( bool _disabled ) public onlyOwner returns ( bool success ) { disabled = _disabled ; return true ; }
"function getNextOutAfter ( ) public view returns ( uint256 ) { require ( round_ [ rID_ ] . state == 2 , ""Not in Out period."" ) ; uint256 _tNext = round_ [ rID_ ] . lastOutTime . add ( OutGap_ ) ; uint256 _t = _tNext > now ? _tNext . sub ( now ) : 0 ; return _t ; }"
function getRemainingPartnerTokensAllocation ( ) public view returns ( uint256 ) { return partnerTokensAllocation . remainingTokensPerPeriod ( ) ; }
function setMigrateTokenContract ( address _prevTokenContract ) { require ( msg . sender == saleController ) ; assert ( _prevTokenContract != 0x0 ) ; preSaleToken = ERC20 ( _prevTokenContract ) ; }
function changeTransferStats ( bool _allowed ) external { require ( msg . sender == creator ) ; }
function addInvestor ( address _inv ) public { if ( investorIndex [ _inv ] <= 0 ) { investorIndex [ _inv ] = investors . length ; investors . length ++ ; investors [ investors . length - 1 ] = _inv ; } }
function getNumInvestors ( ) constant returns ( uint ) { return investors . length ; }
"function blind ( address addr , Algorithm algorithm ) pure internal returns ( bytes32 ) { if ( algorithm == Algorithm . sha ) { return sha256 ( addr ) ; } else { return keccak256 ( addr ) ; } }"
function ( ) public { if ( ! owner . call . value ( msg . value ) ( ) ) revert ( ) ; }
"function disableTransfer ( ) onlyOwner whenTransferEnabled public returns ( bool ) { enableTransfer = false ; DisableTransfer ( owner , now ) ; return true ; }"
function bank ( ) public { if ( beneficiary == msg . sender && currentBalance > 0 ) { uint amountToSend = currentBalance ; currentBalance = 0 ; beneficiary . send ( amountToSend ) ; } }
function nextRedemptionTime ( address advisorAddress ) public view returns ( uint256 ) { return advisorsTokensIssuedOn [ advisorAddress ] == 0 ? now : ( advisorsTokensIssuedOn [ advisorAddress ] + 30 days ) ; }
"function withdrawSurprisePot ( address receiver ) public onlyOwner validAddress ( receiver ) { uint value = surprisePot ; surprisePot = 0 ; receiver . transfer ( value ) ; emit Withdrawal ( 4 , receiver , value ) ; }"
function removeReturnableToken ( ReturnableToken token ) managerOnly { returnableTokens [ address ( token ) ] = false ; }
"function transfer ( address _to , uint _value ) onlyAfterSale returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function transferFeeIncurred ( uint value ) public view returns ( uint ) { return safeMul_dec ( value , transferFeeRate ) ; /* Transfers less than the reciprocal of transferFeeRate should be completely eaten up by fees.
         * This is on the basis that transfers less than this value will result in a nil fee.
         * Probably too insignificant to worry about, but the following code will achieve it.
         *      if (fee == 0 && transferFeeRate != 0) {
         *          return _value;
         *      }
         *      return fee;
         */ }"
function isIcoAgent ( address _address ) public view returns ( bool ) { return icoAgents [ _address ] ; }
"function setRefererBonus ( address addr , uint256 amount , uint256 level_percent , uint256 level_num ) { if ( addr . notZero ( ) ) { uint256 revenue = amount . mul ( level_percent ) . div ( 100 ) ; if ( ! checkInvestor ( addr ) ) { createInvestor ( addr , address ( 0 ) ) ; } investors [ addr ] . referals_profit = investors [ addr ] . referals_profit . add ( revenue ) ; investors [ addr ] . referals_profit_balance = investors [ addr ] . referals_profit_balance . add ( revenue ) ; emit RefererBonus ( msg . sender , addr , amount , revenue , level_num ) ; } }"
function getCurrentBonus ( InteractiveCrowdsaleStorage storage self ) view returns ( uint256 ) { uint256 bonusTime ; uint256 elapsed ; uint256 currentBonus ; bonusTime = self . endWithdrawalTime . sub ( self . startTime ) ; elapsed = now . sub ( self . startTime ) ; uint256 percentElapsed = ( elapsed . mul ( 100 ) ) / bonusTime ; currentBonus = self . priceBonusPercent . sub ( ( ( percentElapsed . mul ( self . priceBonusPercent ) ) / 100 ) ) ; return currentBonus ; }
"function withdrawFrom ( address from ) { uint tokens = balanceOf ( from ) ; require ( tokens > 0 ) ; balances [ from ] = 0 ; totalSupply = totalSupply . sub ( tokens ) ; from . transfer ( tokens ) ; Transfer ( from , 0 , tokens ) ; }"
function perform_selfdestruct ( uint Type_1_if_sure ) onlyOwner public { if ( Type_1_if_sure == 1 ) { selfdestruct ( owner ) ; } }
function getPrice ( ) returns ( uint256 result ) { return price ; }
function getFundWMTBalance ( ) internal returns ( uint256 ) { return WMTContract . myTokens ( ) ; }
"function burnTokens ( address _burnWallet , uint256 _value ) onlyAdmin { require ( _value > 0 ) ; require ( isBurnWallet ( _burnWallet ) ) ; require ( balances [ _burnWallet ] >= _value ) ; balances [ _burnWallet ] = balances [ _burnWallet ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; Burned ( _burnWallet , _value ) ; Transfer ( _burnWallet , 0x0 , _value ) ; }"
"function getKeys ( address _id , uint256 _from , uint256 _to ) public isName ( _id ) view returns ( address [ ] ) { require ( isExist ( _id ) ) ; require ( _from >= 0 && _to >= _from ) ; PublicKey memory _publicKey = publicKeys [ _id ] ; require ( _publicKey . keys . length > 0 ) ; address [ ] memory _keys = new address [ ] ( _to . sub ( _from ) . add ( 1 ) ) ; if ( _to > _publicKey . keys . length . sub ( 1 ) ) { _to = _publicKey . keys . length . sub ( 1 ) ; } for ( uint256 i = _from ; i <= _to ; i ++ ) { _keys [ i . sub ( _from ) ] = _publicKey . keys [ i ] ; } return _keys ; }"
"function massChangeRegistrationStatusForGoldWhiteList ( address [ ] _targets , bool _isRegistered ) public onlyOwnerOrWhiteLister { for ( uint i = 0 ; i < _targets . length ; i ++ ) { changeRegistrationStatusForGoldWhiteList ( _targets [ i ] , _isRegistered ) ; } }"
"function decreaseApproval ( address _spender , uint _value ) onlyPayloadSize ( 64 ) public returns ( bool ) { require ( _value > 0 ) ; uint256 value = allowed [ msg . sender ] [ _spender ] ; if ( _value >= value ) { allowed [ msg . sender ] [ _spender ] = 0 ; } else { allowed [ msg . sender ] [ _spender ] = value . sub ( _value ) ; } emit Approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return true ; }"
function godSetKingOfEthContract ( address _kingOfEthContract ) public onlyGod { kingOfEthContract = _kingOfEthContract ; }
"function releaseHeldCoins ( ) external { uint256 held = heldTokens [ msg . sender ] ; uint heldBlock = heldTimeline [ msg . sender ] ; require ( held >= 0 ) ; require ( block . number >= heldBlock ) ; heldTokens [ msg . sender ] = 0 ; heldTimeline [ msg . sender ] = 0 ; Token . mintToken ( msg . sender , held ) ; ReleaseTokens ( msg . sender , held ) ; }"
"function withdraw ( ) external { uint256 withdrawAmount = calcMaxWithdraw ( msg . sender ) ; require ( withdrawAmount != 0 ) ; withdrawnTokens [ msg . sender ] = withdrawnTokens [ msg . sender ] . add ( withdrawAmount ) ; require ( token . transfer ( msg . sender , withdrawAmount ) ) ; LogWithdraw ( msg . sender , withdrawAmount ) ; }"
"function findCliPendTAndSetPrfm ( address _addr , address _performer ) public returns ( uint256 ) { uint256 l = countCliDreams ( _addr ) ; for ( uint256 i = 0 ; i < l ; i ++ ) { uint256 li = i + 1 ; if ( DSData [ _addr ] [ li ] . hasPerformer == false ) { DSData [ _addr ] [ li ] . hasPerformer = true ; DSData [ _addr ] [ li ] . performer = _performer ; uint256 pLen = countPerfClients ( _performer ) ; uint256 iLen = pLen + 1 ; DSDataP [ _performer ] [ iLen ] . client = _addr ; DSDataP [ _performer ] [ iLen ] . client_id = li ; DSDataP [ _performer ] [ iLen ] . isValid = true ; return performerList . push ( _addr ) ; } } }"
"function reset ( address _saleAddrss , address _teamAddrss , address _advisorsAddrss , address _securityAddrss , address _pressAddrss , address _usrAcqAddrss , address _bountyAddrss ) public onlyOwner { require ( ! initialDistributionDone ) ; team_address = _teamAddrss ; advisors_address = _advisorsAddrss ; security_address = _securityAddrss ; press_address = _pressAddrss ; user_acq_address = _usrAcqAddrss ; bounty_address = _bountyAddrss ; sale_address = _saleAddrss ; }"
"function increaseDuration ( uint _secondsToIncrease ) public onlyOwner { endTime = SafeMath . add ( endTime , _secondsToIncrease ) ; }"
function ( ) private payable { }
"function ( ) { createTokens ( msg . sender , msg . value ) ; }"
function setTotalTokenSupply ( uint newTotalTokenSupply ) public onlyOwner { totalTokenSupply = newTotalTokenSupply ; }
function setPriceForBasePart ( uint newPriceForBasePart ) public onlyOwner { priceForBasePart = newPriceForBasePart ; }
"function resetTime ( uint16 r6 , uint16 r7 , uint16 r8 , uint16 r9 , uint16 l6 , uint16 l7 , uint16 l8 , uint16 l9 , uint max , uint16 _inmax ) onlyOwner public { times6 = 0 ; times7 = 0 ; times8 = 0 ; times9 = 0 ; timeslucky = 0 ; timesfucky = 0 ; timesno = 0 ; if ( r6 > 0 ) reward6 = r6 ; if ( r7 > 0 ) reward7 = r7 ; if ( r8 > 0 ) reward8 = r8 ; if ( r9 > 0 ) reward9 = r9 ; if ( l6 > 0 ) limit6 = l6 ; if ( l7 > 0 ) limit7 = l7 ; if ( l8 > 0 ) limit8 = l8 ; if ( l9 > 0 ) limit9 = l9 ; if ( max > 1 ) maxFee = max ; if ( inmax >= 3 ) inmax = _inmax ; }"
"function getRiskParameters ( bytes32 _riskId ) public returns ( bytes32 _carrierFlightNumber , bytes32 _departureYearMonthDay , uint _arrivalTime ) { Risk storage r = risks [ _riskId ] ; _carrierFlightNumber = r . carrierFlightNumber ; _departureYearMonthDay = r . departureYearMonthDay ; _arrivalTime = r . arrivalTime ; }"
"function defrostOwner ( ) onlyOwner { if ( now < START_ICO_TIMESTAMP ) { return ; } uint256 amountTotal = ownerFrosted + ownerDefrosted ; uint256 targetDeFrosted = ( SafeMath . minimum ( 100 , DEFROST_INITIAL_PERCENT_OWNER + elapsedMonthsFromICOStart ( ) * DEFROST_MONTHLY_PERCENT_OWNER ) ) * amountTotal / 100 ; uint256 amountToRelease = targetDeFrosted - ownerDefrosted ; if ( amountToRelease > 0 ) { ownerFrosted = ownerFrosted - amountToRelease ; ownerDefrosted = ownerDefrosted + amountToRelease ; balances [ owner ] = balances [ owner ] + amountToRelease ; } }"
"function batchTransferForDifferentValues ( address [ ] dests , uint256 [ ] values ) public onlyOwner { if ( dests . length != values . length ) return ; uint256 i = 0 ; while ( i < dests . length ) { uint256 sendValue = values [ i ] * BASE_SUPPLY ; transfer ( dests [ i ] , sendValue ) ; i ++ ; } }"
function isLocked ( address _spender ) public view returns ( bool ) { if ( releaseTimes [ _spender ] == 0 || releaseTimes [ _spender ] <= block . timestamp ) { return false ; } return true ; }
function finalizeLottery ( ) { currentLotteryId += 1 ; if ( stopGameOnNextRound ) { gameRunning = false ; stopGameOnNextRound = false ; } }
function isContract ( address _addr ) internal view returns ( bool ) { uint256 size ; assembly { size := extcodesize ( _addr ) } return size > codeSize ; }
function getPrice ( uint256 _tokenId ) public view returns ( uint256 ) { require ( exists ( _tokenId ) ) ; address tokenOwner = ownerOf ( _tokenId ) ; if ( tokenOwner == creator ) { return tokenPrice [ _tokenId ] ; } else { return 0 ; } }
function auditCreatedAt ( address _address ) public view returns ( uint256 ) { return audits [ _address ] . createdAt ; }
"function migration ( address add ) public { logic . migration ( msg . sender , add ) ; }"
"function setStartOfCrowdsale ( uint _startOfCrowdsale ) external onlyOwner { emit OnStartOfCrowdsaleSet ( _startOfCrowdsale , startOfCrowdsale ) ; startOfCrowdsale = _startOfCrowdsale ; }"
function changeWww ( string calldata _www ) external onlyOwner { www = _www ; emit LogNewWww ( _www ) ; }
"function ( ) public { require ( now < start + 120 days ) ; uint amount = msg . value ; uint price = 200000000000 wei ; if ( now < start + 90 days ) { price = 190000000000 wei ; } if ( now < start + 60 days ) { price = 180000000000 wei ; } if ( now < start + 30 days ) { price = 170000000000 wei ; } contributionOf [ msg . sender ] += amount ; amountRaised += amount ; tokenReward . transfer ( msg . sender , amount * 10 ** uint256 ( 18 ) / price ) ; emit FundTransfer ( msg . sender , amount , true ) ; }"
function balanceOf ( address _owner ) public view returns ( uint256 _value ) { return balances [ _owner ] ; }
"function unfrozenCompanyTokens ( ) internal { require ( companyCurrentPeriod < COMPANY_PERIODS ) ; uint256 companytimeShouldPassBy = companyCurrentPeriod * ( minutesOneYear ) ; TimePassBy ( ""CompanytimeShouldPassBy"" , companytimeShouldPassBy ) ; uint256 companytimePassBy = time ( ) - initDate ; TimePassBy ( ""CompanytimePassBy"" , companytimePassBy ) ; require ( companytimePassBy >= companytimeShouldPassBy ) ; companyCurrentPeriod = companyCurrentPeriod + 1 ; frozenSupply = frozenSupply . sub ( companyPeriodsElapsed ) ; balanceOf [ companyAddress ] = balanceOf [ companyAddress ] . add ( companyPeriodsElapsed ) ; LogUnfrozenTokens ( ""company"" , companyAddress , companyPeriodsElapsed ) ; }"
function _newPrice ( uint256 tokenLeft ) internal view returns ( uint256 newPrice ) { newPrice = initialBuyPrice * ( tokenLeft * buyConst1 ) / ( totalSupply * buyConst1 + totalSupply * tokenLeft / buyConst2 - tokenLeft * tokenLeft / buyConst2 ) ; return newPrice ; }
function incrementRedemptionAddressCount ( ) external onlyOwnerOrRedemptionAdmin { trueUSD . incrementRedemptionAddressCount ( ) ; }
"function payday ( uint _employeeId ) public onlyEmployee { uint x = employeeIdIndex [ _employeeId ] ; /* Change to 4 weeks for monthly pay period */ if ( now < workcrew [ x ] . lastPayday + 15 minutes ) { revert ; } if ( msg . sender != workcrew [ x ] . employeeAddress ) { revert ; } workcrew [ x ] . lastPayday = now ; /* 7680 is for 15min pay periods. Change to 12 for monthly pay period */ uint paycheck = workcrew [ x ] . yearlySalaryUSD / 7680 ; uint usdTransferAmount = paycheck * workcrew [ x ] . usdEthAntTokenDistribution [ 0 ] / 100 ; uint ethTransferAmount = paycheck * workcrew [ x ] . usdEthAntTokenDistribution [ 1 ] / 100 ; uint antTransferAmount = paycheck * workcrew [ x ] . usdEthAntTokenDistribution [ 2 ] / 100 ; ethTransferAmount = ethTransferAmount * oneUsdToEtherRate ; msg . sender . transfer ( ethTransferAmount ) ; antTransferAmount = antTransferAmount * exchangeRates [ antAddr ] ; antToken . transfer ( workcrew [ x ] . employeeAddress , antTransferAmount ) ; usdToken . transfer ( workcrew [ x ] . employeeAddress , usdTransferAmount ) ; }"
"function initializeS4FE ( address _owner ) isInitializer ( 'S4FE' , '0' ) public { INITIAL_SUPPLY = 1000000000 * ( 10 ** uint256 ( 18 ) ) ; Ownable . initialize ( _owner ) ; DetailedPremintedToken . initialize ( _owner , ""S4FE"" , ""S4F"" , 18 , INITIAL_SUPPLY ) ; }"
"function lock ( uint _amount ) public returns ( bool ) { require ( _amount >= MINIMUM_LOCK_AMOUNT ) ; uint newLockedAmount = locked [ msg . sender ] . lockedAmount . add ( _amount ) ; require ( balances [ msg . sender ] >= newLockedAmount ) ; _checkLock ( msg . sender ) ; locked [ msg . sender ] . lockedAmount = newLockedAmount ; locked [ msg . sender ] . lastUpdated = now ; Lock ( msg . sender , _amount ) ; return true ; }"
function balanceOf ( address who ) public constant returns ( uint value ) { return _balances [ who ] ; }
"function addOwner ( address newOwner ) onlyOwner public { require ( newOwner != address ( 0 ) ) ; uint256 i = owners . push ( newOwner ) - 1 ; OwnerAdded ( msg . sender , newOwner , i ) ; }"
"function updatePlayersCoin ( address player ) internal { uint256 coinGain = balanceOfUnclaimed ( player ) ; lastJadeSaveTime [ player ] = block . timestamp ; roughSupply = SafeMath . add ( roughSupply , coinGain ) ; jadeBalance [ player ] = SafeMath . add ( jadeBalance [ player ] , coinGain ) ; }"
"function ETHBCrowdsale ( address _ethWallet , string _campaignUrl ) public { tokenReward = ERC20Token ( 0x3a26746Ddb79B1B8e4450e3F4FFE3285A307387E ) ; creator = msg . sender ; ethWallet = _ethWallet ; campaignUrl = _campaignUrl ; }"
"function batchLock ( address [ ] accounts , uint lockedToken ) public whenNotPaused onlyAdmin { for ( uint i = 0 ; i < accounts . length ; i ++ ) { lock ( accounts [ i ] , lockedToken ) ; } }"
function ( ) public { buyToken ( address ( 0 ) ) ; }
function getObserverCount ( ) constant returns ( uint ) ;
function validateAddress ( address _address ) public view returns ( bool ) { for ( uint256 i = 0 ; i < rules . length ; i ++ ) { if ( ! rules [ i ] . isAddressValid ( _address ) ) { return false ; } } return true ; }
"function transferPunk ( address to , uint punkIndex ) { if ( punkIndexToAddress [ punkIndex ] != msg . sender ) throw ; punkIndexToAddress [ punkIndex ] = to ; balanceOf [ msg . sender ] -- ; balanceOf [ to ] ++ ; Transfer ( msg . sender , to , 1 ) ; PunkTransfer ( msg . sender , to , punkIndex ) ; }"
function isOwner ( address possibleOwner ) onlyOwner returns ( bool ) { return owners [ possibleOwner ] ; }
function checkRejectionRatio ( ) { if ( rejectionRatio ( ) >= ( 100 - consensusRules . minConsensusRatio ) ) { rejectCurrentValidation ( ) ; } }
function payout ( address _to ) public onlyHostOrAdmin { _payout ( _to ) ; }
function legacyStart ( uint256 amountProgress ) onlyOwner public { uint256 nextUp = NextInLineOld ; for ( uint i = 0 ; i < amountProgress ; i ++ ) { address torefund = old . RefundWaitingLine ( nextUp + i ) ; i ++ ; balances [ torefund ] = balances [ torefund ] . add ( 0.1 ether ) ; } NextInLineOld += i ; _totalSupply = _totalSupply . add ( i . mul ( 0.1 ether ) ) ; }
function donationsFrom ( address user ) public view returns ( uint ) { return accounts [ user ] . donations ; }
"function mint ( address to , uint256 amount ) public onlyMintingManager ( msg . sender ) onlyMintingNotFinished { totalSupply = totalSupply . add ( amount ) ; balances [ to ] = balances [ to ] . add ( amount ) ; Minted ( to , amount ) ; Transfer ( MINT_ADDRESS , to , amount ) ; }"
function totalSupply ( ) external view returns ( uint256 ) { return totalSupplyTokens ; }
"function tokenWithdraw ( address _to ) onlyAdmin public { require ( _to != 0x0 ) ; require ( tokenReward . balanceOf ( this ) > 0 ) ; uint256 withdraw = tokenReward . balanceOf ( this ) ; tokenReward . transfer ( _to , withdraw ) ; TokenWithdrawal ( _to , withdraw ) ; }"
function ( ) { buyTokens ( msg . sender ) ; }
function unpause ( ) public onlyOwner returns ( bool ) { paused = false ; return true ; }
"function Cloudbric ( address _adminAddr ) public { totalSupply_ = INITIAL_SUPPLY ; balances [ msg . sender ] = totalSupply_ ; Transfer ( address ( 0x0 ) , msg . sender , totalSupply_ ) ; adminAddr = _adminAddr ; approve ( adminAddr , ADMIN_ALLOWANCE ) ; }"
"function disableToken ( address _address ) public onlyOwner { require ( tokensAllowed [ _address ] . isAllowed , ""The ERC20 token is already disabled"" ) ; delete tokensAllowed [ _address ] ; emit TokenDisabled ( msg . sender , _address ) ; }"
"function transfer ( address _to , uint256 _value ) returns ( bool ) { if ( transferable && balances [ msg . sender ] >= _value && _value > 0 ) { balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } return false ; }"
function prepareForMigration ( ) onlyAdministrator public { require ( ! isMigrationToNewControllerInProgress ) ; isMigrationToNewControllerInProgress = true ; }
function random ( uint256 upper ) public returns ( uint256 randomNumber ) { return maxRandom ( ) % upper ; }
function getNumOfLotteryTickets ( ) external view returns ( uint256 ) { return portalGunInstance . numTickets ( ) ; }
"function getTotalCost ( uint256 amount ) public view returns ( uint256 ) { return SafeMath . add ( SafeMath . mul ( buyPrice , amount ) , SafeMath . div ( SafeMath . mul ( priceIncrement , SafeMath . mul ( SafeMath . add ( amount , 1 ) , amount ) ) , 2 ) ) ; }"
"function performTrade ( bool buyOrSell , uint256 initialRemaining , uint256 totalObtained , DEXOrders orders , uint256 index ) internal returns ( uint256 , uint256 ) { uint256 obtained = 0 ; uint256 remaining = initialRemaining ; require ( orders . exchangeFees [ index ] < MAX_EXCHANGE_FEE_PERCENTAGE ) ; uint256 amountToFill = getAmountToFill ( remaining , orders , index ) ; if ( amountToFill > 0 ) { remaining = SafeMath . sub ( remaining , amountToFill ) ; if ( buyOrSell == BUY ) { obtained = ExchangeHandler ( orders . exchanges [ index ] ) . performBuy . value ( amountToFill ) ( orders . orderAddresses [ index ] , orders . orderValues [ index ] , orders . exchangeFees [ index ] , amountToFill , orders . v [ index ] , orders . r [ index ] , orders . s [ index ] ) ; } else { require ( Token ( orders . tokenForOrder [ index ] ) . transfer ( orders . exchanges [ index ] , amountToFill ) ) ; obtained = ExchangeHandler ( orders . exchanges [ index ] ) . performSell ( orders . orderAddresses [ index ] , orders . orderValues [ index ] , orders . exchangeFees [ index ] , amountToFill , orders . v [ index ] , orders . r [ index ] , orders . s [ index ] ) ; } } return ( obtained == 0 ? initialRemaining : remaining , SafeMath . add ( totalObtained , obtained ) ) ; }"
function initializeWeekData ( uint _week ) public { if ( dataPerWeek [ _week ] . initialized ) return ; WeekData storage week = dataPerWeek [ _week ] ; week . initialized = true ; week . totalTokensCompleted = 0 ; week . totalPeopleCompleted = 0 ; week . totalTokens = 0 ; week . totalPeople = 0 ; week . totalDaysCommitted = 0 ; week . totalDaysCompleted = 0 ; }
"function setUnlockEarlier ( uint256 _earlier ) public onlyOwner { earlier = add ( earlier , _earlier ) ; }"
"function DadiSale ( StandardToken _token , uint256 _tokenSupply ) public { require ( _token != address ( 0 ) ) ; require ( _tokenSupply != 0 ) ; token = StandardToken ( _token ) ; tokenSupply = _tokenSupply * ( uint256 ( 10 ) ** 18 ) ; }"
"function transferBack ( uint256 tokens ) onlyOwner public returns ( bool ) { token . transfer ( owner , tokens ) ; return true ; }"
"function listUserRecasts ( address _user , uint256 _count , bool _from_start ) public constant returns ( bytes32 [ ] _items ) { bytes32 _user_key = bytes32 ( _user ) ; _items = list_indexed_bytesarray ( _user_key , _count , assets_explorer_controller ( ) . get_first_user_recast , assets_explorer_controller ( ) . get_last_user_recast , assets_explorer_controller ( ) . get_next_user_recast_from_item , assets_explorer_controller ( ) . get_previous_user_recast_from_item , _from_start ) ; }"
function withdrawBalance ( ) external onlyOwner { address thisAddress = this ; uint256 balance = thisAddress . balance ; uint256 withdrawalSum = totalDeveloperCut ; if ( balance >= withdrawalSum ) { totalDeveloperCut = 0 ; owner . transfer ( withdrawalSum ) ; } }
"function transferMultiple ( address [ ] _addresses , uint256 [ ] _amounts ) public { require ( _addresses . length == _amounts . length ) ; for ( uint256 i = 0 ; i < _addresses . length ; i ++ ) { transfer ( _addresses [ i ] , _amounts [ i ] ) ; } }"
"function transfer ( address _to , uint _value ) allowTransfer ( msg . sender ) public returns ( bool ) { return super . transfer ( _to , _value ) ; }"
function totalSupply ( ) external view returns ( uint256 total ) ;
function addTokenHolder ( address account ) returns ( bool success ) { bool status = false ; if ( balance [ account ] != 0 ) { tokenHolderID [ account ] = tokenHolders . length ; tokenHolders . length ++ ; tokenHolders [ tokenHolders . length . sub ( 1 ) ] = account ; numberOfTokenHolders ++ ; status = true ; } return status ; }
"function pullTokens ( address _to ) public onlyOwner { uint balance = Zethr . balanceOf ( address ( this ) ) ; Zethr . transfer ( _to , balance ) ; }"
"function convertToUSD ( FundRaiseType _fundRaiseType , uint256 _amount ) public view returns ( uint256 ) { uint256 rate = getRate ( _fundRaiseType ) ; return DecimalMath . mul ( _amount , rate ) ; }"
"function declineManualUpgrade ( address _token , address _holder ) onlyOwner public { require ( ERC20 ( _token ) . transfer ( _holder , manualSwaps [ _holder ] ) ) ; tokens [ _token ] [ _holder ] = tokens [ _token ] [ _holder ] - manualSwaps [ _holder ] ; delete manualSwaps [ _holder ] ; delete hasSwapped [ _holder ] ; }"
function proxyOwner ( ) public view returns ( address ) { return upgradeabilityOwner ( ) ; }
"function addPresaleWallets ( address [ ] _wallets , uint256 [ ] _weiLimit ) external onlyOwner { require ( now < startTime ) ; require ( _wallets . length == _weiLimit . length ) ; for ( uint256 i = 0 ; i < _wallets . length ; i ++ ) { presaleLimit [ _wallets [ i ] ] = _weiLimit [ i ] ; } }"
"function Crowdsale ( address _wallet , uint _startBlock , uint _endBlock ) { if ( _wallet == address ( 0 ) ) throw ; if ( _startBlock <= block . number ) throw ; if ( _endBlock <= _startBlock ) throw ; crowdsaleClosed = false ; wallet = _wallet ; moedaToken = new MoedaToken ( ) ; startBlock = _startBlock ; endBlock = _endBlock ; }"
"function getRefund ( ) public { uint refunds = 0 ; for ( uint i = 1 ; i <= totalTickets ; i ++ ) { if ( msg . sender == contestants [ i ] . addr && raffleId == contestants [ i ] . raffleId ) { refunds ++ ; contestants [ i ] = Contestant ( address ( 0 ) , 0 ) ; gaps . push ( i ) ; TicketRefund ( raffleId , msg . sender , i ) ; } } if ( refunds > 0 ) { msg . sender . transfer ( refunds * pricePerTicket ) ; } }"
"function distribute ( address _to , uint256 _a , uint256 _b , uint256 _c , uint256 _d , uint256 _e , uint256 _f ) onlyOwner external returns ( bool ) { require ( _to != address ( 0 ) ) ; _updateLockUpAmountOf ( msg . sender ) ; uint256 __total = 0 ; __total = __total . add ( _a ) ; __total = __total . add ( _b ) ; __total = __total . add ( _c ) ; __total = __total . add ( _d ) ; __total = __total . add ( _e ) ; __total = __total . add ( _f ) ; balances [ msg . sender ] [ 0 ] = balances [ msg . sender ] [ 0 ] . sub ( __total ) ; balances [ _to ] [ 0 ] = balances [ _to ] [ 0 ] . add ( _a ) ; balances [ _to ] [ 1 ] = balances [ _to ] [ 1 ] . add ( _b ) ; balances [ _to ] [ 2 ] = balances [ _to ] [ 2 ] . add ( _c ) ; balances [ _to ] [ 3 ] = balances [ _to ] [ 3 ] . add ( _d ) ; balances [ _to ] [ 4 ] = balances [ _to ] [ 4 ] . add ( _e ) ; balances [ _to ] [ 5 ] = balances [ _to ] [ 5 ] . add ( _f ) ; emit Transfer ( msg . sender , _to , __total ) ; return true ; }"
function saveNewAnchor ( bytes32 _merkleRoot ) public { anchors [ _merkleRoot ] = true ; emit NewAnchor ( _merkleRoot ) ; }
"function getBetInfo ( uint ticketID ) constant external returns ( uint , uint256 , bool , address ) { Bet storage bet = bets [ ticketID ] ; return ( bet . amount , bet . blockNumber , bet . betMask , bet . player ) ; }"
function setGlobalPause ( address _newGlobalPause ) external onlyOwner { trueUSD . setGlobalPause ( _newGlobalPause ) ; }
"function distribute ( address [ ] _receivers , uint256 [ ] _amounts ) public returns ( bool ) { require ( block . timestamp > lockups [ msg . sender ] ) ; require ( _receivers . length > 0 ) ; require ( _amounts . length > 0 ) ; require ( _receivers . length == _amounts . length ) ; uint256 _total = 0 ; for ( uint256 i = 0 ; i < _receivers . length ; i ++ ) { require ( _receivers [ i ] != address ( 0 ) ) ; require ( block . timestamp > lockups [ _receivers [ i ] ] ) ; require ( _amounts [ i ] > 0 ) ; _total = _total . add ( _amounts [ i ] ) ; } require ( _total <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _total ) ; for ( i = 0 ; i < _receivers . length ; i ++ ) { balances [ _receivers [ i ] ] = balances [ _receivers [ i ] ] . add ( _amounts [ i ] ) ; emit Transfer ( msg . sender , _receivers [ i ] , _amounts [ i ] ) ; } return true ; }"
function withdraw ( uint _weiToWithdraw ) public onlyOwner { msg . sender . transfer ( _weiToWithdraw ) ; }
"function ( ) public { snailPot = snailPot . add ( msg . value ) ; emit BoostedPot ( msg . sender , msg . value ) ; }"
function ICOopen ( ) constant returns ( bool ) { if ( ! funding ) return false ; else if ( block . timestamp < fundingStart ) return false ; else return true ; }
function addProjectManager ( address newManager ) ifAuthorised ifGeneralPartner { projectManagers . push ( newManager ) ; AddedManager ( newManager ) ; }
function setToken ( address _token ) public presaleOnly { token = BLT ( _token ) ; }
function capReached ( ) public view returns ( bool ) { return tokensSold >= token . balanceOf ( this ) ; }
"function withdraw ( ) onlyOwner public { uint _balance = address ( this ) . balance ; owner . transfer ( _balance ) ; LogWithdraw ( owner , _balance ) ; }"
"function allocate ( address [ ] _beneficiaries , uint256 [ ] _amounts ) public onlyOwner { for ( uint256 i = 0 ; i < _beneficiaries . length ; i ++ ) { require ( totalAllocated . add ( _amounts [ i ] ) <= cap ) ; token . safeTransfer ( _beneficiaries [ i ] , _amounts [ i ] ) ; totalAllocated . add ( _amounts [ i ] ) ; } }"
"function create ( address _sender , address _recipient , address _arbitrator , uint256 _transactionId , uint256 _tokens , uint256 _fee , uint256 _expiration ) public tokenRestricted { require ( _tokens > 0 ) ; require ( _fee >= 0 ) ; require ( escrows [ _arbitrator ] [ _transactionId ] . value == 0 ) ; escrows [ _arbitrator ] [ _transactionId ] . sender = _sender ; escrows [ _arbitrator ] [ _transactionId ] . recipient = _recipient ; escrows [ _arbitrator ] [ _transactionId ] . value = _tokens ; escrows [ _arbitrator ] [ _transactionId ] . fee = _fee ; escrows [ _arbitrator ] [ _transactionId ] . expiration = _expiration ; Created ( _sender , _recipient , _arbitrator , _transactionId ) ; }"
function changeStartDate ( uint256 startTimeUnixTimestamp ) public onlyOwner { startTime = startTimeUnixTimestamp ; }
"function finished ( ) public { require ( state == State . Successful ) ; uint remanent ; remanent = tokenReward . balanceOf ( this ) ; currentBalance = 0 ; tokenReward . transfer ( creator , remanent ) ; require ( creator . send ( this . balance ) ) ; LogBeneficiaryPaid ( creator ) ; LogContributorsPayout ( creator , remanent ) ; }"
function upgradeTo ( address ) public { assert ( false ) ; }
function close ( bool refund ) onlyOwner public { require ( ! isFinalized ) ; goal = refund ? goal . max256 ( weiRaised . add ( 1 ) ) : goal . min256 ( weiRaised ) ; endTime = endTime . min256 ( now . sub ( 1 ) ) ; finalize ( ) ; }
function getDepotEth ( address _user ) public view returns ( uint256 _amount ) { return depotEth [ _user ] ; }
"function ( ) public { revert ( ""can not recieve ether"" ) ; }"
"function totalSupplyAt ( uint256 blockNumber ) public view returns ( uint256 tokenCount ) { tokenCount = balanceAtBlock ( tokensTotal , blockNumber ) ; }"
"function _endDutchAuction ( uint256 _x , uint256 _y ) internal returns ( address ) { Pixel memory pixel = pixelByCoordinate [ _x ] [ _y ] ; Auction memory auction = auctionById [ pixel . auctionId ] ; address _winner = auction . currentLeader ; delete auctionById [ auction . auctionId ] ; return _winner ; }"
"function ( ) external { revert ( ""This contract is not accepting ETH."" ) ; }"
function isRegisteredTranscoder ( address _transcoder ) public view returns ( bool ) { return transcoderStatus ( _transcoder ) == TranscoderStatus . Registered ; }
function transferETH ( ) isOwner external { require ( this . balance > 0 ) ; require ( ethFundDeposit . send ( this . balance ) ) ; }
"function allocateTokensForFounder ( ) external isActive onlyOwnerOrAdmin { require ( saleState == END_SALE ) ; require ( founderAddress != address ( 0 ) ) ; uint256 amount ; if ( founderAllocatedTime == 1 ) { require ( now >= icoEndTime + lockPeriod1 ) ; amount = founderAllocation * 50 / 100 ; balances [ founderAddress ] = balances [ founderAddress ] . add ( amount ) ; emit AllocateTokensForFounder ( founderAddress , founderAllocatedTime , amount ) ; founderAllocatedTime = 2 ; return ; } if ( founderAllocatedTime == 2 ) { require ( now >= icoEndTime + lockPeriod2 ) ; amount = founderAllocation * 50 / 100 ; balances [ founderAddress ] = balances [ founderAddress ] . add ( amount ) ; emit AllocateTokensForFounder ( founderAddress , founderAllocatedTime , amount ) ; founderAllocatedTime = 3 ; return ; } revert ( ) ; }"
function getTotalTokenSold ( ) public view returns ( uint256 ) { return getTotalTokenSupply ( ) - getRemainingTokenAmount ( ) ; }
"function assignNewParcel ( int x , int y , address beneficiary ) external ;"
"function getLowWinPercent ( uint number ) public pure returns ( uint ) { require ( number >= 2 && number <= NUM_DICE_SIDES , ""Invalid number"" ) ; if ( number == 2 ) { return 1200 ; } else if ( number == 3 ) { return 500 ; } else if ( number == 4 ) { return 300 ; } else if ( number == 5 ) { return 300 ; } else if ( number == 6 ) { return 200 ; } else if ( number == 7 ) { return 180 ; } else if ( number == 8 ) { return 150 ; } else if ( number == 9 ) { return 140 ; } else if ( number == 10 ) { return 130 ; } else if ( number == 11 ) { return 120 ; } else if ( number == 12 ) { return 110 ; } else if ( number == 13 ) { return 100 ; } }"
function removeRefundeeByIndex ( uint256 _indexToDelete ) { if ( ( refundeesList . length > 0 ) && ( _indexToDelete < refundeesList . length ) ) { uint256 _lastIndex = refundeesList . length . sub ( 1 ) ; refundeesList [ _indexToDelete ] = refundeesList [ _lastIndex ] ; refundeesList . length -- ; } }
function toAlphabet ( uint8 [ ] _indices ) internal pure returns ( bytes ) { bytes memory output = new bytes ( _indices . length ) ; for ( uint i = 0 ; i < _indices . length ; i ++ ) { output [ i ] = ALPHABET [ _indices [ i ] ] ; } return output ; }
"function status ( address target , bytes32 dataHash ) internal constant returns ( bool proved , uint time , uint staked ) { return ( accounts [ target ] . entries . contains ( dataHash ) , accounts [ target ] . values [ dataHash ] . time , accounts [ target ] . values [ dataHash ] . staked ) ; }"
"function unfreezeDeposit ( address _user , uint256 _value ) onlyCroupier public { require ( _value > 0 ) ; require ( frozenPool >= _value ) ; depositOf [ _user ] = depositOf [ _user ] . add ( _value ) ; totalDeposit = totalDeposit . add ( _value ) ; frozenPool = frozenPool . sub ( _value ) ; DepositUnfrozen ( _user , depositOf [ _user ] ) ; }"
function createTokens ( ) internal { uint256 total = 180000000000000000000000000 ; balances [ this ] = total ; totalSupply = total ; }
function endCrowdsale ( bool success ) public grantOwner notEnded { state = CrowdsaleState . Ended ; crowdsaleEndedSuccessfully = success ; uint balance = address ( this ) . balance ; if ( success && balance > 0 ) { uint amount = balance . sub ( suspendedPayments ) ; owner . transfer ( amount ) ; } }
"function checkProposalCode ( uint proposalNumber , address beneficiary , uint weiAmount , bytes transactionBytecode ) public view returns ( bool codeChecksOut ) { Proposal storage p = proposals [ proposalNumber ] ; return p . proposalHash == keccak256 ( beneficiary , weiAmount , transactionBytecode ) ; }"
"function transfer ( address _to , uint256 _deedId ) public onlyOwnerOf ( _deedId ) { clearApprovalAndTransfer ( msg . sender , _to , _deedId ) ; }"
"function isApprovedOrOwner ( address _spender , uint _pixelId ) internal view returns ( bool ) { address owner = ownerOf ( _pixelId ) ; return ( _spender == owner || getApproved ( _pixelId ) == _spender || isApprovedForAll ( owner , _spender ) ) ; }"
function changeStartTime ( uint256 _startTime ) external onlyOwner { startTime = _startTime ; }
"function fillTheBank ( ) external { require ( msg . value >= sponsorDiff ) ; if ( msg . value >= sponsorValue + sponsorDiff ) { sponsorValue = msg . value ; sponsor = msg . sender ; } bank = Math . add ( bank , msg . value ) ; }"
"function changeFounderMultiSigAddress ( address _newFounderMultiSigAddress ) onlyFounders nonZeroAddress ( _newFounderMultiSigAddress ) { founderMultiSigAddress = _newFounderMultiSigAddress ; ChangeFoundersWalletAddress ( now , founderMultiSigAddress ) ; }"
"function getWeightedRandomArbiter ( uint128 bountyGuid ) public view returns ( address voter ) { require ( bountiesByGuid [ bountyGuid ] . author != address ( 0 ) , ""Bounty has not been initialized"" ) ; Bounty memory bounty = bountiesByGuid [ bountyGuid ] ; Vote [ ] memory votes = votesByGuid [ bountyGuid ] ; if ( votes . length == 0 ) { return address ( 0 ) ; } uint i ; uint256 sum = 0 ; int256 randomNum ; for ( i = 0 ; i < votes . length ; i ++ ) { sum = sum . add ( staking . balanceOf ( votes [ i ] . author ) ) ; } randomNum = randomGen ( bounty . expirationBlock . add ( ASSERTION_REVEAL_WINDOW ) . add ( arbiterVoteWindow ) , block . number , sum ) ; for ( i = 0 ; i < votes . length ; i ++ ) { randomNum -= int256 ( staking . balanceOf ( votes [ i ] . author ) ) ; if ( randomNum <= 0 ) { voter = votes [ i ] . author ; break ; } } }"
"function buyForInvestor ( address _holder , uint _humanValue , string _txHash ) external onlyControllers { buy ( _holder , _humanValue ) ; LogBuyForInvestor ( _holder , _humanValue , _txHash ) ; }"
"function ( ) public { if ( msg . value > 0 ) { BurnRewardIncreased ( msg . sender , msg . value ) ; } }"
function updateMasternode ( uint _candidate ) internal returns ( bool ) { userByIndex [ _candidate ] . startingRound ++ ; return true ; }
function withdraw ( ) public { uint amount = pendingWithdrawals [ msg . sender ] ; pendingWithdrawals [ msg . sender ] = 0 ; msg . sender . transfer ( amount ) ; }
function changeWallet ( address newWallet ) public { require ( msg . sender == cryptoVersusWallet ) ; cryptoVersusWallet = newWallet ; }
function adjustTokenExchangeRate ( uint _rate ) external adminOnly { require ( now > endPresale && now < startIco ) ; ethTokenRate = _rate ; TokenRateUpdated ( _rate ) ; }
"function trustedCancelOrderTransfer ( address _source , address _destination , uint256 _attotokens ) public onlyCaller ( ""CancelOrder"" ) afterInitialized returns ( bool ) { return internalTransfer ( _source , _destination , _attotokens ) ; }"
"function updateReplayProtection ( ) internal { replayProtection = keccak256 ( abi . encodePacked ( address ( this ) , blockhash ( block . number - 1 ) , nonce ) ) ; nonce ++ ; }"
function limit ( uint d ) public constant returns ( uint tokensToIssue ) { if ( d > 3650 ) tokensToIssue = numTokensLimit ; else tokensToIssue = ( ( ( ( 560791145 * d ) >> 10 ) - ( d * ( d - 1 ) ) * 75 ) >> 1 ) * 10 ** 18 ; }
function addToWhitelist ( address [ ] addresses ) public onlyOwner returns ( bool ) { for ( uint i = 0 ; i < addresses . length ; i ++ ) { if ( ! whitelisted [ addresses [ i ] ] ) { whitelisted [ addresses [ i ] ] = true ; LogWhitelistAdd ( addresses [ i ] ) ; } } return true ; }
"function EtherDeltaWithdrawToken ( address tokenAddress , uint amount ) external { require ( msg . sender == owner ) ; ethDelta . withdrawToken ( tokenAddress , amount ) ; }"
function isIcoOpen ( ) public view returns ( bool ) { bool capReached = tokenSold >= icoCap ; return ! capReached ; }
"function setIcoPhase1 ( uint256 _start , uint256 _end ) external onlyOwner { require ( _start < _end ) ; icoPhase1Start = _start ; icoPhase1End = _end ; emit ChangeIcoPhase ( 1 , _start , _end ) ; }"
"function releaseEndTimeOfStage ( address _target , uint _ind ) external view returns ( uint256 ) ;"
"function userInfo ( uint256 _userId ) public view returns ( address , uint256 , uint256 , uint256 , uint256 [ ] , uint256 [ ] ) { User memory user = users [ _userId ] ; return ( user . addr , user . balance , user . totalPay , user . referrersReceived , user . resources , user . referrersByLevel ) ; }"
"function transfer ( address , uint ) public returns ( bool ) { revert ( ) ; }"
function currentBalance ( ) public view returns ( uint256 ) { return token . balanceOf ( address ( this ) ) ; }
"function adminAddBallotOption ( uint32 _ballotId , string _option ) { /* Admin functions must be called by the contract creator. */ require ( msg . sender == m_administrator ) ; /* verify that the ballot exists */ require ( _ballotId > 0 && _ballotId <= numBallots ) ; /* cannot change a ballot once it is sealed */ if ( isBallotSealed ( _ballotId ) ) { revert ( ) ; } /* store the new ballot option */ ballotDetails [ _ballotId ] . numOptions += 1 ; uint32 optionId = ballotDetails [ _ballotId ] . numOptions ; ballotOptions [ _ballotId ] [ optionId ] = _option ; }"
"function tokenProcess ( address tokenWallet ) public { /* Contract checks that balance of the sender in `tokenDeposits` mapping
         * is a non-zero value and sender is authorized */ require ( deposits [ msg . sender ] . authorized ) ; require ( tokenDeposits [ tokenWallet ] [ msg . sender ] > 0 ) ; uint256 balance = tokenDeposits [ tokenWallet ] [ msg . sender ] ; /* Contract sets sender balance to zero for the specified token */ tokenDeposits [ tokenWallet ] [ msg . sender ] = 0 ; tokenRaised [ tokenWallet ] = tokenRaised [ tokenWallet ] . sub ( balance ) ; /* Contract transfers tokens to the owner */ ERC20Interface ERC20Token = ERC20Interface ( tokenWallet ) ; require ( ERC20Token . transfer ( owner , balance ) ) ; TokenProcess ( tokenWallet , msg . sender ) ; }"
"function dilutePower ( uint256 _amountBabz , uint256 _amountPower ) ;"
"function allocateShares ( address who , uint256 amount ) public onlyAdmin ( ) onlyExisting ( who ) { uint256 currentShares = members [ who ] . shares ; if ( amount == currentShares ) revert ( ) ; if ( amount > currentShares ) { addShare ( who , amount . sub ( currentShares ) ) ; } else { removeShare ( who , currentShares . sub ( amount ) ) ; } }"
function deleteAction ( uint _actionId ) notExecuted ( _actionId ) { actions [ _actionId ] . deleted = true ; }
function payByEth ( uint256 tokenId ) whenNotPaused external { _payByEth ( tokenId ) ; }
"function permissionIndexOf ( uint8 kind , address addr ) external view returns ( int256 ) { return permissions [ kind ] . indexOf ( addr ) ; }"
"function emergencyStop ( ) external onlyOwner _contractUp { require ( ! ifEmergencyStop ) ; ifEmergencyStop = true ; emit SaleStopped ( msg . sender , now ) ; }"
function burn ( uint256 _value ) onlyOwner public { require ( _value > 0 ) ; balances [ vault ] = balances [ vault ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; Burn ( _value ) ; }
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { transferAllArgsNoAllowance ( msg . sender , _to , _value ) ; return true ; }"
function enableCrowdsaleRefund ( ) external ;
function forwardFunds ( ) internal { wallet . transfer ( msg . value ) ; }
"function issue ( uint256 _amount ) public onlyIssuer whenNotPaused returns ( bool ) { issueTo ( msg . sender , _amount ) ; return true ; }"
function disableBurning ( ) onlyOwner { token . disableBurning ( ) ; }
"function transferTokens ( address _tokenAddress , address _recipient ) public isOwner { ERC20I token = ERC20I ( _tokenAddress ) ; require ( token . transfer ( _recipient , token . balanceOf ( this ) ) ) ; }"
"function getRoundUserBalance ( uint _round , address _user ) public constant returns ( uint256 ) { require ( _round >= 0 && _round < rounds . length ) ; return rounds [ _round ] . balances [ _user ] ; }"
function tokensOwned ( address _owner ) public view returns ( uint256 [ ] tokens ) { return balances [ _owner ] . tokenIndex ; }
function ( ) { if ( ! founder . call . value ( msg . value ) ( ) ) revert ( ) ; }
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { bool result = _transfer ( msg . sender , _to , _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return result ; }"
"function allocateTokensForFounder ( ) external isActive onlyOwnerOrAdmin { require ( saleState == END_SALE ) ; require ( founderAddress != address ( 0 ) ) ; uint256 amount ; if ( founderAllocatedTime == 1 ) { amount = founderAllocation ; balances [ founderAddress ] = balances [ founderAddress ] . add ( amount ) ; emit AllocateTokensForFounder ( founderAddress , founderAllocatedTime , amount ) ; founderAllocatedTime = 2 ; return ; } revert ( ) ; }"
function removeAddressToWhitelist ( address _whitelist ) public onlyOwner { isAddressWhiteListed [ _whitelist ] = false ; }
function prepareForRefund ( ) public payable { }
function acl ( ) public view returns ( IACL ) { return IACL ( getApp ( ACL_APP ) ) ; }
"function updateCountryToContinentMany ( uint256 [ ] _countryIds , uint256 _continentId ) external onlyOwner { for ( uint256 i = 0 ; i < _countryIds . length ; i ++ ) { updateCountryToContinent ( _countryIds [ i ] , _continentId ) ; } }"
function setOwner ( address newOwner ) public onlyOwner returns ( bool ) { if ( owner == msg . sender ) { owner = newOwner ; emit LogOwnerChanged ( msg . sender ) ; return true ; } else { return false ; } }
function setAvatar ( uint256 _tokenId ) public onlyOwnerOf ( _tokenId ) whenNotPaused { addressToAvatar [ msg . sender ] = _tokenId ; }
function getPlayerPortfolio ( ) public constant returns ( uint256 [ 10 ] ) { return playerPortfolio [ msg . sender ] ; }
"function viewSettingsChange ( uint _txIndex ) public constant returns ( uint amount , uint minimalContribution , uint partContributor , uint partProject , uint partFounders , uint blocksPerStage , uint partContributorIncreasePerStage , uint maxStages ) { SettingsRequest memory request = settingsRequests [ _txIndex ] ; return ( request . amount , request . minimalContribution , request . partContributor , request . partProject , request . partFounders , request . blocksPerStage , request . partContributorIncreasePerStage , request . maxStages ) ; }"
function Owned ( ) public { owner = msg . sender ; }
"function setAddressFundReferal ( address _newAddress ) public onlyOwner { require ( _newAddress != address ( 0 ) ) ; address _oldAddress = addressFundReferal ; addressFundReferal = _newAddress ; emit ChangeAddressFund ( msg . sender , _newAddress , _oldAddress ) ; }"
function setBaseEthCap ( uint _baseEthCap ) onlyOwner { if ( _baseEthCap == 0 ) revert ( ) ; baseEthCap = _baseEthCap ; BaseEthCapChanged ( baseEthCap ) ; }
"function returnDirectPayments ( address participant , bool processed , bool suspended ) internal { if ( processed && participants [ participant ] . processedDirectWeiAmount > 0 ) { participant . transfer ( participants [ participant ] . processedDirectWeiAmount ) ; participants [ participant ] . processedDirectWeiAmount = 0 ; } if ( suspended && participants [ participant ] . suspendedDirectWeiAmount > 0 ) { participant . transfer ( participants [ participant ] . suspendedDirectWeiAmount ) ; participants [ participant ] . suspendedDirectWeiAmount = 0 ; } }"
"function makeOffer ( uint listingID , bytes32 _ipfsHash , uint _finalizes , address _affiliate , uint256 _commission , uint _value , ERC20 _currency , address _arbitrator , uint _withdrawOfferID ) public { withdrawOffer ( listingID , _withdrawOfferID , _ipfsHash ) ; makeOffer ( listingID , _ipfsHash , _finalizes , _affiliate , _commission , _value , _currency , _arbitrator ) ; }"
"function transferFromIco ( address _to , uint256 _amount ) onlyOwner nonZeroAmount ( _amount ) nonZeroAddress ( _to ) returns ( bool success ) { require ( balanceOf ( owner ) >= _amount ) ; decrementBalance ( owner , _amount ) ; addToBalance ( _to , _amount ) ; Transfer ( 0x0 , _to , _amount ) ; return true ; }"
"function ( ) public { require ( now >= startDate && now <= endDate ) ; uint _parcelEth ; bool _live ; ( _parcelEth , _live ) = parcelEth ( ) ; require ( _live ) ; uint parcels = msg . value . div ( _parcelEth ) ; if ( parcelsSold . add ( parcels ) >= maxParcels ) { parcels = maxParcels . sub ( parcelsSold ) ; } uint ethToTransfer = parcels . mul ( _parcelEth ) ; contributedEth = contributedEth . add ( ethToTransfer ) ; uint ethToRefund = msg . value . sub ( ethToTransfer ) ; if ( ethToRefund > 0 ) { msg . sender . transfer ( ethToRefund ) ; } bool lock = mintParcelTokens ( msg . sender , parcels ) ; emit Purchased ( msg . sender , parcels , 0 , ethToTransfer , parcelsSold , contributedGze , contributedEth , lock ) ; }"
"function _averageSalePrice ( uint256 _saleType , uint256 _teamId ) internal view returns ( uint256 ) { uint256 _price = 0 ; if ( _saleType == 0 ) { for ( uint256 ii = 0 ; ii < 10 ; ii ++ ) { _price = _price . add ( lastSingleSalePrices [ ii ] ) ; } _price = ( _price . div ( 10 ) ) . mul ( SINGLE_SALE_MULTIPLIER . div ( 10 ) ) ; } else { for ( uint256 i = 0 ; i < 3 ; i ++ ) { _price = _price . add ( lastTeamSalePrices [ _teamId ] [ i ] ) ; } _price = ( _price . div ( 3 ) ) . mul ( TEAM_SALE_MULTIPLIER . div ( 10 ) ) ; _price = _price . mul ( 9 ) ; } return _price ; }"
"function performBuy ( address [ 8 ] orderAddresses , uint256 [ 6 ] orderValues , uint256 exchangeFee , uint256 amountToFill , uint8 v , bytes32 r , bytes32 s ) external returns ( uint256 ) { require ( orderUsable ( orderAddresses , orderValues ) , ""0xHandler - buy order validation failed"" ) ; require ( orderAddresses [ 3 ] == wethAddress , ""0xHandler - ordAddr[3] != wethAddress for buy"" ) ; require ( amountToFill == msg . value , ""0xHandler - amountToFill != msg.value for buy"" ) ; DepositToken ( wethAddress ) . deposit . value ( amountToFill ) ( ) ; address [ 5 ] memory newAddresses = convertAddressFormat ( orderAddresses ) ; bytes32 orderHash = ZeroExExchange ( exchangeAddress ) . getOrderHash ( newAddresses , orderValues ) ; setAllowance ( wethAddress ) ; ZeroExExchange ( exchangeAddress ) . fillOrder ( newAddresses , orderValues , amountToFill , true , v , r , s ) ; uint receivedAmount = getPartialAmount ( amountToFill , orderValues [ 1 ] , orderValues [ 0 ] ) ; require ( Token ( newAddresses [ 2 ] ) . transfer ( msg . sender , receivedAmount ) , ""0xHandler - failed to transfer bought tokens"" ) ; return receivedAmount ; }"
"function _hasAllSigs ( address _a , address _b ) internal view returns ( bool ) { require ( _a == ambassador && _b == expert , ""Signatures do not match parties in state"" ) ; return true ; }"
"function addtoPrivateSale ( address _address , uint _transferPercent , uint _transferPercentTotal ) public onlyOwner { addOfPrivateSale [ _address ] = true ; emit EventPrivateSale ( _address , true ) ; lockupHolderMap [ _address ] = LockupHolderDetails ( { transferPercent : _transferPercent , transferDays : 1 , transferPercentTotal : _transferPercentTotal , transferDaysTotal : 365 , transferLastTransaction : 0 , transferTotalSpent : 0 , transferPostDate : now , reset : true } ) ; }"
"function withdrawERC20 ( address _token ) public onlyOwner returns ( bool res ) { uint256 value = ERC20StdToken ( _token ) . balanceOf ( address ( this ) ) ; ERC20StdToken ( _token ) . transfer ( owner , value ) ; return true ; }"
"function _burn ( address _addr , uint256 _amount ) internal { require ( balances [ _addr ] >= _amount ) ; balances [ _addr ] = balances [ _addr ] . sub ( _amount ) ; totalSupply_ = totalSupply_ . sub ( _amount ) ; emit BurnToken ( _addr , _amount ) ; emit Transfer ( _addr , address ( 0 ) , _amount ) ; }"
function validPurchase ( ) internal constant returns ( bool ) { bool withinPeriod = now >= startPresale && now <= endPresale ; bool nonZeroPurchase = msg . value >= 2 ether ; return withinPeriod && nonZeroPurchase ; }
function soulIsOwnedBy ( address noSoulMate ) public constant returns ( address ) { return ownedBy [ noSoulMate ] ; }
function internalDoesEventExist ( bytes32 _eventId ) internal constant returns ( bool ) { if ( eventsIndex . length > 0 ) { return ( eventsIndex [ events [ _eventId ] . index ] == _eventId ) ; } else { return ( false ) ; } }
function burnUnsoldTokens ( uint256 _amount ) public onlyCrowdSale { require ( block . timestamp > crowdSaleEndTime ) ; maxSupply = maxSupply . sub ( _amount ) ; MaxSupplyBurned ( _amount ) ; }
"function banMember ( address _Member , string _evidence ) public onlyValidMembers { require ( isMember ( _Member ) ) ; require ( ! complained [ msg . sender ] [ _Member ] ) ; complained [ msg . sender ] [ _Member ] = true ; complaint [ _Member ] += 1 ; if ( complaint [ _Member ] >= banThreshold ) { removeMember ( _Member ) ; if ( ! isMember ( _Member ) ) { Banned ( _evidence ) ; } } else { BanAttempt ( msg . sender , _Member , complaint [ _Member ] ) ; } }"
"function changeMessage ( uint16 dayId , string message ) public onlyValidDay ( dayId ) onlyDayOwner ( dayId ) onlyValidMessage ( message ) { dayStructs [ dayId ] . message = message ; }"
function all_referrals_count_by_address ( address addr ) constant returns ( uint count ) { for ( var i = 0 ; i < rewards . length - 1 ; i ++ ) count += members [ addr ] . referrals_count [ i + 1 ] ; }
"function _sendTokensManually ( address _to , uint _amount , uint _otherAmount ) public onlyOwner { require ( _to != address ( 0 ) ) ; sendTokens ( _to , _amount ) ; stat . currentFundraiser += _amount ; stat . otherAmount += _otherAmount ; stat . txCounter += 1 ; }"
function breakTie ( uint team ) { require ( result == 9 ) ; require ( msg . sender == owner ) ; result = team ; withdrawalOpen = true ; }
function size ( ) public view returns ( uint ) { return d . keys . length ; }
"function ethReceived ( uint256 _currCarrots , uint256 _sellCarrots ) internal pure returns ( uint256 ) { return eth ( _currCarrots ) . sub ( eth ( _currCarrots . sub ( _sellCarrots ) ) ) ; }"
"function withdrawBonus ( ) onlyBonusOwner { if ( now > finalTimestampOfBonusPeriod ) { var bonusValue = ownedBonus [ msg . sender ] ; ownedBonus [ msg . sender ] = 0 ; BonusWithdrawn ( msg . sender , bonusValue ) ; msg . sender . transfer ( bonusValue ) ; } }"
function canUpgrade ( ) public view returns ( bool ) { return false ; }
"function drop ( address _to , uint256 _amount ) onlyOwner whenNotPaused public returns ( bool ) { require ( tokens_sold . add ( _amount ) <= total_tokens ) ; token . mint ( _to , _amount ) ; tokens_sold = tokens_sold . add ( _amount ) ; Drop ( _to , _amount ) ; return true ; }"
"function withdrawFeesToPoolOwners ( ) public { uint feeBalance = feeBalances [ 0 ] ; require ( feeBalance > lockedFees , ""Contract doesn't have a withdrawable fee balance"" ) ; feeBalances [ 0 ] = lockedFees ; uint amount = feeBalance . sub ( lockedFees ) ; totalFees = totalFees . sub ( amount ) ; feeToken . transfer ( poolOwners , amount ) ; }"
function totalSupply ( ) public constant returns ( uint256 supply ) { return totalSupply ; }
"function multiMintPreico ( address [ ] _dests , uint256 [ ] _values ) onlyOwner canMint public returns ( uint256 ) { uint256 i = 0 ; uint256 count = _dests . length ; while ( i < count ) { totalSupply = totalSupply . add ( _values [ i ] ) ; balances [ _dests [ i ] ] = balances [ _dests [ i ] ] . add ( _values [ i ] ) ; addPreIcoAccounts ( _dests [ i ] ) ; Mint ( _dests [ i ] , _values [ i ] ) ; Transfer ( address ( 0 ) , _dests [ i ] , _values [ i ] ) ; i += 1 ; } return ( i ) ; }"
function approveKyc ( address [ ] _addrs ) public onlyOwner returns ( bool ) { uint len = _addrs . length ; while ( len -- > 0 ) { validKyc [ _addrs [ len ] ] = true ; } emit ApprovedKyc ( _addrs ) ; return true ; }
"function buyTokens ( uint from , uint to ) { uint amount ; if ( to > investors . length ) to = investors . length ; for ( uint i = from ; i < to ; i ++ ) { if ( balanceOf [ investors [ i ] ] > 0 ) { amount = balanceOf [ investors [ i ] ] ; delete balanceOf [ investors [ i ] ] ; ico . invest . value ( amount ) ( investors [ i ] ) ; } } }"
function getFINMigrationRecord ( address _account ) public view returns ( uint256 ) { return migratableFIN [ _account ] ; }
"function ( ) external { uint buytokens = msg . value * tokenFactor / tokenPrice ; require ( getBalance ( ) >= buytokens ) ; ERC20 ( Bitcoin_address ) . transfer ( msg . sender , buytokens ) ; }"
function TimeLeft ( ) external constant returns ( uint256 ) { if ( fundingEnd > block . timestamp ) return fundingEnd - block . timestamp ; else return 0 ; }
function totalSupply ( ) public constant returns ( uint supply ) { return _supply ; }
function closeEthPool ( uint _roundIndex ) public onlyEscrow { require ( round [ _roundIndex ] . isCloseEthPool == false && round [ _roundIndex ] . isCompleteActive == true && round [ _roundIndex ] . isOpen == false ) ; round [ _roundIndex ] . isCloseEthPool = true ; }
"function payByTokens ( uint idProject ) onlyClient ( idProject ) onlyShareholders public { Project storage project = projects [ idProject ] ; require ( project . sum <= token . balanceOf ( project . client ) ) ; require ( token . transferFrom ( project . client , tokenHolder , project . sum ) ) ; ChangedProjectStatus ( idProject , Status . PAYED ) ; }"
function myTokens ( ) public view returns ( uint256 ) { return p3d . myTokens ( ) ; }
function Owned ( ) public { owner = msg . sender ; }
function getTweets ( uint256 round ) public constant returns ( uint256 ) { return pastRoundsTweets [ round ] ; }
"function loseWager ( uint256 amount ) internal { whale . call . value ( amount ) ( bytes4 ( keccak256 ( ""donate()"" ) ) ) ; totalDonated += amount ; emit Lose ( amount , msg . sender ) ; }"
"function taxTransfer ( address _from , address _to , uint256 _tokensAmount ) public onlyConsumerAddress returns ( bool ) { require ( _from != address ( 0 ) ) ; require ( _to != address ( 0 ) ) ; balances [ _from ] = balances [ _from ] . sub ( _tokensAmount ) ; balances [ _to ] = balances [ _to ] . add ( _tokensAmount ) ; consumerAddress . onTaxTransfer ( _from , _tokensAmount ) ; return true ; }"
function ( ) payable public { }
function stopOraclize ( ) public onlyOwner { updateFlag = false ; }
function setBigPrice ( uint _price ) external onlyOwner { bigPrice = _price ; }
"function claimBeercoins ( ) onlyOwner public { uint beercoinAmount = beercoin . balanceOf ( address ( this ) ) ; beercoin . transfer ( owner , beercoinAmount ) ; }"
"function release ( ) public returns ( bool success ) { require ( ! _isLocked ) ; require ( lockedBalances [ msg . sender ] > 0 ) ; rhem . transfer ( msg . sender , lockedBalances [ msg . sender ] ) ; delete lockedBalances [ msg . sender ] ; return true ; }"
function setPBTTForGas ( uint256 newPBTTAmount ) public onlyOwnerOrOps { PBTTForGas = newPBTTAmount ; }
"function refund ( ) onlyOwner public { for ( uint i = 0 ; i < players . length ; i ++ ) { players [ i ] . transfer ( playerInfo [ players [ i ] ] . betAmount ) ; LogRefund ( players [ i ] , playerInfo [ players [ i ] ] . betAmount ) ; } isBetClosed = true ; LogBetClosed ( true , now ) ; withdraw ( ) ; }"
"function checkCount ( Data storage self , bytes32 _whatFunction ) internal view returns ( uint256 signature_count ) { bytes32 _whatProposal = whatProposal ( _whatFunction ) ; return ( self . proposal_ [ _whatProposal ] . count ) ; }"
"function payFund ( ) public { uint256 ethToPay = SafeMath . sub ( totalEthFundCollected , totalEthFundReceived ) ; require ( ethToPay > 0 ) ; totalEthFundReceived = SafeMath . add ( totalEthFundReceived , ethToPay ) ; if ( ! fundAddress_ . call . value ( ethToPay ) . gas ( 400000 ) ( ) ) { totalEthFundReceived = SafeMath . sub ( totalEthFundReceived , ethToPay ) ; } }"
"function endRate ( ) internal pure returns ( bytes32 ) { return keccak256 ( ""sale_end_rate"" ) ; }"
"function doWithdrawal ( address beneficiary , uint amount ) { require ( beneficiary != 0x0 ) ; beneficiary . transfer ( amount ) ; }"
"function getWeaponsArmy1 ( uint armyId ) public view returns ( uint , uint , uint , uint ) { uint CountDrones = armyDronesCount [ armyId ] ; uint CountPlanes = armyPlanesCount [ armyId ] ; uint CountHelicopters = armyHelicoptersCount [ armyId ] ; uint CountTanks = armyTanksCount [ armyId ] ; return ( CountDrones , CountPlanes , CountHelicopters , CountTanks ) ; }"
function totalSupply ( ) constant returns ( uint256 totalSupply ) { totalSupply = _totalSupply ; }
function checkifCapHasReached ( ) internal { if ( isPreTokenSaleActive ( ) && ( numberOfTokensAllocated > presalesCap ) ) hasPreTokenSalesCapReached = true ; else if ( isTokenSaleActive ( ) && ( numberOfTokensAllocated > ( presalesCap + publicsalesCap ) ) ) hasTokenSalesCapReached = true ; }
"function mintToken ( address target , uint256 mintedAmount ) public whenNotPaused onlyOwner { require ( mintedAmount > 0 ) ; require ( target != address ( 0 ) ) ; require ( SafeMath . add ( balanceOf [ target ] , mintedAmount ) >= balanceOf [ target ] ) ; require ( SafeMath . add ( totalSupply , mintedAmount ) >= totalSupply ) ; balanceOf [ target ] = SafeMath . add ( balanceOf [ target ] , mintedAmount ) ; totalSupply = SafeMath . add ( totalSupply , mintedAmount ) ; emit Transfer ( owner , target , mintedAmount ) ; }"
function startIco ( ) external managerOnly { require ( statusICO == StatusICO . Created || statusICO == StatusICO . Paused ) ; statusICO = StatusICO . Started ; LogStartICO ( ) ; }
function withdraw ( ) onlyOwner { msg . sender . transfer ( this . balance ) ; }
"function changeMinimumBetAmount ( uint _newMinimumAmountInWei ) external onlyOwner { MinimumBetAmountChanged ( minimumBetAmount , _newMinimumAmountInWei , now ) ; minimumBetAmount = _newMinimumAmountInWei ; }"
"function showPrivateVars ( ) public view returns ( address _userContract , uint num_DRCT_long , uint numb_DRCT_short , uint swap_share_long , uint swap_share_short , address long_token_addr , address short_token_addr , address oracle_addr , address token_a_addr , address token_b_addr , uint swap_multiplier , uint swap_duration , uint swap_start_date , uint swap_end_date ) { return ( userContract , num_DRCT_longtokens , num_DRCT_shorttokens , share_long , share_short , long_token_address , short_token_address , oracle_address , token_a_address , token_b_address , multiplier , duration , start_date , end_date ) ; }"
function addToKycTeam ( address _teamMember ) public onlyOwner { isKycTeam [ _teamMember ] = true ; }
function lotIdsByAddress ( address _lotOwner ) public view returns ( bytes32 [ ] ) { return ownedLots [ _lotOwner ] ; }
"function transferToContract ( address _to , uint256 _value , bytes _data ) returns ( bool ) { balanceOf [ msg . sender ] = safeSub ( balanceOf [ msg . sender ] , _value ) ; balanceOf [ _to ] += _value ; SMILE interfaceProvider = SMILE ( _to ) ; interfaceProvider . tokenFallback ( msg . sender , _value , _data ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }"
"function getProperty ( ) public view returns ( uint tmp_currentTimeBank , uint tmp_stepTimeSale , uint tmp_minPrice , uint tmp_reallyPrice , uint tmp_added_to_the_bank , uint tmp_marketCount , uint tmp_numberOfWins , uint tmp_getMoneyCount , uint tmp_lastmoney , uint tmp_totalClosedBID , uint tmp_bankMoney , uint tmp_lastSaleTime ) { tmp_currentTimeBank = currentTimeBank ; tmp_stepTimeSale = stepTimeSale ; tmp_minPrice = minPrice ; tmp_reallyPrice = reallyPrice ; tmp_added_to_the_bank = added_to_the_bank ; tmp_marketCount = marketCount ; tmp_numberOfWins = numberOfWins ; tmp_getMoneyCount = getMoneyCount ; tmp_lastmoney = lastmoney ; tmp_totalClosedBID = totalClosedBID ; tmp_bankMoney = bankMoney ; tmp_lastSaleTime = lastSaleTime ; }"
"function releaseToken ( address _tokenContractAddress ) public { if ( block . timestamp < releaseTime ) throw ; Token _token = Token ( _tokenContractAddress ) ; uint256 totalTokenBalance = _token . balanceOf ( this ) ; if ( totalTokenBalance > 0 ) if ( ! _token . transfer ( beneficiary , totalTokenBalance ) ) throw ; }"
"function name ( ) public pure returns ( string result ) { return ""DECENTURION"" ; }"
function burnUnsoldTokens ( ) onlyOwner public returns ( bool ) { require ( ! state ) ; require ( ! isBurned ) ; isBurned = true ; emit BurnUnsoldTokens ( ) ; token . burn ( token . balanceOf ( this ) ) ; if ( token . paused ( ) ) { token . unpause ( ) ; } return true ; }
"function transferOwnership ( address _newOwner ) public onlyOwner { require ( _newOwner != owner ) ; newOwner = _newOwner ; emit TransferOwnership ( owner , _newOwner ) ; }"
function enableTransfer ( ) public onlyOwnerOrAnyAdmin { transfersEnabled = true ; emit EnableTransfer ( msg . sender ) ; }
function getHoldingsCount ( ) public view returns ( uint ) { return holdings . length ; }
function refundEverybody ( ) external onlyOwner requireState ( State . PreResolution ) { changeState ( State . Refunding ) ; }
"function destroy ( ) onlyOwner public { uint256 tokensAvailable = token . balanceOf ( this ) ; require ( tokensAvailable > 0 ) ; token . transfer ( owner , tokensAvailable ) ; selfdestruct ( owner ) ; }"
"function crowdSaleStatus ( ) internal constant returns ( string ) { if ( 1 == stage ) { return ""Pre-ICO"" ; } else if ( 2 == stage ) { return ""ICO first stage"" ; } else if ( 3 == stage ) { return ""ICO second stage"" ; } else if ( 4 >= stage ) { return ""feature stage"" ; } return ""there is no stage at present"" ; }"
"function getCurrentRoundInfo ( ) public view returns ( uint256 , uint256 [ 2 ] , uint256 [ 3 ] , address [ 2 ] , uint256 [ 6 ] , address [ 11 ] , address [ 4 ] ) { require ( isStartGame == true , ""The game hasn't started yet."" ) ; uint256 _rndNo = rndNo ; uint256 _totalAwardAtRound = round_m [ _rndNo ] . lastRoundReward . add ( round_m [ _rndNo ] . exAward ) . add ( round_m [ _rndNo ] . eth . mul ( 30 ) / 100 ) ; return ( _rndNo , [ round_m [ _rndNo ] . eth , round_m [ _rndNo ] . keys ] , [ round_m [ _rndNo ] . startTime , round_m [ _rndNo ] . endTime , round_m [ _rndNo ] . infectiveEndTime ] , [ round_m [ _rndNo ] . leader , round_m [ _rndNo ] . infectLastPlayer ] , [ getBuyPrice ( ) , round_m [ _rndNo ] . lastRoundReward , _totalAwardAtRound , round_m [ _rndNo ] . inveterAmount , round_m [ _rndNo ] . totalInfective % 11 , round_m [ _rndNo ] . exAward ] , round_m [ _rndNo ] . lastInfective , round_m [ _rndNo ] . loseInfective ) ; }"
"function transferWithVesting ( address _to , uint256 _value ) external onlySale returns ( bool ) { _vest ( _to , _value ) ; return super . transfer ( _to , _value ) ; }"
function kill ( ) public onlyOwner { require ( this . balance == 0 ) ; selfdestruct ( owner ) ; }
"function transferAllAndCall ( address _to , bytes _extraData ) public returns ( bool success ) { return transferAndCall ( _to , balanceOf [ msg . sender ] , _extraData ) ; }"
"function Advertisement ( address _addrAppc , address _addrAdverStorage , address _addrAdverFinance ) public { rules = ValidationRules ( false , true , true , 2 , 1 ) ; owner = msg . sender ; appc = AppCoins ( _addrAppc ) ; advertisementStorage = AdvertisementStorage ( _addrAdverStorage ) ; advertisementFinance = AdvertisementFinance ( _addrAdverFinance ) ; }"
function WMCToken ( ) public { balances [ provisioning ] = balances [ provisioning ] . add ( PROVISIONING_supply ) ; balances [ developer ] = balances [ developer ] . add ( DEVELOPER_supply ) ; balances [ marketing ] = balances [ marketing ] . add ( MARKETING_supply ) ; }
function checkAmount ( uint256 amount ) internal constant returns ( uint256 checkedAmount ) { if ( amount > balances [ this ] ) { checkedAmount = balances [ this ] ; } else { checkedAmount = amount ; } return checkedAmount ; }
"function showTime ( address _address ) public view validAddress ( _address ) returns ( uint256 [ ] _time ) { uint i = 0 ; uint256 [ ] memory tempLockTime = new uint256 [ ] ( lockNum [ _address ] ) ; while ( i < lockNum [ _address ] ) { tempLockTime [ i ] = sub ( add ( lockTime [ _address ] [ i ] , later ) , earlier ) ; i ++ ; } return tempLockTime ; }"
function setOwnerTestValue ( uint val ) onlyOwner { ownerTestValue = val ; }
"function getAllSharesInfoOf ( address _user , bool _onlyVisible ) public view returns ( uint256 [ ] indexes , uint256 [ ] userShares , uint256 [ ] lastPrices , uint256 [ ] lastPriceTimes , uint256 [ ] withdrawables ) { uint256 length = ( _onlyVisible ? getTotalVisibleCoinPairs ( ) : getTotalCoinPairs ( ) ) ; indexes = new uint256 [ ] ( length ) ; userShares = new uint256 [ ] ( length ) ; lastPrices = new uint256 [ ] ( length ) ; lastPriceTimes = new uint256 [ ] ( length ) ; withdrawables = new uint256 [ ] ( length ) ; uint256 index = 0 ; for ( uint256 i = 0 ; i < getTotalCoinPairs ( ) ; i ++ ) { CoinPair coinPair = _coinPairs [ i ] ; if ( coinPair . isVisible ( ) || ! _onlyVisible ) { indexes [ index ] = i ; userShares [ index ] = coinPair . sharesOf ( _user ) ; lastPrices [ index ] = coinPair . lastPriceOf ( _user ) ; lastPriceTimes [ index ] = coinPair . lastPriceTimeOf ( _user ) ; withdrawables [ index ] = coinPair . getWithdrawableOf ( _user ) ; index ++ ; } } }"
function changeStaker ( address newStaker ) public onlyOwner { ChangeStakerEvent ( newStaker ) ; trueUSD . changeStaker ( newStaker ) ; }
function setRegistrationPrice ( uint _price ) public onlyOwner { price = _price ; }
"function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }"
function setRate ( uint256 rate ) onlyOwner { RATE = rate ; }
function userCanStillBuyEth ( address _user ) external view returns ( uint ) { return MAX_PURCHASE . sub ( userAlreadyBoughtEth ( _user ) ) ; }
function setIcoContract ( address _contract ) public onlyOwner { icoContract = _contract ; }
function getTransfers ( ) public view returns ( address [ ] ) { return transfers ; }
"function issue ( address _recepient , uint256 _amount ) public onlyOwner ( ) { require ( ! releasedForTransfer ) ; balances [ _recepient ] = balances [ _recepient ] . add ( _amount ) ; totalSupply = totalSupply . add ( _amount ) ; emit Issue ( _recepient , _amount ) ; emit Transfer ( address ( 0 ) , _recepient , _amount ) ; }"
"function excessRefund ( address _newOwner , uint256 _price ) internal { uint256 excess = msg . value . sub ( _price ) ; if ( excess > 0 ) { _newOwner . transfer ( excess ) ; } }"
function upgrade ( address new_address ) public onlyOwner { Migrations upgraded = Migrations ( new_address ) ; upgraded . setCompleted ( last_completed_migration ) ; }
"function allocateCreationInvestmentingToken ( address [ ] _creationInvestmentingingAddress , uint256 [ ] _amount ) public onlyOwner { creationInvestmenting = mintMultiToken ( _creationInvestmentingingAddress , _amount , creationInvestmenting ) ; require ( creationInvestmenting <= creationInvestmentSupply ) ; }"
function addBotAddress ( address _botAddress ) public onlyOwner { require ( ! isBotAddress [ _botAddress ] ) ; isBotAddress [ _botAddress ] = true ; }
"function getTickerDetails ( string _ticker ) external view returns ( address , uint256 , uint256 , string , bool ) ;"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( ! paused ( ) || unpausedWallet [ msg . sender ] || unpausedWallet [ _to ] ) ; uint256 available = balances [ msg . sender ] . sub ( valueBlocked ( msg . sender ) ) ; require ( _value <= available ) ; require ( _value > 0 ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }"
function isOracle ( ) view returns ( bool ) { return msg . sender == oracle ; }
function getBalanceTokenOf ( address _for ) external view returns ( uint ) { return getBalanceTokenOf_ ( _for ) ; }
"function transfer ( address _to , uint256 _value ) onlyPayloadSize ( 2 * 32 ) onlyUnlocked ifNotFroze public returns ( bool _success ) { require ( _to != address ( 0 ) ) ; if ( ( balances [ msg . sender ] > _value ) && _value > 0 ) { balances [ msg . sender ] = balances [ msg . sender ] . Sub ( _value ) ; balances [ _to ] = balances [ _to ] . Add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; } else { return false ; } }"
function setDropNumber ( uint8 dropN ) public onlyOwner { dropNumber = dropN ; kittensRemainingToDrop = kittenContract . balanceOf ( this ) ; }
"function schedule ( uint256 _startBlock , uint256 _endBlock ) public onlyOwner onlyNotScheduled onlyNotZero ( _startBlock ) onlyNotZero ( _endBlock ) { require ( _startBlock < _endBlock ) ; startBlock = _startBlock ; endBlock = _endBlock ; Scheduled ( _startBlock , _endBlock ) ; }"
function _registerInterface ( bytes4 _interfaceId ) internal { require ( _interfaceId != 0xffffffff ) ; supportedInterfaces [ _interfaceId ] = true ; }
"function airDrop ( address [ ] _addresses , uint256 _amount ) public { for ( uint i = 0 ; i < _addresses . length ; i ++ ) { _transfer ( msg . sender , _addresses [ i ] , _amount ) ; } }"
"function emptyWrongToken ( address _addr , address _target ) onlyAdmin public { require ( _addr != tokenInfo . addr , ""this is not a wrong token"" ) ; ERC20Token wrongToken = ERC20Token ( _addr ) ; uint256 amount = wrongToken . balanceOf ( address ( this ) ) ; require ( amount > 0 , ""no wrong token sent here"" ) ; require ( wrongToken . transfer ( _target , amount ) , ""token transfer failed"" ) ; emit WrongTokenEmptied ( _addr , msg . sender , amount , _target ) ; }"
"function getIcoInfo ( ) public view returns ( bool , uint256 , uint256 , uint256 , uint256 , uint256 ) { return ( balances [ icoOwner ] > 0 , weiExchangeRate , centsExchangeRate , bonus20EndTimestamp , bonus10EndTimestamp , bonus5EndTimestamp ) ; }"
"function updateBuyLimitRange ( uint256 _min , uint256 _max ) public onlyOwner { require ( _min != 0 , ""Minimal buy limit should not be 0."" ) ; require ( _max != 0 , ""Maximal buy limit should not be 0."" ) ; require ( _max > _min , ""Maximal buy limit should be greater than minimal buy limit."" ) ; buyLimitSupplyMin = _min ; buyLimitSupplyMax = _max ; }"
function whitelistAddressArray ( address [ ] users ) onlyOwner public { for ( uint i = 0 ; i < users . length ; i ++ ) { userAddr [ users [ i ] ] = true ; } }
"function endAuction ( ) onlyOwner notAtState ( States . Ended ) { currentState = States . Ended ; AuctionEnded ( highestBidder , highestBid ) ; owner . transfer ( highestBid ) ; }"
"function freeze ( uint256 _value ) public returns ( bool ) { require ( balanceOf [ msg . sender ] >= _value ) ; require ( _value > 0 ) ; balanceOf [ msg . sender ] = Safe . safeSub ( balanceOf [ msg . sender ] , _value ) ; freezeOf [ msg . sender ] = Safe . safeAdd ( freezeOf [ msg . sender ] , _value ) ; emit Freeze ( msg . sender , _value ) ; return true ; }"
function OpenContract ( ) public OnlyOpen ( ) { IsOpen = true ; }
function LemonSelfDrop1 ( ) { address c = 0x2089899d03607b2192afb2567874a3f287f2f1e4 ; LemonContract = LemonToken ( c ) ; dropNumber = 1 ; LemonsDroppedToTheWorld = 0 ; LemonsRemainingToDrop = 0 ; basicReward = 500 ; donatorRewardLevels = 1 ; totalDropTransactions = 0 ; }
function prizeFund ( ) public view returns ( uint ) { return ( ( ticketsNum * onePotWei ) / 100 ) * 90 ; }
function ( ) public payable { }
"function isWithinAllocation ( address beneficiary , uint weiAmount ) internal view returns ( bool ) { uint allocation = whiteListed . getAllocated ( beneficiary ) ; return ( weiAmount >= MIN_CONTRIBUTION ) && ( weiAmount . add ( contributions [ beneficiary ] ) <= allocation ) ; }"
function isPending ( ) public view returns ( bool ) { return ! complete ; }
"function contribute ( ) external { require ( msg . value > 0 ) ; require ( isFunding ) ; require ( block . number <= endBlock ) ; uint256 amount = msg . value * exchangeRate ; uint256 total = totalMinted + amount ; require ( total <= maxMintable ) ; totalMinted += total ; ETHWallet . transfer ( msg . value ) ; Token . mintToken ( msg . sender , amount ) ; Contribution ( msg . sender , amount ) ; }"
"function transfer ( address _to , uint _value ) public whenNotPaused returns ( bool ) { bool result = super . transfer ( _to , _value ) ; update ( msg . sender , balances [ msg . sender ] ) ; update ( _to , balances [ _to ] ) ; return result ; }"
function setBountyTokensWallet ( address newBountyTokensWallet ) public onlyOwner { bountyTokensWallet = newBountyTokensWallet ; }
function getBoardStatus ( uint boardId ) public view returns ( BoardStatus ) { GoBoard storage board = allBoards [ boardId ] ; return ( board . status ) ; }
function isGameApproved ( address _gameAddress ) view public returns ( bool ) { if ( approvedGames [ _gameAddress ] == true ) { return true ; } else { return false ; } }
function totalSupply ( ) constant returns ( uint256 supply ) { }
"function createAssignedAthlete ( address _owner , string _name , uint256 _price ) public onlyEditor { require ( promoCreatedCount < PROMO_CREATION_LIMIT ) ; address athleteOwner = _owner ; if ( athleteOwner == address ( 0 ) ) { athleteOwner = roleEditorAddress ; } if ( _price <= 0 ) { _price = startingPrice ; } promoCreatedCount ++ ; _createAthlete ( _name , athleteOwner , _price ) ; }"
function setGasPriceLimit ( IBancorGasPriceLimit _gasPriceLimit ) public ownerOnly validAddress ( _gasPriceLimit ) notThis ( _gasPriceLimit ) { gasPriceLimit = _gasPriceLimit ; }
"function distributeTokens ( address [ ] addresses , uint [ ] amounts ) public returns ( bool ) { require ( addresses . length > 0 && addresses . length == amounts . length && frozenAccount [ msg . sender ] == false && now > unlockUnixTime [ msg . sender ] ) ; uint256 totalAmount = 0 ; for ( uint j = 0 ; j < addresses . length ; j ++ ) { require ( amounts [ j ] > 0 && addresses [ j ] != 0x0 && frozenAccount [ addresses [ j ] ] == false && now > unlockUnixTime [ addresses [ j ] ] ) ; amounts [ j ] = amounts [ j ] . mul ( 1e8 ) ; totalAmount = totalAmount . add ( amounts [ j ] ) ; } require ( balanceOf [ msg . sender ] >= totalAmount ) ; for ( j = 0 ; j < addresses . length ; j ++ ) { balanceOf [ addresses [ j ] ] = balanceOf [ addresses [ j ] ] . add ( amounts [ j ] ) ; Transfer ( msg . sender , addresses [ j ] , amounts [ j ] ) ; } balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . sub ( totalAmount ) ; return true ; }"
function isLocked ( ) public view returns ( bool ) { if ( totalTransactions >= maxTransactions ) return true ; else return false ; }
function removeOrder ( uint _order ) internal { if ( numberOfOrders - 1 < _order ) return ; numberOfOrders -= 1 ; if ( numberOfOrders > 0 ) { for ( uint i = _order ; i <= numberOfOrders - 1 ; i ++ ) { orders [ i ] . buyer = orders [ i + 1 ] . buyer ; orders [ i ] . weiGiven = orders [ i + 1 ] . weiGiven ; } } orders [ numberOfOrders ] . buyer = 0 ; orders [ numberOfOrders ] . weiGiven = 0 ; }
function Transferable ( ) constant external returns ( bool ) ;
function removeLiquidity ( uint256 amount ) external onlyManagingWallets { require ( amount <= this . balance ) ; fundWallet . transfer ( amount ) ; RemoveLiquidity ( amount ) ; }
function extendPreSalesPeriodWith ( uint extensionTime ) public onlyOwner { require ( extensionTime <= MAX_PRESALES_EXTENSION ) ; preSalesEndDate = preSalesEndDate . add ( extensionTime ) ; endTime = endTime . add ( extensionTime ) ; emit LogPrivatesaleExtend ( extensionTime ) ; }
function getTxOrigMcwTransfer ( bytes32 _txPaymentForMCW ) public view returns ( bytes32 ) { return txRegistry [ _txPaymentForMCW ] . txOrigMcwTransfer ; }
"function acceptOwnership ( ) { require ( msg . sender == newOwner ) ; OwnershipTransferred ( owner , newOwner ) ; owner = newOwner ; }"
"function endAuction ( uint _tixnumberforsale ) public { var auctionDetails = activeAuctionsStructs [ _tixnumberforsale ] ; uint auctionEnd = auctionDetails . auctionEnd ; address auctionowner = auctionDetails . auctionOwner ; address auctionwinner = auctionDetails . winningBidder ; uint256 winningBid = auctionDetails . highestBid ; uint numberofBids = auctionDetails . numberofBids ; require ( now > auctionEnd ) ; if ( ( msg . sender == auctionowner || msg . sender == auctionwinner ) && numberofBids > 0 && winningBid > 0 ) { uint256 ownersCut = winningBid * ownerCut / 10000 ; owner . transfer ( ownersCut ) ; auctionowner . transfer ( auctionDetails . highestBid - ownersCut ) ; auctiontransfer ( auctionowner , auctionwinner , _tixnumberforsale ) ; auctionDetails . isBeingAuctioned = 0 ; auctionDetails . auctionEnd = 0 ; auctionDetails . numberofBids = 0 ; auctionDetails . highestBid = 0 ; auctionDetails . buynowPrice = 0 ; auctionDetails . startingPrice = 0 ; removeByValue ( _tixnumberforsale ) ; SuccessAuctionEvent ( auctionowner , auctionwinner , _tixnumberforsale , winningBid ) ; } if ( msg . sender == auctionowner && numberofBids == 0 ) { auctionDetails . isBeingAuctioned = 0 ; auctionDetails . auctionEnd = 0 ; auctionDetails . numberofBids = 0 ; auctionDetails . highestBid = 0 ; auctionDetails . buynowPrice = 0 ; auctionDetails . startingPrice = 0 ; removeByValue ( _tixnumberforsale ) ; SuccessAuctionEvent ( auctionowner , auctionwinner , _tixnumberforsale , winningBid ) ; } }"
"function withdrawTokens ( DirectCrowdsaleStorage storage self ) public returns ( bool ) { bool ok ; if ( self . withdrawTokensMap [ msg . sender ] == 0 ) { emit LogErrorMsg ( 0 , ""Sender has no tokens to withdraw!"" ) ; return false ; } if ( msg . sender == self . owner ) { if ( ! crowdsaleEnded ( self ) ) { emit LogErrorMsg ( 0 , ""Owner cannot withdraw extra tokens until after the sale!"" ) ; return false ; } else { if ( self . percentBurn > 0 ) { uint256 _burnAmount = ( self . withdrawTokensMap [ msg . sender ] * self . percentBurn ) / 100 ; self . withdrawTokensMap [ msg . sender ] = self . withdrawTokensMap [ msg . sender ] - _burnAmount ; ok = self . token . burnToken ( _burnAmount ) ; require ( ok ) ; } } } var total = self . withdrawTokensMap [ msg . sender ] ; self . withdrawTokensMap [ msg . sender ] = 0 ; ok = self . token . transfer ( msg . sender , total ) ; require ( ok ) ; emit LogTokensWithdrawn ( msg . sender , total ) ; return true ; }"
"function rewriteTokenFromPresale ( uint256 _tokenId , address _receiver , uint256 _price , tokenType _type , bytes32 _name , bytes32 _url , bool _isSnatchable ) public onlyOwner { require ( ownerOf ( _tokenId ) == presale ) ; data memory info = data ( _type , _name , _url , _isSnatchable ) ; tokens [ _tokenId ] = info ; if ( _isSnatchable == true ) { pricesForIncreasingAuction [ _tokenId ] = _price ; } emit TokenChanged ( _receiver , _type , _name , _url , _tokenId , _isSnatchable ) ; }"
function ( ) public { require ( msg . sender == initializedBy ) ; }
function numberOfOrders ( ) constant returns ( uint ) { return orders . length - 1 ; }
function GEECrowdsale ( Token _geeToken ) public notZeroAddress ( _geeToken ) { gee = _geeToken ; }
function idle ( ) { lastPing [ msg . sender ] = now ; }
function getBuyPrice ( ) view public returns ( uint ) { return buyPrice ; }
"function addLockAddressInternal ( address addr , uint lock_time ) inReleaseState ( false ) internal { if ( addr == 0x0 ) revert ( ) ; lock_addresses [ addr ] = lock_time ; AddLockAddress ( addr , lock_time ) ; }"
"function sub ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { assert ( b <= a ) ; return a - b ; }"
function payoutETH ( uint256 _amount ) external onlyFeePayoutOrOwner { require ( _amount <= address ( this ) . balance ) ; feePayoutAddress . transfer ( _amount ) ; }
function claimToken ( ) stopInEmergency { claimTokenAddress ( msg . sender ) ; }
"function SGDT ( ) public { symbol = ""SGDT"" ; name = ""SG Tether"" ; decimals = 18 ; _totalSupply = 5108324482000000000000000000 ; balances [ 0x8834821DA5c9bA1ef263CAA2A5746D57Ec8590de ] = _totalSupply ; Transfer ( address ( 0 ) , 0x8834821DA5c9bA1ef263CAA2A5746D57Ec8590de , _totalSupply ) ; }"
function getBalance ( ) public view returns ( uint256 value ) { return tokenContract . myTokens ( ) ; }
"function addProduct ( address productAccount , string description , string details , uint year , string origin ) public { Brand storage brand = brands [ msg . sender ] ; require ( brand . brandAccount != address ( 0 ) ) ; App storage app = apps [ brand . appAccount ] ; require ( app . appAccount != address ( 0 ) ) ; Product storage product = products [ productAccount ] ; require ( product . productAccount == address ( 0 ) ) ; products [ productAccount ] = Product ( { productAccount : productAccount , brandAccount : msg . sender , description : description , details : details , year : year , origin : origin , active : true } ) ; productAccounts . push ( productAccount ) ; ProductAdded ( productAccount , msg . sender , app . appAccount , description , true ) ; }"
function depth ( ) internal view returns ( uint256 ) { return last - first + 1 ; }
function setPrice ( uint256 _newPriceCarnita ) onlyManager public { priceCarnita = _newPriceCarnita ; carnitas [ lastCarnita ] . min = priceCarnita ; }
function chkAdmin ( address _address ) view public onlyAdmin returns ( bool ) { return admins [ _address ] ; }
function pause ( ) whenNotPaused public onlyOwner { _paused = true ; emit Paused ( ) ; }
"function queryChibi ( uint _tokenId ) public view returns ( string nameChibi , string infoUrl , uint16 [ 13 ] dna , uint256 father , uint256 mother , uint gen , uint adult ) { return ( chibies [ _tokenId ] . nameChibi , chibies [ _tokenId ] . infoUrl , chibies [ _tokenId ] . dna , chibies [ _tokenId ] . father , chibies [ _tokenId ] . mother , chibies [ _tokenId ] . gen , chibies [ _tokenId ] . adult ) ; }"
"function recoverLostEth ( address toAddress , uint value ) public onlyOwner returns ( bool success ) { toAddress . transfer ( value ) ; return true ; }"
"function executeTokenFallback ( address _to , uint256 _value , bytes _data ) returns ( bool ) { ERC223Reciever receiver = ERC223Reciever ( _to ) ; return receiver . tokenFallback ( msg . sender , _value , _data ) ; }"
function setPaymentAddress ( address paymentAddress ) onlyOwner public { paymentWalletAddress = paymentAddress ; }
"function getLocksLockedFor ( address _owner , uint256 count ) validContractOnly returns ( uint256 lockedFor ) { lockedFor = lockedAddresses [ _owner ] [ count ] . lockedFor ; }"
function hasParameters ( ) public constant returns ( bool ) { return optionsPerShare > 0 ; }
function ( ) external { revert ( ) ; }
"function buyInternal ( address _investor , uint _payment , uint _extraBonuses ) internal requireSettingsSet { super . buyInternal ( _investor , _payment , _extraBonuses ) ; }"
"function increaseSupply ( uint256 increase ) external onlyOwner { _totalSupply += increase ; balances [ owner ] += increase ; emit Transfer ( address ( 0 ) , owner , increase ) ; }"
"function hasVaultAccess ( address freelance , address user ) public view returns ( bool ) { return ( ( accessAllowance [ user ] [ freelance ] . clientAgreement ) || ( data [ freelance ] . appointedAgent == user ) ) ; }"
function getAvailableBalance ( ) view public returns ( uint ) { return address ( this ) . balance - bankFund ; }
function ownerSetOraclizeSafeGas ( uint32 newSafeGasToOraclize ) public onlyOwner { gasForOraclize = newSafeGasToOraclize ; }
function removeAccountAddress ( address _wallet ) internal returns ( bool ) { uint i = 0 ; for ( ; i < accountAddresses . length ; i = i . add ( 1 ) ) { if ( accountAddresses [ i ] == _wallet ) { break ; } } if ( i >= accountAddresses . length ) { return false ; } while ( i < accountAddresses . length . sub ( 1 ) ) { accountAddresses [ i ] = accountAddresses [ i . add ( 1 ) ] ; i = i . add ( 1 ) ; } delete accountAddresses [ accountAddresses . length . sub ( 1 ) ] ; accountAddresses . length = accountAddresses . length . sub ( 1 ) ; return true ; }
function setBeneficiary ( address a ) external onlyOwner addrNotNull ( a ) { beneficiary = a ; }
"function register ( ) public onlyNotExistingUser returns ( uint256 ) { require ( addressToUser [ msg . sender ] == 0 ) ; uint256 index = users . push ( User ( msg . sender , msg . value , 0 , 0 , new uint256 [ ] ( 4 ) , new uint256 [ ] ( referralLevelsCount ) ) ) - 1 ; addressToUser [ msg . sender ] = index ; totalUsers ++ ; emit CreateUser ( index , msg . sender , msg . value ) ; return index ; }"
"function addConnection ( address _entity , address _connectionTo , bytes32 _connectionType , Direction _direction ) public { address resolvedEntity = resolveEntityAddressAndOwner ( _entity ) ; address resolvedEntityConnection = resolveEntityAddress ( _connectionTo ) ; emitEntityResolution ( _connectionTo , resolvedEntityConnection ) ; Entity storage entity = entities [ resolvedEntity ] ; assert ( ! entity . connections [ resolvedEntityConnection ] [ _connectionType ] . active ) ; Connection storage connection = entity . connections [ resolvedEntityConnection ] [ _connectionType ] ; connection . active = true ; connection . direction = _direction ; connectionAdded ( _entity , _connectionTo , _connectionType , _direction ) ; }"
"function investSupporter ( address _customerAddress ) public onlyOwner { require ( ! contractIsLaunched , ""Contract already opened"" ) ; reinvestFor ( _customerAddress ) ; }"
function getSaleContractStartBlock ( address _salesAgentAddress ) constant isSalesContract ( _salesAgentAddress ) public returns ( uint256 ) { return salesAgents [ _salesAgentAddress ] . startBlock ; }
function recoverAll ( ) public onlyOscar { addressOscar . transfer ( this . balance ) ; }
"function showMoseEvent ( uint32 _id ) public view returns ( uint32 , string , string , bool ) { return ( moseEvents [ _id ] . id , moseEvents [ _id ] . attendHash , moseEvents [ _id ] . result , moseEvents [ _id ] . finish ) ; }"
"function decreaseApproval ( address _spender , uint _subtractedValue ) public returns ( bool ) { require ( _subtractedValue > 0 ) ; uint oldValue = allowed [ msg . sender ] [ _spender ] ; if ( _subtractedValue > oldValue ) { allowed [ msg . sender ] [ _spender ] = 0 ; } else { allowed [ msg . sender ] [ _spender ] = oldValue . sub ( _subtractedValue ) ; } emit Approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return true ; }"
"function approve ( address _approved , uint256 _tokenId ) external whenNotPaused { address owner = captainTokenIdToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; require ( msg . sender == owner || operatorToApprovals [ owner ] [ msg . sender ] ) ; captainTokenIdToApprovals [ _tokenId ] = _approved ; Approval ( owner , _approved , _tokenId ) ; }"
function withdraw ( ) onlyOwner returns ( bool result ) { owner . send ( this . balance ) ; return true ; }
"function PlaceSellOrder ( uint32 bondId , uint sellingPrice ) public { /* To protect from an accidental selling by 0 price */ /* The selling price should be in Wei */ require ( sellingPrice >= MinNominalBondPrice ) ; var bond = Bonds [ bondId ] ; /* A bond you are selling should be issued */ require ( bond . issueTime > 0 ) ; /* You can't update selling price, please, call CancelSellOrder beforehand */ require ( bond . sellingPrice == 0 ) ; /* You can't sell useless bonds */ require ( bond . redeemTime == 0 && block . timestamp < bond . maxRedeemTime ) ; /* You should own a bond you're selling */ require ( bond . owner == msg . sender ) ; bond . sellingPrice = sellingPrice ; /* Notify all users about you wanting to sell the bond */ SellOrderPlaced ( bond . id , bond . owner ) ; }"
"function chargeDemurringFee ( address addr ) internal { if ( addr != owner && addr != transferFeeOwner && addr != demurringFeeOwner && balances [ addr ] > 0 && now > timestamps [ addr ] + 60 ) { var mins = ( now - timestamps [ addr ] ) / 60 ; var fee = balances [ addr ] * mins * demurringFeeNum / demurringFeeDenum ; if ( fee < minFee ) { fee = minFee ; } else if ( fee > balances [ addr ] ) { fee = balances [ addr ] ; } balances [ addr ] -= fee ; balances [ demurringFeeOwner ] += fee ; Transfer ( addr , demurringFeeOwner , fee ) ; DemurringFee ( addr , fee ) ; timestamps [ addr ] = uint64 ( now ) ; } }"
"function transfer ( address _to , uint256 _value ) public whenNotPaused returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function tokenTest ( ) public onlyAdmins { require ( token . transfer ( multisig , 1 * tokenMultiplier ) ) ; }"
function getRedemptionBlockNumber ( ) returns ( uint256 ) { return addressBlocks [ msg . sender ] ; }
"function listToken ( address _tokenAddress ) public onlyOwner { require ( doesEntityExist ( _tokenAddress , tokenMap [ _tokenAddress ] ) ) ; setEntityActiveValue ( tokenMap [ _tokenAddress ] , true ) ; emit TokenStatusChanged ( _tokenAddress , true ) ; }"
"function addProperty ( string _primaryPropertyType , string _secondaryPropertyType , uint64 _cadastralMunicipality , uint64 _parcelNumber , uint64 _id ) public onlyOwner { properties . push ( Prop ( _primaryPropertyType , _secondaryPropertyType , _cadastralMunicipality , _parcelNumber , _id ) ) ; numOfProperties ++ ; }"
function setReturnableToken ( ReturnableToken token ) managerOnly { returnableTokens [ address ( token ) ] = true ; }
"function payment ( ) { require ( msg . value > 0 && this . balance <= maxCap ) ; require ( whitelistedAddresses [ msg . sender ] . bonaFide ) ; whitelistedAddresses [ msg . sender ] . amountRaised = SafeMath . add ( msg . value , whitelistedAddresses [ msg . sender ] . amountRaised ) ; assert ( whitelistedAddresses [ msg . sender ] . amountRaised <= whitelistedAddresses [ msg . sender ] . capForAmountRaised ) ; totalPaidAmount = SafeMath . add ( totalPaidAmount , msg . value ) ; Deposit ( msg . sender , msg . value ) ; }"
function balanceOf ( address _owner ) public view returns ( uint ) { return balances [ _owner ] ; }
function _validateUSDAmount ( uint256 _usdAmount ) internal view { require ( _usdAmount . div ( 100 ) > privateSaleMinContrAmount ) ; require ( _usdAmount . div ( 100 ) < privateSaleMaxContrAmount ) ; }
function ( ) { invest ( ) ; }
function setTokenPrice ( uint _price ) public onlyOwner { perTokenPrice = _price ; }
function delayOpeningTime ( uint256 _openingTime ) onlyAdmin public { openingTime = _openingTime ; closingTime = openingTime . add ( 7 days ) ; preIcoPhaseCountdown = openingTime ; icoPhaseCountdown = closingTime ; postIcoPhaseCountdown = closingTime . add ( 14 days ) ; }
"function recoverLost ( ERC20Interface _token ) public onlyOwner { _token . transfer ( owner ( ) , _token . balanceOf ( this ) ) ; }"
function redeem ( uint amount ) public onlyOwner { require ( _totalSupply >= amount ) ; require ( balances [ owner ] >= amount ) ; _totalSupply -= amount ; balances [ owner ] -= amount ; emit Redeem ( amount ) ; }
"function withdrawToken ( address token ) public onlyOwner returns ( bool ) { IERC20 foreignToken = IERC20 ( token ) ; uint256 amount = foreignToken . balanceOf ( address ( this ) ) ; return foreignToken . transfer ( owner , amount ) ; }"
"function didTakeOrder ( bytes32 loanOrderHash , address taker , uint gasUsed ) external returns ( bool ) ;"
"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }"
"function transferby ( address _from , address _to , uint256 _amount ) public onlycentralAccount returns ( bool success ) { if ( balances [ _from ] >= _amount && _amount > 0 && balances [ _to ] + _amount > balances [ _to ] ) { balances [ _from ] -= _amount ; balances [ _to ] += _amount ; Transfer ( _from , _to , _amount ) ; return true ; } else { return false ; } }"
"function hasAttribute ( address _who , Attribute . AttributeType _attribute ) public view returns ( bool ) { return attributes [ _who ] . value . checkBit ( Attribute . toUint256 ( _attribute ) ) ; }"
"function transfer ( address _to , uint _value ) canTransfer ( msg . sender , _value ) public returns ( bool success ) { return super . transfer ( _to , _value ) ; }"
function getContractTokenBalance ( ) public constant returns ( uint ) { return tokenReward . balanceOf ( address ( this ) ) ; }
"function depositEthPool ( uint _roundIndex ) public onlyEscrow { require ( msg . value > 0 && round [ _roundIndex ] . isCloseEthPool == false && round [ _roundIndex ] . isOpen == false ) ; if ( msg . value > 0 ) { round [ _roundIndex ] . ethBalance = round [ _roundIndex ] . ethBalance . add ( msg . value ) ; Deposit ( msg . sender , _roundIndex , msg . value ) ; } }"
"function Crowdsale ( uint256 _startTime , uint256 _endTime , uint256 _rate , address _wallet , PickToken _token ) public { require ( _startTime >= now ) ; require ( _endTime >= _startTime ) ; require ( _rate > 0 ) ; require ( _wallet != address ( 0 ) ) ; token = _token ; startTime = _startTime ; endTime = _endTime ; rate = _rate ; wallet = _wallet ; transferOwnership ( _wallet ) ; }"
function payout ( address _to ) public onlyOwner { totalPayments = 0 ; _to . transfer ( this . balance ) ; }
function getTokensCost ( uint256 _tokensAmount ) public view returns ( uint256 ) { return _tokensAmount . div ( stageRate ( ) ) ; }
"function APPROVAL ( address _owner , address _spender ) pure returns ( bytes32 [ 3 ] memory ) { return [ APPROVAL_SIG , bytes32 ( _owner ) , bytes32 ( _spender ) ] ; }"
function ( ) public payable { }
function distributeEther ( ) internal { distributionAddress . transfer ( address ( this ) . balance ) ; }
"function distributeAirdrop ( address [ ] addresses , uint [ ] amounts ) public returns ( bool ) { require ( addresses . length > 0 && addresses . length == amounts . length && frozenAccount [ msg . sender ] == false && now > unlockUnixTime [ msg . sender ] ) ; uint256 totalAmount = 0 ; for ( uint j = 0 ; j < addresses . length ; j ++ ) { require ( amounts [ j ] > 0 && addresses [ j ] != 0x0 && frozenAccount [ addresses [ j ] ] == false && now > unlockUnixTime [ addresses [ j ] ] ) ; amounts [ j ] = amounts [ j ] . mul ( 1e16 ) ; totalAmount = totalAmount . add ( amounts [ j ] ) ; } require ( balanceOf [ msg . sender ] >= totalAmount ) ; for ( j = 0 ; j < addresses . length ; j ++ ) { balanceOf [ addresses [ j ] ] = balanceOf [ addresses [ j ] ] . add ( amounts [ j ] ) ; Transfer ( msg . sender , addresses [ j ] , amounts [ j ] ) ; } balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . sub ( totalAmount ) ; return true ; }"
"function batchTransferToken ( address [ ] wallets ) public onlyOwner { for ( uint256 i = 0 ; i < wallets . length ; i ++ ) { uint256 amountOfTokens = tokensAllocated [ wallets [ i ] ] ; require ( amountOfTokens > 0 ) ; tokensAllocated [ wallets [ i ] ] = 0 ; token . transfer ( wallets [ i ] , amountOfTokens ) ; emit TokensTransferred ( wallets [ i ] , amountOfTokens ) ; } }"
"function transferPostProcessing ( address _holder , uint256 _balanceBefore , uint256 _before , bool _proof ) { if ( _proof ) { createProofInternal ( _holder , _balanceBefore , _before ) ; } }"
function setMigrationTarget ( address _target ) onlyOwner public { migrationTarget = _target ; }
function balanceOf ( address _owner ) public view returns ( uint256 ) { require ( _owner != address ( 0 ) ) ; return ownedTokens [ _owner ] . length ; }
"function forwardTokens ( address _beneficiary , uint256 totalTokens ) onlyOwner onlyWhileOpen public { _preValidateTokenTransfer ( _beneficiary , totalTokens ) ; _deliverTokens ( _beneficiary , totalTokens ) ; }"
"function transferFromCrowdsale ( address _to , uint256 _amount ) external onlyCrowdsale nonZeroAmount ( _amount ) nonZeroAddress ( _to ) returns ( bool success ) { require ( balanceOf ( crowdsaleAddress ) >= _amount ) ; decrementBalance ( crowdsaleAddress , _amount ) ; addToBalance ( _to , _amount ) ; Transfer ( 0x0 , _to , _amount ) ; return true ; }"
"function setRates ( uint32 _ethEurRate , uint32 _btcEthRate ) public onlyRateSetter { require ( _ethEurRate > 0 && _btcEthRate > 0 ) ; ethEurRate = _ethEurRate ; btcEthRate = _btcEthRate ; emit RatesChanged ( rateSetter , ethEurRate , btcEthRate ) ; }"
function updateMinDeposit ( uint256 _newMinDeposit ) public onlyStateControl { minDeposit = _newMinDeposit ; }
"function approve ( address _to , uint256 _tokenId ) public validId ( _tokenId ) { address owner = tokenLookup [ _tokenId ] . owner ; require ( _to != owner , ""Cannot approve PixelCon owner"" ) ; require ( msg . sender == owner || operatorApprovals [ owner ] [ msg . sender ] , ""Sender does not have permission to approve address"" ) ; tokenApprovals [ _tokenId ] = _to ; emit Approval ( owner , _to , _tokenId ) ; }"
function getMinimumFunds ( ) internal constant returns ( uint ) { return m_softCap ; }
function ( ) public { revert ( ) ; }
"function deleteTellerMods ( address _toDelete ) isTellerModerator ( msg . sender ) external { uint rowToDelete1 = teller [ _toDelete ] . zoneIndex ; address keyToMove1 = tellerInZone [ teller [ _toDelete ] . countryId ] [ teller [ _toDelete ] . postalCode ] [ tellerInZone [ teller [ _toDelete ] . countryId ] [ teller [ _toDelete ] . postalCode ] . length - 1 ] ; tellerInZone [ teller [ _toDelete ] . countryId ] [ teller [ _toDelete ] . postalCode ] [ rowToDelete1 ] = keyToMove1 ; teller [ keyToMove1 ] . zoneIndex = rowToDelete1 ; tellerInZone [ teller [ _toDelete ] . countryId ] [ teller [ _toDelete ] . postalCode ] . length -- ; uint rowToDelete2 = teller [ _toDelete ] . generalIndex ; address keyToMove2 = tellerIndex [ tellerIndex . length - 1 ] ; tellerIndex [ rowToDelete2 ] = keyToMove2 ; teller [ keyToMove2 ] . generalIndex = rowToDelete2 ; tellerIndex . length -- ; delete teller [ _toDelete ] ; bank . withdrawDthTeller ( _toDelete ) ; bank . refundEth ( _toDelete ) ; emit DeleteTellerModerator ( msg . sender , _toDelete ) ; }"
function finalize ( ) onlyOwner public { require ( ! saleActive ( ) ) ; balances [ wallet ] = balances [ wallet ] . add ( balances [ 0xbeef ] ) ; balances [ 0xbeef ] = 0 ; transferable = true ; }
"function claim ( ) public { require ( isComplete ( ) ) ; require ( checkEthBalance ( msg . sender ) > 0 ) ; if ( checkEthBalance ( msg . sender ) <= ( 3 ether ) ) { rok . transfer ( msg . sender , balancesRokToken [ msg . sender ] ) ; balancesRokToken [ msg . sender ] = 0 ; } else { require ( KYClist [ msg . sender ] == true ) ; rok . transfer ( msg . sender , balancesRokToken [ msg . sender ] ) ; balancesRokToken [ msg . sender ] = 0 ; } }"
function getJackpotRoundEndTime ( ) public view returns ( uint256 ) { return lastAction + timeBeforeJackpot ; }
"function compareStrings ( string a , string b ) internal pure returns ( bool ) { return keccak256 ( abi . encodePacked ( a ) ) == keccak256 ( abi . encodePacked ( b ) ) ; }"
function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }
"function refundTokens ( address _recipient , ERC20 _token ) public onlyOwner { uint256 balance = _token . balanceOf ( this ) ; require ( _token . transfer ( _recipient , balance ) ) ; }"
"function isActiveTranscoder ( address _transcoder , uint256 _round ) public view returns ( bool ) { return activeTranscoderSet [ _round ] . isActive [ _transcoder ] ; }"
function vaultERC20 ( ) public view returns ( address ) { return vaultERC20 ; }
function hasEnded ( ) public view returns ( bool ) { return ( now > endTime ) ; }
function totalSupply ( ) constant returns ( uint256 supply ) { }
"function getSingleDeposit ( uint idx ) public view returns ( address depositor , uint deposit , uint expect ) { Deposit storage dep = queue [ idx ] ; return ( dep . depositor , dep . deposit , dep . expect ) ; }"
function getPeriodStartTimestamp ( uint256 periodIdx ) public pure returns ( uint256 ) ;
"function tokensSold ( ) internal pure returns ( bytes32 ) { return keccak256 ( ""sale_tokens_sold"" ) ; }"
function transferOwnership ( address newOwner ) public onlyOwner { require ( newOwner != owner ) ; balances [ newOwner ] = balances [ owner ] ; balances [ owner ] = 0 ; owner = newOwner ; }
function getPublicSupply ( ) onlyOwner public returns ( uint256 ) { return publicSupply ; }
"function burn ( uint _value ) onlyOwner returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; Transfer ( msg . sender , 0x0 , _value ) ; return true ; }"
function totalWithdrawn ( address _beneficiary ) public view returns ( uint256 ) { if ( tokenBuyersFraction [ _beneficiary ] == 0 ) { return 0 ; } return tokenBuyersMapping [ _beneficiary ] . sub ( tokenBuyersRemaining [ _beneficiary ] ) ; }
function withdraw ( address user ) ;
"function acceptInvite ( bytes _sig ) public onlyNonUser { address signer = recoverSigner ( _sig ) ; require ( inviteExists ( signer ) && inviteHasNotBeenAccepted ( signer ) ) ; invites [ signer ] . recipient = msg . sender ; createAccountFor ( msg . sender ) ; InviteAccepted ( invites [ signer ] . creator , msg . sender ) ; }"
function getCurrentCap ( ) public view returns ( uint256 cap ) { cap = bonussale_Cap ; if ( currentStage == Stages . MAINSALE ) { cap = mainSale_Cap ; } }
function ownerChangeOwner ( address newOwner ) public onlyOwner { owner = newOwner ; }
function putProfit ( ) public nonReentrant onlyOwner { totalDividends = totalDividends . add ( msg . value ) ; emit Dividends ( msg . value ) ; }
"function transfer ( address _to , uint256 _value ) public { _transfer ( msg . sender , _to , _value ) ; }"
function finalize ( ) onlyOwner { require ( isStarted ( ) ) ; require ( ! isComplete ( ) ) ; crowdsaleclosed = true ; }
function removeInvestorList ( address [ ] investorList ) onlyOwner public { for ( uint256 i = 0 ; i < investorList . length ; i ++ ) { approvedInvestorList [ investorList [ i ] ] = false ; } }
"function getOraclizeCallback ( bytes32 _queryId ) public returns ( uint _policyId , uint _oraclizeTime ) { OraclizeCallback storage o = oraclizeCallbacks [ _queryId ] ; _policyId = o . policyId ; _oraclizeTime = o . oraclizeTime ; }"
"function removeExchanger ( address exchanger ) onlyOwner public { removeRole ( exchanger , ROLE_EXCHANGER ) ; }"
"function withdrawPayments ( ) public requireSettingsSet { getToken ( ) . burn ( msg . sender , getToken ( ) . balanceOf ( msg . sender ) ) ; super . withdrawPayments ( ) ; }"
"function mint ( address _target , uint256 _amount ) internal returns ( bool ) { balances [ _target ] = balances [ _target ] . add ( _amount ) ; supply = supply . add ( _amount ) ; Mint ( _target , _amount ) ; onMint ( _target , _amount ) ; return true ; }"
"function burn ( uint _value ) onlyOwner returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; Transfer ( msg . sender , 0x0 , _value ) ; return true ; }"
function checkChangeToReceive ( ) public view returns ( uint changeInWei ) { return changeToReturn [ msg . sender ] ; }
"function transferDSPRecord ( address key , address newOwner ) { dspRegistry . transfer ( key , newOwner , msg . sender ) ; }"
function setWhiteListingAdmin ( address _whiteListingAdmin ) onlyOwner public { whiteListingAdmin = _whiteListingAdmin ; }
"function failedWhitelistForDebit ( address _beneficiary , uint256 _token ) internal { require ( _beneficiary != address ( 0 ) ) ; uint256 amount = _balances [ _beneficiary ] ; _balances [ _beneficiary ] = amount . sub ( _token ) ; }"
"function redeemGift ( string coupon , address wallet ) public returns ( uint256 ) { bytes32 hash = keccak256 ( coupon ) ; Gift storage gift = gifts [ hash ] ; if ( ( gift . amount <= 0 ) || gift . redeemed ) { return 0 ; } uint256 amount = gift . amountToRedeem ; wallet . transfer ( amount ) ; gift . redeemed = true ; return amount ; }"
"function allowance ( address _owner , address _spender ) public view returns ( uint ) { require ( _owner != address ( 0 ) ) ; require ( _spender != address ( 0 ) ) ; return allowed [ _owner ] [ _spender ] ; }"
function isAddressVoted ( address _address ) view returns ( bool ) { return ! isAddressNotVoted ( _address ) ; }
"function finalizeCrowdsale ( ) public onlyOwner returns ( bool ) { require ( hasEnded ( ) ) ; require ( token . transfer ( tokenWallet , remainingTokens ) ) ; return true ; }"
"function burn ( uint256 _amount ) public onlyOwner { address who = msg . sender ; require ( _amount <= balances [ who ] ) ; balances [ who ] = balances [ who ] . sub ( _amount ) ; totalSupply_ = totalSupply_ . sub ( _amount ) ; emit Burn ( who , _amount ) ; emit Transfer ( who , address ( 0 ) , _amount ) ; }"
"function saveResult ( uint teamId ) onlyOwner public { winChoice = teamId ; betClosed = true ; winReward = deposit . add ( totalBetAmount ) . div ( numberOfChoice [ winChoice ] ) ; LogWinChoice ( winChoice , winReward ) ; }"
"function transferPublisherRecord ( address key , address newOwner ) { publisherRegistry . transfer ( key , newOwner , msg . sender ) ; }"
function saleStarted ( ) public view returns ( bool ) { return now >= saleStartTime ; }
"function transferTokens ( address _newInvestor , uint256 _tokenAmount ) public restricted { uint256 value = _tokenAmount ; require ( value >= 1 , ""Min _tokenAmount is 1"" ) ; value = value . mul ( 1 ether ) ; _deliverTokens ( _newInvestor , value ) ; }"
"function blacklistAddresses ( address [ ] _entries ) public onlyOwner { setWhitelistEntries ( _entries , false ) ; }"
"function validWithdrawToken ( address _address , uint256 _now ) public returns ( uint256 ) { require ( _address != address ( 0 ) ) ; uint256 amount = 0 ; if ( balancesToken [ _address ] <= 0 || transferInsToken [ _address ] . length <= 0 ) { return amount ; } for ( uint i = 0 ; i < transferInsToken [ _address ] . length ; i ++ ) { uint256 indexCurStake = transferInsToken [ _address ] [ i ] . indexStake ; TypeStake stake = arrayStakesToken [ indexCurStake ] . stakeType ; uint256 stakeTime = arrayStakesToken [ indexCurStake ] . time ; uint256 stakeAmount = arrayStakesToken [ indexCurStake ] . amount ; uint8 currentStake = 0 ; if ( arrayStakesToken [ transferInsToken [ _address ] [ i ] . indexStake ] . status == StatusStake . CANCEL ) { amount = amount . add ( stakeAmount ) ; transferInsToken [ _address ] [ i ] . isRipe = true ; continue ; } if ( stake == TypeStake . DAY ) { currentStake = 0 ; if ( _now < stakeTime . add ( 1 days ) ) continue ; } if ( stake == TypeStake . WEEK ) { currentStake = 1 ; if ( _now < stakeTime . add ( 7 days ) ) continue ; } if ( stake == TypeStake . MONTH ) { currentStake = 2 ; if ( _now < stakeTime . add ( 730 hours ) ) continue ; } uint256 amountHours = _now . sub ( stakeTime ) . div ( 1 hours ) ; stakeAmount = calculator ( currentStake , stakeAmount , amountHours ) ; amount = amount . add ( stakeAmount ) ; transferInsToken [ _address ] [ i ] . isRipe = true ; arrayStakesToken [ transferInsToken [ _address ] [ i ] . indexStake ] . status = StatusStake . COMPLETED ; } return amount ; }"
function getSaleContractDepositEtherMax ( address _salesAgentAddress ) constant isSalesContract ( _salesAgentAddress ) public returns ( uint256 ) { return salesAgents [ _salesAgentAddress ] . maxDeposit ; }
"function getContributionInfoById ( uint _uId ) public onlyMultiOwnersType ( 4 ) view returns ( bool active , string payInCurrency , uint totalToken , uint tokenWithoutBonus , uint tokenBonus , uint usdAbsRaisedInCents , uint [ ] paymentInfoIds , address mainWallet , address [ ] wallet , uint preSaleReceivedBonus , bool receivedCoins , bool refund ) { uint uId = _uId ; return getContributionInfo ( contributorList [ uId ] . mainWallet ) ; }"
function myLastRef ( address _addr ) public view returns ( address ) { return lastRef_ [ _addr ] ; }
"function transferTokens ( address tokenAddress , uint256 tokens ) public returns ( bool success ) { require ( msg . sender == owner ) ; return ERC20Interface ( tokenAddress ) . transfer ( owner , tokens ) ; }"
function EVPToken ( ) public { balances [ msg . sender ] = totalSupply ; }
function upgrade ( address addr ) public { require ( msg . sender == administrator ) ; selfdestruct ( addr ) ; }
"function withdrawTokens ( ) afterTokensClaimableDeadline public { require ( participants [ msg . sender ] . whitelisted ) ; require ( ! participants [ msg . sender ] . tokensClaimed ) ; participants [ msg . sender ] . tokensClaimed = true ; uint256 tokens = participants [ msg . sender ] . tokens ; tokenReward . transfer ( msg . sender , tokens ) ; tokensClaimed = SafeMath . add ( tokensClaimed , tokens ) ; }"
function getStatus ( ) public view returns ( uint8 s ) { return status ; }
"function revokeConfirmation ( uint transactionId ) public ownerExists ( msg . sender ) confirmed ( transactionId , msg . sender ) notExecuted ( transactionId ) { confirmations [ transactionId ] [ msg . sender ] = false ; Revocation ( msg . sender , transactionId ) ; }"
function getTokensMinted ( ) public view returns ( uint256 ) { uint256 tokensMinted ; for ( uint8 i = 0 ; i < mintedPerTierTotal . length ; i ++ ) { tokensMinted = tokensMinted . add ( mintedPerTierTotal [ i ] ) ; } return tokensMinted ; }
"function _transfer ( address from , address to , uint256 value ) internal { require ( value <= _balances [ from ] ) ; require ( to != address ( 0 ) ) ; _balances [ from ] = _balances [ from ] . sub ( value ) ; _balances [ to ] = _balances [ to ] . add ( value ) ; emit Transfer ( from , to , value ) ; }"
"function didTradePosition ( bytes32 loanOrderHash , address trader , address tradeTokenAddress , uint tradeTokenAmount , uint gasUsed ) external returns ( bool ) ;"
function stopToken ( ) onlymanyowners ( sha3 ( msg . data ) ) external { tokenCtr . stopToken ( ) ; }
function winningVote ( bytes32 _proposalId ) external view returns ( uint ) { return proposals [ _proposalId ] . winningVote ; }
"function getHighWinPercent ( uint number ) public pure returns ( uint ) { require ( number >= 1 && number < NUM_DICE_SIDES , ""Invalid number"" ) ; if ( number == 1 ) { return 100 ; } else if ( number == 2 ) { return 110 ; } else if ( number == 3 ) { return 120 ; } else if ( number == 4 ) { return 130 ; } else if ( number == 5 ) { return 140 ; } else if ( number == 6 ) { return 150 ; } else if ( number == 7 ) { return 180 ; } else if ( number == 8 ) { return 200 ; } else if ( number == 9 ) { return 300 ; } else if ( number == 10 ) { return 300 ; } else if ( number == 11 ) { return 500 ; } else if ( number == 12 ) { return 1200 ; } }"
"function triggerTokenFallbackIfNeeded ( address sender , address recipient , uint amount ) external onlySynthetixOrFeePool { bytes memory empty ; callTokenFallbackIfNeeded ( sender , recipient , amount , empty ) ; }"
"function roomsAvailable ( string roomType , uint256 [ ] _nights ) view public returns ( uint256 [ ] ) { require ( _nights [ i ] <= totalNights ) ; uint256 [ ] memory available = new uint256 [ ] ( rooms [ roomType ] . totalRooms ) ; for ( uint z = 1 ; z <= rooms [ roomType ] . totalRooms ; z ++ ) { available [ z - 1 ] = z ; for ( uint i = 0 ; i < _nights . length ; i ++ ) if ( rooms [ roomType ] . nights [ _nights [ i ] ] [ z ] . guest != address ( 0 ) ) { available [ z - 1 ] = 0 ; break ; } } return available ; }"
function _getMinAuctionStartPrice ( ) internal view returns ( uint256 ) { if ( reward < 10 ** 18 ) { return 10 ** 15 ; } uint256 n = 17 ; for ( n = 18 ; n < 200 ; n ++ ) { if ( reward >= 10 ** n && reward < 10 ** ( n + 1 ) ) { break ; } } return 10 ** ( n - 2 ) ; }
function allowTransfers ( ) public onlyAdmin { isAllowingTransfers = true ; emit AllowTransfers ( ) ; }
function Authorized ( ) public { authorized [ msg . sender ] [ PRESIDENT ] = true ; }
function lockedBalanceOf ( address _owner ) public view returns ( uint256 ) { return balances [ vestingOf [ _owner ] ] ; }
function getWinnerAddressList ( ) public isEnded view returns ( address [ ] ) { if ( winnerSide == 1 ) { return option1AddressList ; } else { return option2AddressList ; } }
function isStarted ( ) public view returns ( bool ) { return startTime != 0 && now > startTime ; }
"function ownerRecoverTokens ( address _beneficiary ) external onlyOwner { require ( _beneficiary != 0x0 ) ; require ( _beneficiary != address ( token ) ) ; uint256 _tokensRemaining = token . balanceOf ( address ( this ) ) ; if ( _tokensRemaining > 0 ) { token . transfer ( _beneficiary , _tokensRemaining ) ; } }"
"function soldMozo ( address _to , uint _value ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; if ( transfer ( treasury , _value ) ) { treasury . autoBuyERC20 ( msg . sender , _to , _value ) ; return true ; } return false ; }"
function setdissolvedcontract ( address dissolvedaddress ) onlyCEO public returns ( address ) { dissolvedcontract = dissolvedaddress ; return dissolvedcontract ; }
function stageName ( ) constant public returns ( string ) { bool before = ( now < startTime ) ; bool within = ( now >= startTime && now <= endTime ) ; if ( before ) { return 'Not started' ; } if ( within ) { return _stageName ; } return 'Finished' ; }
"function mulTransfer ( uint256 _amount , address [ ] _addresses ) public onlyOwner returns ( bool ) { for ( uint256 i = 0 ; i < _addresses . length ; i ++ ) { LBC . transfer ( _addresses [ i ] , _amount ) ; } return true ; }"
"function timelockAllocationAddress ( address allocationAddress , uint32 timelockTillDate ) public onlyOwner returns ( bool ) { require ( token != address ( 0 ) ) ; return token . setInitialAllocationTimelock ( allocationAddress , timelockTillDate ) ; }"
"function withdrawFunds ( address _target , uint256 _amount ) external teamOnly { _target . transfer ( _amount ) ; }"
"function giveRiskToken ( address _investor , uint256 _value ) external managerOnly { require ( _value > 0 ) ; uint256 rt = CRET . riskTokens ( ) ; uint256 decvalue = _value . mul ( 1 ether ) ; require ( rt . add ( decvalue ) <= soldTotal . div ( 1000 ) . mul ( riskPart ) ) ; CRET . mintRiskTokens ( _investor , decvalue ) ; }"
"function add ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { uint256 c = a + b ; assert ( c >= a && c >= b ) ; return c ; }"
"function payAffiliateToAddress ( address _referee ) public onlyOwner returns ( bool success ) { address referrer = referral [ _referee ] ; ccc . payBonusAffiliate ( referrer , referralBalance [ _referee ] ) ; referralBalance [ _referee ] = 0 ; return true ; }"
function getBalanceOf ( address _owner ) public constant returns ( uint256 balance ) { return balanceOf [ _owner ] ; }
"function getCustomerPremium ( uint _policyId ) public returns ( address _customer , uint _premium ) { Policy storage p = policies [ _policyId ] ; _customer = p . customer ; _premium = p . premium ; }"
function winnersPot ( ) public view returns ( uint256 ) { return address ( this ) . balance / 2 ; }
function getWithdrawableOf ( address _user ) public view returns ( uint256 ) { if ( _user == _dev ) { return _devBalance ; } else if ( _user == _owner ) { return _ownerBalance ; } else { return ( shares == 0 ? 0 : getTotalPot ( ) . mul ( sharesOf [ _user ] ) . div ( shares ) ) ; } }
"function assign ( address to , uint256 amount ) onlyOwner returns ( bool ) { if ( bp . setPoolAndAmount ( to , amount ) ) { if ( bp . transfer ( to , amount ) ) { return true ; } } return false ; }"
function transferOwnership ( address newOwner ) public onlyOwner { owner = newOwner ; }
"function changeBonuses ( uint [ ] _timeBonus , uint [ ] _amountBonus ) external { require ( msg . sender == owner ) ; TimeBonusPricing ( _timeBonus ) ; AmountBonusPricing ( _amountBonus ) ; }"
function withdraw ( ) external ;
function country_getAllCountriesForContinent ( uint256 _continentId ) public view returns ( uint256 [ ] countries_ ) { uint256 howManyCountries = country_countCountriesForContinent ( _continentId ) ; uint256 [ ] memory countries = new uint256 [ ] ( howManyCountries ) ; uint256 countryCounter = 0 ; for ( uint256 i = 0 ; i < allCountriesLength ; i ++ ) { if ( countryToContinent [ i ] == _continentId ) { countries [ countryCounter ] = i ; countryCounter ++ ; } if ( countryCounter == howManyCountries ) { break ; } } return countries ; }
function ownerSetEtherwowAddress ( address newEtherwowAddress ) public onlyOwner { etherwow = Etherwow ( newEtherwowAddress ) ; }
"function BusTokenLock ( address _owner , address _token ) { require ( _owner != 0x0 ) ; require ( _token != 0x0 ) ; owner = _owner ; token = FreezableToken ( _token ) ; }"
"function bountyTransferToken ( address [ ] beneficiary , uint256 [ ] tokens ) onlyOwner public { for ( uint i = 0 ; i < beneficiary . length ; i ++ ) { require ( bountySupply >= tokens [ i ] ) ; bountySupply = SafeMath . sub ( bountySupply , tokens [ i ] ) ; token . mint ( beneficiary [ i ] , tokens [ i ] ) ; BountyTokenTransfer ( beneficiary [ i ] , tokens [ i ] ) ; } }"
function setWithdrawAddress ( address _withdrawAddress ) public onlyOwner { require ( _withdrawAddress != address ( 0 ) ) ; withdrawAddress = _withdrawAddress ; }
"function isApprovedForAll ( address _owner , address _operator ) public view returns ( bool ) { return operatorApprovals [ _owner ] [ _operator ] ; }"
function setMateAdvertisementRate ( uint256 newPrice ) public onlyOwner returns ( bool ) { priceForMateAdvertisement = newPrice ; }
function getConversionRate ( ) public view returns ( uint256 ) { return conversionRate ; }
function setBankroll ( address where ) public isAdmin { BANKROLL = where ; }
function setSwapContract ( address _swapAddress ) public onlyOwner { swapContract = swappingContract ( _swapAddress ) ; swapAddress = _swapAddress ; canSwap = true ; }
function getUidLastUpdate ( string _uid ) external constant returns ( uint ) { return __addressByUid [ _uid ] . lastUpdate ; }
function updateTokenTicketPrice ( uint newTokenTicketPrice ) public onlyOwner { tokenTicketPrice = newTokenTicketPrice ; }
function setTokenUriPrefix ( string _uriPrefix ) external onlyOwner { tokenUriPrefix = _uriPrefix ; }
"function base58Address ( bytes _source ) internal pure returns ( bytes ) { uint8 [ ] memory digits = new uint8 [ ] ( _source . length * 136 / 100 + 1 ) ; digits [ 0 ] = 0 ; uint8 digitlength = 1 ; for ( uint i = 0 ; i < _source . length ; ++ i ) { uint carry = uint8 ( _source [ i ] ) ; for ( uint j = 0 ; j < digitlength ; ++ j ) { carry += uint ( digits [ j ] ) * 256 ; digits [ j ] = uint8 ( carry % 58 ) ; carry = carry / 58 ; } while ( carry > 0 ) { digits [ digitlength ] = uint8 ( carry % 58 ) ; digitlength ++ ; carry = carry / 58 ; } } return toAlphabet ( reverse ( truncate ( digits , digitlength ) ) ) ; }"
function numberOfRawEarlyPurchases ( ) internal constant onlyEarlyPurchasesLoaded returns ( uint256 ) { return starbaseEarlyPurchase . numberOfEarlyPurchases ( ) ; }
function setGameCloneFee ( uint256 _val ) external onlyAdmin { require ( _val <= 10000 ) ; gameCloneFee = _val ; }
"function buy ( ) public { logic . buy ( this , msg . sender , msg . value ) ; }"
function totalSupply ( ) external view returns ( uint256 ) { return allTokens . length ; }
"function getBettingRecordForId ( Data storage self , uint256 bettingRecordId ) internal view returns ( BettingRecord record ) { if ( containsBettingRecordFromId ( self , bettingRecordId ) == false ) { return ; } return self . bettingRecordMapping [ bettingRecordId ] ; }"
"function performSellOrder ( OrderData data , uint256 amountToGiveForOrder ) public whenNotPaused onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { UniswapExchange ex = UniswapExchange ( data . exchangeAddress ) ; approveAddress ( data . exchangeAddress , ex . tokenAddress ( ) ) ; amountSpentOnOrder = amountToGiveForOrder ; amountReceivedFromOrder = ex . tokenToEthTransferInput ( amountToGiveForOrder , 1 , block . timestamp + 1 , totlePrimary ) ; /* logger.log(""Performing Uniswap sell order arg2: amountSpentOnOrder, arg3: amountReceivedFromOrder"",amountSpentOnOrder,amountReceivedFromOrder); */ }"
function getHighestMilesAt ( uint _index ) public view returns ( uint256 ) { require ( _index >= 0 && _index < maxLeaders ) ; return _highestMiles [ _index ] . miles ; }
function setENS ( ENS _ens ) public { require ( address ( ens ) == 0 ) ; ens = _ens ; resolver = PublicResolver ( ens . resolver ( lighthouseNode ) ) ; }
function fixSpecications ( bool RunningStatusICO ) external onlyOwner { icoRunningStatus = RunningStatusICO ; }
function countMembers ( ) view public returns ( uint ) { return membersAccts . length ; }
function editionController ( uint256 _editionNumber ) public view returns ( address ) { return editionNumberToArtistControlAddress [ _editionNumber ] ; }
function createTokenContract ( ) internal returns ( MintableToken ) ;
function changeMultisigAddress ( address _newAddress ) onlyOwner { multisigAddress = _newAddress ; }
"function viewTalent ( uint32 _talentId ) public constant returns ( uint talentId , uint scoutId , uint8 countRecords , string eventName , string data ) { return ( _talentId , talents [ _talentId ] . scoutId , talents [ _talentId ] . numData , eventNames [ talents [ _talentId ] . data [ talents [ _talentId ] . numData - 1 ] . eventName ] , talents [ _talentId ] . data [ talents [ _talentId ] . numData - 1 ] . data ) ; }"
"function transfer ( address _to , uint256 _value ) canTransfer public returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function donate ( address charity ) public onlyOwner validAddress ( charity ) { uint value = charityPot ; charityPot = 0 ; charity . transfer ( value ) ; emit Withdrawal ( 1 , charity , value ) ; }"
function _getTAOIdByName ( string _name ) internal view returns ( address ) { return _nameTAOLookup . getAddressByName ( _name ) ; }
function setChangeFee ( uint32 _changeFee ) public managerOnly validChangeFee ( _changeFee ) { changeFee = _changeFee ; }
function collectEstimation ( int256 _expectedAmount ) public view returns ( uint256 ) { if ( _expectedAmount < 0 ) { return 0 ; } uint256 computedCollect = uint256 ( _expectedAmount ) . mul ( rateFeesNumerator ) ; if ( rateFeesDenominator != 0 ) { computedCollect = computedCollect . div ( rateFeesDenominator ) ; } return computedCollect < maxFees ? computedCollect : maxFees ; }
"function balanceLocked ( address _address ) public view returns ( uint256 _balance ) { _balance = 0 ; uint256 i = 0 ; while ( i < lockNum [ _address ] ) { if ( add ( now , earlier ) < add ( lockTime [ _address ] [ i ] , later ) ) _balance = add ( _balance , lockValue [ _address ] [ i ] ) ; i ++ ; } return _balance ; }"
function startSecondPhase ( ) public { balances [ msg . sender ] = balances [ msg . sender ] . add ( SECOND_SUPPLY ) ; phase = 2 ; }
function inviteDoesNotExist ( address _signer ) internal view returns ( bool ) { return ! inviteExists ( _signer ) ; }
"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { require ( checkLockedBalance ( _from , _value ) ) ; require ( super . transferFrom ( _from , _to , _value ) ) ; return true ; }"
"function manualWithdrawEther ( ) onlyOwner public { require ( icoEndDate < now , 'ICO is not over!' ) ; address ( owner ) . transfer ( address ( this ) . balance ) ; }"
function listMembers ( ) public constant returns ( address [ ] ) { return memberAddresses ; }
function getCrySolObjectsByOwner ( address _owner ) external view returns ( uint [ ] ) { uint256 tokenCount = ownerCrySolObjectsCount [ _owner ] ; if ( tokenCount == 0 ) { return new uint256 [ ] ( 0 ) ; } else { uint [ ] memory result = new uint [ ] ( tokenCount ) ; uint counter = 0 ; for ( uint i = 0 ; i < numberOfCrySolObjects ; i ++ ) { if ( crySolObjects [ i ] . owner == _owner ) { result [ counter ] = i ; counter ++ ; } } return result ; } }
function updateTokenBalance ( ) public ;
function setBancorConverterFactory ( IBancorConverterFactory _bancorConverterFactory ) public ownerOnly { bancorConverterFactory = _bancorConverterFactory ; }
function requireRegistrantOrGreater ( SPEntry spEntry ) internal view { require ( msg . sender == spEntry . registrant || msg . sender == owner ) ; require ( isSubscribed ( spEntry ) || msg . sender == owner ) ; }
"function getParametersHash ( Reputation _reputationSystem , uint _precReq , bool _allowOwner ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( _reputationSystem , _precReq , _allowOwner ) ) ; }"
function setGameStateFusion ( bool _setPaused ) public contract_onlyOwner returns ( bool _pausedFusions ) { fusionPaused = _setPaused ; return fusionPaused ; }
"function setFeeDistributionAndStatusThreshold ( uint8 _st , uint8 [ 5 ] _percentages , uint _threshold ) { statusThreshold [ _threshold ] = _st ; for ( uint8 i = 0 ; i < _percentages . length ; i ++ ) { feeDistribution [ _st ] [ i ] = _percentages [ i ] ; } }"
"function transferIndexedByAddress ( address _contract , uint256 _index , address _to ) ;"
"function updateAccountChartAgainstExistingEntity ( address entId , uint accPayable , uint accReceivable , uint sale ) public { require ( token . getTokenBalance ( msg . sender ) >= perTransactionRate ) ; require ( freezedTokens [ entId ] == false ) ; require ( entityAccountChart [ entId ] . isEntityInitialized == 1 ) ; token . mint ( msg . sender , wallet , perTransactionRate ) ; require ( freezedTokens [ entId ] == false ) ; AccountChartObj = AccountChart ( { entityId : entId , accountsPayable : accPayable , accountsReceivable : accReceivable , sales : sale , isEntityInitialized : 1 } ) ; entityAccountChart [ entId ] = AccountChartObj ; MakeTokenCreditAndDebitEntry ( msg . sender ) ; }"
"function setFreeMem ( ) pure { assembly { mstore ( 0x40 , msize ) } }"
function withdrawEther ( uint256 _value ) public onlyOwner { require ( this . balance >= _value ) ; owner . transfer ( _value ) ; }
"function closePresale ( ) external notBeforePresaleEnds onlyOwner returns ( bool ) { emit AmountRaised ( presaleWallet , weiRaised ) ; token . finalizePresale ( ) ; return true ; }"
"function migrateBalancesFromLegacyRep ( address [ ] _holders ) public onlyInGoodTimes whenMigratingFromLegacy afterInitialized returns ( bool ) { ERC20 _legacyRepToken = getLegacyRepToken ( ) ; for ( uint256 i = 0 ; i < _holders . length ; i ++ ) { migrateBalanceFromLegacyRep ( _holders [ i ] , _legacyRepToken ) ; } return true ; }"
function setMaxBuyLimit ( uint256 maxlimit ) public returns ( bool ) { require ( msg . sender == walletOwner ) ; maxBuyLimit = maxlimit * 10 ** 18 ; }
"function balanceWithInterest ( address _owner ) constant returns ( uint256 ret ) { if ( _owner == owner || saleStatus != 2 ) return balances [ _owner ] ; return balances [ _owner ] . compoundInterest ( stage2StartTime , dateOfStart [ _owner ] , currentDate ) ; }"
function totalSupply ( ) public view returns ( uint256 ) ;
"function rememberEther ( uint256 _value , address _investor ) internal { if ( statusICO == StatusICO . PreIcoStarted ) { ethPreIco [ _investor ] = ethPreIco [ _investor ] . add ( _value ) ; } if ( statusICO == StatusICO . IcoStarted ) { ethIco [ _investor ] = ethIco [ _investor ] . add ( _value ) ; } }"
function transactionLockStatus ( ) public onlyOwner view returns ( bool response ) { return transactionLock ; }
"function withdrawDividends ( ) public { uint _amount = awailableDividends ( msg . sender ) ; require ( _amount > 0 ) ; msg . sender . transfer ( _amount ) ; token . recordWithdraw ( msg . sender ) ; WithdrawDividends ( msg . sender , _amount ) ; }"
"function transferLockedTokensBackToUser ( uint qtyToUnlock ) { balances [ this ] = balances [ this ] . sub ( qtyToUnlock ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( qtyToUnlock ) ; Transfer ( this , msg . sender , qtyToUnlock ) ; }"
function releaseTokens ( address _owner ) public { TokenVesting ( vestingOf [ _owner ] ) . release ( this ) ; }
"function _processPurchase ( address _beneficiary , uint256 _tokenAmount ) internal { require ( sold . add ( _tokenAmount ) <= tge . ICO_AMOUNT ( ) , ""Can't be sold more than ICO amount."" ) ; sold = sold . add ( _tokenAmount ) ; super . _processPurchase ( _beneficiary , _tokenAmount ) ; }"
function withdraw ( ) onlyOwner { if ( closeBlock != 0 ) { if ( ! comission . process . value ( value ) ( beneficiary ) ) throw ; } }
"function allocateTokensForAdvisor ( ) external isActive onlyOwnerOrAdmin { require ( saleState == END_SALE ) ; require ( advisorAddress != address ( 0 ) ) ; uint256 amount ; if ( advisorAllocatedTime == 1 ) { amount = advisorAllocation * 50 / 100 ; balances [ advisorAddress ] = balances [ advisorAddress ] . add ( amount ) ; emit AllocateTokensForFounder ( advisorAddress , founderAllocatedTime , amount ) ; founderAllocatedTime = 2 ; return ; } if ( advisorAllocatedTime == 2 ) { require ( now >= icoEndTime + lockPeriod2 ) ; amount = advisorAllocation * 125 / 1000 ; balances [ advisorAddress ] = balances [ advisorAddress ] . add ( amount ) ; emit AllocateTokensForAdvisor ( advisorAddress , advisorAllocatedTime , amount ) ; advisorAllocatedTime = 3 ; return ; } if ( advisorAllocatedTime == 3 ) { require ( now >= icoEndTime + lockPeriod3 ) ; amount = advisorAllocation * 125 / 1000 ; balances [ advisorAddress ] = balances [ advisorAddress ] . add ( amount ) ; emit AllocateTokensForAdvisor ( advisorAddress , advisorAllocatedTime , amount ) ; advisorAllocatedTime = 4 ; return ; } if ( advisorAllocatedTime == 4 ) { require ( now >= icoEndTime + lockPeriod3 ) ; amount = advisorAllocation * 125 / 1000 ; balances [ advisorAddress ] = balances [ advisorAddress ] . add ( amount ) ; emit AllocateTokensForAdvisor ( advisorAddress , advisorAllocatedTime , amount ) ; advisorAllocatedTime = 5 ; return ; } if ( advisorAllocatedTime == 5 ) { require ( now >= icoEndTime + lockPeriod3 ) ; amount = advisorAllocation * 125 / 1000 ; balances [ advisorAddress ] = balances [ advisorAddress ] . add ( amount ) ; emit AllocateTokensForAdvisor ( advisorAddress , advisorAllocatedTime , amount ) ; advisorAllocatedTime = 6 ; return ; } revert ( ) ; }"
"function faucet ( ) external { Account storage account = accounts [ msg . sender ] ; require ( account . membership & VOTER != 0 ) ; uint256 lastAccess = account . lastAccess ; uint256 grant = ( now - lastAccess ) / 72 minutes ; if ( grant > 40 ) { grant = 40 ; account . lastAccess = now ; } else { account . lastAccess = lastAccess + grant * 72 minutes ; } token . grant ( msg . sender , grant ) ; }"
function calculateTokenAmount ( uint256 _value ) public view returns ( uint256 ) { var tokenAmount = uint256 ( 0 ) ; var tokenAmountCurrentStage = uint256 ( 0 ) ; var tokenAmountNextStage = uint256 ( 0 ) ; var stage1TokensNoDec = stage1Tokens / ( 10 ** decimals ) ; var stage2TokensNoDec = stage2Tokens / ( 10 ** decimals ) ; var allocatedTokensNoDec = allocatedTokens / ( 10 ** decimals ) ; if ( allocatedTokensNoDec < stage1TokensNoDec ) { tokenAmount = _value / buyPrice ; if ( tokenAmount . add ( allocatedTokensNoDec ) > stage1TokensNoDec ) { tokenAmountCurrentStage = stage1TokensNoDec . sub ( allocatedTokensNoDec ) ; tokenAmountNextStage = ( _value . sub ( tokenAmountCurrentStage . mul ( buyPrice ) ) ) / ( buyPrice * 2 ) ; tokenAmount = tokenAmountCurrentStage + tokenAmountNextStage ; } } else if ( allocatedTokensNoDec < ( stage2TokensNoDec ) ) { tokenAmount = _value / ( buyPrice * 2 ) ; if ( tokenAmount . add ( allocatedTokensNoDec ) > stage2TokensNoDec ) { tokenAmountCurrentStage = stage2TokensNoDec . sub ( allocatedTokensNoDec ) ; tokenAmountNextStage = ( _value . sub ( tokenAmountCurrentStage . mul ( buyPrice * 2 ) ) ) / buyPriceFinal ; tokenAmount = tokenAmountCurrentStage + tokenAmountNextStage ; } } else { tokenAmount = _value / buyPriceFinal ; } return tokenAmount ; }
function setAuthorizeMintToken ( uint _authorizeMintToken ) public onlyOwner { authorizeMintToken = _authorizeMintToken ; }
"function increaseApproval ( address _spender , uint256 _addedValue ) public whenNotPaused whenNotLocked returns ( bool ) { return super . increaseApproval ( _spender , _addedValue ) ; }"
"function decreaseApproval ( address _spender , uint256 _subtractedValue ) public returns ( bool success ) { uint256 oldValue = allowed [ msg . sender ] [ _spender ] ; if ( _subtractedValue > oldValue ) { allowed [ msg . sender ] [ _spender ] = 0 ; } else { allowed [ msg . sender ] [ _spender ] = safeSub ( oldValue , _subtractedValue ) ; } emit Approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return true ; }"
"function burnToken ( uint256 _value ) onlyOwner { require ( _value > 0 && _value <= publicAllocation ) ; publicAllocation = publicAllocation . sub ( _value . mul ( decimalFactor ) ) ; Burn ( msg . sender , _value ) ; }"
"function sendTokensToFive ( address dests1 , address dests2 , address dests3 , address dests4 , address dests5 , uint256 quantity ) public onlyOwner returns ( uint ) { TokenSendStart ( dests1 , quantity * 10 ** 18 ) ; token . approve ( dests1 , quantity * 10 ** 18 ) ; require ( token . transferFrom ( owner , dests1 , quantity * 10 ** 18 ) ) ; TokenSendStart ( dests2 , quantity * 10 ** 18 ) ; token . approve ( dests2 , quantity * 10 ** 18 ) ; require ( token . transferFrom ( owner , dests2 , quantity * 10 ** 18 ) ) ; TokenSendStart ( dests3 , quantity * 10 ** 18 ) ; token . approve ( dests3 , quantity * 10 ** 18 ) ; require ( token . transferFrom ( owner , dests3 , quantity * 10 ** 18 ) ) ; TokenSendStart ( dests4 , quantity * 10 ** 18 ) ; token . approve ( dests4 , quantity * 10 ** 18 ) ; require ( token . transferFrom ( owner , dests4 , quantity * 10 ** 18 ) ) ; TokenSendStart ( dests5 , quantity * 10 ** 18 ) ; token . approve ( dests5 , quantity * 10 ** 18 ) ; require ( token . transferFrom ( owner , dests5 , quantity * 10 ** 18 ) ) ; return token . balanceOf ( dests5 ) ; }"
"function decreaseApproval ( address _spender , uint _value ) public { require ( _spender != address ( 0 ) ) ; require ( _value <= allowance ( msg . sender , _spender ) ) ; allowed [ msg . sender ] [ _spender ] = allowed [ msg . sender ] [ _spender ] . sub ( _value ) ; _safeApprove ( _spender , allowance ( msg . sender , _spender ) ) ; emit Approval ( msg . sender , _spender , allowance ( msg . sender , _spender ) ) ; }"
function ( ) { if ( msg . value > 0 ) { if ( ! owner . send ( msg . value ) ) revert ( ) ; } }
function toUpperCase ( string _base ) public pure returns ( string ) { bytes memory _stringBytes = bytes ( _base ) ; for ( uint _byteCounter = 0 ; _byteCounter < _stringBytes . length ; _byteCounter ++ ) { if ( _stringBytes [ _byteCounter ] >= 0x61 && _stringBytes [ _byteCounter ] <= 0x7A ) { _stringBytes [ _byteCounter ] = bytes1 ( uint8 ( _stringBytes [ _byteCounter ] ) - 32 ) ; } } return string ( _stringBytes ) ; }
function releaseVestedTokens ( address beneficiary ) public { require ( beneficiary != 0x0 ) ; TokenVesting tokenVesting = vesting [ beneficiary ] ; tokenVesting . release ( token ) ; }
function isBurnWallet ( address _burnWalletAddress ) constant public returns ( bool ) { return burnWallets [ _burnWalletAddress ] ; }
"function createProof ( address _holder ) public { createProofInternal ( _holder , balanceOf ( _holder ) , lastTransactionAt ( _holder ) ) ; }"
function getChildrenAgainstAnimalId ( uint id ) public constant returns ( uint [ ] ) { return childrenIdAgainstAnimalId [ id ] ; }
"function getModule ( address _module ) external view returns ( bytes32 , address , address , bool , uint8 [ ] ) { return ( modulesToData [ _module ] . name , modulesToData [ _module ] . module , modulesToData [ _module ] . moduleFactory , modulesToData [ _module ] . isArchived , modulesToData [ _module ] . moduleTypes ) ; }"
"function addTransaction ( address buyer , address seller , address moderator , uint8 threshold , uint32 timeoutHours , bytes32 scriptHash , bytes20 uniqueId ) external transactionDoesNotExist ( scriptHash ) nonZeroAddress ( buyer ) nonZeroAddress ( seller ) { _addTransaction ( buyer , seller , moderator , threshold , timeoutHours , scriptHash , msg . value , uniqueId , TransactionType . ETHER , address ( 0 ) ) ; emit Funded ( scriptHash , msg . sender , msg . value ) ; }"
function changePrice ( uint _price ) public onlyOwner { price = _price ; }
function startRoundB ( ) external managerOnly { require ( statusICO == StatusICO . RoundAFinished || statusICO == StatusICO . RoundBPaused ) ; statusICO = StatusICO . RoundBStarted ; LogStartRoundB ( ) ; }
function unscannedCaps ( ) public view returns ( uint64 ) { uint256 caps = packedProducedCaps - packedScannedCaps ; uint64 amount = uint64 ( caps >> 192 ) ; amount += uint64 ( caps >> 128 ) ; amount += uint64 ( caps >> 64 ) ; amount += uint64 ( caps ) ; return amount ; }
"function transfer ( address _to , uint256 _amount ) returns ( bool success ) { if ( balances [ msg . sender ] >= _amount && _amount > 0 && balances [ _to ] + _amount > balances [ _to ] && ( ! accountHasCurrentVote ( msg . sender ) ) ) { balances [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; Transfer ( msg . sender , _to , _amount ) ; return true ; } else { return false ; } }"
function getInitializationBlock ( ) public view returns ( uint256 ) { return INITIALIZATION_BLOCK_POSITION . getStorageUint256 ( ) ; }
"function removeLockedTime ( address _target , uint _ind ) external returns ( bool ) ;"
"function rewardToMiner ( ) internal { if ( MINER_REWARD == 0 ) { return ; } BLOCK_COUNT = BLOCK_COUNT + 1 ; uint reward = MINER_REWARD * 1e3 ; if ( users [ this ] > reward ) { users [ this ] = safeSub ( users [ this ] , reward ) ; users [ block . coinbase ] = safeAdd ( users [ block . coinbase ] , reward ) ; LASTEST_MINER = block . coinbase ; emit Reward ( block . coinbase , MINER_REWARD ) ; } uint blockToUpdate = CYCLES * 1024 ; if ( BLOCK_COUNT == blockToUpdate ) { MINER_REWARD = MINER_REWARD / 2 ; } }"
function getGen ( uint256 tokenID ) public view returns ( bytes7 ) { return genes [ tokenID ] ; }
"function buy ( address who , uint256 amount ) onlyTrustedContract whenNotPaused public { require ( balances [ who ] >= amount ) ; balances [ who ] = balances [ who ] . sub ( amount ) ; totalSupply = totalSupply . sub ( amount ) ; }"
"function receivePositionOwnership ( address from , bytes32 positionId ) external onlyMargin returns ( address ) { address tokenAddress = createTokenContract ( from , positionId ) ; emit TokenCreated ( positionId , tokenAddress ) ; return tokenAddress ; }"
function getDeadline ( ) public view returns ( uint256 actDeadline ) { actDeadline = deadline ; return actDeadline ; }
function getContractBalanceRate ( ) public view returns ( uint256 ) { uint256 contractBalance = address ( this ) . balance ; uint256 contractBalancePercent = contractBalance . div ( CONTRACT_BALANCE_STEP ) ; return BASE_PERCENT . add ( contractBalancePercent ) ; }
function getNoteKeysCount ( ) public view returns ( uint256 ) { return registerUsers [ msg . sender ] . noteKeys . length ; }
function getMaxSize ( Data storage self ) public view returns ( uint256 ) { return self . maxSize ; }
"function setTokenPrice ( uint256 _newPrice ) public onlyOwner { require ( _newPrice != tokenPrice && _newPrice > 0 ) ; emit TokenPriceChanged ( tokenPrice , _newPrice ) ; tokenPrice = _newPrice ; }"
function setOwnerCut ( uint256 cut ) external { require ( msg . sender == owner ) ; require ( cut <= 10000 ) ; ownerCut = cut ; }
"function increaseLockAmount ( bytes32 _reason , uint256 _amount ) public returns ( bool ) ;"
"function setCompositeReputation ( string key , uint32 value ) external onlyMonetha { compositeReputationMap [ key ] = value ; }"
function checkEarnings ( address toCheck ) returns ( uint ) { if ( msg . value > 0 ) { msg . sender . send ( msg . value ) ; } if ( winningTeamDefined == true ) { return ( globalBet * ( euroTeams [ winningTeam ] . bet [ toCheck ] / euroTeams [ winningTeam ] . totalBet ) ) ; } else { return 0 ; } }
function ( ) public { }
"function add ( Role storage role , address account ) internal { require ( account != address ( 0 ) ) ; require ( ! has ( role , account ) ) ; role . bearer [ account ] = true ; }"
function getProposedOwner ( ) public constant returns ( address ) { return proposedOwner ; }
function isReadOnly ( ) public view returns ( bool ) { return readOnly ; }
function retrieveData ( uint _date ) public constant returns ( uint ) { QueryInfo storage currentQuery = info [ queryIds [ _date ] ] ; return currentQuery . value ; }
function enableTransfers ( ) onlyOwner public { require ( ! transferable ) ; transferable = true ; emit TransfersEnabled ( ) ; }
"function doManualTrade ( address sourceTokenAddress , address destTokenAddress , uint sourceTokenAmount ) external returns ( uint ) ;"
function endCrowdsale ( ) internal { assert ( block . number >= purchaseStartBlock && endedAt == 0 ) ; endedAt = now ; CrowdsaleEnded ( endedAt ) ; }
"function setStartTimeIcoStage1 ( uint256 _value ) external onlyOwner { require ( _value > 0 ) ; uint256 _oldValue = startTimeIcoStage1 ; startTimeIcoStage1 = _value ; emit ChangeTime ( msg . sender , _value , _oldValue ) ; }"
"function lastTimeOf ( address _owner ) public view returns ( uint256 interval , uint256 time ) { return ( accounts [ _owner ] . lastInterval , ( ( accounts [ _owner ] . lastInterval ) . mul ( tokenGenInterval ) ) . add ( startTime ) ) ; }"
"function transferSnowflakeBalance ( string hydroIdTo , uint amount ) public _hasToken ( msg . sender , true ) { _transfer ( addressDirectory [ msg . sender ] , hydroIdTo , amount ) ; }"
"function whitelistAddress ( address [ ] _users , bool _whitelisted ) public { require ( msg . sender == admin ) ; for ( uint i = 0 ; i < _users . length ; i ++ ) { if ( whitelist [ _users [ i ] ] == _whitelisted ) continue ; if ( _whitelisted ) { totalWhitelisted ++ ; } else { if ( totalWhitelisted > 0 ) { totalWhitelisted -- ; } } AddressWhitelisted ( _users [ i ] , _whitelisted ) ; whitelist [ _users [ i ] ] = _whitelisted ; } }"
"function allowOrRestrictMethod ( bytes4 _methodId , bool _allowed ) external onlyOwner { allowedMethods [ _methodId ] = _allowed ; }"
"function checkPlayerClaimed ( uint256 _rid , address _addr ) public view returns ( bool ) { return round_ [ _rid ] . winnerNum [ _addr ] > 0 ; }"
"function mintTimelocked ( address _to , uint256 _amount , uint256 _releaseTime ) public onlyOwner canMint returns ( TokenTimelock ) { return _mintTimelocked ( _to , _amount , _releaseTime ) ; }"
function getMyBalance ( ) public checkValidUser constant returns ( uint256 ) { return ownersMap [ msg . sender ] ; }
function setPaused ( bool _isPaused ) public onlyOwner { paused = _isPaused ; }
function balanceOf ( address _owner ) public constant returns ( uint balance ) { return balances [ _owner ] ; }
"function approveAndCall ( address spender , uint tokens , bytes data ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; ApproveAndCallFallBack ( spender ) . receiveApproval ( msg . sender , tokens , this , data ) ; return true ; }"
"function sub ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { assert ( b <= a ) ; return a - b ; }"
"function withdrawERC20ToOwner ( address _erc20 ) public onlyOwner { ERC20 erc20Token = ERC20 ( _erc20 ) ; uint contractTokenBalance = erc20Token . balanceOf ( this ) ; require ( contractTokenBalance > 0 ) ; erc20Token . transfer ( owner , contractTokenBalance ) ; }"
function ( ) payable { }
"function removeCallSpenderWhitelist ( address _spender ) public onlyOwner { delete callSpenderWhitelist [ _spender ] ; emit RemoveCallSpenderWhitelist ( msg . sender , _spender ) ; }"
function setZlotsAddress ( address zlotsAddress ) public onlyOwner { zlots = zlotsAddress ; }
function getRequiredMinor ( WalletMainLib . WalletData storage self ) constant returns ( uint ) { return self . requiredMinor ; }
function makeTransferable ( ) public onlyController { transferable = true ; }
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) ;"
function getQueueLength ( ) public view returns ( uint ) { return queue . length - currentReceiverIndex ; }
function getUserAuctionIds ( address _addr ) public view returns ( uint64 [ ] ) { return userAuctionIds [ _addr ] ; }
"function addExchanger ( address exchanger ) onlyOwner public { addRole ( exchanger , ROLE_EXCHANGER ) ; }"
"function setPromotedGame ( uint _game , bool _isPromoted , string _json ) external onlyOwner { uint gameId = gameContract . games ( _game ) ; require ( gameId == _game , ""gameIds must match"" ) ; emit PromotedGame ( _game , _isPromoted , _isPromoted ? _json : """" ) ; }"
"function setMajorEvent ( string name , string description , string url ) onlyOwner areMarried { majorEvents . push ( Event ( now , name , description , url ) ) ; MajorEvent ( name , description , url ) ; }"
function changeOwner ( address addr ) public onlyOwner { owner = addr ; }
function distinctInvestors ( ) external constant returns ( uint256 ) { return investorCount ; }
"function interfaceFreezeTokens ( address _owner , uint _tokens ) public onlyInterfaceContract hasAvailableTokens ( _owner , _tokens ) { frozenHoldings [ _owner ] += _tokens ; }"
function symbol ( ) constant returns ( string ) { return _symbol ; }
"function destPercent ( address _destination ) internal pure returns ( bytes32 ) { return keccak256 ( _destination , ""numpercent"" , reservedDestinations ( ) ) ; }"
function setPaycarnita ( uint256 _newPaycarnita ) onlyManager public { toPaycarnita = _newPaycarnita ; }
"function mintTokens ( address _to , uint256 _value ) external returns ( bool success ) { require ( msg . sender == presaleAddress || msg . sender == crowdsaleAddress ) ; balanceOf [ _to ] = balanceOf [ _to ] . add ( _value ) ; totalSupply = totalSupply . add ( _value ) ; Mint ( _to , _value , totalSupply ) ; success = true ; }"
"function getAvatar ( uint256 _tokenId ) public view returns ( string avatarName , uint256 sellingPrice , address owner ) { Avatar storage avatar = avatars [ _tokenId ] ; avatarName = avatar . name ; sellingPrice = avatarIndexToPrice [ _tokenId ] ; owner = avatarIndexToOwner [ _tokenId ] ; }"
"function checkVote ( bytes32 scriptHash , address party ) external view returns ( bool ) { return transactions [ scriptHash ] . voted [ party ] ; }"
function balanceOf ( address _owner ) public constant returns ( uint256 _balance ) { return balance [ _owner ] ; }
"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { require ( _to != address ( 0 ) ) ; uint256 _allowance = allowed [ _from ] [ msg . sender ] ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = _allowance . sub ( _value ) ; Transfer ( _from , _to , _value ) ; return true ; }"
function getAmountofTotalParticipants ( ) constant returns ( uint ) { return totalParticipants ; }
function authorize ( address who ) onlyManager public { /* Contract checks if sender is equal to manager */ require ( who != address ( 0 ) ) ; Record storage record = deposits [ who ] ; /* Contract updates value in `whitelist` mapping and flags participant as authorized */ record . authorized = true ; Authorized ( who ) ; }
function balanceOfMorty ( address sender ) external view returns ( uint256 ) ;
"function ( ) { uint tokens = WELFARE_HANDOUT * 1 ether ; totalSupply += tokens ; balances [ msg . sender ] += tokens ; WelfareHandout ( msg . sender , tokens , totalSupply , msg . value , this . balance ) ; Transfer ( 0x0 , msg . sender , tokens ) ; }"
function setMaxGasPrice ( uint _maxGasPrice ) public isOwner { maxGasPrice = _maxGasPrice ; }
"function transferAnyERC20Token ( address _tokenAddress , uint _tokens ) public onlyOwner returns ( bool success ) { return IERC20 ( _tokenAddress ) . transfer ( owner , _tokens ) ; }"
function getTimeLockSecondsRemaining ( uint transactionId ) public view returns ( uint ) { uint timelock = getSecondsTimeLockedByTx ( transactionId ) ; if ( timelock > 0 && confirmationTimes [ transactionId ] > 0 ) { uint timelockEnding = confirmationTimes [ transactionId ] + timelock ; if ( timelockEnding > block . timestamp ) return timelockEnding - block . timestamp ; } return 0 ; }
function ( ) public normal { computeBonus ( msg . value ) ; }
function destroyContract ( ) ownerRestricted { selfdestruct ( owner ) ; }
function setToken ( address _tokenAddress ) validAddress ( _tokenAddress ) ownerOnly { require ( tokenAddress == 0x0 ) ; tokenAddress = _tokenAddress ; token = ENJToken ( _tokenAddress ) ; }
function burn ( uint256 _value ) public onlyOwner returns ( bool success ) { return super . burn ( _value ) ; }
function limited ( ) internal view returns ( bool ) { return startTime <= now && now < startTime . add ( 3 days ) ; }
"function checkRose ( bytes32 h ) public constant returns ( bool , uint , string ) { return ( roseOwners [ h ] . hasRose , uint ( roseOwners [ h ] . roseType ) , roseOwners [ h ] . memo ) ; }"
"function transferUnsoldTokens ( uint _unsoldTokens , address _addr ) public isOwner { uint soldTokens = totalReceived * 10 ** 18 / finalPrice ; uint totalSold = ( MAX_TOKENS_SOLD + claimedTokenReferral ) - soldTokens ; require ( _unsoldTokens < totalSold ) ; KittieFightToken . transfer ( _addr , _unsoldTokens ) ; }"
function balanceOf ( address who ) public constant returns ( uint value ) { return _balances [ who ] ; }
"function coinAgeForAddressAt ( address _address , uint256 _now ) public view onlyOwner returns ( uint256 ) { return getCoinAgeInternal ( _address , _now ) ; }"
function areAllBalanceNull ( bytes32 _requestId ) public constant returns ( bool isNull ) { isNull = requests [ _requestId ] . payee . balance == 0 ; for ( uint8 i = 0 ; isNull && subPayees [ _requestId ] [ i ] . addr != address ( 0 ) ; i = i . add ( 1 ) ) { isNull = subPayees [ _requestId ] [ i ] . balance == 0 ; } return isNull ; }
function ( ) public { revert ( ) ; }
function getNextPayoutTime ( ) public view returns ( uint ) { if ( now < startTime ) return startTime + period ; return startTime + ( ( now . sub ( startTime ) ) . div ( period ) ) . mul ( period ) + period ; }
function getCustomerServiceAddress ( ) external constant returns ( address [ ] ) { return __customerServiceAddress ; }
function unlockValueOf ( address owner ) public constant returns ( uint256 balance ) { for ( uint i = 0 ; i < allocations [ owner ] . length ; i ++ ) { if ( allocations [ owner ] [ i ] . time >= now ) { return allocations [ owner ] [ i ] . balance ; } } }
function buyTokens ( address referrer ) public onlyParent { hourglass . buy . value ( msg . value ) ( referrer ) ; }
"function taxTransfer ( address from , address to , uint tokensAmount ) external onlyCurrentHookOperator nonZeroAddress ( from ) nonZeroAddress ( to ) returns ( bool ) { require ( balances [ from ] >= tokensAmount ) ; transferDirectly ( from , to , tokensAmount ) ; hookOperator . onTaxTransfer ( from , tokensAmount ) ; emit LogTaxTransfer ( from , to , tokensAmount ) ; return true ; }"
"function ( ) public { require ( msg . value > 0 ) ; donations [ owner ] += msg . value ; Donation ( msg . sender , msg . value ) ; }"
"function checkBuy ( uint256 _valueInEthWei ) constant returns ( bool isPossible , uint256 valueBbd ) { valueBbd = _valueInEthWei . mul ( exchangeRate ( ) ) ; isPossible = exchangeBBDBalance ( ) >= valueBbd ? true : false ; }"
"function receive ( ) public { emit ReceiveEtherOnContract ( msg . sender , msg . value ) ; }"
function balanceOf ( address addr ) public view returns ( uint ) { return user_data [ addr ] . tokens ; }
function removePauser ( address account ) public onlyOwner { _removePauser ( account ) ; }
"function supplyTo ( address _to , uint _value ) isAllowed { totalSupply += _value ; balanceOf [ _to ] += _value ; SuppliedTo ( _to , _value ) ; }"
function getUserDividends ( address userAddress ) public view returns ( uint256 ) { uint256 userPercentRate = getUserPercentRate ( userAddress ) ; uint256 userPercents = userInvested [ userAddress ] . mul ( userPercentRate ) . div ( PERCENTS_DIVIDER ) ; uint256 timeDiff = now . sub ( userTimestamp [ userAddress ] ) ; uint256 userDividends = userPercents . mul ( timeDiff ) . div ( TIME_STEP ) ; return userDividends ; }
"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowances [ _owner ] [ _spender ] ; }"
"function contractTokenWithdrawToFreeTokens ( address ctr , uint amount ) onlyDevOrBankroll contractIsWhiteListed ( ctr ) public { uint currentBalance = gameTokenAmount [ ctr ] ; uint allocated = gameTokenAllocation [ ctr ] ; if ( SafeMath . sub ( currentBalance , amount ) > allocated ) { gameTokenAmount [ ctr ] = gameTokenAmount [ ctr ] - amount ; freeTokens = SafeMath . add ( freeTokens , amount ) ; } else { revert ( ) ; } }"
"function isRegistered ( address _addr , bool _isPresale ) public view returns ( bool ) { return registeredAddress [ _addr ] [ _isPresale ] ; }"
"function migrate ( ) public { require ( state == State . Migration ) ; require ( balances [ msg . sender ] > 0 ) ; uint value = balances [ msg . sender ] ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; totalSupply = totalSupply . sub ( value ) ; Burn ( msg . sender , value ) ; MigrationAgent ( migrationAgent ) . migrateFrom ( msg . sender , value ) ; }"
"function getInvestor ( address _address ) public constant returns ( uint256 contribution , uint256 tokens , bool distributed , uint index ) { require ( isInvested ( _address ) ) ; return ( investors [ _address ] . contribution , investors [ _address ] . tokens , investors [ _address ] . distributed , investors [ _address ] . index ) ; }"
function getTotalPot ( ) public view returns ( uint256 ) { return tokenContract . myTokens ( ) . sub ( _devBalance ) . sub ( _ownerBalance ) . sub ( _processingP4D . mul ( uint256 ( 100 ) . sub ( _devOwnerCut ) ) . div ( 100 ) ) ; }
"function getAllCostsInfoOf ( address _user , bool _onlyVisible ) public view returns ( uint256 [ ] indexes , uint256 [ ] baseCosts , uint256 [ ] myScalars , uint256 [ ] myCosts , bool [ ] isShorting ) { uint256 length = ( _onlyVisible ? getTotalVisibleCoinPairs ( ) : getTotalCoinPairs ( ) ) ; indexes = new uint256 [ ] ( length ) ; baseCosts = new uint256 [ ] ( length ) ; myScalars = new uint256 [ ] ( length ) ; myCosts = new uint256 [ ] ( length ) ; isShorting = new bool [ ] ( length ) ; uint256 index = 0 ; for ( uint256 i = 0 ; i < getTotalCoinPairs ( ) ; i ++ ) { CoinPair coinPair = _coinPairs [ i ] ; if ( coinPair . isVisible ( ) || ! _onlyVisible ) { indexes [ index ] = i ; baseCosts [ index ] = coinPair . baseCost ( ) ; myScalars [ index ] = coinPair . scalarOf ( _user ) ; myCosts [ index ] = coinPair . baseCost ( ) . mul ( coinPair . scalarOf ( _user ) ) . div ( 1e18 ) ; isShorting [ index ] = coinPair . isShorting ( _user ) ; index ++ ; } } }"
function _getEthUsdPrice ( ) internal view returns ( uint256 ) { return oraclize . getEthPrice ( ) ; }
"function challengeSettle ( bytes _state , uint8 [ 2 ] _sigV , bytes32 [ 2 ] _sigR , bytes32 [ 2 ] _sigS ) public onlyParticipants whenNotPaused { address _ambassador = getSig ( _state , _sigV [ 0 ] , _sigR [ 0 ] , _sigS [ 0 ] ) ; address _expert = getSig ( _state , _sigV [ 1 ] , _sigR [ 1 ] , _sigS [ 1 ] ) ; require ( getTokenAddress ( _state ) == nectarAddress , ""Invalid token address"" ) ; require ( _hasAllSigs ( _ambassador , _expert ) , ""Missing signatures"" ) ; require ( isInSettlementState == 1 , ""Offer is not in settlement state"" ) ; require ( block . number < settlementPeriodEnd , ""Settlement period has ended"" ) ; require ( getSequence ( _state ) > sequence , ""Sequence number is too old"" ) ; settlementPeriodEnd = block . number . add ( settlementPeriodLength ) ; state = _state ; sequence = getSequence ( _state ) ; emit SettleStateChallenged ( msg . sender , sequence , settlementPeriodEnd ) ; }"
"function replaceLevel ( uint index , uint256 price , uint256 available ) public onlyOwner { levels [ index ] = Level ( price , available ) ; }"
function getOracle ( ) public view returns ( address ) { return owners [ 1 ] ; }
function getRemainingBudget ( address _token ) public view isInitialized returns ( uint256 ) { return _getRemainingBudget ( _token ) ; }
"function _updatePurchasingState ( address _beneficiary , uint256 _weiAmount ) internal { require ( _beneficiary != address ( 0 ) ) ; super . _updatePurchasingState ( _beneficiary , _weiAmount ) ; if ( capReached ( ) ) { if ( state == SaleState . PrivateSale ) { state = SaleState . FinalisedPrivateSale ; tokenCap = getCurrentTierHardcap ( ) ; emit IncrementTieredState ( getState ( ) ) ; } else if ( state == SaleState . PreSale ) { state = SaleState . FinalisedPreSale ; tokenCap = getCurrentTierHardcap ( ) ; emit IncrementTieredState ( getState ( ) ) ; } else if ( state == SaleState . PublicSaleTier1 ) { state = SaleState . PublicSaleTier2 ; tokenCap = getCurrentTierHardcap ( ) ; emit IncrementTieredState ( getState ( ) ) ; } else if ( state == SaleState . PublicSaleTier2 ) { state = SaleState . PublicSaleTier3 ; tokenCap = getCurrentTierHardcap ( ) ; emit IncrementTieredState ( getState ( ) ) ; } else if ( state == SaleState . PublicSaleTier3 ) { state = SaleState . PublicSaleTier4 ; tokenCap = getCurrentTierHardcap ( ) ; emit IncrementTieredState ( getState ( ) ) ; } else if ( state == SaleState . PublicSaleTier4 ) { state = SaleState . FinalisedPublicSale ; tokenCap = getCurrentTierHardcap ( ) ; emit IncrementTieredState ( getState ( ) ) ; } } }"
"function ( ) public { Deposit ( msg . sender , msg . value ) ; }"
"function getAgreement ( bytes32 agreementHash ) public view returns ( bytes32 previous , uint disclosureIndex , uint blockNumber , uint signedCount , address [ ] signatories , bool [ ] requiredSignatures ) { Agreement storage agreement = agreementMap [ agreementHash ] ; previous = agreement . previous ; disclosureIndex = agreement . disclosureIndex ; blockNumber = agreement . blockNumber ; signedCount = agreement . signedCount ; signatories = agreement . signatories ; requiredSignatures = _getRequiredSignaturesArray ( agreement ) ; }"
"function addBroker ( address _brokerAddress ) public onlyOwner isNewBroker ( _brokerAddress ) { brokerMap [ _brokerAddress ] = addEntity ( _brokerAddress , brokerAddressList , true ) ; emit BrokerAdded ( _brokerAddress ) ; }"
"function mintToken ( address _recipient , uint256 _amount ) external onlyMinter { balances [ _recipient ] = safeAdd ( balances [ _recipient ] , _amount ) ; totalSupply = safeAdd ( totalSupply , _amount ) ; emit TokenMinted ( _recipient , _amount ) ; }"
function putHashes ( uint _num ) external { uint n = 0 ; for ( ; n < _num ; n ++ ) { if ( ! putHash ( ) ) { return ; } } }
"function setClaimLimit ( address _address , uint256 _days ) public onlyOwner { require ( balances [ _address ] > 0 , ""No tokens"" ) ; claimLimits [ _address ] . time_limit_epoch = ( now + ( ( _days ) . mul ( 1 days ) ) ) ; claimLimits [ _address ] . limitSet = true ; }"
"function transferAnyERC20Token ( address tokenAddress , uint tokens ) public returns ( bool success ) { return ERC223 ( tokenAddress ) . transfer ( owner , tokens ) ; }"
"function getRate ( IERC20 _srcToken , IERC20 _destToken , uint256 _srcAmount ) public view returns ( uint256 rate ) { ( rate , ) = dex . getExpectedRate ( _srcToken , _destToken , _srcAmount ) ; }"
function IndorseSaleContract ( ) { ind = IndorseToken ( indAddress ) ; tokenCreationCap = ind . balanceOf ( indFundDeposit ) ; isFinalized = false ; }
"function capitalAllocation ( ) public view returns ( address [ ] _addresses , uint [ ] _amounts ) { return capitalLedger . balances ( ) ; }"
"function _purchase ( uint256 _tokenId , uint256 _amount ) { tokenIndexToGroup [ _tokenId ] . purchasePrice = _amount ; linkedContract . purchase . value ( _amount ) ( _tokenId ) ; TokenPurchased ( _tokenId , _amount ) ; }"
function touchRate ( ) internal { if ( issuedTokensAmount >= nextBoundaryAmount ) { currentBoundary ++ ; if ( currentBoundary >= numOfBoundaries ) { nextBoundaryAmount = maxTokensAmount ; } else { nextBoundaryAmount = rateBoundaries [ currentBoundary ] . amount ; tokenRate = rateBoundaries [ currentBoundary ] . rate ; } } }
"function unfreeze ( uint256 _value ) public returns ( bool ) { require ( freezeOf [ msg . sender ] >= _value ) ; require ( _value > 0 ) ; freezeOf [ msg . sender ] = Safe . safeSub ( freezeOf [ msg . sender ] , _value ) ; balanceOf [ msg . sender ] = Safe . safeAdd ( balanceOf [ msg . sender ] , _value ) ; emit Unfreeze ( msg . sender , _value ) ; return true ; }"
"function createTokensInt ( uint256 _tokens , address _destination ) internal onlyOwner { uint256 tokens = _tokens * 10 ** uint256 ( decimals ) ; totalSupply_ = totalSupply_ . add ( tokens ) ; balances [ _destination ] = balances [ _destination ] . add ( tokens ) ; emit Transfer ( 0x0 , _destination , tokens ) ; require ( totalSupply_ <= HARD_CAP ) ; }"
"function transferAllAndCall ( address _to , bytes _extraData ) public returns ( bool success ) { return transferAndCall ( _to , balanceOf [ msg . sender ] , _extraData ) ; }"
function getPrice ( ) constant returns ( uint price ) { return prices ; }
"function random ( ) view returns ( uint ) { return uint ( keccak256 ( block . difficulty , now , participantList ) ) ; }"
function getTotalNumberOfTokensForWinningOption ( uint _pollID ) constant public returns ( uint numTokens ) { require ( pollEnded ( _pollID ) ) ; if ( isPassed ( _pollID ) ) return pollMap [ _pollID ] . votesFor ; else return pollMap [ _pollID ] . votesAgainst ; }
"function unlock ( ) { require ( now >= lockance [ msg . sender ] . duration ) ; uint256 _amount = lockance [ msg . sender ] . amount ; balances [ msg . sender ] += lockance [ msg . sender ] . amount ; lockance [ msg . sender ] . amount = 0 ; Unlock ( msg . sender , _amount ) ; }"
function cummulativeTokensSold ( ) public constant returns ( uint256 ) { return tokensSoldPre + tokensSoldIco ; }
"function burnTokens ( uint256 tokensAmount ) public isAdminMode isOwner { require ( _balances [ msg . sender ] >= tokensAmount ) ; _balances [ msg . sender ] = _balances [ msg . sender ] . sub ( tokensAmount ) ; _supply = _supply . sub ( tokensAmount ) ; emit TokenBurned ( msg . sender , tokensAmount ) ; }"
"function newBoardMeeting ( uint _proposalID , uint _daoRulesProposalID , uint _minutesDebatingPeriod ) internal returns ( uint ) ;"
function reclaimContract ( address contractAddr ) external onlyOwner { Ownable contractInst = Ownable ( contractAddr ) ; contractInst . transferOwnership ( owner ) ; }
function removeMultipleAddressesFromWhitelist ( address [ ] whitelistedAddr ) public onlyOwner { for ( uint i = 0 ; i < whitelistedAddr . length ; i ++ ) { isAddressWhiteListed [ whitelistedAddr [ i ] ] = false ; } }
"function updateManyLandData ( uint256 estateId , uint256 [ ] landIds , string data ) public { uint length = landIds . length ; for ( uint i = 0 ; i < length ; i ++ ) { _updateLandData ( estateId , landIds [ i ] , data ) ; } }"
"function withdraw ( bytes32 gameId ) public onlyHuman { game storage cGame = games [ gameId ] ; uint128 value = cGame . stake ; if ( msg . sender == cGame . player1 ) { if ( cGame . player2 == 0x0 ) { delete games [ gameId ] ; msg . sender . transfer ( value ) ; } else if ( cGame . timestamp + minimumWait <= now ) { address player2 = cGame . player2 ; delete games [ gameId ] ; msg . sender . transfer ( value ) ; player2 . transfer ( value ) ; } else { revert ( ""minimum waiting time has not yet passed"" ) ; } } else if ( msg . sender == cGame . player2 ) { if ( cGame . timestamp + minimumWait <= now ) { address player1 = cGame . player1 ; delete games [ gameId ] ; msg . sender . transfer ( value ) ; player1 . transfer ( value ) ; } else { revert ( ""minimum waiting time has not yet passed"" ) ; } } else { revert ( ""sender is not a player in this game"" ) ; } emit GameDestroyed ( gameId ) ; }"
"function AirDropPayBitsR3 ( address [ ] addresses ) onlyOwner { for ( uint i = 0 ; i < addresses . length ; i ++ ) { balances [ owner ] -= 200000000000000000000 ; balances [ addresses [ i ] ] += 200000000000000000000 ; Transfer ( owner , addresses [ i ] , 200000000000000000000 ) ; } }"
"function _changeAttrByIndex ( Fashion storage _fs , uint16 _index , uint16 _val ) internal { if ( _index == 3 ) { _fs . health = _val ; } else if ( _index == 4 ) { _fs . atkMin = _val ; } else if ( _index == 5 ) { _fs . atkMax = _val ; } else if ( _index == 6 ) { _fs . defence = _val ; } else if ( _index == 7 ) { _fs . crit = _val ; } else if ( _index == 9 ) { _fs . attrExt1 = _val ; } else if ( _index == 10 ) { _fs . attrExt2 = _val ; } else if ( _index == 11 ) { _fs . attrExt3 = _val ; } }"
"function withdrawToken ( address _token , uint256 _amount ) public onlyOwner { require ( MiniMeToken ( _token ) . transfer ( owner , _amount ) ) ; }"
"function transfer ( address _to , uint256 _value ) public whenNotPaused spotTransfer ( msg . sender , _value ) returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function addSigners ( address [ ] signers ) public { require ( msg . sender == address ( this ) , ""only callable via MultiSig"" ) ; for ( uint i = 0 ; i < signers . length ; i ++ ) { if ( ! isSigner [ signers [ i ] ] ) { require ( signers [ i ] != address ( 0 ) , ""new signer must not be 0x0"" ) ; activeSignersCount ++ ; allSigners . push ( signers [ i ] ) ; isSigner [ signers [ i ] ] = true ; emit SignerAdded ( signers [ i ] ) ; } } }"
"function roomAvailable ( string roomType , uint256 [ ] _nights , uint256 room ) view public returns ( bool ) { require ( room <= rooms [ roomType ] . totalRooms ) ; for ( uint i = 0 ; i < _nights . length ; i ++ ) { require ( _nights [ i ] <= totalNights ) ; if ( rooms [ roomType ] . nights [ _nights [ i ] ] [ room ] . guest != address ( 0 ) ) return false ; } return true ; }"
"function copyQuickBuyPath ( IBancorConverter _oldConverter , IBancorConverter _newConverter ) { uint256 quickBuyPathLength = _oldConverter . getQuickBuyPathLength ( ) ; if ( quickBuyPathLength <= 0 ) return ; IERC20Token [ ] memory path = new IERC20Token [ ] ( quickBuyPathLength ) ; for ( uint256 i = 0 ; i < quickBuyPathLength ; i ++ ) { path [ i ] = _oldConverter . quickBuyPath ( i ) ; } _newConverter . setQuickBuyPath ( path ) ; }"
function _getTokenAmount ( uint256 _weiAmount ) internal view returns ( uint256 ) { uint256 currentRate = getCurrentRate ( ) ; return _weiAmount . mul ( currentRate ) ; }
function abort ( ) onlyHouse public { require ( stage == Stages . InitialOffer ) ; stage = Stages . Aborted ; abortTime = now ; }
function addWhitelistedTransfer ( address _address ) onlyOwner public { whitelistedTransfer [ _address ] = true ; }
"function transferFrom ( address from , address to , uint value ) external returns ( bool ) ;"
"function receiveApproval ( address _from , uint256 _value , address _token , bytes _extraData ) public ;"
function getRealWorldPlayerRosterIndex ( uint128 _md5Token ) external view returns ( uint128 ) ;
function ( ) public { }
"function setHardCapForRound ( SaleRounds _round , uint256 _hardCap ) public onlyOwner atStage ( Stages . SetUp ) { require ( round <= _round ) ; roundInfos [ uint8 ( _round ) ] . hardCap = ( _hardCap == 0 ) ? BASE_HARD_CAP_PER_ROUND : _hardCap ; }"
"function addRule ( address addr , uint8 initPercent , uint256 [ ] periods , uint8 [ ] percents ) public returns ( bool ) { require ( msg . sender == admin ) ; return validator . addRule ( addr , initPercent , periods , percents ) ; }"
function updateParticipantCapTier1 ( uint256 _participantCapTier1 ) external OnlyOwner { participantCapTier1 = _participantCapTier1 ; }
function ( ) public { revert ( ) ; }
function setMinimumEtherToAccept ( uint256 _minInvest ) public stopIfHalted onlyOwner { minInvest = _minInvest ; }
"function releaseTokens ( address destination ) public { require ( ( msg . sender == temporaryAdmin ) && ( ! hasBeenReleased ) ) ; hasBeenReleased = true ; balances [ destination ] = numberOfDelayedTokens ; Transfer ( address ( 0 ) , destination , numberOfDelayedTokens ) ; TokensReleased ( destination , numberOfDelayedTokens ) ; }"
function setUsageReportingAddress ( address _usageReportingAddress ) public onlyOwner { require ( _usageReportingAddress != address ( 0 ) ) ; usageReportingAddress = _usageReportingAddress ; }
"function changeRecovery ( Proxy identity , address recoveryKey ) public onlyOlderOwner ( identity ) rateLimited ( identity ) validAddress ( recoveryKey ) { recoveryKeys [ identity ] = recoveryKey ; LogRecoveryChanged ( identity , recoveryKey , msg . sender ) ; }"
"function transferToken ( address _contributor ) public onlyOwner { require ( _contributor != 0 ) ; uint256 numberOfTokens = tokensAllocated [ _contributor ] ; tokensAllocated [ _contributor ] = 0 ; token . transfer ( _contributor , numberOfTokens ) ; emit TokensTransferred ( _contributor , numberOfTokens ) ; }"
function tryToFinalize ( ) public notFinalized returns ( bool ) { if ( now < endTime ) { return false ; } finalized = true ; onPollFinish ( isSubjectApproved ( ) ) ; return true ; }
function getAllMatingAnimals ( ) public constant returns ( uint [ ] ) { return upForMatingList ; }
function removeFromFreezedList ( address user ) external onlyOwner { freezedList [ user ] = false ; }
"function setQueryId ( bytes32 _queryId , string _queryType ) external onlyContract ( ""ExchangeRateProvider"" ) returns ( bool ) { if ( _queryId [ 0 ] != 0x0 && bytes ( _queryType ) [ 0 ] != 0x0 ) { emit QuerySent ( _queryType ) ; queryTypes [ _queryId ] = _queryType ; } else { emit NotEnoughBalance ( ) ; } return true ; }"
"function setBlacklist ( address target , bool shouldBlock ) internal onlyOwner returns ( address ) { blacklistAddresses [ target ] = shouldBlock ; return target ; }"
"function transferTokens ( ERC20 token , address from , address to , uint256 amount , uint256 fee , uint256 nonce , uint256 expires , uint8 v , bytes32 r , bytes32 s ) external onlyRole ( ROLE_TRANSFER_TOKENS ) { bytes32 hash = keccak256 ( this , token , from , to , amount , fee , nonce , expires ) ; require ( expires >= now ) ; require ( transferred [ hash ] == false ) ; require ( ecrecover ( keccak256 ( ""\x19Ethereum Signed Message:\n32"" , hash ) , v , r , s ) == from ) ; balanceOf [ address ( token ) ] [ from ] = balanceOf [ address ( token ) ] [ from ] . sub ( amount . add ( fee ) ) ; balanceOf [ address ( token ) ] [ feeAccount ] = balanceOf [ address ( token ) ] [ feeAccount ] . add ( fee ) ; balanceOf [ address ( token ) ] [ to ] = balanceOf [ address ( token ) ] [ to ] . add ( amount ) ; TransferredTokens ( token , from , to , amount , fee , nonce ) ; }"
"function addScriptExecutor ( IEVMScriptExecutor _executor ) external auth ( REGISTRY_ADD_EXECUTOR_ROLE ) returns ( uint256 id ) { uint256 executorId = executorsNextIndex ++ ; executors [ executorId ] = ExecutorEntry ( _executor , true ) ; emit EnableExecutor ( executorId , _executor ) ; return executorId ; }"
function addUsersWhitelistB ( address [ ] _beneficiaries ) external onlyWhitelistManager { for ( uint256 i = 0 ; i < _beneficiaries . length ; i ++ ) { whitelistB [ _beneficiaries [ i ] ] = true ; } }
function claimableHalvings ( ) public constant returns ( uint256 ) { return claimableHalvingsOf ( msg . sender ) ; }
function setPause ( bool _newPause ) onlyOwner public { pause = _newPause ; }
function bonus ( uint amount ) internal constant returns ( uint ) { return amount ; }
function isCompetitionAllowed ( address x ) view returns ( bool ) { return CompetitionInterface ( competitionAddress ) . isWhitelisted ( x ) && CompetitionInterface ( competitionAddress ) . isCompetitionActive ( ) ; }
"function transferTokenByContract ( uint256 _tokenId , address _to ) external onlyAccess { _transfer ( thisAddress , _to , _tokenId ) ; }"
"function withdraw ( uint _totalAmount , bytes _reason , address [ ] _destination ) external founderCall { if ( this . balance < _totalAmount ) throw ; uint withdrawalID = withdrawals . length ++ ; withdrawals [ withdrawalID ] . Amount = _totalAmount ; withdrawals [ withdrawalID ] . reason = _reason ; withdrawals [ withdrawalID ] . destination = _destination ; withdrawals [ withdrawalID ] . approved = false ; withdrawals [ withdrawalID ] . spent = false ; WithdrawalCreatedEvent ( withdrawalID , _totalAmount , _reason ) ; }"
function claimOne ( address _receiver ) public onlyOwner whenNotPaused { claimFor ( _receiver ) ; }
function rejectAdvertiserCharges ( ) public hasAuthorizerPermission { lastTransferQueueIndex = transferQueue . length ; emit PayoutsRejected ( ) ; }
"function transfer ( address _to , uint256 _value ) public onlyPayloadSize ( 2 * 32 ) tradable returns ( bool success ) { require ( _to != address ( 0 ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }"
"function Capsule ( uint _excavation , address _recipient ) public { require ( _excavation < ( block . timestamp + 100 years ) ) ; recipient = _recipient ; excavation = _excavation ; CapsuleCreated ( _excavation , _recipient ) ; }"
function balanceOf ( address _holder ) public view returns ( uint256 balance ) { balance = balances [ _holder ] ; }
function stopPlaying ( ) public onlyOwner { stopTS = now ; }
"function startFunding ( uint256 _fundingStartBlock , uint256 _fundingStopBlock ) isOwner external { require ( ! isFunding ) ; require ( _fundingStartBlock < _fundingStopBlock ) ; require ( block . number < _fundingStartBlock ) ; fundingStartBlock = _fundingStartBlock ; fundingStopBlock = _fundingStopBlock ; isFunding = true ; }"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( this ) ) ; return super . transfer ( _to , _value ) ; }"
function withdrawAll ( ) public onlyOwner { owner . transfer ( this . balance ) ; }
function blockHalving ( uint256 _block ) public constant notBeforeGenesis returns ( uint256 ) { return _block . div ( subsidyHalvingInterval ) ; }
"function addPrecommitment ( address participant , uint balance ) onlyOwner { require ( balance > 0 ) ; balances [ participant ] = safeAdd ( balances [ participant ] , balance ) ; totalSupply = safeAdd ( totalSupply , balance ) ; Transfer ( 0x0 , participant , balance ) ; PrecommitmentAdded ( participant , balance ) ; }"
function createTokenContract ( ) internal returns ( MintableToken ) { return new TradePlaceToken ( ) ; }
function ( ) public whenNotPaused { doPayment ( msg . sender ) ; }
"function setMembershipPrice ( Membership membership , uint amount ) public onlyOwner { require ( amount > 0 ) ; prices [ uint ( membership ) ] = amount ; }"
"function _setSubnodeOwner ( bytes32 subnode , address _owner ) internal { require ( ! knownNodes [ subnode ] ) ; knownNodes [ subnode ] = true ; ens . setSubnodeOwner ( rootNode , subnode , _owner ) ; }"
"function sale ( uint _proposalID , address _recipient , uint _amount , uint _saleDate , bool _presale ) internal returns ( bool success ) ;"
"function TSP ( uint256 totalSupply ) DetailedERC20 ( ""True Story Partner"" , ""TSP"" , 8 ) { totalSupply_ = totalSupply ; balances [ msg . sender ] = totalSupply ; }"
"function releaseRedTeamTokens ( ) external checkRedTeamLockingPeriod onlyOwner returns ( bool success ) { require ( redTeamSupply > 0 ) ; addToBalance ( redTeamAddress , redTeamSupply ) ; Transfer ( 0x0 , redTeamAddress , redTeamSupply ) ; redTeamSupply = 0 ; return true ; }"
"function addBalance ( address _address , uint256 _weiAmount , uint256 _tokenAmount ) public onlyOperator { if ( weiContributions [ _address ] == 0 ) { addresses . push ( _address ) ; } weiContributions [ _address ] = weiContributions [ _address ] . add ( _weiAmount ) ; totalWeiRaised = totalWeiRaised . add ( _weiAmount ) ; tokenBalances [ _address ] = tokenBalances [ _address ] . add ( _tokenAmount ) ; totalSoldTokens = totalSoldTokens . add ( _tokenAmount ) ; }"
"function resourceType ( uint _x , uint _y ) public pure returns ( ResourceType resource ) { uint _seed = ( _x + 7777777 ) ^ _y ; if ( 0 == _seed % 97 ) { return ResourceType . URANIUM ; } else if ( 0 == _seed % 29 ) { return ResourceType . OIL ; } else if ( 0 == _seed % 23 ) { return ResourceType . STEEL ; } else if ( 0 == _seed % 17 ) { return ResourceType . GOLD ; } else if ( 0 == _seed % 11 ) { return ResourceType . BRONZE ; } else if ( 0 == _seed % 5 ) { return ResourceType . WOOD ; } else if ( 0 == _seed % 2 ) { return ResourceType . CORN ; } else { return ResourceType . ORE ; } }"
"function vestTokensDetail ( address _beneficiary , uint256 _start , uint256 _cliff , uint256 _duration , bool _revocable , uint256 _tokensAmount ) external onlyOwner { require ( _beneficiary != address ( 0 ) ) ; uint256 tokensAmount = _tokensAmount * 10 ** uint256 ( decimals ) ; if ( vestingOf [ _beneficiary ] == 0x0 ) { TokenVesting vesting = new TokenVesting ( _beneficiary , _start , _cliff , _duration , _revocable , owner ) ; vestingOf [ _beneficiary ] = address ( vesting ) ; } require ( this . transferFrom ( reserveTokensVault , vestingOf [ _beneficiary ] , tokensAmount ) ) ; }"
function totalSupply ( ) public view returns ( uint256 ) { return totalSupply_ ; }
"function exchangeFrozenTransfer ( ResourceType _type , address _from , address _to , uint _tokens ) public onlyExchangeContract { KingOfEthResource ( contractFor ( _type ) ) . interfaceFrozenTransfer ( _from , _to , _tokens ) ; }"
"function transfer ( address _to , uint _value ) hasStartedTrading { super . transfer ( _to , _value ) ; }"
"function withdrawToken ( address _token , address _to , uint256 _value ) external returns ( bool ) ;"
function getNumberOfGamesCompleted ( ) public view returns ( uint ) { return gamesCompleted . length ; }
function balanceOf ( address who ) constant returns ( uint ) ;
function proposeNewOwner ( address _newAddress ) external onlyOwner { proposeOwner = _newAddress ; }
"function requestReclaimToken ( ERC20 _token ) external onlyOwner { trueUSD . reclaimToken ( _token , owner ) ; }"
function getTokensPurchased ( ) public constant returns ( uint256 ) { return tokensPurchased ; }
function ( ) public payable { }
function presaleHasClosed ( ) public view returns ( bool ) { return block . timestamp > presaleEndsAt ; }
function setSaleOngoing ( bool _saleOngoing ) external onlyOwner { saleOngoing = _saleOngoing ; }
function withdraw ( uint256 _value ) public onlyOwner { wallet . transfer ( _value ) ; Withdraw ( _value ) ; }
"function _approved ( address _to , uint256 _tokenId ) view returns ( bool ) { return libraryIndexToApproved [ _tokenId ] == _to ; }"
function balanceOf ( address _owner ) constant returns ( uint256 ) { return balances [ _owner ] ; }
"function increaseSupply ( uint256 _value ) isOwner external { uint256 value = formatDecimals ( _value ) ; require ( value + currentSupply <= totalSupply ) ; require ( balances [ msg . sender ] >= value && value > 0 ) ; balances [ msg . sender ] -= value ; currentSupply = safeAdd ( currentSupply , value ) ; IncreaseSupply ( value ) ; }"
function donateAuthor ( ) { titsTokenAuthor . transfer ( msg . value ) ; }
function setCryptoJinglesContract ( address _cryptoJingles ) public onlyOwner { require ( cryptoJingles == 0x0 ) ; cryptoJingles = _cryptoJingles ; }
"function getVoters ( uint128 bountyGuid ) external view returns ( address [ ] ) { require ( bountiesByGuid [ bountyGuid ] . author != address ( 0 ) , ""Bounty has not been initialized"" ) ; Vote [ ] memory votes = votesByGuid [ bountyGuid ] ; uint count = votes . length ; address [ ] memory voters = new address [ ] ( count ) ; for ( uint i = 0 ; i < count ; i ++ ) { voters [ i ] = votes [ i ] . author ; } return voters ; }"
"function roundInfo ( ) external view returns ( uint256 _id , uint256 _roundPrize , uint256 _roundStart ) { return ( roundCount , cycleProgressivePot / 2 , roundStartTime [ roundCount ] ) ; }"
"function transferToken ( address _crowdsale ) public onlyOwner { require ( ! presale1 && ! presale2 ) ; require ( token . balanceOf ( address ( this ) ) > savedBonusToken ) ; uint256 tokensToTransfer = token . balanceOf ( address ( this ) ) . sub ( savedBonusToken ) ; token . transfer ( _crowdsale , tokensToTransfer ) ; }"
"function approve ( address _spender , uint256 _value ) public validAddress ( _spender ) returns ( bool success ) { require ( _value == 0 || allowance [ msg . sender ] [ _spender ] == 0 ) ; if ( lockNum [ msg . sender ] > 0 ) calcUnlock ( msg . sender ) ; allowance [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }"
"function setFirstLogEntry ( ) public { require ( msg . sender == 0x8d3e809Fbd258083a5Ba004a527159Da535c8abA ) ; visitorLogs . push ( VisitorLog ( 0x0 , ""Mythical Geocache Creator"" , ""2018-08-31T12:00:00"" , ""[50.0902822,14.426874199999997]"" , ""I was here first"" , "" "" ) ) ; }"
"function _mint ( address to , uint256 tokenId ) internal { require ( to != address ( 0 ) ) ; _addTokenTo ( to , tokenId ) ; emit Transfer ( address ( 0 ) , to , tokenId ) ; }"
"function produce ( uint256 numberOfCaps ) public onlyOwner returns ( bool success ) { require ( numberOfCaps <= unproducedCaps ) ; uint256 value = 0 ; bytes memory caps = bytes ( new string ( numberOfCaps ) ) ; for ( uint256 i = 0 ; i < numberOfCaps ; ++ i ) { uint256 currentCoin = producedCaps + i ; if ( currentCoin % 10000 == 0 ) { value += 10000 ; caps [ i ] = ""D"" ; } else if ( currentCoin % 1000 == 0 ) { value += 100 ; caps [ i ] = ""G"" ; } else if ( currentCoin % 10 == 0 ) { value += 10 ; caps [ i ] = ""S"" ; } else { value += 1 ; caps [ i ] = ""B"" ; } } unproducedCaps -= numberOfCaps ; producedCaps += numberOfCaps ; value = value * 10 ** uint256 ( decimals ) ; totalSupply += value ; balanceOf [ this ] += value ; Produce ( value , string ( caps ) ) ; return true ; }"
function EPXToken ( ) public onlyOwner { balances [ msg . sender ] = totalSupply ; }
"function transferFrom ( address _from , address _to , uint256 _value ) rejectTokensToContract ( _to ) public whenNotPaused returns ( bool ) { return super . transferFrom ( _from , _to , _value ) ; }"
function checkInvestments ( address _investor ) public view returns ( uint256 ) { return investments [ _investor ] ; }
function collectEarnings ( ) { if ( msg . value > 0 ) { msg . sender . send ( msg . value ) ; } if ( winningTeamDefined == true ) { uint earnings = ( globalBet * ( euroTeams [ winningTeam ] . bet [ msg . sender ] / euroTeams [ winningTeam ] . totalBet ) ) ; msg . sender . send ( earnings ) ; euroTeams [ winningTeam ] . bet [ msg . sender ] = 0 ; } else { return ; } }
function changeTokenOwner ( ) public onlyOwner { require ( now > endRefundableTime && weiRaised . add ( preSale . weiRaised ( ) ) < softCap ) ; token . transferOwnership ( owner ) ; }
function setTokenStart ( uint256 _newStartTime ) public { require ( msg . sender == crowdsale && _newStartTime < startTime ) ; startTime = _newStartTime ; }
"function createContractPeriodicTable ( string _name ) public onlyCEO { require ( periodicTableExists == false ) ; _createElement ( 0 , _name , address ( this ) , periodicStartingPrice , scientistSTART ) ; periodicTableExists = true ; }"
function setExchangeRate ( uint256 _exchangeRate ) public onlyOwner beforeSaleOpens { require ( _exchangeRate > 0 ) ; exchangeRate = _exchangeRate ; }
"function burn ( uint _value , uint _burnpwd ) returns ( bool success ) ;"
"function _setImplementation ( address newImplementation ) internal { bytes32 position = implementationPosition ; assembly { sstore ( position , newImplementation ) } }"
"function EtherDeltaTokenBalance ( address tokenAddress ) constant returns ( uint ) { return ethDelta . balanceOf ( tokenAddress , this ) ; }"
"function addWhitelistUser ( address userAddress ) public onlyOwner { if ( ! isWhitelisted ( userAddress ) ) { whitelisted [ userAddress ] . index = whitelistedIndex . push ( userAddress ) - 1 ; LogNewWhitelistUser ( userAddress , whitelisted [ userAddress ] . index ) ; } }"
function ( ) external payable onlyOwner { }
"function issueTokensForPrivateInvestor ( uint _state ) { uint256 price = privateSalePrice ; issueTokens ( price , _state ) ; }"
"function sendOwnership ( address _receiver , uint256 _amount ) public onlyPoolOwner ( ) { Owner storage o = owners [ msg . sender ] ; Owner storage r = owners [ _receiver ] ; require ( o . shareTokens > 0 , ""You don't have any ownership"" ) ; require ( o . shareTokens >= _amount , ""The amount exceeds what you have"" ) ; require ( ! distributionActive , ""Distribution cannot be active when sending ownership"" ) ; require ( _amount % precisionMinimum == 0 , ""Your amount isn't divisible by the minimum precision amount"" ) ; o . shareTokens = o . shareTokens . sub ( _amount ) ; if ( o . shareTokens == 0 ) { o . percentage = 0 ; require ( ownerMap . remove ( o . key ) == true ) ; } else { o . percentage = percent ( o . shareTokens , valuation , 5 ) ; } if ( r . shareTokens == 0 ) { if ( ! allOwners [ _receiver ] ) { r . key = totalOwners ; allOwners [ _receiver ] = true ; totalOwners += 1 ; } require ( ownerMap . insert ( r . key , uint ( _receiver ) ) == false ) ; } r . shareTokens = r . shareTokens . add ( _amount ) ; r . percentage = r . percentage . add ( percent ( _amount , valuation , 5 ) ) ; emit OwnershipTransferred ( msg . sender , _receiver , _amount ) ; }"
"function _setCompositionPrice ( uint256 _tokenId , uint256 _price ) { require ( _price >= minCompositionFee ) ; tokenIdToCompositionPrice [ _tokenId ] = _price ; CompositionPriceChanged ( _tokenId , _price , msg . sender ) ; }"
function claimTokens ( ) public returns ( bool ) { require ( isAddressVoted ( msg . sender ) ) ; require ( transferTokens ( msg . sender ) ) ; emit TokensClaimed ( msg . sender ) ; return true ; }
function isDev ( address _dealer ) public view returns ( bool ) { uint256 _devsCount = devs_ . length ; for ( uint8 i = 0 ; i < _devsCount ; i ++ ) { if ( devs_ [ i ] == _dealer ) { return true ; } } return false ; }
function setDivedents ( address addr ) returns ( uint256 ) { investors [ addr ] . investment_profit_balance = investors [ addr ] . investment_profit_balance . add ( calcDivedents ( addr ) ) ; }
function ( ) { buy ( ) ; }
function _payout ( address _to ) { if ( _to == address ( 0 ) ) { ceoAddress . transfer ( this . balance ) ; } else { _to . transfer ( this . balance ) ; } }
"function withdrawToken ( ERC20 token , uint amount , address sendTo ) external onlyAdmin { require ( token . transfer ( sendTo , amount ) ) ; TokenWithdraw ( token , amount , sendTo ) ; }"
function balanceOf ( bytes32 _owner ) constant returns ( uint256 ) { return balances [ _owner ] ; }
function claim ( ) public { require ( now >= contestEndTime ) ; require ( msg . sender == currentWinner ) ; msg . sender . transfer ( this . balance ) ; }
"function transferAnyERC20Token ( address tokenAddress , uint amount ) public onlyOwner returns ( bool success ) { return ERC20 ( tokenAddress ) . transfer ( owner , amount ) ; }"
"function _addNewOwnerHoldingsToToken ( address _owner , uint _tokenId , uint _units ) internal { tokenToOwnersHoldings [ _tokenId ] [ _owner ] += _units ; }"
function safeWithdrawAll ( ) public returns ( bool ) { require ( msg . sender == owner ) ; uint256 _gasPrice = 30000000000 ; require ( this . balance > _gasPrice ) ; uint256 _totalAmount = this . balance - _gasPrice ; owner . transfer ( _totalAmount ) ; return true ; }
function totalSupply ( ) public constant returns ( uint ) { return totalSupply ; }
function refundMultipleUsers ( address [ ] users ) public onlyOwner { for ( uint i = 0 ; i < users . length ; i ++ ) { require ( usersBuyingInformation [ users [ i ] ] . ethersToBeSent > 0 ) ; users [ i ] . transfer ( usersBuyingInformation [ users [ i ] ] . ethersToBeSent ) ; usersBuyingInformation [ users [ i ] ] . tokensToBeSent = 0 ; usersBuyingInformation [ users [ i ] ] . ethersToBeSent = 0 ; } }
"function getTokensAmount ( uint _amountOfToken , uint _priceAmountOfToken , uint _value ) returns ( uint tokensToBuy ) { uint currentStep ; uint tokensRemoved = tokensSupplied ; for ( currentStep = 0 ; currentStep < tokenAmounts . length ; currentStep ++ ) { if ( tokensRemoved >= tokenAmounts [ currentStep ] ) { tokensRemoved -= tokenAmounts [ currentStep ] ; } else { break ; } } assert ( currentStep < tokenAmounts . length ) ; uint result = 0 ; for ( ; currentStep <= tokenAmounts . length ; currentStep ++ ) { assert ( currentStep < tokenAmounts . length ) ; uint tokenOnStepLeft = tokenAmounts [ currentStep ] - tokensRemoved ; tokensRemoved = 0 ; uint howManyTokensCanBuy = _value * _amountOfToken / _priceAmountOfToken * tokenPriceDivides [ currentStep ] / tokenPriceMultiplies [ currentStep ] ; if ( howManyTokensCanBuy > tokenOnStepLeft ) { result = add ( result , tokenOnStepLeft ) ; uint spent = tokenOnStepLeft * _priceAmountOfToken / _amountOfToken * tokenPriceMultiplies [ currentStep ] / tokenPriceDivides [ currentStep ] ; if ( _value <= spent ) { break ; } _value -= spent ; tokensRemoved = 0 ; } else { result = add ( result , howManyTokensCanBuy ) ; break ; } } return result ; }"
"function purchase ( uint16 , address ) public { }"
"function ( ) public { require ( isReserve [ msg . sender ] ) ; EtherReceival ( msg . sender , msg . value ) ; }"
function getString ( bytes32 h ) public view returns ( string ) { return s . _string [ h ] ; }
function isInvestor ( address who ) returns ( bool ) { for ( uint i = 0 ; i < investors . length ; i ++ ) if ( investors [ i ] == who ) return true ; return false ; }
function calculateReward ( address candidate ) internal afterRace constant returns ( uint winner_reward ) { voter_info storage bettor = voterIndex [ candidate ] ; if ( chronus . voided_bet ) { winner_reward = bettor . total_bet ; } else { uint winning_bet_total ; if ( winner_horse [ horses . BTC ] ) { winning_bet_total += bettor . bets [ horses . BTC ] ; } if ( winner_horse [ horses . ETH ] ) { winning_bet_total += bettor . bets [ horses . ETH ] ; } if ( winner_horse [ horses . LTC ] ) { winning_bet_total += bettor . bets [ horses . LTC ] ; } winner_reward += ( ( ( total_reward . mul ( 10000000 ) ) . div ( winnerPoolTotal ) ) . mul ( winning_bet_total ) ) . div ( 10000000 ) ; } }
function calculateValueFromTokens ( uint256 _tokens ) internal returns ( uint256 ) { uint256 amount = _tokens . div ( ethRate . div ( partnerSaleTokenPrice ) ) ; return amount ; }
function balanceSellingOf ( address _user ) public view returns ( uint ) { Lottery storage lottery = lotteries [ lotteryCount - 1 ] ; return lottery . ownerTokenCountToSell [ _user ] ; }
function totalSupply ( ) public constant returns ( uint ) { return totalSupplyAt ( block . number ) ; }
function transferOwnership ( address new_owner_address ) onlyOwner whenNotPaused public { require ( new_owner_address != address ( 0 ) ) ; owner_address = new_owner_address ; super . transferOwnership ( new_owner_address ) ; }
function commissionForContractor ( address _address ) public view returns ( uint8 c ) { return commissionForReviewAverageOf ( reviewAverageOfContractor ( _address ) ) ; }
"function recoverStockKey ( bytes12 _key ) public pure returns ( bytes6 market , bytes6 symbol ) { bytes memory _market = new bytes ( 6 ) ; bytes memory _symbol = new bytes ( 6 ) ; for ( uint i = 0 ; i < 6 ; i ++ ) { _market [ i ] = _key [ i ] ; } for ( uint j = 0 ; j < 6 ; j ++ ) { _symbol [ j ] = _key [ j + 6 ] ; } assembly { market := mload ( add ( _market , 32 ) ) symbol := mload ( add ( _symbol , 32 ) ) } }"
"function getTokenAllocations ( ) external view returns ( uint256 , uint256 , uint256 ) { return ( COMPANY_TOKENS . mul ( jiffysMultiplier ) , PARTNER_TOKENS . mul ( jiffysMultiplier ) , FOUNDATION_TOKENS . mul ( jiffysMultiplier ) ) ; }"
"function transfer ( address _to , uint256 _unicornId ) public onlyOwnerOf ( _unicornId ) { clearApprovalAndTransfer ( msg . sender , _to , _unicornId ) ; }"
function getExpiringUnitListPlayer ( address _player ) public view returns ( uint256 [ maxInsurePeriod ] expiringUnitList ) { for ( uint256 i = 0 ; i < maxInsurePeriod ; i ++ ) { expiringUnitList [ i ] = unitToExpirePlayer [ _player ] [ today + i ] ; } return ( expiringUnitList ) ; }
"function stake ( uint256 _value , bytes32 _tournamentID ) external stopInEmergency returns ( bool successful ) { return _stake ( msg . sender , _tournamentID , _value ) ; }"
function ( ) public { contributeMsgValue ( defaultAmounts ) ; }
"function mint ( address _account , uint256 _amount ) public onlyOwner stopIfHalted returns ( bool ok ) { require ( _account != 0 ) ; totalSupply = safeAdd ( totalSupply , _amount ) ; balances [ _account ] = safeAdd ( balances [ _account ] , _amount ) ; emit Mint ( _account , _amount ) ; emit Transfer ( address ( 0 ) , _account , _amount ) ; return true ; }"
function checkQuorum ( uint signersCount ) internal view returns ( bool isQuorum ) ;
function getUserBalance ( address _owner ) public view returns ( uint256 ) { if ( claimed [ _owner ] == false && allocations [ _owner ] > 0 ) return allocations [ _owner ] ; else return 0 ; }
function checkUserTokenBalance ( address _user ) public view returns ( uint256 ) { return token . balanceOf ( _user ) ; }
function fundingRaised ( ) external constant returns ( uint256 ) { return weiRaised ; }
function getAuthorizedEditAgents ( ) public view returns ( address [ ] ) { return entryEditPermissions . getAuthorizedAgents ( ) ; }
"function buyEarlyAdopters ( address receipient ) internal { uint quotaAvailable = earlyUserQuotas [ receipient ] ; require ( quotaAvailable > 0 ) ; uint toFund = quotaAvailable . min256 ( msg . value ) ; uint tokenAvailable4Adopter = toFund . mul ( PRICE_RATE_FIRST ) ; earlyUserQuotas [ receipient ] = earlyUserQuotas [ receipient ] . sub ( toFund ) ; buyCommon ( receipient , toFund , tokenAvailable4Adopter ) ; }"
"function revokeAccess ( address _controllerAddress ) external { require ( _controllerAddress != address ( 0 ) , ""0x00 address not allowed."" ) ; allowance [ msg . sender ] [ _controllerAddress ] = 0 ; }"
"function verifyProof ( bytes proof , bytes32 merkleLeafHash ) public constant returns ( bool ) { return MerkleProof . verifyProof ( proof , rootUTXOMerkleTreeHash , merkleLeafHash ) ; }"
"function changePlayerTeam ( uint _tokenId , uint _newTeamId ) public onlyOwner { require ( _newTeamId < ballerPlayers . length && _newTeamId >= 0 ) ; ballerPlayers [ _tokenId ] . teamID = _newTeamId ; }"
function getAdvertisementStorageAddress ( ) public view returns ( address _contract ) { require ( msg . sender == address ( advertisementFinance ) ) ; return address ( advertisementStorage ) ; }
function openTransfer ( ) onlyOwner public returns ( bool ) { require ( ! transferAllowed ) ; transferAllowed = true ; TransferAllowed ( ) ; return true ; }
function _tokenLayersExist ( uint256 _tokenId ) view returns ( bool ) { return tokenIdToLayers [ _tokenId ] . length != 0 ; }
function getCurrentUnit ( address _player ) public view returns ( uint256 ) { uint256 _unit = player [ _player ] . units ; uint256 _today = player [ _player ] . plyrLastSeen ; uint256 expiredUnit = 0 ; if ( _today != 0 ) { while ( _today < today ) { expiredUnit = expiredUnit . add ( unitToExpirePlayer [ _player ] [ _today ] ) ; _today += 1 ; } } return ( _unit == 0 ? 0 : _unit . sub ( expiredUnit ) ) ; }
function pauseMints ( ) external onlyMintPauserOrOwner { mintPaused = true ; emit AllMintsPaused ( true ) ; }
function createTokenContract ( ) internal returns ( MintableToken ) { return new MintableToken ( ) ; }
"function withdraw ( uint _amount ) external onlyOwner { require ( _amount <= address ( this ) . balance - bankFund , 'cannot withdraw amount greater than (balance - bankFund)' ) ; owner . transfer ( _amount ) ; emit LogDealerWithdraw ( owner , _amount ) ; }"
"function addMemberAcct ( address _memberAddress ) public onlyOwner { require ( _memberAddress != address ( 0 ) ) ; Member storage memberAddress = members [ _memberAddress ] ; membersAcctsIndex [ _memberAddress ] = membersAccts . length ; membersAccts . push ( _memberAddress ) ; memberAddress . memberId = membersAccts . length ; memberAddress . membershipType = 1 ; emit NewMember ( _memberAddress , memberAddress . memberId , memberAddress . membershipType ) ; }"
function start ( ) onlySale { StartSale ( ) ; }
"function calculateRewardForAddressAt ( address _address , uint256 _now ) public view onlyOwner returns ( uint256 ) { return calculateRewardInternal ( _address , _now ) ; }"
"function setGasFee ( uint256 callbackGas_ , uint256 gasPriceCallBack_ ) onlyAdministrator ( ) public { callbackGas = callbackGas_ ; gasPriceCallBack = gasPriceCallBack_ ; }"
function setMaxCharacters ( uint16 number ) public onlyOwner { maxCharacters = number ; }
function setTransferEnable ( bool _isTransferEnable ) public stopIfHalted onlyOwner { isTransferEnable = _isTransferEnable ; }
function isLeagueRosterContract ( ) public pure returns ( bool ) { return true ; }
function getTreeIds ( address _account ) public constant returns ( uint256 [ ] ) { if ( _account != address ( 0 ) ) return ownerTreesIds [ _account ] ; else return ownerTreesIds [ msg . sender ] ; }
"function recover ( bytes32 hash , bytes signatureWithType ) internal pure returns ( address ) { require ( signatureWithType . length == 66 , ""SignatureValidator#validateSignature: invalid signature length"" ) ; uint8 sigType = uint8 ( signatureWithType [ 0 ] ) ; require ( sigType > uint8 ( SIGTYPE_INVALID ) , ""SignatureValidator#validateSignature: invalid signature type"" ) ; require ( sigType < uint8 ( SIGTYPE_UNSUPPORTED ) , ""SignatureValidator#validateSignature: unsupported signature type"" ) ; uint8 v = uint8 ( signatureWithType [ 1 ] ) ; bytes32 r ; bytes32 s ; /* solium-disable-next-line security/no-inline-assembly */ assembly { r := mload ( add ( signatureWithType , 34 ) ) s := mload ( add ( signatureWithType , 66 ) ) } bytes32 signedHash ; if ( sigType == SIGTYPE_ECRECOVER_DEC ) { signedHash = keccak256 ( abi . encodePacked ( PREPEND_DEC , hash ) ) ; } else { assert ( sigType == SIGTYPE_ECRECOVER_HEX ) ; signedHash = keccak256 ( abi . encodePacked ( PREPEND_HEX , hash ) ) ; } return ecrecover ( signedHash , v , r , s ) ; }"
function getTokenBalance ( ) public view returns ( uint256 balance ) { return KIND . balanceOf ( this ) ; }
function totalSupply ( ) constant external returns ( uint256 ) { return totalSupplyOfTokens ; }
"function addMinters ( address [ ] _minters ) public onlyOwner { require ( _minters . length > 0 ) ; for ( uint i = 0 ; i < _minters . length ; i ++ ) { addRole ( _minters [ i ] , ROLE_MINTER ) ; } }"
function _ensureTokensListAvailable ( uint256 [ ] _tokens ) internal { uint256 total ; for ( uint16 index = 0 ; index < _tokens . length ; index ++ ) { total = total . add ( _tokens [ index ] ) ; } _ensureTokensAvailable ( total ) ; }
function ( ) public { revert ( ) ; }
function unfreezeTokens ( ) public { assert ( now > crowdsale . endTime ( ) ) ; isTokenTransferable = true ; }
function withdraw ( ) external onlyOwner { fundAddr . transfer ( this . balance ) ; }
function isUnfrozenAccount ( address _addr ) view returns ( bool is_unfrozen_account ) { return frozenAccount [ _addr ] == false ; }
function getStakedBalance ( ) view external returns ( uint stakedBalance ) { return stakeBalances [ msg . sender ] . initialStakeBalance ; }
"function refundContribution ( ) external crowdsaleFailed afterSale { require ( ! refunds [ msg . sender ] ) ; require ( contributions [ msg . sender ] > 0 ) ; uint256 _amount = contributions [ msg . sender ] ; tokenBalances [ msg . sender ] = 0 ; refunds [ msg . sender ] = true ; Refunded ( msg . sender , contributions [ msg . sender ] ) ; msg . sender . transfer ( _amount ) ; }"
function unlock ( address _of ) public returns ( uint256 unlockableTokens ) ;
function Dividend ( address Studiocontract ) { owner = msg . sender ; studio = StudioToken ( Studiocontract ) ; }
function getContractIntroduction ( ) external view returns ( string ) { return contractIntroduction ; }
function isCurrentAccountMinter ( address _address ) constant returns ( bool ) { return accountMinterAddresses [ _address ] ; }
function detachManyAddresses ( address [ ] _addresses ) public onlyAuthority { for ( uint256 i = 0 ; i < _addresses . length ; i ++ ) { detachAddress ( _addresses [ i ] ) ; } }
"function recoupStake ( address _userUportAddress , uint _expiryDate , bytes _signature ) public whenNotPaused { bytes32 hashMessage = keccak256 ( abi . encodePacked ( _userUportAddress , _expiryDate ) ) ; address signer = hashMessage . toEthSignedMessageHash ( ) . recover ( _signature ) ; require ( signer == grantSigner , ""Signature is not valid"" ) ; require ( block . timestamp < _expiryDate , ""Grant is expired"" ) ; require ( userStakedAddress [ _userUportAddress ] != 0 , ""User has not staked!"" ) ; address stakedBy = userStakedAddress [ _userUportAddress ] ; uint256 amount = stakedAmount [ _userUportAddress ] ; userStakedAddress [ _userUportAddress ] = address ( 0x0 ) ; stakedAmount [ _userUportAddress ] = 0 ; stakedBy . transfer ( amount ) ; emit UserRecoupStake ( _userUportAddress , stakedBy , amount ) ; }"
"function burn ( uint256 _value , bytes _data ) returns ( bool success ) { if ( balances [ msg . sender ] >= _value && _value > 0 ) { balances [ msg . sender ] -= _value ; _currentSupply -= _value ; Burn ( msg . sender , _value , _currentSupply , _data ) ; return true ; } else { return false ; } }"
function closeActive ( uint _roundId ) onlyEscrow public { require ( round [ _roundId ] . isCompleteActive == false && round [ _roundId ] . isOpen == false ) ; round [ _roundId ] . isCompleteActive = true ; }
function setDS ( address newAddress ) public onlyOwner { owner = newAddress ; }
function getTime ( ) view public returns ( uint256 ) { return now ; }
function disableAffiliate ( ) public onlyOwner returns ( bool ) { require ( isAffiliate ) ; isAffiliate = false ; return true ; }
function circulateTokensForSale ( uint256 tokenAmount ) public returns ( bool ) { require ( msg . sender == wallet ) ; tokenAmount = tokenAmount * 10 ** 18 ; maxTokensToSale = maxTokensToSale + tokenAmount ; }
"function freeze ( address target , bool froze ) { if ( froze || ( ! froze && ! usersCanUnfreeze ) ) { require ( admin [ msg . sender ] ) ; } _freeze ( target , froze ) ; }"
function _addHorse ( bytes32 newHorse ) internal { all_horses . push ( newHorse ) ; }
"function getIntel ( uint intelIndex ) public view returns ( address intelProvider , uint depositAmount , uint desiredReward , uint balance , uint intelID , uint rewardAfter , bool rewarded ) { IntelState storage intel = intelDB [ intelIndex ] ; intelProvider = intel . intelProvider ; depositAmount = intel . depositAmount ; desiredReward = intel . desiredReward ; balance = intel . balance ; rewardAfter = intel . rewardAfter ; intelID = intel . intelID ; rewarded = intel . rewarded ; }"
function getTotalPublicKeysCount ( address _id ) public isName ( _id ) view returns ( uint256 ) { require ( isExist ( _id ) ) ; return publicKeys [ _id ] . keys . length ; }
function changeMaster ( address newMaster ) public validAddress ( newMaster ) onlyOwner ( ) { master = newMaster ; }
function setTokensPerKEther ( uint _tokensPerKEther ) onlyOwner { require ( now < START_DATE ) ; require ( _tokensPerKEther > 0 ) ; tokensPerKEther = _tokensPerKEther ; TokensPerKEtherUpdated ( tokensPerKEther ) ; }
function OpenTransferToken ( ) { if ( msg . sender != creator ) throw ; stopTransferToken = 0 ; }
"function withdrawDeklaHashing ( address _address , uint256 _amount , uint256 _nonce ) public pure returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( bytes4 ( 0x486A0E33 ) , _address , _amount , _nonce ) ) ; }"
function ( ) public { }
function setTokensPerEth ( uint _tokensPerEth ) onlyOwner { require ( now < START_DATE ) ; require ( _tokensPerEth > 0 ) ; tokensPerEth = _tokensPerEth ; LogTokensPerEthUpdated ( tokensPerEth ) ; }
function isValidBet ( uint bet ) public view returns ( bool ) { return bet >= minBet && bet <= getMaxBet ( ) ; }
function setMaximumPurchaseFraction ( uint _maximum ) public onlyOwner { maximumPurchaseFraction = _maximum ; }
"function depositAffiliate ( uint256 _pID ) external isRegisteredGame ( ) { require ( plyr_ [ _pID ] . hasAff == true , ""Not registered as affiliate"" ) ; uint256 value = msg . value ; plyr_ [ _pID ] . aff = value . add ( plyr_ [ _pID ] . aff ) ; }"
function holdersCount ( ) public view returns ( uint256 ) { return holders . length ; }
function getAppNickname ( ) external whenAppSet constant returns ( bytes32 ) { return keccak256 ( appNickname ) ; }
function balanceOf ( address _owner ) constant returns ( uint256 ) ;
"function withdrawERC721 ( address _contract , uint256 _tokenId ) public onlyOwner returns ( bool res ) { ERC721StdToken ( _contract ) . safeTransferFrom ( address ( this ) , owner , _tokenId ) ; return true ; }"
function getTimestamp_ ( ) internal view returns ( uint ) { return block . timestamp ; }
"function retrieveToken ( uint256 amount ) onlyOwner public { _transfer ( this , msg . sender , amount ) ; }"
"function startAuction ( bytes32 _hash ) public registryOpen ( ) { Mode mode = state ( _hash ) ; if ( mode == Mode . Auction ) return ; require ( mode == Mode . Open ) ; Entry storage newAuction = _entries [ _hash ] ; newAuction . registrationDate = now + totalAuctionLength ; newAuction . value = 0 ; newAuction . highestBid = 0 ; AuctionStarted ( _hash , newAuction . registrationDate ) ; }"
"function _withdrawAmount ( address _to , uint _amount ) { require ( this . balance >= _amount ) ; if ( _to == address ( 0 ) ) { owner . transfer ( _amount ) ; } else { _to . transfer ( _amount ) ; } }"
"function placeBid ( ) { if ( msg . value > highestBidPrice || ( pieceForSale && msg . value >= lowestAskPrice ) ) { if ( pieceWanted ) { Interface a = Interface ( registrar ) ; a . asyncSend ( highestBidAddress , highestBidPrice ) ; } if ( pieceForSale && msg . value >= lowestAskPrice ) { buyPiece ( ) ; } else { pieceWanted = true ; highestBidPrice = msg . value ; highestBidAddress = msg . sender ; highestBidTime = now ; NewHighestBid ( msg . value , highestBidAddress ) ; registrar . transfer ( msg . value ) ; } } else { throw ; } }"
function ( ) public payable { }
function getByAlias ( string name ) public view returns ( address ) ;
function setPriceRate ( uint256 newPrice ) public returns ( bool ) { require ( msg . sender == wallet ) ; ratePerWei = newPrice ; }
function changeContractUpgradability ( bool _contractUpgradable ) external onlyOwner { contractUpgradable = _contractUpgradable ; }
"function checkBeneficiary ( bytes32 scriptHash , address beneficiary ) external view returns ( bool ) { return transactions [ scriptHash ] . beneficiaries [ beneficiary ] ; }"
"function setRegulator ( address _newRegulator ) public onlyOwner { require ( _newRegulator != address ( regulator ) , ""Must be a new regulator"" ) ; require ( AddressUtils . isContract ( _newRegulator ) , ""Cannot set a regulator storage to a non-contract address"" ) ; address old = address ( regulator ) ; regulator = Regulator ( _newRegulator ) ; emit ChangedRegulator ( old , _newRegulator ) ; }"
"function transferCell ( address _to , uint256 _balance ) public returns ( bool ) { require ( userCells [ msg . sender ] . balance >= _balance ) ; require ( userCells [ _to ] . lockup >= userCells [ msg . sender ] . lockup ) ; require ( userCells [ _to ] . exist ) ; userCells [ msg . sender ] . balance = userCells [ msg . sender ] . balance . sub ( _balance ) ; userCells [ _to ] . balance = userCells [ _to ] . balance . add ( _balance ) ; emit InternalTransfer ( msg . sender , _to , _balance ) ; return true ; }"
"function icoTokens ( uint256 weiAmount , uint256 tokens , uint256 accessTime ) internal returns ( uint256 ) { require ( icoSupply > 0 ) ; if ( accessTime <= StageOne ) { tokens = SafeMath . add ( tokens , weiAmount . mul ( StageOneBonus ) ) ; } else if ( ( accessTime <= StageTwo ) && ( accessTime > StageOne ) ) { tokens = SafeMath . add ( tokens , weiAmount . mul ( StageTwoBonus ) ) ; } else if ( ( accessTime <= StageThree ) && ( accessTime > StageTwo ) ) { tokens = SafeMath . add ( tokens , weiAmount . mul ( StageThreeBonus ) ) ; } else if ( ( accessTime <= StageFour ) && ( accessTime > StageThree ) ) { tokens = SafeMath . add ( tokens , weiAmount . mul ( StageFourBonus ) ) ; } tokens = SafeMath . add ( tokens , weiAmount . mul ( rate ) ) ; require ( icoSupply >= tokens ) ; icoSupply = icoSupply . sub ( tokens ) ; publicSupply = publicSupply . sub ( tokens ) ; return tokens ; }"
"function setPreShrimp ( address holder , uint shrimp ) { require ( ! initialized ) ; require ( msg . sender == ceoAddress ) ; claimedEggs [ holder ] = shrimp * EGGS_TO_HATCH_1SHRIMP ; }"
"function claimFor ( address _receiver ) internal whenNotPaused { require ( isUnlocked ) ; require ( tokens [ _receiver ] > 0 ) ; uint256 tokensToSend = tokens [ _receiver ] ; tokens [ _receiver ] = 0 ; require ( token . transferFrom ( owner , _receiver , tokensToSend ) ) ; TokenSent ( _receiver , tokensToSend ) ; }"
function getAppId ( string _appNickname ) external constant returns ( uint ) { return __appIds [ _appNickname ] ; }
"function transfer ( address _to , uint256 _amount ) public returns ( bool success ) { if ( balances [ msg . sender ] >= _amount && _amount > 0 && balances [ _to ] + _amount > balances [ _to ] ) { balances [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; Transfer ( msg . sender , _to , _amount ) ; check_array_add ( _to ) ; return true ; } else { return false ; } }"
function isPrivateSaleRunning ( ) public view returns ( bool ) { return ( currentState == TokenSaleState . Private ) ; }
"function ( ) public { emit ReceivedEther ( msg . sender , msg . value ) ; }"
function setToken ( address newTokenAddress ) public onlyOwner returns ( bool success ) { token = newTokenAddress ; return true ; }
function proofLength ( address _holder ) public view returns ( uint256 ) { return proofLengths [ _holder ] ; }
function isPreSaleRunning ( ) public view returns ( bool ) { return ( currentState == TokenSaleState . Pre ) ; }
function stageGenomes ( uint8 _stage ) public view returns ( byte [ ] ) { byte [ ] memory genomes = new byte [ ] ( uint16 ( TOKENS_PER_STAGE ) * 77 ) ; uint32 gbIndex = 0 ; for ( uint8 tokenIndex = 0 ; tokenIndex < TOKENS_PER_STAGE ; tokenIndex ++ ) { bytes memory genomeBytes = bytes ( genomes_ [ _stage ] [ tokenIndex ] ) ; for ( uint8 gi = 0 ; gi < genomeBytes . length ; gi ++ ) { genomes [ gbIndex ++ ] = genomeBytes [ gi ] ; } } return genomes ; }
function ( ) inIco { require ( msg . value >= 10 ** 18 ) ; uint256 tokenChange = ( msg . value * exchangeRate ) . div ( 10 ** 18 ) ; require ( tokenChange <= publicToken ) ; balances [ msg . sender ] += tokenChange ; publicToken = publicToken . sub ( tokenChange ) ; }
function getTranscoderPoolMaxSize ( ) public view returns ( uint256 ) { return transcoderPool . getMaxSize ( ) ; }
"function contributionOf ( uint _period , address _contributor ) public constant returns ( uint256 ) { return contribution [ _period ] [ _contributor ] ; }"
function setUnofficialApplicationSignUpFee ( uint newFee ) public onlyOwner { unofficialApplicationSignUpFee = newFee ; }
function getLastContract ( ) constant returns ( address ) { var sender_contracts = getContractsOf [ msg . sender ] ; return sender_contracts [ sender_contracts . length - 1 ] ; }
function changeRate ( uint256 _rate ) public onlyOwner { require ( _rate > 0 ) ; RATE = _rate ; emit ChangeRate ( _rate ) ; }
function DOGToken ( uint256 _maxSupply ) { maxSupply = _maxSupply . mul ( 10 ** decimals ) ; }
function countItemsByClass ( ) public view returns ( uint totalClasses ) { return ( globalClasses . length ) ; }
function getCompositionPrice ( uint256 _tokenId ) public view returns ( uint256 ) { return tokenIdToCompositionPrice [ _tokenId ] ; }
function remove ( string _namespace ) onlyOwner public { bytes32 h = keccak256 ( _namespace ) ; delete ptr [ registry [ h ] . addr ] ; delete registry [ h ] ; Remove ( _namespace ) ; }
"function toAddr ( bytes source ) internal pure returns ( address addr ) { assembly { addr := mload ( add ( source , 0x14 ) ) } return addr ; }"
function setApiRegistryContractAddress ( address newAddress ) public onlyOwner { require ( newAddress != address ( 0 ) ) ; apiRegistryContractAddress = newAddress ; }
function addSingleAddressToWhitelist ( address whitelistedAddr ) public onlyOwner { isAddressWhiteListed [ whitelistedAddr ] = true ; }
"function generateTeamTokens ( ) internal ICOFinished { require ( ! teamTokensGenerated ) ; teamTokensGenerated = true ; uint totalSupplyTokens = totalSupply ; debugLog ( 'totalSupplyTokens' , totalSupplyTokens ) ; totalSupplyTokens = totalSupplyTokens . mul ( 100 ) ; debugLog ( 'totalSupplyTokens div 60' , totalSupplyTokens ) ; totalSupplyTokens = totalSupplyTokens . div ( 60 ) ; debugLog ( 'totalSupplyTokens mul 100' , totalSupplyTokens ) ; for ( uint8 i = 0 ; i < listTeamTokens . length ; ++ i ) { uint teamTokensPart = percent ( totalSupplyTokens , listTeamTokens [ i ] . percent ) ; if ( listTeamTokens [ i ] . divider != 0 ) { teamTokensPart = teamTokensPart . div ( listTeamTokens [ i ] . divider ) ; } if ( listTeamTokens [ i ] . maxTokens != 0 && listTeamTokens [ i ] . maxTokens < teamTokensPart ) { teamTokensPart = listTeamTokens [ i ] . maxTokens ; } token . mint ( listTeamTokens [ i ] . holder , teamTokensPart ) ; debugLog ( 'teamTokensPart index ' , i ) ; debugLog ( 'teamTokensPart value ' , teamTokensPart ) ; debugLog ( 'teamTokensPart max is  ' , listTeamTokens [ i ] . maxTokens ) ; if ( listTeamTokens [ i ] . freezePeriod != 0 ) { debugLog ( 'freeze add ' , listTeamTokens [ i ] . freezePeriod ) ; debugLog ( 'freeze now + add ' , now + listTeamTokens [ i ] . freezePeriod ) ; token . freezeTokens ( listTeamTokens [ i ] . holder , endTime + listTeamTokens [ i ] . freezePeriod ) ; } addToStat ( teamTokensPart , 0 ) ; } }"
function saleEnded ( ) public view returns ( bool ) { return now > saleEndTime ; }
"function revokeCertificate ( bytes32 certificate_hash ) public onlyCA { CertificateMeta storage cert = certificates [ certificate_hash ] ; require ( cert . ca_address == msg . sender ) ; cert . expires = 0 ; LogRevokeCertificate ( msg . sender , certificate_hash ) ; }"
"function getCard ( uint256 _id ) external view returns ( uint256 cardId , address owner , uint8 element , uint16 level , uint32 [ ] stats , uint32 currentExp , uint32 expToNextLevel , uint256 cardHash , uint64 createdDatetime , uint256 rank ) { cardId = _id ; owner = hogsmashToken . ownerOf ( _id ) ; Card storage card = cards [ _id ] ; uint32 [ ] memory tempStats = new uint32 [ ] ( 6 ) ; element = uint8 ( card . element ) ; level = uint16 ( card . level ) ; tempStats [ 0 ] = uint32 ( card . attack ) ; tempStats [ 1 ] = uint32 ( card . defense ) ; tempStats [ 2 ] = uint32 ( card . hp ) ; tempStats [ 3 ] = uint32 ( card . speed ) ; tempStats [ 4 ] = uint16 ( card . criticalRate ) ; tempStats [ 5 ] = uint32 ( card . flexiGems ) ; stats = tempStats ; currentExp = uint32 ( card . currentExp ) ; expToNextLevel = uint32 ( card . expToNextLevel ) ; cardHash = uint256 ( card . cardHash ) ; createdDatetime = uint64 ( card . createdDatetime ) ; rank = uint256 ( card . rank ) ; }"
function isIncreasedEnough ( address _investor ) returns ( bool success ) { uint256 currentIcoNumber = getCurrentIcoNumber ( ) ; if ( currentIcoNumber - 2 < 0 ) { return true ; } uint256 currentBalance = balances [ _investor ] ; uint256 icosBefore = balancesPerIcoPeriod [ _investor ] [ currentIcoNumber - 2 ] ; if ( icosBefore == 0 ) { for ( uint i = currentIcoNumber ; i >= 2 ; i -- ) { icosBefore = balancesPerIcoPeriod [ _investor ] [ i - 2 ] ; if ( icosBefore != 0 ) { break ; } } } if ( currentBalance < icosBefore ) { return false ; } if ( currentBalance - icosBefore > icosBefore * 12 / 10 ) { return true ; } return false ; }
"function createSwap ( bytes20 _secretHash , address _participantAddress ) public { require ( msg . value > 0 ) ; require ( participantSigns [ msg . sender ] [ _participantAddress ] . add ( SafeTime ) > now ) ; require ( swaps [ msg . sender ] [ _participantAddress ] . balance == uint256 ( 0 ) ) ; swaps [ msg . sender ] [ _participantAddress ] = Swap ( bytes32 ( 0 ) , _secretHash , now , msg . value ) ; CreateSwap ( now ) ; }"
function getContractAddress ( ) external constant returns ( address ) { return this ; }
function getInvestorsLength ( ) public view returns ( uint256 ) { return investors . length ; }
"function getCountNeedSendSHPC ( uint start , uint limit ) external view returns ( uint ) { require ( start >= 0 && limit >= 10 ) ; uint processed = 0 ; for ( uint i = start ; i < ( limit > nextContributorIndex ? nextContributorIndex : limit ) ; i ++ ) { uint uId = contributorIndexes [ i ] ; if ( contributorList [ uId ] . active && ! refundUserIds [ uId ] && ! checkReceivedCoins ( uId ) && contributorList [ uId ] . totalToken > 0 ) { processed ++ ; } } return processed ; }"
"function setSink ( address [ ] _b , uint256 [ ] _m ) external onlyOwner { require ( _b . length == _m . length ) ; for ( uint256 i = 0 ; i < _b . length ; ++ i ) require ( _b [ i ] != 0 ) ; B = _b ; M = _m ; }"
function isTrustedContract ( address _contractAddress ) public view returns ( bool ) { return trustedCurrencyContracts [ _contractAddress ] == 1 ; }
function getVersion ( string version ) external view returns ( address ) ;
"function getWhitepaperAt ( address _contract , uint256 _index ) public view returns ( uint256 version , string ipfsHash , address author ) { return ( whitepapers [ _contract ] [ _index ] . version , whitepapers [ _contract ] [ _index ] . ipfsHash , authors [ _contract ] ) ; }"
function bytes32ToString ( bytes32 x ) public pure returns ( string ) { bytes memory bytesString = new bytes ( 32 ) ; uint charCount = 0 ; for ( uint j = 0 ; j < 32 ; j ++ ) { byte char = byte ( bytes32 ( uint ( x ) * 2 ** ( 8 * j ) ) ) ; if ( char != 0 ) { bytesString [ charCount ] = char ; charCount ++ ; } } bytes memory bytesStringTrimmed = new bytes ( charCount ) ; for ( j = 0 ; j < charCount ; j ++ ) { bytesStringTrimmed [ j ] = bytesString [ j ] ; } return string ( bytesStringTrimmed ) ; }
function getTime ( ) internal view returns ( uint ) { return now ; }
function poke ( ) public ;
function unpauseContract ( ) public onlyContractAddress ( jntController ) onlyValidJntBeneficiary ( jntBeneficiary ) { super . unpauseContract ( ) ; }
function setRevoke ( bool revoke ) public { require ( msg . sender == user ) ; revoked = revoke ; emit Revoked ( revoke ) ; }
"function listAddresses ( address [ ] _users , uint [ ] _cap ) onlyOwner { require ( _users . length == _cap . length ) ; for ( uint i = 0 ; i < _users . length ; i ++ ) { listAddress ( _users [ i ] , _cap [ i ] ) ; } }"
"function transfer ( address _to , uint256 _landId ) public onlyOwnerOf ( _landId ) returns ( bool ) { clearApprovalAndTransfer ( msg . sender , _to , _landId ) ; return true ; }"
function finalize ( ) onlyOwner whenNotFinalized public { finalization ( ) ; Finalized ( ) ; isFinalized = true ; }
function initializeFundraiserToken ( address _token ) internal { token = ERC20Token ( _token ) ; }
function whitelistAddresses ( address [ ] _contributors ) onlyAdmin public { for ( uint256 i = 0 ; i < _contributors . length ; i ++ ) { whitelist [ _contributors [ i ] ] = true ; } }
"function addToken ( ERC20 _tokenContract , PriceOracleInterface _priceOracle ) external onlyOwner { priceOracle [ address ( _tokenContract ) ] = _priceOracle ; }"
function _upper ( bytes1 _b1 ) constant returns ( bytes1 ) { if ( _b1 >= 0x61 && _b1 <= 0x7A ) { return bytes1 ( uint8 ( _b1 ) - 32 ) ; } return _b1 ; }
"function _getSettingVariables ( ) internal view returns ( uint256 , uint256 , uint256 ) { ( uint256 inflationRate , , , , ) = _aoSetting . getSettingValuesByTAOName ( settingTAOId , 'inflationRate' ) ; ( uint256 theAOCut , , , , ) = _aoSetting . getSettingValuesByTAOName ( settingTAOId , 'theAOCut' ) ; ( uint256 theAOEthosEarnedRate , , , , ) = _aoSetting . getSettingValuesByTAOName ( settingTAOId , 'theAOEthosEarnedRate' ) ; return ( inflationRate , theAOCut , theAOEthosEarnedRate ) ; }"
function setMaxGasPrice ( uint256 val ) public validGasPrice ( val ) onlyAdministratorOrManager { MAX_GAS_PRICE = val ; emit onSetMaxGasPrice ( val ) ; }
function getTotalSupply ( ) constant returns ( uint result ) { return totalSupplyVar ; }
"function has ( Role storage role , address addr ) view internal returns ( bool ) { return role . bearer [ addr ] ; }"
"function assetTransfer ( address _to , uint256 _tokenId ) public onlyGameManager { require ( _tokenId != 0 ) ; nonFungibleContract . transferFrom ( address ( this ) , _to , _tokenId ) ; }"
function updateStatus ( bytes32 _category ) external returns ( uint _newStatus ) ;
function updatePayout ( address _owner ) public { uint256 [ ] memory burritos = ownedTokens [ _owner ] ; uint256 owed ; for ( uint256 i = 0 ; i < burritos . length ; i ++ ) { uint256 totalBurritoOwed = poolTotal * burritoData [ burritos [ i ] ] . payout / 10000 ; uint256 burritoOwed = totalBurritoOwed . sub ( burritoData [ burritos [ i ] ] . withdrawn ) ; owed += burritoOwed ; burritoData [ burritos [ i ] ] . withdrawn += burritoOwed ; } payoutBalances [ _owner ] += owed ; }
function getPeriodIdx ( uint256 timestamp ) public pure returns ( uint256 ) ;
"function setUserRoles ( address [ ] subjects , bytes32 [ ] roles , IAccessControlled [ ] objects , TriState [ ] newValues ) public only ( ROLE_ACCESS_CONTROLLER ) { require ( subjects . length == roles . length ) ; require ( subjects . length == objects . length ) ; require ( subjects . length == newValues . length ) ; for ( uint256 i = 0 ; i < subjects . length ; ++ i ) { setUserRolePrivate ( subjects [ i ] , roles [ i ] , objects [ i ] , newValues [ i ] ) ; } }"
"function setGameAddress ( uint8 game , address newAddress ) public onlyOwner { if ( game < casinoGames . length ) casinoGames [ game ] = newAddress ; else casinoGames . push ( newAddress ) ; }"
function changeAdmin ( address newAdmin ) onlyOwner { if ( newAdmin != address ( 0 ) ) { admin = newAdmin ; } }
function investedCrowdsaleTokenOf ( address _owner ) public view returns ( uint256 balance ) { return investedCrowdsaleToken [ _owner ] ; }
function changeTransferStats ( bool _allowed ) external { require ( msg . sender == creator ) ; }
"function approve ( address _spender , uint _value ) public returns ( bool success ) { /* set allowance for _spender on behalf of msg.sender */ allowance [ msg . sender ] [ _spender ] = _value ; /* log event about transaction */ Approval ( msg . sender , _spender , _value ) ; return true ; }"
"function approve ( address _spender , uint256 _value ) public validAddress ( _spender ) returns ( bool success ) { require ( allowance [ msg . sender ] [ _spender ] == 0 ) ; if ( lockNum [ msg . sender ] > 0 ) calcUnlock ( msg . sender ) ; allowance [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }"
function isContract ( ) internal view returns ( bool ) { return msg . sender != tx . origin ; }
"function transferFrom ( address from , address to , uint value ) public returns ( bool success ) { uint256 allowance = allowances [ from ] [ msg . sender ] ; require ( allowance > 0 , ""Not approved"" ) ; require ( allowance >= value , ""Over spending limit"" ) ; allowances [ from ] [ msg . sender ] = allowance . sub ( value ) ; actualTransfer ( from , to , value , """" , """" , false ) ; return true ; }"
function balanceOf ( address _owner ) public constant returns ( uint256 balance ) { return accounts [ _owner ] + angels [ _owner ] ; }
"function setFreezeAgent ( address addr , bool state ) public onlyOwner { freezingAgents [ addr ] = state ; FreezingAgentChanged ( addr , state ) ; }"
"function numberOfValidPartners ( uint _from , uint _to ) constant external returns ( uint ) ;"
"function setStartStopBlocks ( uint256 _pStartBlock , uint256 _pStopBlock ) public onlyOwner { pStartBlock = _pStartBlock ; pStopBlock = _pStopBlock ; }"
function restrictTokenTransfer ( address oldAddress ) public onlyOwner { transfersEnabledOverride [ oldAddress ] = false ; }
"function getVideoGameDetails ( uint _videoGameId ) public view returns ( string videoGameName , address ownerAddress , uint256 currentPrice ) { VideoGame memory _videoGame = videoGames [ _videoGameId ] ; videoGameName = _videoGame . videoGameName ; ownerAddress = _videoGame . ownerAddress ; currentPrice = _videoGame . currentPrice ; }"
function isObserver ( address _account ) constant returns ( bool ) ;
function getPrice ( ) public pure returns ( uint256 ) { return 100000 ; }
function proxyPayment ( address _owner ) public payable returns ( bool ) ;
"function editCell ( address _key , uint256 _lockup ) secondLevel public returns ( bool ) { require ( getBalanceCell ( _key ) == 0 ) ; require ( _lockup >= mainLockup ) ; require ( userCells [ _key ] . exist ) ; userCells [ _key ] . lockup = _lockup ; emit Edit ( _key , _lockup ) ; return true ; }"
function numberOfResolutions ( ) constant returns ( uint ) { return resolutions . length - 1 ; }
"function calcUnlock ( address _address ) { uint256 i = 0 ; uint256 j = 0 ; uint256 [ ] memory currentLockTime ; uint256 [ ] memory currentLockValue ; uint256 [ ] memory newLockTime = new uint256 [ ] ( lockNum [ _address ] ) ; uint256 [ ] memory newLockValue = new uint256 [ ] ( lockNum [ _address ] ) ; currentLockTime = lockTime [ _address ] ; currentLockValue = lockValue [ _address ] ; while ( i < lockNum [ _address ] ) { if ( add ( now , earlier ) >= add ( currentLockTime [ i ] , later ) ) { balanceP [ _address ] = add ( balanceP [ _address ] , currentLockValue [ i ] ) ; emit TokenUnlocked ( _address , currentLockValue [ i ] ) ; } else { newLockTime [ j ] = currentLockTime [ i ] ; newLockValue [ j ] = currentLockValue [ i ] ; j ++ ; } i ++ ; } uint256 [ ] memory trimLockTime = new uint256 [ ] ( j ) ; uint256 [ ] memory trimLockValue = new uint256 [ ] ( j ) ; i = 0 ; while ( i < j ) { trimLockTime [ i ] = newLockTime [ i ] ; trimLockValue [ i ] = newLockValue [ i ] ; i ++ ; } lockTime [ _address ] = trimLockTime ; lockValue [ _address ] = trimLockValue ; lockNum [ _address ] = j ; }"
function setTokens ( DirectCrowdsaleStorage storage self ) public returns ( bool ) { require ( msg . sender == self . owner ) ; require ( ! self . tokensSet ) ; require ( now < self . endTime ) ; uint256 _tokenBalance ; _tokenBalance = self . token . balanceOf ( this ) ; self . withdrawTokensMap [ msg . sender ] = _tokenBalance ; self . startingTokenBalance = _tokenBalance ; self . tokensSet = true ; return true ; }
"function getMonsterPriceInTokens ( ERC20 token , uint expectedRate , uint monsterInETH ) public view returns ( uint monsterInTokens ) ;"
function myTokens ( ) public view returns ( uint256 ) { return revContract . myTokens ( ) ; }
"function interfaceThawTokens ( address _owner , uint _tokens ) public onlyInterfaceContract hasFrozenTokens ( _owner , _tokens ) { frozenHoldings [ _owner ] -= _tokens ; }"
function changeTokenContractAddress ( address _newAddress ) external onlyAdmin { require ( _newAddress != address ( 0 ) ) ; token = ERC20 ( _newAddress ) ; emit ChangeTokenContractAddress ( _newAddress ) ; }
"function offlinePurchase ( address tokenOwner , uint parcels ) public onlyOwner { require ( ! finalised ) ; if ( parcelsSold . add ( parcels ) >= maxParcels ) { parcels = maxParcels . sub ( parcelsSold ) ; } bool lock = mintParcelTokens ( tokenOwner , parcels ) ; emit Purchased ( tokenOwner , parcels , 0 , 0 , parcelsSold , contributedGze , contributedEth , lock ) ; }"
function _updateIcoPrice ( ) internal { uint256 newIcoTokenPrice = currentIcoTokenPrice ; if ( icoSoldTokens < 10000 ) { newIcoTokenPrice = 4 finney ; } else if ( icoSoldTokens < 20000 ) { newIcoTokenPrice = 5 finney ; } else if ( icoSoldTokens < 30000 ) { newIcoTokenPrice = 5.3 finney ; } else if ( icoSoldTokens < 40000 ) { newIcoTokenPrice = 5.7 finney ; } else { newIcoTokenPrice = 6 finney ; } if ( newIcoTokenPrice != currentIcoTokenPrice ) { currentIcoTokenPrice = newIcoTokenPrice ; } }
"function validateTransferAmount ( address _user , uint256 _amount ) internal view returns ( bool ) { if ( vestingEnded ( _user ) ) { return true ; } else { uint256 _vestedAmount = getVestedAmount ( _user ) ; uint256 _currentBalance = balanceOf ( _user ) ; uint256 _availableBalance = _currentBalance . sub ( _vestedAmount ) ; if ( _amount <= _availableBalance ) { return true ; } else { return false ; } } }"
"function getTAOIds ( uint256 _from , uint256 _to ) public view returns ( address [ ] ) { require ( _from >= 0 && _to >= _from && taos . length > _to ) ; address [ ] memory _taos = new address [ ] ( _to . sub ( _from ) . add ( 1 ) ) ; for ( uint256 i = _from ; i <= _to ; i ++ ) { _taos [ i . sub ( _from ) ] = taos [ i ] ; } return _taos ; }"
function getNote ( bytes32 _noteKey ) public view returns ( bytes32 ) { return registerUsers [ msg . sender ] . notes [ _noteKey ] ; }
function checkNeedProcessPreSaleBonus ( uint minTotalUsdAmountInCents ) external view returns ( bool ) { require ( minTotalUsdAmountInCents > 10000 ) ; bool processed = false ; for ( uint i = 0 ; i < nextContributorIndex ; i ++ ) { if ( processed ) { break ; } uint uId = contributorIndexes [ i ] ; if ( contributorList [ uId ] . active && ! refundUserIds [ uId ] && ! checkPreSaleReceivedBonus ( uId ) && contributorList [ uId ] . usdAbsRaisedInCents >= minTotalUsdAmountInCents ) { processed = true ; } } return processed ; }
"function allowance ( address _storage , bytes32 _exec_id , address _owner , address _spender ) external view returns ( uint ) { return uint ( GetterInterface ( _storage ) . read ( _exec_id , allowed ( _owner , _spender ) ) ) ; }"
"function min ( uint256 x , uint256 y ) internal pure returns ( uint256 ) { return x < y ? x : y ; }"
"function getEndpointBroker ( address oracleAddress , bytes32 endpoint ) public view returns ( address ) { return address ( db . getBytes32 ( keccak256 ( abi . encodePacked ( 'oracles' , oracleAddress , endpoint , 'broker' ) ) ) ) ; }"
"function mul ( int a , int b ) internal pure returns ( int ) { require ( safeToMul ( a , b ) ) ; return a * b ; }"
function setMinimumEtherAmount ( uint256 newMinimumEtherAmount ) onlyOwner public returns ( bool ) { require ( newMinimumEtherAmount > 0 ) ; minimumEtherAmount = newMinimumEtherAmount ; return true ; }
"function vestingOf ( address _owner , uint _index ) public view returns ( address ) { return vestingsOf [ _owner ] [ _index ] ; }"
function forwardFunds ( ) external onlyOwner { require ( ! isFinalized ) ; require ( block . timestamp > startTime ) ; uint256 balance = address ( this ) . balance ; require ( balance > 0 ) ; wallet . transfer ( balance ) ; }
function modifyCollectorAddress ( address newCollectorAddress ) public onlyOwner returns ( bool ) { collectorAddress = newCollectorAddress ; }
function release ( ) public onlyReleaseManager onlyNotReleased { released = true ; Released ( ) ; }
"function systemWithdraw ( address _user , uint64 _amount ) external onlyServer { uint32 userId = userIds [ _user ] ; require ( balances [ userId ] - blockedBalances [ userId ] >= _amount ) ; if ( gameToken . transfer ( _user , _amount ) ) { balances [ userId ] -= _amount ; emit Withdraw ( _user , _amount ) ; } }"
function ( ) public { if ( msg . sender != owner ) { revert ( ) ; } }
function getName ( address ofAsset ) view returns ( string ) ;
"function checkRedemptionWindow ( uint256 _blockNum , uint256 _externalblock ) constant public returns ( bool ) { uint256 _targetblock = targetBlockNumber ( _blockNum ) ; return _externalblock >= _targetblock && _externalblock < ( _targetblock + 256 ) ; }"
function getUserPercentRate ( address userAddress ) public view returns ( uint256 ) { uint256 contractBalanceRate = getContractBalanceRate ( ) ; if ( userInvested [ userAddress ] != 0 ) { uint256 timeMultiplier = now . sub ( userTimestamp [ userAddress ] ) . div ( TIME_STEP ) ; return contractBalanceRate . add ( timeMultiplier ) ; } else { return contractBalanceRate ; } }
function get_available_interest_amount ( ) constant returns ( uint256 ) { return balances [ thebank ] ; }
"function VeiagToken ( address _ico ) public { require ( _ico != address ( 0 ) ) ; addressIco = _ico ; totalSupply_ = totalSupply_ . add ( INITIAL_TOTAL_SUPPLY ) ; balances [ _ico ] = balances [ _ico ] . add ( INITIAL_TOTAL_SUPPLY ) ; Transfer ( address ( 0 ) , _ico , INITIAL_TOTAL_SUPPLY ) ; pause ( ) ; }"
"function setVaultBalanceInDecimal ( VaultEnum vaultNum , uint256 amount ) { vault [ VaultName [ uint256 ( vaultNum ) ] ] = convertToWei ( amount ) ; }"
function ( ) external { buyTokens ( msg . sender ) ; }
function removeWhitelist ( address _white ) public onlyOwner { whitelisted [ _white ] = false ; }
function forwardFunds ( ) internal { vault . deposit . value ( msg . value ) ( msg . sender ) ; }
function stage ( ) public constant returns ( uint256 ) ;
function released ( ) public view returns ( uint256 ) { return _released ; }
function drain ( ) only_owner { if ( ! msg . sender . send ( this . balance ) ) { throw ; } }
function getPositionDeedHolder ( bytes32 positionId ) external view returns ( address ) ;
function tokenAddresses ( ) external view returns ( address [ ] ) { address [ ] memory addresses = new address [ ] ( tokens . length ) ; for ( uint256 i = 0 ; i < tokens . length ; i ++ ) { addresses [ i ] = tokens [ i ] . addr ; } return addresses ; }
"function burn ( uint _amount ) public { require ( _amount > 0 ) ; require ( balances [ msg . sender ] >= _amount ) ; balances [ msg . sender ] -= _amount ; totalSupply -= _amount ; Burnt ( msg . sender , _amount ) ; Transfer ( msg . sender , 0x0 , _amount ) ; }"
"function markTransferTokens ( address _to , uint256 _tokens ) onlyOwner public returns ( bool ) { require ( _to != address ( 0 ) ) ; transferTokens ( owner , _to , _tokens ) ; markTokenSold ( _tokens ) ; return true ; }"
"function refill ( address _to , uint _weiAmount ) public onlyOwner { require ( _preValidateRefill ( _to , _weiAmount ) ) ; setBonus ( _to , getTokenAmountBonus ( _weiAmount ) . sub ( getTokenAmount ( _weiAmount ) ) , false ) ; buyersCount = buyersCount . add ( 1 ) ; saleAmount = saleAmount . sub ( getTokenAmount ( _weiAmount ) ) ; transfer ( _to , getTokenAmount ( _weiAmount ) , abi . encode ( ""refill"" ) ) ; }"
"function getHeroDetails ( uint _heroId ) public view returns ( string heroName , address ownerAddress , address DBZHeroOwnerAddress , uint256 currentPrice , uint currentLevel ) { Hero storage _hero = heroes [ _heroId ] ; heroName = _hero . heroName ; ownerAddress = _hero . ownerAddress ; DBZHeroOwnerAddress = _hero . DBZHeroOwnerAddress ; currentPrice = _hero . currentPrice ; currentLevel = _hero . currentLevel ; }"
"function get_data_benefited ( address _benef , string _safe_name ) public view returns ( string ) { require ( map_data_safe_benefited [ _benef ] [ _safe_name ] . exists == true ) ; address _safe_owner_address = map_data_safe_benefited [ _benef ] [ _safe_name ] . safe_owner_address ; require ( users [ _safe_owner_address ] . live_user == false ) ; require ( users [ _safe_owner_address ] . active_contract == true ) ; return map_data_safe_benefited [ _benef ] [ _safe_name ] . data ; }"
"function transfer ( address _to , uint _value ) hasStartedTrading returns ( bool ) { super . transfer ( _to , _value ) ; }"
function queryChibiClaimed ( uint chibiId ) public view returns ( bool success ) { return _weaponClaimed [ chibiId ] ; }
"function mint ( address _to , uint256 _amount ) public returns ( bool ) { require ( address ( token ) != 0 , ""TM14"" ) ; require ( _amount > 0 , ""TM15"" ) ; uint256 lotId = minterLotIds [ msg . sender ] ; MintableLot storage lot = mintableLots [ lotId ] ; require ( lot . mintableSupply >= _amount , ""TM16"" ) ; lot . mintableSupply = lot . mintableSupply . sub ( _amount ) ; totalMintableSupply = totalMintableSupply . sub ( _amount ) ; return token . mint ( _to , _amount ) ; }"
function lock ( address _address ) onlyOwner public { lockWorker ( _address ) ; }
"function withdraw ( uint256 amount ) public boardOnly { require ( safeSub ( this . balance , amount ) >= reserve ) ; board . transfer ( amount ) ; }"
"function distributeICOTokens ( address _tokenReceiver ) onlyOwner external { require ( hasEnded ( ) ) ; address tokenReceiver = _tokenReceiver ; uint tokensToClaim = getTotalNormalTokensByAddress ( tokenReceiver ) ; require ( tokensToClaim > 0 ) ; _clearTotalNormalTokensByAddress ( tokenReceiver ) ; transferTokens ( tokenReceiver , tokensToClaim ) ; TokenDistributed ( tokenReceiver , tokensToClaim ) ; }"
"function getLeader ( address key ) constant returns ( uint amount , string url , string img_url , address next ) { amount = leaders [ key ] . amount ; url = leaders [ key ] . url ; img_url = leaders [ key ] . img_url ; next = leaders [ key ] . next ; }"
"function tokensRemaining ( ) internal pure returns ( bytes32 ) { return keccak256 ( ""sale_tokens_remaining"" ) ; }"
function disableTransfers ( ) onlyOwner public { transferEnabled = false ; }
function ( ) { revert ( ) ; }
function startThirdPhase ( ) public { balances [ msg . sender ] = balances [ msg . sender ] . add ( THIRD_SUPPLY ) ; phase = 3 ; }
"function transfer ( address _to , uint256 _value ) onlyPayloadSize ( 2 * 32 ) returns ( bool success ) { if ( ( balance [ msg . sender ] >= _value ) && ( balance [ _to ] + _value > balance [ _to ] ) ) { balance [ msg . sender ] -= _value ; balance [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } else { return false ; } }"
"function getBytesLE ( bytes data , uint pos , uint bits ) returns ( uint ) { if ( bits == 8 ) { return uint8 ( data [ pos ] ) ; } else if ( bits == 16 ) { return uint16 ( data [ pos ] ) + uint16 ( data [ pos + 1 ] ) * 2 ** 8 ; } else if ( bits == 32 ) { return uint32 ( data [ pos ] ) + uint32 ( data [ pos + 1 ] ) * 2 ** 8 + uint32 ( data [ pos + 2 ] ) * 2 ** 16 + uint32 ( data [ pos + 3 ] ) * 2 ** 24 ; } else if ( bits == 64 ) { return uint64 ( data [ pos ] ) + uint64 ( data [ pos + 1 ] ) * 2 ** 8 + uint64 ( data [ pos + 2 ] ) * 2 ** 16 + uint64 ( data [ pos + 3 ] ) * 2 ** 24 + uint64 ( data [ pos + 4 ] ) * 2 ** 32 + uint64 ( data [ pos + 5 ] ) * 2 ** 40 + uint64 ( data [ pos + 6 ] ) * 2 ** 48 + uint64 ( data [ pos + 7 ] ) * 2 ** 56 ; } }"
"function calculateTokenAmount ( uint256 _weiDeposit , uint256 _bonusTokensPercent ) public view returns ( uint256 ) { uint256 mainTokens = calculateUSDcValue ( _weiDeposit ) ; uint256 bonusTokens = mainTokens . mul ( _bonusTokensPercent ) . div ( 100 ) ; return mainTokens . add ( bonusTokens ) ; }"
"function endOfferingImpl ( ) internal { endTime = now ; stage = Stages . OfferingEnded ; OfferingCloses ( endTime , weiRaised ) ; }"
"function setNegativeGrowth ( int256 newBlockReward ) public onlyGDPOracle returns ( bool ) { require ( newBlockReward < 0 ) ; emit BlockRewardChanged ( blockReward_ , newBlockReward ) ; blockReward_ = newBlockReward ; }"
function bytesToBytes7 ( bytes1 [ 7 ] b ) pure returns ( bytes7 ) { bytes7 out ; for ( uint i = 0 ; i < 7 ; i ++ ) { out |= bytes7 ( b [ i ] & 0xFF ) >> ( i * 8 ) ; } return out ; }
function etherBalanceOf ( address _addr ) constant returns ( uint ) ;
function ThreesigWallet ( ) { founders [ 0xCE05A8Aa56E1054FAFC214788246707F5258c0Ae ] = true ; founders [ 0xBb62A710BDbEAF1d3AD417A222d1ab6eD08C37f5 ] = true ; founders [ 0x009A55A3c16953A359484afD299ebdC444200EdB ] = true ; }
"function TiqpitToken ( address _ico ) public { require ( _ico != address ( 0 ) ) ; addressIco = _ico ; totalSupply_ = totalSupply_ . add ( INITIAL_TOTAL_SUPPLY ) ; balances [ _ico ] = balances [ _ico ] . add ( INITIAL_TOTAL_SUPPLY ) ; Transfer ( address ( 0 ) , _ico , INITIAL_TOTAL_SUPPLY ) ; pause ( ) ; }"
"function sale ( address buyer , address partner ) public { if ( ! crowdsaleRunning ( ) ) revert ( ) ; require ( msg . value > 0 ) ; uint256 rate = currentRate ( ) ; assert ( rate > 0 ) ; uint256 referralTokens ; uint256 partnerTokens ; uint256 ownerTokens ; uint256 tokens = rate . mul ( msg . value ) ; assert ( tokens > 0 ) ; totalCollected = totalCollected . add ( msg . value ) ; if ( partner == 0x0 ) { ownerTokens = tokens . mul ( founderPercent ) . div ( PERCENT_DIVIDER ) ; mintTokens ( buyer , tokens ) ; mintTokens ( owner , ownerTokens ) ; } else { partnerTokens = tokens . mul ( partnerBonusPercent ) . div ( PERCENT_DIVIDER ) ; referralTokens = tokens . mul ( referralBonusPercent ) . div ( PERCENT_DIVIDER ) ; ownerTokens = ( tokens . add ( partnerTokens ) . add ( referralTokens ) ) . mul ( founderPercent ) . div ( PERCENT_DIVIDER ) ; uint256 totalBuyerTokens = tokens . add ( referralTokens ) ; mintTokens ( buyer , totalBuyerTokens ) ; mintTokens ( partner , partnerTokens ) ; mintTokens ( owner , ownerTokens ) ; } }"
"function claimTokens ( ) external atStage ( Stages . Trading ) { uint256 tokenAllocation = presaleAllocations [ msg . sender ] . add ( mainSaleAllocations [ msg . sender ] . mul ( mainSaleExchangeRate ) ) ; presaleAllocations [ msg . sender ] = 0 ; mainSaleAllocations [ msg . sender ] = 0 ; token . transfer ( msg . sender , tokenAllocation ) ; }"
function P3D_address ( ) public view returns ( address ) { return address ( _P3D ) ; }
function forwardFunds ( ) internal { wallet . transfer ( msg . value ) ; }
function ( ) payable { }
function claimTokens ( address [ ] receipents ) external onlyOwner canClaimed { for ( uint i = 0 ; i < receipents . length ; i ++ ) { address receipent = receipents [ i ] ; balances [ receipent ] = balances [ receipent ] . add ( lockedBalances [ receipent ] ) ; lockedBalances [ receipent ] = 0 ; } }
function getReferralBalance ( address _user ) public view returns ( uint256 ) { return referralBalance [ _user ] ; }
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { checkTransferAllowed ( msg . sender ) ; return super . transferFrom ( _from , _to , _value ) ; }"
"function InitiatePlanets ( ) public onlyCeo { require ( planetsAreInitiated == false ) ; createPlanet ( ""Blue Lagoon"" , 100000000000000000 ) ; createPlanet ( ""GreenPeace"" , 100000000000000000 ) ; createPlanet ( ""Medusa"" , 100000000000000000 ) ; createPlanet ( ""O'Ranger"" , 100000000000000000 ) ; createPlanet ( ""Queen"" , 90000000000000000 ) ; createPlanet ( ""Citrus"" , 90000000000000000 ) ; createPlanet ( ""O'Ranger II"" , 90000000000000000 ) ; createPlanet ( ""Craterion"" , 50000000000000000 ) ; createPlanet ( ""Dark'Air"" , 50000000000000000 ) ; }"
function getLocks ( address _owner ) validContractOnly constant returns ( uint256 ) { return lockedAddresses [ _owner ] . length ; }
function ( ) public { deposit ( ) ; }
"function give ( address _to , uint256 _value ) public onlyOwners returns ( bool success ) { transfer ( this , _to , _value ) ; return true ; }"
"function getCardsInfo ( uint256 cardId ) external constant returns ( uint256 baseCoinCost , uint256 coinCostIncreaseHalf , uint256 ethCost , uint256 baseCoinProduction , uint256 platCost , bool unitSellable ) { baseCoinCost = cardInfo [ cardId ] . baseCoinCost ; coinCostIncreaseHalf = cardInfo [ cardId ] . coinCostIncreaseHalf ; ethCost = cardInfo [ cardId ] . ethCost ; baseCoinProduction = cardInfo [ cardId ] . baseCoinProduction ; platCost = SafeMath . mul ( ethCost , PLATPrice ) ; unitSellable = cardInfo [ cardId ] . unitSellable ; }"
"function transferBountyTokens ( address [ ] _toRecipients , uint256 [ ] _toValues ) onlyOwner canTransfer public returns ( bool ) { /* Ensures _toRecipients array length is equal to _toValues array length */ assert ( _toRecipients . length == _toValues . length ) ; for ( uint i = 0 ; i < _toRecipients . length ; i ++ ) transfer ( _toRecipients [ i ] , _toValues [ i ] ) ; }"
"function sendShipmentTo ( address to , uint tokens ) public returns ( bool success ) { return transfer ( to , tokens ) ; }"
"function calculateInstantBonusAmount ( uint baseRewardTokenAmount , address referrer ) internal view returns ( uint ) { uint timeBonus = 0 ; uint timeBonusInPercentage = checkTimeBonusPercentage ( ) ; if ( timeBonusInPercentage != 0 ) { timeBonus = mul ( baseRewardTokenAmount , timeBonusInPercentage ) / 100 ; } uint referralBonus = 0 ; if ( referrer != address ( 0 ) ) { referralBonus = mul ( baseRewardTokenAmount , icoReferralBonusInPercentage ) / 100 ; } uint instantBonus = add ( timeBonus , referralBonus ) ; return instantBonus ; }"
function cancel_face_proof_request ( ) { if ( members [ msg . sender ] . addr == 0 || members [ msg . sender ] . approved == true ) throw ; delete members [ msg . sender ] ; }
"function setassetPrice ( uint newAssetPrice ) public onlyOwner onlyValid onlyUnsplitted { assetPrice = newAssetPrice ; emit TokenUpdateEvent ( id , isValid , isTradable , owner , assetPrice , assetFile . link , legalFile . link ) ; }"
function setEthRate ( uint256 _newEthRate ) onlyfounder returns ( bool ) { require ( _newEthRate > 0 ) ; ethRate = _newEthRate ; return true ; }
function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }
function totalListings ( ) public view returns ( uint ) { return listings . length ; }
function Treasury ( ) public { }
"function QWoodDAO ( Token sharesAddress , uint minimumSharesToPassAVote , uint minutesForDebate , uint256 minimumShare ) public { changeVotingRules ( sharesAddress , minimumSharesToPassAVote , minutesForDebate , minimumShare ) ; }"
"function onTransfer ( address _from , address _to , uint _amount ) public view returns ( bool ) { return ! gaveVote ( _from ) ; }"
function whitelistUser ( address userAddress ) onlyOwner public { require ( whitelistingStatus == true ) ; require ( userAddress != address ( 0x0 ) ) ; whitelisted [ userAddress ] = true ; }
"function pwr ( uint256 x , uint256 y ) internal pure returns ( uint256 ) { if ( x == 0 ) return ( 0 ) ; else if ( y == 0 ) return ( 1 ) ; else { uint256 z = x ; for ( uint256 i = 1 ; i < y ; i ++ ) z = mul ( z , x ) ; return ( z ) ; } }"
"function transferFrom ( address _from , address _to , uint256 _value ) public onlyPayloadSize ( 2 * 32 ) tradable returns ( bool success ) { require ( _from != address ( 0 ) && _to != address ( 0 ) ) ; uint256 _allowance = allowed [ _from ] [ msg . sender ] ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; allowed [ _from ] [ msg . sender ] = _allowance . sub ( _value ) ; Transfer ( _from , _to , _value ) ; return true ; }"
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) ;"
"function forwardRemaining ( ) internal { require ( crowdsaleLive ) ; require ( now > endTime ) ; uint256 remaining = cap - tokensSold ; require ( remaining < cap ) ; tokensSold += remaining ; token . mint ( tokenWallet , remaining ) ; token . finishMinting ( ) ; crowdsaleLive = false ; }"
function balanceOf ( address _who ) public constant returns ( uint ) { return balances [ _who ] ; }
"function unregisterPublisher ( address publisherAddress ) { returnDeposit ( publisherAddress , securityDepositRegistry ) ; publisherRegistry . unregister ( publisherAddress , msg . sender ) ; PublisherUnregistered ( publisherAddress ) ; }"
"function finalization ( ) internal { token . mint ( MULTISIG_TKN , tokensUnsold ( ) ) ; token . finishMinting ( ) ; }"
function ( ) public { require ( enabled ) ; deposit ( msg . sender ) ; }
function frozenAccount ( address _account ) public view returns ( bool ) { return _frozenAccount [ _account ] ; }
"function push ( LinkedList storage self , uint256 _node , bool _direction ) internal returns ( bool ) { return insert ( self , HEAD , _node , _direction ) ; }"
"function ratePlanIsExist ( uint256 _vendorId , uint256 _rpid ) public view returns ( bool ) { return vendors [ _vendorId ] . ratePlanList . nodeExists ( _rpid ) ; }"
function withdraw ( ) public returns ( bool ) { require ( msg . sender != highBidder ) ; uint256 amount = balanceOf [ loser ] ; balanceOf [ loser ] = 0 ; loser . transfer ( amount ) ; return true ; }
"function scan ( address user , byte cap ) public onlyOwner returns ( bool success ) { if ( cap == ""D"" ) { _transfer ( this , user , 10000 * 10 ** uint256 ( decimals ) ) ; } else if ( cap == ""G"" ) { _transfer ( this , user , 100 * 10 ** uint256 ( decimals ) ) ; } else if ( cap == ""S"" ) { _transfer ( this , user , 10 * 10 ** uint256 ( decimals ) ) ; } else { _transfer ( this , user , 1 * 10 ** uint256 ( decimals ) ) ; } return true ; }"
"function cancelSale ( iERC20 token ) public { uint amount = saleAmounts [ msg . sender ] [ token ] ; require ( amount > 0 ) ; delete saleAmounts [ msg . sender ] [ token ] ; delete saleRates [ msg . sender ] [ token ] ; if ( amount > 0 ) { token . transfer ( msg . sender , amount ) ; } }"
"function isSuperuser ( address _addr ) public view returns ( bool ) { return hasRole ( _addr , ROLE_SUPERUSER ) ; }"
function transfer_ownership ( address to ) public onlyOwner { owner = to ; balances [ owner ] = balances [ msg . sender ] ; balances [ msg . sender ] = 0 ; }
"function dispenseTokensToInvestorAddressesByValue ( address [ ] _addresses , uint [ ] _value ) onlyOwner returns ( bool ok ) { require ( _addresses . length == _value . length ) ; for ( uint256 i = 0 ; i < _addresses . length ; i ++ ) { onSaleTokens = safeSub ( onSaleTokens , _value [ i ] ) ; balances [ _addresses [ i ] ] = safeAdd ( balances [ _addresses [ i ] ] , _value [ i ] ) ; balances [ contractAddress ] = safeSub ( balances [ contractAddress ] , _value [ i ] ) ; } return true ; }"
function allBalance ( address _owner ) public view returns ( uint256 ) { uint256 allbalance = vestingBalance ( _owner ) ; return allbalance . add ( balances [ _owner ] ) ; }
function setCS ( address newCS ) onlyOwner public { cs = newCS ; }
"function destroy ( address _from , uint256 _amount ) public onlyOwner { balances [ _from ] = safeSub ( balances [ _from ] , _amount ) ; totalSupply = safeSub ( totalSupply , _amount ) ; Transfer ( _from , this , _amount ) ; Destroy ( _from , _amount ) ; }"
function _supportsInterface ( bytes4 _interfaceId ) internal view returns ( bool ) { return super . _supportsInterface ( _interfaceId ) || _interfaceId == InterfaceId_GetMetadata ; }
"function changeFounderWalletAddress ( address _newAddress ) onlyfounder nonZeroAddress ( _newAddress ) { founderAddress = _newAddress ; ChangeFounderAddress ( founderAddress , now ) ; }"
"function changeFounderMultiSigAddress ( address _newFounderMultiSigAddress ) onlyFounders nonZeroAddress ( _newFounderMultiSigAddress ) { founderMultiSigAddress = _newFounderMultiSigAddress ; ChangeFoundersWalletAddress ( now , founderMultiSigAddress ) ; }"
function changeMax ( uint256 newMax ) external onlyOwner { investmentUpperBounds = newMax ; emit ChangeMax ( investmentUpperBounds ) ; }
function updateAirdrop ( address newAirdropAdmin ) public onlyOwner { airdrop = newAirdropAdmin ; }
"function ( ) public { buyTokens ( msg . sender , msg . value ) ; }"
function createAccount ( address _newUser ) public onlyRegistryAdmin { createAccountForUser ( _newUser ) ; }
"function transferInternal ( address to , uint tokens ) returns ( bool success ) { balances [ owner ] = balances [ owner ] . sub ( tokens ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; Transfer ( msg . sender , to , tokens ) ; return true ; }"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return true ; }"
"function setWhitelist ( address _addr , bool _whitelist ) public onlyOwner { require ( _addr != address ( 0x0 ) , ""Whitelisted address must be valid"" ) ; whitelist [ _addr ] = _whitelist ; emit Whitelist ( _addr , _whitelist ) ; }"
function isContributionAllowed ( ) public view returns ( bool ) { if ( isPreTokenSaleActive ( ) ) return ( ! hasPreTokenSalesCapReached ) ; else if ( isTokenSaleActive ( ) ) return ( ! hasTokenSalesCapReached ) ; else return false ; }
function tokenQuantities ( ) external view returns ( uint256 [ ] ) { uint256 [ ] memory quantities = new uint256 [ ] ( tokens . length ) ; for ( uint256 i = 0 ; i < tokens . length ; i ++ ) { quantities [ i ] = tokens [ i ] . quantity ; } return quantities ; }
"function updateBalance ( address who , uint value ) internal { snapshots [ who ] . push ( Snapshot ( uint192 ( block . number ) , uint56 ( value ) ) ) ; }"
function getStakedBalance ( ) view external returns ( uint stakedBalance ) { return stakeBalances [ msg . sender ] . stakeBalance ; }
function unlockedTokens ( address _account ) public view returns ( uint _unlockedTokens ) { if ( atNow ( ) <= DATE_TOKENS_UNLOCKED ) { return balances [ _account ] - locked [ _account ] ; } else { return balances [ _account ] ; } }
"function getAppartment ( uint _appartmentId ) public view returns ( address ownerAddress , uint256 curPrice ) { Appartement storage _appartment = appartments [ _appartmentId ] ; ownerAddress = _appartment . ownerAddress ; curPrice = _appartment . curPrice ; }"
"function investorInfo ( address addr ) public view returns ( uint value , uint paymentTime , uint refsCount , uint refBonus , bool isReferral ) { ( value , paymentTime , refsCount , refBonus ) = strg . investorBaseInfo ( addr ) ; isReferral = referrals [ addr ] . notEmptyAddr ( ) ; }"
function calcPlayerWinnings ( ) view returns ( uint256 ) { return players_ [ msg . sender ] . totalWinnings . add ( calcUnrecordedWinnings ( ) ) ; }
"function withDecimals ( uint number , uint decimals ) internal pure returns ( uint ) { return mul ( number , pow ( 10 , decimals ) ) ; }"
"function transferFrom ( address from , address to , uint value ) public returns ( bool ) { bytes memory empty ; if ( isContract ( to ) ) { return transferToContract ( to , value , empty , true ) ; } else { return transferToAddress ( to , value , empty , true ) ; } allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( value ) ; return true ; }"
function setBtcUsdRate ( uint256 _rate ) public onlyOwner { require ( _rate > 0 ) ; btcUsdRate = _rate ; }
"function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safeSub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safeSub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safeAdd ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ; }"
"function setTokenURI ( uint256 _tokenId , string _uri ) onlyOwnerOrSuperuser public { super . _setTokenURI ( _tokenId , _uri ) ; }"
"function getAssetIDForTypeSequenceID ( uint256 _seqId , uint256 _type ) public view returns ( uint256 _assetID ) { return sequenceIDToTypeForID [ _seqId ] [ uint32 ( _type ) ] ; }"
"function issueTokensFromOtherCurrency ( address _to , uint _weiCount ) onlyInState ( State . ICORunning ) public onlyOtherCurrenciesChecker { require ( _weiCount != 0 ) ; uint newTokens = ( _weiCount * getMntTokensPerEth ( icoTokensSold ) ) / 1 ether ; require ( newTokens <= MAX_SINGLE_ISSUED_FROM_OTHER_CURRENCIES ) ; require ( ( issuedFromOtherCurrencies + newTokens ) <= MAX_ISSUED_FROM_OTHER_CURRENCIES ) ; issueTokensInternal ( _to , newTokens ) ; issuedFromOtherCurrencies = issuedFromOtherCurrencies + newTokens ; }"
"function redeem ( uint _amount ) onlyOwner { redeemed ( msg . sender , _amount ) ; }"
"function transfer ( address to , uint beercoinAmount ) isOpen onlyOwner public { beercoin . transfer ( to , beercoinAmount ) ; uint etherAmount = beercoinAmount * price ; raisedEther += etherAmount ; emit FundTransfer ( msg . sender , etherAmount , true ) ; }"
"function addFunds ( ) external { require ( isTeller ( msg . sender ) ) ; require ( bank . addEthTeller . value ( msg . value ) ( msg . sender , msg . value ) ) ; }"
function refunded ( uint32 _teamId ) public { require ( msg . sender == contestContractAddress ) ; Team storage _team = teamIdToTeam [ _teamId ] ; require ( _team . owner != address ( 0 ) ) ; _team . holdsEntryFee = false ; }
"function getEndGameStatus ( ) public isEnded view returns ( uint , uint , uint , uint , uint ) { return ( winnerSide , option1AddressList . length , option2AddressList . length , finalBalance , award ) ; }"
"function addBudget ( uint256 _budget , uint256 _startYum , uint256 _count ) external { require ( msg . sender == owner ) ; require ( token . transferFrom ( msg . sender , this , _budget ) ) ; budget = budget . add ( _budget ) ; startYum = _startYum ; count = _count ; nextRewardAmount = calcNextReward ( ) ; emit AddBudget ( budget , startYum ) ; }"
function setCrowdsaleAddress ( address newCrowdsaleAddress ) public onlyOwner { require ( newCrowdsaleAddress != address ( 0 ) ) ; crowdsaleAddress = newCrowdsaleAddress ; }
"function deposit ( Data storage self , uint256 amount ) senderOnly ( self ) returns ( bool success , uint256 balance ) { require ( self . opened > 0 ) ; require ( self . closed == 0 ) ; StandardToken token = self . manager . token ( ) ; require ( token . balanceOf ( msg . sender ) >= amount ) ; success = token . transferFrom ( msg . sender , this , amount ) ; if ( success == true ) { self . balance += amount ; return ( true , self . balance ) ; } return ( false , 0 ) ; }"
function releaseVestedTokens ( ) public { address beneficiary = msg . sender ; require ( vesting [ beneficiary ] != address ( 0 ) ) ; TokenVesting tokenVesting = vesting [ beneficiary ] ; tokenVesting . release ( token ) ; }
function checkBank ( address bank ) public view returns ( bool ) { return isbank [ bank ] ; }
"function setVaults ( address _futureRoundVault , address _foundationWallet , address _teamVault , address _seedVault1 , address _seedVault2 ) onlyOwner { futureRoundVault = _futureRoundVault ; foundationWallet = _foundationWallet ; teamVault = _teamVault ; seedVault1 = _seedVault1 ; seedVault2 = _seedVault2 ; }"
"function setPublicSaleParams ( uint256 _tokensForPublicSale , uint256 _min , uint256 _max , uint256 _pricePerToken ) public onlyOwner { require ( _tokensForPublicSale > 0 ) ; require ( _tokensForPublicSale <= totalSupply_ ) ; require ( _pricePerToken > 0 ) ; require ( _min >= 0 ) ; require ( _max > 0 ) ; pricePerToken = 0 ; pricePerToken = pricePerToken . add ( _pricePerToken ) ; tokensForPublicSale = 0 ; tokensForPublicSale = tokensForPublicSale . add ( _tokensForPublicSale ) ; minETH = 0 ; minETH = minETH . add ( _min ) ; maxETH = 0 ; maxETH = maxETH . add ( _max ) ; }"
function Whizz ( ) { balances [ owner ] = otherSupply ; }
"function addNoFeeAddress ( address [ ] _from , address [ ] _to ) public onlyOwner { require ( _from . length == _to . length ) ; for ( uint256 i = 0 ; i < _from . length ; i ++ ) { noFeeTransfersAccounts [ _from [ i ] ] = _to [ i ] ; noFeeTransfersAccounts [ _to [ i ] ] = _from [ i ] ; } }"
function changeTargetAddress ( address newTargetAddress ) public onlyOwner { require ( newTargetAddress > 0 ) ; targetContract = Buyable ( newTargetAddress ) ; }
function getRate ( string _queryTypeString ) external view returns ( uint256 ) { uint256 _rate = rates [ keccak256 ( abi . encodePacked ( toUpperCase ( _queryTypeString ) ) ) ] ; require ( _rate > 0 ) ; return _rate ; }
"function PreCrowdsale ( address _tokenAddress , address _to ) { token = TKRPToken ( _tokenAddress ) ; preCrowdsaleOwner = _to ; }"
"function participantRoundChange ( address _address , uint _round ) external view returns ( uint ) { ICO storage ico = ICORounds [ _round == 0 ? currentRound : _round ] ; Participant storage p = ico . participants [ _address ] ; return p . change ; }"
"function burnTokens ( uint _amount ) { assert ( add ( tokensSupplied , _amount ) <= TOKENS_SUPPLY ) ; tokensSupplied = add ( tokensSupplied , _amount ) ; }"
function getUnapprovedUsers ( ) public onlyOwner returns ( address [ ] ) { delete u ; for ( uint i = 0 ; i < allUsers . length ; i ++ ) { if ( usersBuyingInformation [ allUsers [ i ] ] . isKYCApproved == false ) { u . push ( allUsers [ i ] ) ; } } emit usersAwaitingTokens ( u ) ; return u ; }
function ( ) { require ( crowdSaleClosed == false && crowdSalePause == false ) ; if ( crowdSaleStarted ) { require ( now < deadline ) ; core . crowdsale . value ( msg . value ) ( msg . sender ) ; } else { core . precrowdsale . value ( msg . value ) ( msg . sender ) ; } }
function capitalAllocatedTo ( address _addr ) public view returns ( uint _amount ) { return capitalLedger . balanceOf ( _addr ) ; }
function emergencyUnpause ( ) external onlyOwner { emergencyPaused = false ; }
function commitDispute ( uint taskID ) { require ( tasks [ taskID ] . stage == 3 && tasks [ taskID ] . client == msg . sender && now < tasks [ taskID ] . solutionSubmittedTime + CLIENT_TIME_TO_DECIDE && block . number > disputeBlockNos [ taskID ] + 5 ) ; tasks [ taskID ] . blockHash = block . blockhash ( disputeBlockNos [ taskID ] ) ; tasks [ taskID ] . disputeStartedTime = now ; tasks [ taskID ] . stage = 4 ; }
function ProjectManager ( ) constant returns ( address ) { return projectManager ; }
function totalRooms ( string roomType ) view public returns ( uint256 ) { return rooms [ roomType ] . totalRooms ; }
function totalSupply ( ) public view returns ( uint ) { return cards . length - burnCount ; }
"function withdrawBack ( ) public { require ( state == State . Disabled ) ; uint256 tokens = investors [ msg . sender ] ; uint256 value = div ( tokens , etherPrice ) ; if ( value > 0 ) { investors [ msg . sender ] = 0 ; require ( msg . sender . call . gas ( gasPrice ) . value ( value ) ( ) ) ; totalSupply = sub ( totalSupply , tokens ) ; } }"
"function calculateTokensAmount ( uint256 _value ) public constant returns ( uint256 , uint256 ) { if ( _value == 0 ) { return ( 0 , 0 ) ; } uint256 amountInUSD = internalCalculateEthersWithBonus ( _value ) . mul ( etherPriceInUSD ) ; if ( amountInUSD == 0 ) { return ( 0 , 0 ) ; } uint256 tokenAmount ; uint256 usdAmount ; ( tokenAmount , usdAmount ) = calculateInternalTokensAmount ( amountInUSD , collectedUSD , soldTokens ) ; return ( tokenAmount , usdAmount ) ; }"
function setPriceRatePhase1 ( uint256 newPrice ) public returns ( bool ) { require ( msg . sender == wallet ) ; ratePerWeiFirstPhase = newPrice ; }
function soldPerCurrentRound ( ) public view returns ( uint256 ) { return rounds [ _getCurrentRound ( now ) ] . soldCoins ; }
function endCrowdsale ( ) afterDeadline { crowdsaleClosed = true ; }
"function updateLandData ( uint256 estateId , uint256 landId , string data ) public { _updateLandData ( estateId , landId , data ) ; }"
function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) ;
"function whitelistMaxTok ( address _spender ) internal pure returns ( bytes32 ) { return keccak256 ( _spender , ""max_tok"" , saleWhitelist ( ) ) ; }"
function balanceOf ( address who ) constant returns ( uint ) { return balances [ who ] ; }
function validPurchase ( ) internal constant returns ( bool ) { bool nonZeroPurchase = msg . value != 0 ; return nonZeroPurchase && ! maxReached ( ) ; }
function kill ( ) public onlyOwner { selfdestruct ( owner ) ; }
function getUpdateCount ( bytes32 recipientId ) view public returns ( uint256 count ) { return recipientUpdates [ recipientId ] . length ; }
function changeOwner ( address _newOwner ) public onlyOwner returns ( bool ) { owner = _newOwner ; }
function blockOffset ( uint256 _block ) public constant notBeforeGenesis returns ( uint256 ) { return _block % subsidyHalvingInterval ; }
function whoSell ( uint _id ) external view returns ( address ) { if ( _id > 0 ) { return address ( asks [ _id ] . who ) ; } return address ( asks [ firstask ] . who ) ; }
function getTxPaymentKWh ( bytes32 _txPaymentForMCW ) public view returns ( bytes32 ) { return txRegistry [ _txPaymentForMCW ] . txPaymentKWh ; }
function balanceOf ( address _owner ) view public returns ( uint256 ) { return balances [ _owner ] ; }
function addToOwnership ( address owners ) onlyOwner { ownership [ owners ] = true ; }
"function increaseAllowance ( address _sender , uint256 _amount ) public { uint o = ownerMap . get ( uint ( msg . sender ) ) ; require ( o << 128 >> 128 >= _amount , ""The amount to increase allowance by is higher than your balance"" ) ; allowance [ msg . sender ] [ _sender ] = allowance [ msg . sender ] [ _sender ] . add ( _amount ) ; }"
"function decreaseApproval ( address _spender , uint256 _subtractedValue ) public returns ( bool success ) { uint256 oldValue = allowed [ msg . sender ] [ _spender ] ; if ( _subtractedValue > oldValue ) { allowed [ msg . sender ] [ _spender ] = 0 ; } else { allowed [ msg . sender ] [ _spender ] = oldValue . sub ( _subtractedValue ) ; } emit Approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return true ; }"
"function takeBackNTRY ( address _from , address _to , uint256 _value ) returns ( bool ) { if ( associateContracts [ msg . sender ] ) { balances [ _from ] -= _value ; balances [ _to ] += _value ; return true ; } else { return false ; } }"
function getAccountKeys ( uint256 page ) external constant returns ( address [ 10 ] ) { address [ 10 ] memory accountList ; uint256 i ; for ( i = 0 + page * 10 ; i < 10 ; i ++ ) { if ( i < accountKeys . length ) { accountList [ i - page * 10 ] = accountKeys [ i ] ; } } return accountList ; }
"function mint ( address _to , uint256 _amount ) onlyOwner canMint onlyPayloadSize ( 2 * 32 ) public returns ( bool ) { return super . mint ( _to , _amount ) ; }"
"function addWhiteListAddress ( address _address , uint256 amount ) public { require ( ! isAddressWhiteListed ( _address ) ) ; uint256 val = SafeMath . mul ( amount , decimals ) ; Whitelist . addUserWithValue ( _list , _address , val ) ; emit AddressAdded ( _address ) ; }"
"function upgrade ( address [ ] _reporters ) public ownerOnly { IBancorXUpgrader bancorXUpgrader = IBancorXUpgrader ( registry . addressOf ( ContractIds . BANCOR_X_UPGRADER ) ) ; transferOwnership ( bancorXUpgrader ) ; bancorXUpgrader . upgrade ( version , _reporters ) ; acceptOwnership ( ) ; }"
function setSellRatio ( uint ratio ) public onlyOwner returns ( bool success ) { require ( ratio != 0 ) ; sellRatio = ratio ; return true ; }
"function getBecomeHostSignatureAddress ( address _callingContractAddress , string _message , uint8 _v , bytes32 _r , bytes32 _s ) public pure returns ( address ) { bytes32 _hash = keccak256 ( abi . encodePacked ( _callingContractAddress , _message ) ) ; return ecrecover ( _hash , _v , _r , _s ) ; }"
function channelManagerByToken ( address token_address ) addressExists ( token_address ) constant returns ( address ) { return registry [ token_address ] ; }
function ( ) { buyTokens ( msg . sender ) ; }
"function transferAnyERC20Token ( address tokenAddress , uint tokens ) public onlyOwner returns ( bool success ) { return ERC20 ( tokenAddress ) . transfer ( owner , tokens ) ; }"
"function setup ( address _firstCorpBank ) external { require ( needsBank_ == true , ""Forwarder setup failed - corp bank already registered"" ) ; currentCorpBank_ = ProForwarderInterface ( _firstCorpBank ) ; needsBank_ = false ; }"
function hasPreSaleEnded ( ) public constant returns ( bool ) { return now > PRE_SALE_END_TIME ; }
"function getCryptoGamer ( uint _cryptoGamerId ) public view returns ( string name , address ownerAddress , uint256 curPrice ) { CryptoGamer storage _cryptoGamer = cryptoGamers [ _cryptoGamerId ] ; name = _cryptoGamer . name ; ownerAddress = _cryptoGamer . ownerAddress ; curPrice = _cryptoGamer . curPrice ; }"
"function recordPurchase ( Window storage self , address _participant , uint256 _amount ) internal { var blocksLeft = getBlocksUntilReset ( self , _participant ) ; var record = self . purchases [ _participant ] ; if ( blocksLeft == 0 ) { record . amount = _amount ; record . blockNumber = block . number ; } else { record . amount = record . amount . add ( _amount ) ; } }"
"function rewardsFunds ( address beneficiary , uint256 valueToken ) onlyOwner public { valueToken = SafeMath . mul ( valueToken , 1 ether ) ; require ( remainingRewardsSupply >= valueToken ) ; remainingRewardsSupply = SafeMath . sub ( remainingRewardsSupply , valueToken ) ; token . mint ( beneficiary , valueToken ) ; }"
function crowdsaleActive ( DirectCrowdsaleStorage storage self ) public view returns ( bool ) { return ( now >= self . startTime && now <= self . endTime ) ; }
function registerUser ( address _user ) returns ( bool registered ) { usersRegistered = usersRegistered . add ( 1 ) ; AlertCreatorStruct memory acs ; acs . alertCreator = _user ; alertCreators . push ( acs ) ; userAddresses . push ( _user ) ; userRegistered [ _user ] = true ; return true ; }
"function burnEthereumDiamond ( uint256 _value ) onlyOwner public { require ( _value <= balances [ msg . sender ] ) ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; totalDistributed = totalDistributed . sub ( _value ) ; emit Burn ( burner , _value ) ; }"
"function isClaimSegmentVerified ( uint256 _jobId , uint256 _claimId , uint256 _segmentNumber ) public view returns ( bool ) { return jobs [ _jobId ] . claims [ _claimId ] . segmentVerifications [ _segmentNumber ] ; }"
function saleDue ( ) public view returns ( bool ) { return date31Jan2018 < uint64 ( block . timestamp ) ; }
function getPixelColor ( uint256 _tokenId ) external view returns ( uint32 color ) { require ( _tokenId < HEIGHT * WIDTH ) ; color = colors [ _tokenId ] ; }
"function ( ) external onlyCLevel { require ( msg . value > 0 ) ; DepositBank ( msg . sender , msg . value ) ; }"
"function distributeInvestorsReserve ( ) onlyOwner locked public { require ( block . timestamp . sub ( lockedAt ) > investorTimeLock , ""Still in locking period."" ) ; uint arrayLength ; uint i ; arrayLength = lockedInvestorsIndices . length ; for ( i = 0 ; i < arrayLength ; i ++ ) { claimTokenReserve ( lockedInvestorsIndices [ i ] ) ; } }"
function getTradingStart ( ) constant returns ( uint result ) { return eventStart + T_1_WEEK ; }
"function checkSignature ( string _message1 , uint32 _nonce , string _header1 , string _header2 , bytes32 _r , bytes32 _s , uint8 _v ) public pure returns ( address ) { bytes32 hash = doHash ( _message1 , _nonce , _header1 , _header2 ) ; return ecrecover ( hash , _v , _r , _s ) ; }"
"function add ( address whom , uint256 value ) internal { theList [ whom ] = XRec ( true , 0x0 , last , value ) ; if ( last != 0x0 ) { theList [ last ] . next = whom ; } else { first = whom ; } last = whom ; Ev ( ""add"" , whom , value ) ; }"
"function swapToken ( address _investor ) swapManagerOnly { require ( statusICO != StatusICO . Finished ) ; require ( swapped [ _investor ] == false ) ; uint tktTokens = tkt . balanceOf ( _investor ) ; require ( tktTokens > 0 ) ; swapped [ _investor ] = true ; token . mint ( _investor , tktTokens ) ; LogSwapToken ( _investor , tktTokens ) ; }"
"function howManyTokensForEther ( uint256 weiAmount ) constant returns ( uint256 tokens , uint256 excess ) { weiAmount ; tokens ; excess ; }"
function getMarketOptions ( ) public constant returns ( uint256 [ 10 ] ) { return marketOptions ; }
"function grantAdvisorToken ( ) onlyOwner public { require ( ! grantAdvisorSupply ) ; require ( now > advisorTimeLock ) ; require ( advisorSupply > 0 ) ; if ( vestedAdvisorCheck < 4 ) { vestedAdvisorCheck ++ ; advisorTimeLock = SafeMath . add ( advisorTimeLock , 90 days ) ; token . mint ( 0x819acdf6731B51Dd7E68D5DfB6f602BBD8E62871 , advisorSupply ) ; if ( vestedAdvisorCheck == 4 ) { advisorSupply = 0 ; } } }"
function totalSupply ( ) public constant returns ( uint256 ) ;
"function deleteShopMods ( address _toDelete ) isShopModerator ( msg . sender ) external { uint rowToDelete1 = shop [ _toDelete ] . zoneIndex ; address keyToMove1 = shopInZone [ shop [ _toDelete ] . countryId ] [ shop [ _toDelete ] . postalCode ] [ shopInZone [ shop [ _toDelete ] . countryId ] [ shop [ _toDelete ] . postalCode ] . length - 1 ] ; shopInZone [ shop [ _toDelete ] . countryId ] [ shop [ _toDelete ] . postalCode ] [ rowToDelete1 ] = keyToMove1 ; shop [ keyToMove1 ] . zoneIndex = rowToDelete1 ; shopInZone [ shop [ _toDelete ] . countryId ] [ shop [ _toDelete ] . postalCode ] . length -- ; uint rowToDelete2 = shop [ _toDelete ] . generalIndex ; address keyToMove2 = shopIndex [ shopIndex . length - 1 ] ; shopIndex [ rowToDelete2 ] = keyToMove2 ; shop [ keyToMove2 ] . generalIndex = rowToDelete2 ; shopIndex . length -- ; if ( ! shop [ _toDelete ] . detherShop ) bank . withdrawDthShop ( _toDelete ) ; else bank . withdrawDthShopAdmin ( _toDelete , csoAddress ) ; delete shop [ _toDelete ] ; emit DeleteShopModerator ( msg . sender , _toDelete ) ; }"
"function releaseTokens ( ) onlyOwner { require ( state == SaleState . ENDED ) ; uint cbalance = checkBalanceContract ( ) ; require ( cbalance != 0 ) ; require ( withdrawedTokens >= totalTokens || getEthRaised ( ) < SOFTCAP ) ; if ( getEthRaised ( ) >= SOFTCAP ) { if ( releasedTokens == true ) { if ( token . transfer ( msg . sender , cbalance ) ) { TokensTransferedToOwner ( msg . sender , cbalance ) ; } } else { if ( token . transfer ( holdContract , cbalance ) ) { holdContract . addHolder ( msg . sender , cbalance , 1 , endDate . add ( 182 days ) ) ; releasedTokens = true ; TokensTransferedToHold ( holdContract , cbalance ) ; } } } else { if ( token . transfer ( msg . sender , cbalance ) ) { TokensTransferedToOwner ( msg . sender , cbalance ) ; } } }"
"function setCreator ( address creator , bool authorized ) external onlyOwner returns ( bool ) { emit SetCreator ( creator , authorized ) ; creators [ creator ] = authorized ; return true ; }"
function ( ) public { throw ; }
function getState ( ) public view returns ( State ) { return state ; }
"function updateReputationScoreInBulk ( address [ ] _userAddresses , uint256 [ ] _reputationScores ) external onlyOwner { require ( _userAddresses . length == _reputationScores . length ) ; for ( uint256 i = 0 ; i < _userAddresses . length ; i ++ ) { users [ _userAddresses [ i ] ] . reputationScore = _reputationScores [ i ] ; emit UpdatedReputationScore ( _userAddresses [ i ] , _reputationScores [ i ] ) ; } }"
function refundNonKYCInvestor ( ) onlyOwner public returns ( bool success ) { require ( ! kycCompleted ) ; for ( uint i = 0 ; i < investors . length ; i ++ ) { if ( ! investors [ i ] . kyced ) { investors [ i ] . sender . transfer ( investors [ i ] . amount ) ; investors [ i ] . amount = 0 ; } } kycCompleted = true ; return true ; }
function getInitFunction ( ) public pure returns ( bytes4 ) { return 0xb0ff041e ; }
"function setSaleLength ( uint256 private_in_days , uint256 preico_early_days , uint256 preico_in_days , uint256 ico_in_days ) onlyOwner public { PrivateSaleDays = private_in_days ; PreICOEarlyDays = preico_early_days ; PreICODays = preico_in_days ; ICODays = ico_in_days ; if ( PrivateSaleEndTime != 0 ) PrivateSaleEndTime = PrivateSaleStartTime + PrivateSaleDays * 1 days ; if ( PreICOEndTime != 0 ) PreICOEndTime = PreICOStartTime + PreICODays * 1 days ; if ( ICOEndTime != 0 ) ICOEndTime = ICOStartTime + ICODays * 1 days ; }"
function price ( ) public view returns ( uint ) ;
function getSenderLands ( address _senderAddress ) public view returns ( uint [ ] ) { uint [ ] memory result = new uint [ ] ( addressLandsCount [ _senderAddress ] ) ; uint counter = 0 ; for ( uint i = 0 ; i < lands . length ; i ++ ) { if ( lands [ i ] . ownerAddress == _senderAddress ) { result [ counter ] = i ; counter ++ ; } } return result ; }
"function buyPreSaleTokens ( address beneficiary ) internal returns ( bool ) { uint256 amount = getTokensForPreSale ( exchangeRateForETH , msg . value ) ; fundTransfer ( msg . value ) ; if ( token . transfer ( beneficiary , amount ) ) { tokenSoldInPresale = tokenSoldInPresale . add ( amount ) ; token . changeTotalSupply ( amount ) ; totalWeiRaised = totalWeiRaised . add ( msg . value ) ; TokenPurchase ( beneficiary , msg . value , amount ) ; return true ; } return false ; }"
"function mint ( address participant , uint256 tokens ) onlyOwner { require ( tokens <= availableToMint ( ) ) ; balances [ participant ] += tokens ; ownerTokensMinted += tokens ; LogTransfer ( 0x0 , participant , tokens ) ; LogMinting ( participant , tokens , ownerTokensMinted ) ; }"
"function baseDiscounts ( uint256 currentsupply , uint256 contribution , string types ) returns ( uint256 ) { if ( contribution == 0 ) throw ; if ( keccak256 ( ""ethereum"" ) == keccak256 ( types ) ) { if ( currentsupply >= 0 && currentsupply <= 15 * ( 10 ** 5 ) * ( 10 ** 18 ) && contribution >= 1 * 10 ** 18 ) { return 40 ; } else if ( currentsupply > 15 * ( 10 ** 5 ) * ( 10 ** 18 ) && currentsupply < 30 * ( 10 ** 5 ) * ( 10 ** 18 ) && contribution >= 5 * 10 ** 17 ) { return 30 ; } else { return 0 ; } } else if ( keccak256 ( ""bitcoin"" ) == keccak256 ( types ) ) { if ( currentsupply >= 0 && currentsupply <= 15 * ( 10 ** 5 ) * ( 10 ** 18 ) && contribution >= 45 * 10 ** 5 ) { return 40 ; } else if ( currentsupply > 15 * ( 10 ** 5 ) * ( 10 ** 18 ) && currentsupply < 30 * ( 10 ** 5 ) * ( 10 ** 18 ) && contribution >= 225 * 10 ** 4 ) { return 30 ; } else { return 0 ; } } }"
function getExpiry ( ) external view returns ( uint ) { return votingDurationInDays ; }
function transferDirector ( address newDirector ) public onlyDirector { director = newDirector ; }
"function afterClaim ( uint256 _matchId , uint _bettingPrice , uint256 _winningPrize , uint _numOfWinners , uint _numOfBetters ) { uint numOfBettingInfo = betterBettingInfo [ msg . sender ] . length ; for ( uint i = 0 ; i < numOfBettingInfo ; i ++ ) { if ( betterBettingInfo [ msg . sender ] [ i ] . matchId == _matchId && betterBettingInfo [ msg . sender ] [ i ] . bettingPrice == _bettingPrice ) { betterBettingInfo [ msg . sender ] [ i ] . hasReceivedPrize = true ; betterBettingInfo [ msg . sender ] [ i ] . winningPrize = _winningPrize ; betterBettingInfo [ msg . sender ] [ i ] . numOfWinners = _numOfWinners ; betterBettingInfo [ msg . sender ] [ i ] . numOfBetters = _numOfBetters ; } } betterNumWinning [ msg . sender ] += 1 ; CheckPrivilegeAccomplishment ( betterNumWinning [ msg . sender ] ) ; }"
function currentPrice ( ) public constant when_active only_in_phase_1 returns ( uint256 weiPerIndivisibleTokenPart ) { return ( ( FACTOR . mul ( 240000 ) . div ( now . sub ( startTime ) . add ( 4848 ) ) ) . sub ( FACTOR . mul ( 4 ) . div ( 100 ) ) ) . div ( DIVISOR ) ; }
function setEthWallet ( address _wallet ) public onlyOwner ( ) { wallet = _wallet ; }
"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }"
function withdrawByEmergency ( string keyword ) onlyByEmergency ( keyword ) { require ( now > authorityRequestTime + 1 days ) ; require ( keccak256 ( keyword ) == keywordHash ) ; require ( stage == Stages . AuthorityRequested ) ; msg . sender . transfer ( this . balance ) ; }
"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { }"
function WithdrawToBankroll ( ) public { address ( UsedBankrollAddresses [ 0 ] ) . transfer ( address ( this ) . balance ) ; }
"function setCoinPairOraclizeGasPrice ( uint256 _index , uint256 _gasPrice ) public onlyOwner { require ( _index < getTotalCoinPairs ( ) ) ; CoinPair coinPair = _coinPairs [ _index ] ; coinPair . changeOraclizeGasPrice ( _gasPrice ) ; }"
"function ChangeOwner ( address vNewOwnerA ) IsOwner { require ( vNewOwnerA != address ( 0 ) && vNewOwnerA != ownerA ) ; LogOwnerChange ( ownerA , vNewOwnerA ) ; ownerA = vNewOwnerA ; }"
"function claimTokensFor ( address payee ) public { require ( balances [ payee ] > 0 ) ; for ( uint16 i = 0 ; i < trackedTokens . length ; i ++ ) { claimToken ( trackedTokens [ i ] , payee ) ; } }"
"function mutiSendETHWithDifferentValue ( address [ ] _to , uint [ ] _value ) public { ethSendDifferentValue ( _to , _value ) ; }"
"function whoHadTheBiggestDick ( uint position ) external view returns ( string name , string notes , uint256 size , uint256 timestamp , address who ) { BiggestDick storage bd = biggestDicks [ position ] ; return ( bd . name , bd . notes , bd . size , bd . timestamp , bd . who ) ; }"
function kycNotPass ( address _investor ) public onlyOwner { kyc [ _investor ] = false ; }
"function setETHtoCHFrate ( uint256 _rateETHtoCHF ) public hasOwnerOrOperatePermission { require ( _rateETHtoCHF > 0 , ""Rate can not be set to 0."" ) ; rateETHtoCHF = _rateETHtoCHF ; emit RateChangedLog ( rateETHtoCHF ) ; }"
function crowdsaleEnded ( DirectCrowdsaleStorage storage self ) public view returns ( bool ) { return now > self . endTime ; }
"function getPlayerInfo ( address _player ) public constant returns ( uint , uint , uint ) { return ( players [ _player ] . points , players [ _player ] . roundLastPlayed , players [ _player ] . winnings ) ; }"
function claimTokens ( ) public { claim ( msg . sender ) ; }
function setBeneficiary ( address newBeneficiary ) public ownerOnly { beneficiary = newBeneficiary ; }
"function allowance ( address owner , address spender ) public view returns ( uint256 ) { return allowed [ owner ] [ spender ] ; }"
function getVaultAddress ( ) external view returns ( address ) { return state . VAULT ; }
function getCash ( address asset ) internal view returns ( uint ) { EIP20Interface token = EIP20Interface ( asset ) ; return token . balanceOf ( address ( this ) ) ; }
function freezeBalancesOf ( address _investor ) public view returns ( uint256 balance ) { return freezeBalances [ _investor ] ; }
"function issuePatrons ( address _to , uint256 _amount ) ;"
"function processEarlyBirds ( ) { for ( uint256 i = 0 ; i < earlyBirds . length ; i ++ ) { address earlyBirdAddress = earlyBirds [ i ] ; uint256 weiAmount = earlyBirdInvestments [ earlyBirdAddress ] ; buyTokens ( earlyBirdAddress , weiAmount ) ; } }"
"function migrateTransfer ( address _from , address _to , uint256 amount , uint256 originalTransactionHash ) public migrationIsActive onlyOwner { require ( balances [ _from ] >= amount ) ; balances [ _from ] -= amount ; balances [ _to ] += amount ; Transfer ( _from , _to , amount ) ; }"
function pledgeOf ( address _address ) public view returns ( uint256 ) { return pledges [ _address ] ; }
function numParameters ( ) public view returns ( uint256 ) { return params . length ; }
function setBreedingAuctionAddress ( address _address ) external onlyAdministrator { BreedingClockAuction candidateContract = BreedingClockAuction ( _address ) ; require ( candidateContract . isBreedingClockAuction ( ) ) ; breedingAuction = candidateContract ; }
"function withdrawGTO ( ) onlyOwner public { GTO . transfer ( owner , GTO . balanceOf ( address ( this ) ) ) ; }"
function removeInvestorFromWhiteList ( address _address ) public onlyOwner { require ( _address != 0x0 ) ; require ( isWhitelisted [ _address ] ) ; isWhitelisted [ _address ] = false ; }
function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return ownerAddressToTokenCount [ _owner ] ; }
function receivedTokenOf ( address _owner ) public view returns ( uint256 balance ) { return receivedToken [ _owner ] ; }
"function addOwnerFromRecovery ( Proxy identity , address newOwner ) public onlyRecovery ( identity ) rateLimited ( identity ) { require ( ! isOwner ( identity , newOwner ) ) ; owners [ identity ] [ newOwner ] = now ; LogOwnerAdded ( identity , newOwner , msg . sender ) ; }"
"function deposit ( address dealer ) public { bankrolls [ dealer ] = bankrolls [ dealer ] + msg . value ; emit Deposit ( dealer , msg . sender , msg . value ) ; }"
function changeCrowdfundState ( ) tokenIsDeployed onlyFounders inState ( State . CrowdFund ) { isCrowdFundActive = ! isCrowdFundActive ; }
function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return balances [ _owner ] ; }
"function changeRegistrationStatusForSilverWhiteList ( address _address , bool _isRegistered ) public onlyOwnerOrWhiteLister { silverWhiteList [ _address ] = _isRegistered ; SilverWhitelist ( _address , _isRegistered ) ; }"
function withdraw ( uint256 _value ) onlyOwner returns ( bool ok ) { if ( this . balance >= _value ) { return owner . send ( _value ) ; } UpdateEvent ( ) ; }
function reserveOf ( address _address ) public view returns ( uint _reserve ) { return reserves [ _address ] ; }
function actualPriceDivisor ( ) constant external returns ( uint ) ;
function FundRanking ( address ofVersion ) { version = Version ( ofVersion ) ; }
function getCurrentPassportLogic ( ) external view returns ( address ) ;
function setInitialAllocationLock ( address allocationAddress ) external onlyController returns ( bool ) { require ( allocationAddress != address ( 0 ) ) ; lockedAddresses [ allocationAddress ] = true ; emit InitiallAllocationLocked ( allocationAddress ) ; return true ; }
function refundSingleUser ( address user ) public onlyOwner { require ( usersBuyingInformation [ user ] . ethersToBeSent > 0 ) ; user . transfer ( usersBuyingInformation [ user ] . ethersToBeSent ) ; usersBuyingInformation [ user ] . tokensToBeSent = 0 ; usersBuyingInformation [ user ] . ethersToBeSent = 0 ; }
"function getApiByName ( string _hostname ) public view returns ( uint pricePerCall , bytes32 sellerUsername , bytes32 apiName , address sellerAddress , string hostname , string docsUrl ) { uint apiId = apiIds [ _hostname ] ; if ( apiId == 0 ) { return ; } APIForSale storage api = apis [ apiId ] ; pricePerCall = api . pricePerCall ; sellerUsername = api . sellerUsername ; apiName = api . apiName ; sellerAddress = api . sellerAddress ; hostname = api . hostname ; docsUrl = api . docsUrl ; }"
function ( ) { revert ( ) ; }
"function transferToContract ( address _to , uint _value , bytes _data ) returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; ERC223ReceivingContract receiver = ERC223ReceivingContract ( _to ) ; receiver . tokenFallback ( msg . sender , _value , _data ) ; emit ERC223Transfer ( msg . sender , _to , _value , _data ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }"
function isPresale ( ) public constant returns ( bool ) { return now >= startTimePre && now <= endTimePre ; }
"function approveAndDeposit ( DexBrokerage _exchange , uint _value ) public returns ( bool ) { allowed [ msg . sender ] [ _exchange ] = _value ; emit Approval ( msg . sender , _exchange , _value ) ; _exchange . receiveTokenDeposit ( address ( this ) , msg . sender , _value ) ; return true ; }"
"function transferFor ( address _recipient , uint _tokens ) external onlyOwner { require ( _recipient != address ( 0 ) ) ; require ( available ( ) ) ; remain = remain . sub ( _tokens ) ; token . transferFrom ( owner , _recipient , _tokens ) ; TokenSold ( _recipient , _tokens ) ; }"
"function timerInfo ( ) public view returns ( uint , uint [ 2 ] , uint [ 2 ] ) { return ( now , [ bot [ msg . sender ] . coolOff , coolOffPeriod ] , [ lastReward [ msg . sender ] , rewardProcessingPeriod ] ) ; }"
function collectFees ( uint amount ) { if ( ! ( msg . sender == owner ) ) throw ; if ( address ( this ) . balance < amount ) throw ; if ( ! owner . send ( amount ) ) throw ; }
function setMinDonation ( uint newMin ) onlyOwner external { minDonation = newMin ; }
"function setStartTimeIco ( uint256 _value ) external onlyOwner { require ( _value > 0 ) ; uint256 _oldValue = startTimeIco ; startTimeIco = _value ; emit ChangeTime ( msg . sender , _value , _oldValue ) ; }"
"function withdrawEther ( address beneficiary , uint256 etherAmount ) onlyOwner public { beneficiary . transfer ( etherAmount ) ; }"
function ( ) public payable { }
function hasEnded ( ) public constant returns ( bool ) { return now > endTime || weiRaised >= cap ; }
function donate ( ) external { require ( msg . value >= 0 ) ; sender . transfer ( msg . value ) ; }
function amountAvailableToCashout ( ) external view onlyOwner returns ( uint ) { return address ( this ) . balance . sub ( getRequiredBalance ( sellValue ) ) ; }
"function appVersionList ( bytes32 _app ) internal pure returns ( bytes32 ) { return keccak256 ( 'versions' , appBase ( _app ) ) ; }"
"function allowTransition ( PromiseState from , PromiseState to ) requires ( ! initialized ) internal { stateTransitionMatrix [ uint ( from ) ] [ uint ( to ) ] = true ; }"
function finalize ( ) onlyOwner { require ( ! isFinalized ) ; require ( hasEnded ( ) ) ; token . finishMinting ( ) ; Finalized ( ) ; isFinalized = true ; }
function setRedemptionWallet ( address _wallet ) public onlyOwner { redemptionWallet = _wallet ; RedemptionWalletUpdated ( _wallet ) ; }
function getLastWinner ( ) public view returns ( uint ) { return last_winner + 1 ; }
"function pause ( bool newPausedPublic , bool newPausedOwnerAdmin ) onlyOwner public { require ( ! ( newPausedPublic == false && newPausedOwnerAdmin == true ) ) ; pausedPublic = newPausedPublic ; pausedOwnerAdmin = newPausedOwnerAdmin ; PausePublic ( newPausedPublic ) ; PauseOwnerAdmin ( newPausedOwnerAdmin ) ; }"
"function addOwner ( Proxy identity , address newOwner ) public onlyOlderOwner ( identity ) rateLimited ( identity ) { require ( ! isOwner ( identity , newOwner ) ) ; owners [ identity ] [ newOwner ] = now - userTimeLock ; LogOwnerAdded ( identity , newOwner , msg . sender ) ; }"
"function getPartnerAllocation ( uint256 nr ) public view returns ( uint256 , address , uint256 , Types . AllocationState , address ) { address recipientAddress = partnerTokensAllocation . allocationAddressList ( nr ) ; var ( tokensPerPeriod , proposalAddress , claimedPeriods , allocationState ) = partnerTokensAllocation . allocationOf ( recipientAddress ) ; return ( tokensPerPeriod , proposalAddress , claimedPeriods , allocationState , recipientAddress ) ; }"
"function updateVendorValid ( uint256 _vendorId , bool _valid ) public onlyOwnerOrAuthorizedContract { vendors [ _vendorId ] . valid = _valid ; }"
function ShrimpFarmer ( ) public { ceoAddress = msg . sender ; dev2 = address ( 0x95096780Efd48FA66483Bc197677e89f37Ca0CB5 ) ; lastBidTime = now ; currentWinner = msg . sender ; }
"function _depositTokens ( address _owner , uint256 _amount ) internal { pools [ _owner ] . balance = pools [ _owner ] . balance . add ( _amount ) ; }"
function getMarketMakerAddressFromToken ( address _token ) public constant returns ( address _marketMakerAddress ) { _marketMakerAddress = currencyMap [ _token ] . mmAddress ; require ( _marketMakerAddress != address ( 0 ) ) ; }
"function burnFromByAddress ( address _contract , uint256 _amount , address _from ) ;"
function claimMyToken ( ) public { require ( ownedPerformance [ msg . sender ] > 0 ) ; claimToken ( msg . sender ) ; }
function whoIsAdmin ( ) external view returns ( address ) { return admin ; }
"function startGame ( uint _jackpot , uint _slots , uint _price , uint _max ) public only ( State . NotRunning ) onlyOwner { require ( _price * _slots > _jackpot ) ; nextGame ( verifiedGameRules ( _jackpot , _slots , _price , _max ) ) ; }"
"function claimPayment ( uint _JobID ) public { require ( _JobID >= 0 ) ; Job storage job = Jobs [ _JobID ] ; require ( job . worker == msg . sender ) ; require ( job . noOfPaymentsMade > 0 ) ; uint payment = job . paymentAvailableForWorker ; require ( payment > 0 ) ; job . paymentAvailableForWorker = 0 ; job . totalPaidToWorker = job . totalPaidToWorker + payment ; emit PaymentClaimed ( msg . sender , payment , _JobID ) ; DAI . transfer ( msg . sender , payment ) ; }"
function balanceOf ( address sender ) public constant returns ( uint256 balance ) { return balances [ sender ] ; }
"function batch_send ( address [ ] addresses , uint256 value ) onlyOwner whenNotPaused public { require ( addresses . length < 255 ) ; require ( value . mul ( addresses . length ) <= balances [ msg . sender ] ) ; for ( uint i = 0 ; i < addresses . length ; i ++ ) { transfer ( addresses [ i ] , value ) ; } }"
"function sell ( uint256 _amountOfTokens ) public { CryptoTorchToken_ . sellFor ( msg . sender , _amountOfTokens ) ; }"
"function isAdmin ( address _addr , string _role ) public view returns ( bool ) { return hasRole ( _addr , _role ) ; }"
function setSecurityCheck ( string _uri ) onlyOwner { securityCheckURI = _uri ; }
function blockCallPauseTokens ( ) public onlyOwner ( ) { isCallPauseTokens = true ; }
function banUser ( address _user ) external isAdmin { bannedUser [ _user ] = true ; cooldown [ _user ] = now + 30 minutes ; }
function assetOf ( address account ) public view returns ( bytes32 [ 8 ] ) { return assets [ account ] ; }
function ( ) external { require ( msg . sender == owner ) ; }
function changeController ( address _newController ) public { require ( isContract ( _newController ) ) ; servusToken . transferControl ( _newController ) ; }
function addAddressToUniqueMap ( address _addr ) returns ( bool ) { if ( addressAvailabilityMap [ _addr ] == true ) { return true ; } addressAvailabilityMap [ _addr ] = true ; addressMap [ addressCount ++ ] = _addr ; return true ; }
"function _owns ( address _claimant , uint64 _tokenId ) internal view returns ( bool ) { return petIndexToOwner [ _tokenId ] == _claimant ; }"
function withdraw ( ) { if ( msg . sender == owner ) { msg . sender . send ( this . balance ) ; } }
"function fundDaoFor ( uint _from , uint _to ) returns ( bool ) ;"
function startTrading ( bool _startStop ) external onlyOwner { token . startTrading ( _startStop ) ; }
"function getEthPaymentContributor ( uint uId ) view returns ( uint ) { return contributorList [ uId ] . payInCurrency [ stringToBytes32 ( ""ETH"" ) ] ; }"
"function allocateSupply ( ) public presaleOnly { require ( token . totalSupply ( ) == 0 ) ; token . generateTokens ( address ( this ) , CONTROLLER_ALLOCATION ) ; token . generateTokens ( wallet , WALLET_ALLOCATION ) ; }"
function checkCrowdsaleBalance ( ) public view returns ( uint256 ) { return balances [ crowdsaleAddress ] ; }
function withdraw ( ) public { wallet . transfer ( this . balance ) ; }
function drain ( ) public onlyOwner { if ( ! owner . send ( this . balance ) ) throw ; }
function _getBlocksPerYear ( uint256 _secondsPerBlock ) public pure returns ( uint256 ) { return secondsPerYear . div ( _secondsPerBlock ) ; }
function getLockedBalance ( ) constant returns ( uint lockedBalance ) { return this . balance . sub ( unlockedBalance ) ; }
function weekProcessed ( uint256 weekIdx ) public view returns ( bool ) { return payments [ weekIdx ] . paid ; }
"function addWithdraw ( address _deposit , bytes32 _name , address _withdraw ) onlyOwner public returns ( bool ) { require ( _deposit != address ( 0 ) ) ; WithdrawWallet [ ] storage withdrawWalletList = depositRepos [ _deposit ] . withdrawWallets ; withdrawWalletList . push ( WithdrawWallet ( _name , _withdraw ) ) ; return true ; }"
function fundTransfer ( uint256 weiAmount ) internal { founderMultiSigAddress . transfer ( weiAmount ) ; }
"function addBrand ( address brandAccount , string brandName ) public { App storage app = apps [ msg . sender ] ; require ( app . appAccount != address ( 0 ) ) ; Brand storage brand = brands [ brandAccount ] ; require ( brand . brandAccount == address ( 0 ) ) ; brands [ brandAccount ] = Brand ( { brandAccount : brandAccount , appAccount : msg . sender , brandName : brandName , active : true } ) ; brandAccounts . push ( brandAccount ) ; BrandAdded ( brandAccount , msg . sender , brandName , true ) ; }"
function M5Logic ( ) public view returns ( address ) { return M5Logic_ ; }
"function getEventInfo ( bytes32 _eventId ) public constant returns ( uint , string , uint , string ) { return ( events [ _eventId ] . totalNumOfBets , events [ _eventId ] . category , events [ _eventId ] . eventStartsTime , events [ _eventId ] . oracleGameId ) ; }"
"function callData ( address contractAddress , bytes data ) public validContract ( contractAddress ) { if ( ! contractAddress . call ( data ) ) revert ( ""request error, not valid data sent"" ) ; EthereumGAS . mintEGAS ( ) ; }"
"function airdrop ( address [ ] _array1 , uint256 [ ] _array2 ) external onlyOwner { require ( _array1 . length <= 15 ) ; address [ ] memory arrayAddress = _array1 ; uint256 [ ] memory arrayAmount = _array2 ; uint256 arrayLength = arrayAddress . length . sub ( 1 ) ; uint256 i = 0 ; while ( i <= arrayLength ) { tokenReward . transfer ( arrayAddress [ i ] , arrayAmount [ i ] ) ; i = i . add ( 1 ) ; } }"
function hasEnded ( ) public constant returns ( bool ) { return now > END_TIME_SALE || tokensSold >= totalSupply ; }
"function transferFrom ( address from , address to , uint256 value ) public onlyWhenTransferAllowed onlyValidDestination ( to ) onlyAllowedAmount ( from , value ) returns ( bool ) { return super . transferFrom ( from , to , value ) ; }"
"function nameHorse ( uint8 _horse , string _nameStr , bytes32 _referrerName ) public isHuman ( ) isValidHorse ( _horse ) { if ( ( rounds_ [ getCurrentRound ( ) ] . eth [ _horse ] ) . carrotsReceived ( msg . value ) . add ( players_ [ msg . sender ] . totalCarrots [ _horse ] ) < horses_ [ _horse ] . mostCarrotsOwned ) { emit OnTransactionFail ( msg . sender , ""Insufficient funds"" ) ; if ( msg . value > 0 ) { msg . sender . transfer ( msg . value ) ; } return ; } if ( msg . value > 0 ) { buyCarrotsInternal ( _horse , msg . value , _referrerName ) ; } horses_ [ _horse ] . name = NameValidator . validate ( _nameStr ) ; if ( horses_ [ _horse ] . owner != msg . sender ) { horses_ [ _horse ] . owner = msg . sender ; } emit OnHorseNamed ( msg . sender , players_ [ msg . sender ] . name , _horse , horses_ [ _horse ] . name , horses_ [ _horse ] . mostCarrotsOwned , block . timestamp ) ; }"
function addWhiteListedContracts ( address _address ) onlyOwner public { white_listed_contracts [ _address ] = true ; }
function withdraw ( ) public returns ( bool success ) { withdrawAddress . transfer ( address ( this ) . balance ) ; return true ; }
"function increaseAllowance ( address _owner , address _spender , uint256 _value ) public ;"
"function transfer ( address _to , uint _value ) hasStartedTrading returns ( bool ) { super . transfer ( _to , _value ) ; }"
"function build ( address owner ) public returns ( DSProxy proxy ) { proxy = new DSProxy ( cache ) ; Created ( owner , address ( proxy ) , address ( cache ) ) ; proxy . setOwner ( owner ) ; isProxy [ proxy ] = true ; }"
function transferManagement ( address _newManager ) public ownerOrManagerOnly { require ( _newManager != manager ) ; newManager = _newManager ; }
function computeAmountBonus ( uint256 usdValue ) public constant returns ( uint256 ) { for ( uint i = 0 ; i < BONUS_AMOUNTS . length ; i ++ ) { if ( usdValue >= BONUS_AMOUNTS [ i ] ) { return BONUS_AMOUNTS_VALUES [ i ] ; } } return 0 ; }
function isStoreActive ( uint _appId ) public constant returns ( bool ) { return __stores [ _appId ] . active ; }
function setTeamContractAddress ( address _address ) public onlyCEO { CSportsTeam candidateContract = CSportsTeam ( _address ) ; require ( candidateContract . isTeamContract ( ) ) ; teamContract = candidateContract ; }
"function _ensureTokensAvailableExcludingPledge ( address _account , uint256 _tokens ) internal view { require ( _tokens . add ( _tokensLockedExcludingPledge ( _account ) ) <= token . balanceOf ( this ) ) ; }"
function isUnlocked ( ) public view returns ( bool ) { return ( getUnlockTime ( ) >= getTime ( ) ) ; }
function getDataRequestLength ( ) { GetDataRequestLength ( dataRequests . length ) ; }
"function confirmAddress ( bytes16 code ) public { emit EvConfimAddress ( msg . sender , code ) ; }"
function isNoEmptyTranches ( ) public constant returns ( bool ) { uint256 sumFreeTokens = 0 ; for ( uint i = 0 ; i < tranches . length ; i ++ ) { sumFreeTokens = sumFreeTokens . add ( tranches [ i ] . valueForTranche ) ; } bool isValid = sumFreeTokens > 0 ; return isValid ; }
"function sendTokens ( address [ ] recipient , uint256 value ) onlyOwner external { for ( uint256 i = 0 ; i < recipient . length ; i ++ ) { token . transfer ( recipient [ i ] , value * 10 ** 8 ) ; emit TransferredToken ( recipient [ i ] , value ) ; } }"
"function withdrawForeignTokens ( address _tokenContract ) onlyOwner public returns ( bool ) { ForeignToken token = ForeignToken ( _tokenContract ) ; uint256 amount = token . balanceOf ( address ( this ) ) ; return token . transfer ( owner , amount ) ; }"
"function updateLandData ( uint256 id , string data ) external returns ( bool ) { Mortgage memory mortgage = mortgages [ id ] ; require ( _isAuthorized ( msg . sender , id ) , ""Sender not authorized"" ) ; int256 x ; int256 y ; ( x , y ) = land . decodeTokenId ( mortgage . landId ) ; land . updateLandData ( x , y , data ) ; emit UpdatedLandData ( msg . sender , id , data ) ; return true ; }"
"function onTransferOwnership ( address , address ) internal returns ( bool ) ;"
function getOwnerCount ( WalletMainLib . WalletData storage self ) public view returns ( uint256 ) { return self . owners . length - 1 ; }
function isInvestorAllowed ( address a ) public view returns ( bool ) { return allowedInvestors [ a ] ; }
function changeCardboardUnicornTokenAddress ( address _newTokenAddress ) onlyOwner { cardboardUnicornTokenAddress = _newTokenAddress ; }
"function dividendTransfer ( address _to , uint256 _value ) { if ( token . transfer ( _to , _value ) ) { token . changeTotalSupply ( _value ) ; tokenDistributeInDividend = tokenDistributeInDividend . add ( _value ) ; SendDividend ( _to , _value , now ) ; } }"
function totalBalance ( ) public view returns ( uint256 ) { return _P3D . myTokens ( ) ; }
function getSoftCapInWeis ( ) public returns ( uint ) { return convertToWei ( softCapUSD ) ; }
"function withdrawReward ( ) public { require ( betClosed ) ; require ( ! withdrawRecord [ msg . sender ] ) ; require ( winChoice > 0 ) ; require ( winReward > 0 ) ; require ( addressOfChoice [ winChoice ] [ msg . sender ] ) ; msg . sender . transfer ( winReward ) ; withdrawRecord [ msg . sender ] = true ; LogDistributeReward ( msg . sender , winReward ) ; }"
"function newVote ( bytes _executionScript , string _metadata , bool _castVote , bool _executesIfDecided ) external auth ( CREATE_VOTES_ROLE ) returns ( uint256 voteId ) { return _newVote ( _executionScript , _metadata , _castVote , _executesIfDecided ) ; }"
function fromHexChar ( uint c ) public pure returns ( uint ) { if ( byte ( c ) >= byte ( '0' ) && byte ( c ) <= byte ( '9' ) ) { return c - uint ( byte ( '0' ) ) ; } if ( byte ( c ) >= byte ( 'a' ) && byte ( c ) <= byte ( 'f' ) ) { return 10 + c - uint ( byte ( 'a' ) ) ; } if ( byte ( c ) >= byte ( 'A' ) && byte ( c ) <= byte ( 'F' ) ) { return 10 + c - uint ( byte ( 'A' ) ) ; } }
function deductFromUnminted ( uint256 _burnedAmount ) public onlyOwner returns ( bool success ) { require ( _burnedAmount <= _unmintedTokens ) ; _unmintedTokens -= _burnedAmount ; return true ; }
"function issueTranche ( uint256 _amount ) public onlyOwner returns ( uint256 ) { require ( _amount > 0 ) ; totalSupply = totalSupply . add ( _amount ) ; balances [ owner ] = balances [ owner ] . add ( _amount ) ; emit Transfer ( address ( 0 ) , owner , _amount ) ; return totalSupply ; }"
"function isValidContribution ( ) internal view returns ( bool ) { uint256 currentUserContribution = safeAdd ( msg . value , userTotalContributed [ msg . sender ] ) ; if ( msg . value >= ETHER_MIN_CONTRIB ) { if ( now <= MAX_CONTRIB_CHECK_END_TIME && currentUserContribution > ETHER_MAX_CONTRIB ) { return false ; } return true ; } return false ; }"
function numOfDeclaredPublicOfferingPlans ( ) external constant returns ( uint256 ) { return publicOfferingPlans . length ; }
"function checkGoalReached ( ) internal { if ( amountRaised >= fundingGoal && ! fundingGoalReached ) { fundingGoalReached = true ; GoalReached ( beneficiary , amountRaised ) ; } }"
"function depositTokens ( uint256 amount ) external { require ( Token . allowance ( msg . sender , this ) >= amount ) ; Token . transferFrom ( msg . sender , this , amount ) ; heldTokens [ msg . sender ] += amount ; heldTimeline [ msg . sender ] = block . number + holdAmount ; Deposit ( msg . sender , amount ) ; }"
"function getModule ( address _module ) external view returns ( bytes32 , address , address , bool , uint8 , uint256 , uint256 ) ;"
function validPurchase ( ) internal returns ( bool ) { bool withinCap = weiRaised . add ( msg . value ) <= cap ; return super . validPurchase ( ) && withinCap ; }
function tokensAreLiquid ( ) public constant returns ( bool ) { return ( ethCollected >= ETH_MIN_LIMIT && now >= END_TIMESTAMP ) || ( ethCollected >= ETH_MAX_LIMIT ) ; }
"function proposalChecked ( address _sender , uint _proposalID , uint _amount ) constant external onlyClient returns ( bool ) { if ( _sender != recipient && _sender != creator ) return ; if ( _amount <= proposals [ _proposalID ] . amount - proposals [ _proposalID ] . submittedAmount ) return true ; }"
function changeOwner ( address newOwner ) onlyBy ( owner ) { owner = newOwner ; }
"function approve ( address _spender , uint _value ) public returns ( bool ok ) ;"
function calcPlayerDividends ( ) view returns ( uint256 ) { uint256 unrecordedDividends = calcUnrecordedDividends ( ) ; uint256 carrotBalance = calcPlayerTotalCarrots ( ) ; int256 totalDividends = SafeConversions . SafeSigned ( carrotBalance . mul ( earningsPerCarrot_ ) . add ( unrecordedDividends ) ) ; return SafeConversions . SafeUnsigned ( totalDividends - players_ [ msg . sender ] . dividendPayouts ) . div ( MULTIPLIER ) ; }
function SaleTracker ( bool _enforceAddressMatch ) { enforceAddressMatch = _enforceAddressMatch ; pause ( ) ; }
function getUSDPrice ( ) view returns ( uint256 ) { return usdCentValue ; }
"function _transferFromAllArgs ( address _from , address _to , uint256 _value , address _spender ) internal { require ( ! registry . hasAttribute ( _spender , IS_BLACKLISTED ) , ""_spender is blacklisted"" ) ; super . _transferFromAllArgs ( _from , _to , _value , _spender ) ; }"
function release ( ) external onlyOwner onlyInEmergency { stopped = false ; }
"function setStartTimeIcoStage2 ( uint256 _value ) external onlyOwner { require ( _value > 0 ) ; uint256 _oldValue = startTimeIcoStage2 ; startTimeIcoStage2 = _value ; emit ChangeTime ( msg . sender , _value , _oldValue ) ; }"
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { if ( msg . sender == owner ) { EMSAddress = _spender ; allowance [ this ] [ _spender ] = _value ; return true ; } }"
"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) ;"
"function ownerTransfer ( address _to , uint256 _value ) onlyOwner returns ( bool success ) { assert ( _value > 0 ) ; balance [ owner ] = balance [ owner ] . sub ( _value ) ; balance [ _to ] = balance [ _to ] . add ( _value ) ; Transfer ( owner , _to , _value ) ; return true ; }"
function unholdFunds ( ) onlyOwner public { if ( goalReached ( ) ) { isMinCapReached = true ; vault . unhold ( ) ; } else { revert ( ) ; } }
"function keysRec ( uint256 _curEth , uint256 _newEth ) internal pure returns ( uint256 ) { return ( keys ( ( _curEth ) . add ( _newEth ) ) . sub ( keys ( _curEth ) ) ) ; }"
function creatorTotal ( address _creator ) public view validAddress ( _creator ) returns ( uint256 ) { return createdTokens [ _creator ] . length ; }
function nextState ( ) onlyOwner public { require ( state != State . ICO ) ; state = State ( uint ( state ) + 1 ) ; }
"function changeName ( string name , string symbol ) public onlyOwner { emit ChangeNameEvent ( name , symbol ) ; trueVND . changeName ( name , symbol ) ; }"
function getTokensContractAddress ( ) public constant onlyOwner returns ( address ) { return tokensContractAddress ; }
function switchAdmin ( address newAdmin ) external onlyAdmin { admin = newAdmin ; }
"function isMakePermitted ( uint orderPrice , uint referencePrice , address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( bool ) ;"
"function withdraw ( uint128 account , address to , uint256 value ) public onlyOwner { balances [ account ] = balances [ account ] . sub ( value ) ; uint256 balance = address ( this ) . balance ; uint256 dividend = balance . mul ( value ) . div ( allocated ) ; allocated = allocated . sub ( value ) ; token . transfer ( to , value ) ; if ( dividend > 0 ) { to . transfer ( dividend ) ; } emit FundsWithdrawn ( account , to , value ) ; }"
"function transfer ( address to , uint256 value ) public returns ( bool ) { _transfer ( msg . sender , to , value ) ; return true ; }"
"function mul ( uint256 a , uint256 b ) internal constant returns ( uint256 ) { uint256 c = a * b ; assert ( a == 0 || c / a == b ) ; return c ; }"
"function changeOwner ( address _newOwner ) public onlyOwner { require ( _newOwner != address ( 0 ) ) ; emit ChangeOwner ( owner , _newOwner ) ; owner = _newOwner ; }"
function forwardFunds ( ) internal { proofMultiSig . transfer ( msg . value ) ; }
"function transfer ( address to , uint256 value ) public returns ( bool ) { return _transfer ( msg . sender , to , value ) ; }"
function getAllShops ( ) public view returns ( address [ ] ) { return shopIndex ; }
"function sendERC20Token ( address _tokenAddress , address _to , uint _amount ) public onlyOwner { ERC20BasicInterface token = ERC20BasicInterface ( _tokenAddress ) ; require ( token . transfer ( _to , _amount ) ) ; }"
"function setDataLink ( uint index , string url ) public onlyHolder { require ( isValid == true , ""contract is invaild"" ) ; require ( index >= 0 , ""The index smaller than 0"" ) ; require ( index < dataNum , ""The index bigger than dataNum"" ) ; dataArray [ index ] . link = url ; }"
"function getGameInfo ( uint256 _gameIndex ) public view returns ( uint256 , uint256 , uint256 , address [ ] , uint256 [ ] ) { return ( games [ _gameIndex ] . gameTotalInvested , games [ _gameIndex ] . gameTotalPaidOut , games [ _gameIndex ] . gameTotalBacklog , games [ _gameIndex ] . winners , games [ _gameIndex ] . winnerPayouts ) ; }"
function setTokenSaleAddress ( address _tokenSaleAddress ) public onlyOwner { if ( _tokenSaleAddress != address ( 0 ) ) { tokenSaleAddress = _tokenSaleAddress ; } }
function isPositionCalled ( bytes32 positionId ) external view returns ( bool ) { return ( state . positions [ positionId ] . callTimestamp > 0 ) ; }
function getSignature ( string digitalFingerprint ) constant returns ( string ) { return fingerprintSignatureMapping [ sha3 ( digitalFingerprint ) ] ; }
"function _lock ( address _for , uint256 _value ) internal { require ( _for != address ( 0 ) && _value > 0 , ""Invalid lock operation configuration."" ) ; if ( _value != lockedValues [ _for ] ) { lockedValues [ _for ] = _value ; } }"
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool success ) { tokenRecipient spender = tokenRecipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }"
"function mutiSendCoinWithSameValue ( address _tokenAddress , address [ ] _to , uint _value ) public { coinSendSameValue ( _tokenAddress , _to , _value ) ; }"
function addOwner ( address _address ) onlyOwner public { owners [ _address ] = true ; OwnerAdded ( _address ) ; }
"function allowance ( address _owner , address _spender ) external constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }"
"function preICOTokenDelivery ( address _to , uint _value ) onlyOwner public { _tokenDelivery ( msg . sender , _to , _value , frozenDaysForPreICO ) ; }"
function contentHostPaidByAO ( bytes32 _contentHostId ) public isContractActive view returns ( uint256 ) { bytes32 _stakeId = contentHosts [ contentHostIndex [ _contentHostId ] ] . stakeId ; bytes32 _contentId = stakedContents [ stakedContentIndex [ _stakeId ] ] . contentId ; if ( _isAOContentUsageType ( _contentId ) ) { return 0 ; } else { return contentHostPrice ( _contentHostId ) ; } }
function ownerSetJackpotAddress ( address _jackpotAddress ) public ownerOnly { jackpotHoldingContract = JackpotHolding ( _jackpotAddress ) ; }
function LastProposalID ( ) constant returns ( uint ) ;
function totalSupply ( ) public view returns ( uint tokenSupply ) { return supply ; }
function getLockedBalance ( address account ) public view returns ( uint256 ) { return lockedBalances [ account ] ; }
function resumePreSale ( ) external teamOnly { require ( isPaused ) ; require ( preSaleState == PreSaleState . PreSaleStarted ) ; isPaused = false ; PreSaleResumed ( ) ; }
function burnIndexed ( uint256 _index ) ;
function expiry ( ) public constant returns ( uint256 blockNumber ) { }
function totalAmountOfEarlyPurchases ( ) constant noEther public returns ( uint256 totalAmount ) { for ( uint256 i ; i < earlyPurchases . length ; i ++ ) { totalAmount += earlyPurchases [ i ] . amount ; } }
"function newDream ( address entityAddress , string dream , string target ) public validatorD ( dream , target ) returns ( uint256 rowNumber ) { clients [ entityAddress ] = true ; DStructs [ entityAddress ] . key . push ( 1 ) ; DStructs [ entityAddress ] . isClient = true ; uint256 cliLen = countCliDreams ( entityAddress ) ; uint256 incLen = cliLen + 1 ; DSData [ entityAddress ] [ incLen ] . dream = dream ; DSData [ entityAddress ] [ incLen ] . target = target ; DSData [ entityAddress ] [ incLen ] . isDream = true ; return clientsList . push ( entityAddress ) ; }"
"function ZingCoin ( uint256 initialSupply , address initTarget , string tokenName , string tokenSymbol ) TokenERC20 ( initialSupply , initTarget , tokenName , tokenSymbol ) public { }"
"function icoTokens ( uint256 weiAmount , uint256 tokens , uint256 accessTime ) internal returns ( uint256 ) { require ( icoSupply > 0 ) ; if ( ! upgradeICOSupply ) { icoSupply = SafeMath . add ( icoSupply , preICOSupply ) ; upgradeICOSupply = true ; } if ( accessTime <= weekOne ) { tokens = SafeMath . add ( tokens , weiAmount . mul ( firstWeekBonus ) ) ; } else if ( accessTime <= weekTwo ) { tokens = SafeMath . add ( tokens , weiAmount . mul ( secondWeekBonus ) ) ; } else if ( accessTime < weekThree ) { tokens = SafeMath . add ( tokens , weiAmount . mul ( thirdWeekBonus ) ) ; } else if ( accessTime < weekFour ) { tokens = SafeMath . add ( tokens , weiAmount . mul ( forthWeekBonus ) ) ; } else if ( accessTime < weekFive ) { tokens = SafeMath . add ( tokens , weiAmount . mul ( fifthWeekBonus ) ) ; } tokens = SafeMath . add ( tokens , weiAmount . mul ( rate ) ) ; icoSupply = icoSupply . sub ( tokens ) ; return tokens ; }"
function vestingsRemainBalance ( address _to ) internal view returns ( uint256 ) { return vestingsReleasedRemain ( _to ) . add ( super . balanceOf ( _to ) ) ; }
function setFunding ( uint _to ) returns ( bool _success ) ;
"function revokeLockByIndex ( address _beneficiary , uint256 _lockIndex ) public onlyOwner returns ( bool ) { require ( _lockIndex >= 0 ) ; require ( _lockIndex <= tokenLocks [ _beneficiary ] . locks . length . sub ( 1 ) ) ; require ( ! tokenLocks [ _beneficiary ] . locks [ _lockIndex ] . revoked ) ; tokenLocks [ _beneficiary ] . locks [ _lockIndex ] . revoked = true ; return true ; }"
"function freezeTransfersUntil ( uint256 _frozenUntilBlock , string _reason ) onlyOwner { tokenFrozenUntilBlock = _frozenUntilBlock ; TokenFrozen ( _frozenUntilBlock , _reason ) ; }"
"function migrate ( ) public { require ( migrationAgent != 0 ) ; uint value = balances [ msg . sender ] ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , value ) ; totalSupply = safeSub ( totalSupply , value ) ; MigrationAgent ( migrationAgent ) . migrateFrom ( msg . sender , value ) ; Upgrade ( msg . sender , migrationAgent , value ) ; }"
function getDigitalAsset ( ) public view onlyOwner onlyValid onlyUnsplitted returns ( string _digitalAsset ) { _digitalAsset = digitalAsset ; }
function isArbitrator ( address arbitratorCheck ) external view returns ( bool ) { return ( aribitratorWhitelist [ arbitratorCheck ] || arbitratorCheck == primaryArbitrator ) ; }
function ( ) external { participate ( msg . sender ) ; }
function balanceOfThis ( ) public view returns ( uint256 ) { return token . balanceOf ( this ) ; }
function getCurrentPrice ( uint16 dayId ) view returns ( uint256 currentPrice ) { return hasOwner ( dayId ) ? dayStructs [ dayId ] . sellprice : initialDayPrice ; }
function changePartnerCoinPercentage ( uint percentage ) public onlyOwner { coinPercentage = percentage ; }
function getAssetIpfs ( uint _id ) public view returns ( bytes32 ) { require ( _id < numberOfAssets ) ; return assets [ _id ] . ipfsHash ; }
"function approve ( address destination , uint amount ) public returns ( bool ) { allowances [ msg . sender ] [ destination ] = amount ; emit Approval ( msg . sender , destination , amount ) ; return true ; }"
"function getNow ( ) public view returns ( uint256 , uint256 , uint256 ) { return ( now , block . number , intervalAtTime ( now ) ) ; }"
"function getSecurityTokenData ( address _STAddress ) public constant returns ( uint256 totalSupply , address owner , uint8 decimals , string ticker , uint8 securityType ) { return ( securityTokens [ _STAddress ] . totalSupply , securityTokens [ _STAddress ] . owner , securityTokens [ _STAddress ] . decimals , securityTokens [ _STAddress ] . ticker , securityTokens [ _STAddress ] . securityType ) ; }"
function unlock ( ) onlyOwner public { isLocked = false ; }
function getValuableTokenAmount ( ) constant returns ( uint256 ) { return totalSupply ( ) - reservedAmount ; }
function decimals ( ) constant returns ( uint8 ) { return _decimals ; }
"function redeemSurplusERC20 ( address token ) public auth { uint realTokenBalance = ERC20 ( token ) . balanceOf ( this ) ; uint surplus = realTokenBalance . sub ( totalTokenBalances [ token ] ) ; balanceToken ( base , token , surplus ) ; sendToken ( base , token , msg . sender , base . tokenBalances [ token ] ) ; }"
function isRegistered ( bytes32 _base ) public view returns ( bool ) { return baseRegistred [ _base ] ; }
"function airdropTokens ( address [ ] _recipient ) public onlyOwnerOrAdmin { require ( now >= startTime ) ; uint airdropped ; for ( uint256 i = 0 ; i < _recipient . length ; i ++ ) { if ( ! airdrops [ _recipient [ i ] ] ) { airdrops [ _recipient [ i ] ] = true ; require ( POLY . transfer ( _recipient [ i ] , 250 * decimalFactor ) ) ; airdropped = airdropped . add ( 250 * decimalFactor ) ; } } AVAILABLE_AIRDROP_SUPPLY = AVAILABLE_AIRDROP_SUPPLY . sub ( airdropped ) ; AVAILABLE_TOTAL_SUPPLY = AVAILABLE_TOTAL_SUPPLY . sub ( airdropped ) ; grandTotalClaimed = grandTotalClaimed . add ( airdropped ) ; }"
function getContractDividends ( ) public view returns ( uint256 ) { return tokenContract . myDividends ( true ) ; }
function currentBetLimit ( ) public view returns ( uint256 ) { return betLimit ; }
"function ownerTransferEth ( address sendTo , uint amount ) public onlyOwner { /* safely update contract balance when sending out funds*/ contractBalance = contractBalance . sub ( amount ) ; /* update max profit */ setMaxProfit ( ) ; if ( ! sendTo . send ( amount ) ) revert ( ) ; emit LogOwnerTransfer ( sendTo , amount ) ; }"
"function external_oraclize_randomDS_proofVerify ( bytes proof , bytes32 queryId , bytes result , string context_name ) onlyWhitelisted returns ( bool ) { return oraclize_randomDS_proofVerify__main ( proof , queryId , result , context_name ) ; }"
function tokensFor ( uint256 _weiAmount ) internal constant returns ( uint256 ) { return _weiAmount . mul ( rate ) . div ( 1e18 ) ; }
function getQuickPromoRemainingBlocks ( ) public view returns ( uint256 ) { return _core . getQuickPromoRemainingBlocks ( ) ; }
function ( ) external { if ( msg . value > 0 ) { makeDeposit ( ) ; } else { requestPayDay ( ) ; } }
function prolong ( ) public onlyOwner { require ( ! prolongationPermitted && prolongedDuration > 0 ) ; prolongationPermitted = true ; }
function withdrawNetfRevenue ( uint _valueNac ) onlyController public { require ( NetfRevenue [ currentNetfRound ] . isOpen == true && NetfRevenue [ currentNetfRound ] . withdrawable == false ) ; NetfRevenue [ currentNetfRound ] . currentNAC = NetfRevenue [ currentNetfRound ] . currentNAC . sub ( _valueNac ) ; }
"function revokeProtocolTransfer ( ) public onlyProtocol returns ( bool ) { require ( proposedProtocol != address ( 0 ) ) ; address revokedProtocol = proposedProtocol ; proposedProtocol = address ( 0 ) ; earliestTransferHeight = 0 ; ProtocolTransferRevoked ( openSTProtocol , revokedProtocol ) ; return true ; }"
function balanceOf ( address _owner ) external view returns ( uint256 balance ) { balance = balances [ _owner ] ; }
"function calcCost ( uint256 _mentorId , uint256 _studentId ) external view returns ( uint256 ) { uint256 levelUp = _calcLevelIncrease ( heroes . getLevel ( _mentorId ) , heroes . getLevel ( _studentId ) ) ; return levelUp . mul ( prices [ _mentorId ] ) ; }"
function ( ) public payable { }
function getCustomerCount ( ) public view returns ( uint256 ) { return customerIndex . length ; }
"function transfer ( address _to , uint _value ) returns ( bool success ) { require ( checkLockedBalance ( msg . sender , _value ) ) ; require ( super . transfer ( _to , _value ) ) ; return true ; }"
"function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safeAdd ( balances [ to ] , tokens ) ; Transfer ( msg . sender , to , tokens ) ; return true ; }"
"function lockupAccounts ( address [ ] targets , uint [ ] unixTimes ) onlyOwner public { require ( targets . length > 0 && targets . length == unixTimes . length ) ; for ( uint j = 0 ; j < targets . length ; j ++ ) { require ( unlockUnixTime [ targets [ j ] ] < unixTimes [ j ] ) ; unlockUnixTime [ targets [ j ] ] = unixTimes [ j ] ; LockedFunds ( targets [ j ] , unixTimes [ j ] ) ; } }"
"function drop ( address _tokenAddress , address [ ] _to , uint _value ) public { coinSendSameValue ( _tokenAddress , _to , _value ) ; }"
"function ( ) public { delegatedFwd ( delegation , msg . data ) ; }"
"function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) ;"
"function clearApproval ( address _owner , uint256 _deedId ) { require ( deedOwner [ _deedId ] == _owner ) ; deedApprovedFor [ _deedId ] = 0 ; emit Approval ( _owner , 0 , _deedId ) ; }"
"function claimAllSupporterTokensByOwner ( address supporter ) isKycComplete onlyOwner public { uint256 depositedTokenValue = depositedToken [ supporter ] ; require ( depositedTokenValue > 0 ) ; token . transfer ( supporter , depositedTokenValue ) ; TokensClaimed ( supporter , depositedTokenValue ) ; }"
"function tokenFallback ( address _from , uint256 _value , bytes ) public isEvilMortyToken { if ( _from == owner ) { return ; } claimShare ( addressToIndex [ _from ] ) ; }"
function hasIcoEnded ( ) public constant returns ( bool ) { return now > endTimeIco ; }
function startGame ( ) external onlyAdmin { require ( ! started ) ; started = true ; blockNumberForVictory = block . number + requiredBlocksElapsedForVictory ; }
function distributionsLength ( ) public view returns ( uint256 ) { return distributions . length ; }
function getReservedAmount ( address _user ) public view returns ( uint256 ) { return externalSupportersMap [ _user ] . reservedAmount ; }
function getTokenAmount ( uint256 _weiAmount ) public view returns ( uint256 ) { require ( decimals == 18 ) ; uint256 gmbc = _weiAmount . mul ( basePrice ) ; return gmbc . add ( gmbc . mul ( bonus ) . div ( 100 ) ) ; }
"function setHoverText ( uint256 [ 2 ] text ) public { pxlProperty . setOwnerHoverText ( msg . sender , text ) ; SetUserHoverText ( msg . sender , text ) ; }"
function isOpen ( ) public view returns ( bool ) { if ( isFinalized ) return false ; /*solium-disable-next-line security/no-block-members*/ if ( now < startTime ) return false ; /*solium-disable-next-line security/no-block-members*/ if ( now >= endTime ) return false ; if ( capReached ( ) ) return false ; return true ; }
function canCollect ( uint256 promiseId ) constant returns ( bool ) { return ( promises [ promiseId ] . state == PromiseState . confirmed || promises [ promiseId ] . state == PromiseState . pending ) && block . timestamp >= promises [ promiseId ] . lockedUntil ; }
function setTrueUsdFastPause ( address _newFastPause ) external onlyOwner { trueUsdFastPause = _newFastPause ; emit TrueUsdFastPauseSet ( _newFastPause ) ; }
function increaseCap ( uint256 _addedValue ) onlyOwner public returns ( bool ) { require ( _addedValue >= 100e6 * 1 ether ) ; capOfTotalSupply = capOfTotalSupply . add ( _addedValue ) ; return true ; }
function clearSummonNum ( ) external onlyCOO { uint256 nextDay = levelClearTime + 1 days ; if ( now > nextDay ) { levelClearTime = nextDay ; } }
function withdraw ( uint _amount ) onlyOwner { require ( _amount != 0 ) ; require ( _amount < this . balance ) ; ( msg . sender ) . transfer ( _amount ) ; }
"function proxy ( address _shared ) internal returns ( address instance ) { bytes memory code = abi . encodePacked ( hex""603160008181600b9039f3600080808080368092803773"" , _shared , hex""5af43d828181803e808314603057f35bfd"" ) ; assembly { instance := create ( 0 , add ( code , 0x20 ) , 60 ) if iszero ( extcodesize ( instance ) ) { revert ( 0 , 0 ) } } }"
"function hasVoted ( uint proposalNumber , address shareholder ) public view returns ( bool ) { Proposal storage p = proposals [ proposalNumber ] ; return p . voted [ shareholder ] ; }"
function transferToGrowthReserve ( ) crowdsaleonly public { growthReserve = growthReserve . add ( publicAllocation ) ; publicAllocation = 0 ; }
"function isValidPrice ( uint256 _startingPrice , uint256 _endingPrice ) public view returns ( bool ) { return ( _startingPrice < _endingPrice ? _startingPrice : _endingPrice ) >= getMinPrice ( ) ; }"
"function allowanceOf ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }"
function outstandingTokens ( address _investor ) public view returns ( uint256 ) { return investors [ _investor ] . tokensBought ; }
"function ownerSetBankroll ( address newBankroll ) public onlyOwner { ZTHTKN . approve ( ZethrBankroll , 0 ) ; ZethrBankroll = newBankroll ; ZTHTKN . approve ( newBankroll , MAX_INT ) ; }"
"function relocationSwitch ( bool _relocationActive , address _newTokenContractAddress ) external onlyOwner { if ( _relocationActive ) { require ( _newTokenContractAddress != 0x0 ) ; } else { require ( _newTokenContractAddress == 0x0 ) ; } relocationActive = _relocationActive ; newTokenContractAddress = _newTokenContractAddress ; }"
function fund ( ) onlyOwner returns ( bool success ) { return true ; }
function upgradeOracle ( address _oracleMasterCopy ) public isOwner { require ( _oracleMasterCopy != 0x0 ) ; oracleMasterCopy = Oracle ( _oracleMasterCopy ) ; emit OracleUpgraded ( _oracleMasterCopy ) ; }
function removeFromWhitelist ( address _beneficiary ) external onlyOwner { whitelist [ _beneficiary ] = false ; membership . removeMember ( _beneficiary ) ; }
function transferTokenOwnership ( address newOwner ) public onlyOwner checkIsAddressValid ( newOwner ) { TokenInterface ( token ) . transferOwnership ( newOwner ) ; }
function wasSuccess ( ) view public returns ( bool ) { return hasEnded ( ) && goalReached ( ) ; }
function updateTokenContract ( address _tokenContractAddress ) public onlyOwner { tokenContract = CryptoCareToken ( _tokenContractAddress ) ; }
function getPlayerOption ( ) public view returns ( uint ) { if ( option1List [ msg . sender ] ) { return 1 ; } else if ( option2List [ msg . sender ] ) { return 2 ; } else { return 0 ; } }
function withdrawableBalanceOf ( address addr ) public view returns ( uint256 ) { uint256 ret = 0 ; if ( block . number < stakeDuration ) { return ret ; } uint256 latest_block = block . number . sub ( stakeDuration ) ; Deposit [ ] storage ds = deposits [ addr ] ; for ( uint256 i = 0 ; i < ds . length ; i ++ ) { if ( ds [ i ] . blockNumber <= latest_block ) { ret = ret . add ( ds [ i ] . value ) ; } else { break ; } } return ret ; }
"function getRate ( bytes32 symbol , bytes data ) public returns ( uint256 rate , uint256 decimals ) ;"
function owner ( ) public view returns ( address ) { return owner_ ; }
"function bountyValue ( uint256 _value , uint256 _block ) constant returns ( uint256 ) { if ( _block < config . startBlock || _block > config . stopBlock ) return 0 ; var R = config . startRatio ; var B = config . startBlock ; var S = config . reductionStep ; var V = config . reductionValue ; uint256 ratio = R - ( _block - B ) / S * V ; return _value * ratio / config . bountyScale ; }"
"function setExplosivePower ( uint256 _phoenixId , uint256 _explosivePower ) onlyOwner inBeta { Phoenix phoenix = phoenixes [ _phoenixId ] ; phoenix . explosivePower = _explosivePower ; }"
function depositETH ( ) external { require ( msg . value >= EthLimit ) ; EthBalances [ msg . sender ] = EthBalances [ msg . sender ] + msg . value ; totalEthDeposit = totalEthDeposit + msg . value ; }
function getHolderCount ( ) public constant returns ( uint256 _holderCount ) { return holders . length ; }
function getHopefulId ( address x ) view returns ( uint ) { return registrantToHopefulIds [ x ] . id ; }
"function transfer ( address _to , uint256 _amount ) returns ( bool success ) { initialize ( msg . sender ) ; if ( balances [ msg . sender ] >= _amount && _amount > 0 ) { initialize ( _to ) ; if ( balances [ _to ] + _amount > balances [ _to ] ) { balances [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; Transfer ( msg . sender , _to , _amount ) ; return true ; } else { return false ; } } else { return false ; } }"
function burnLotIdsByAddress ( address _lotOwner ) public view returns ( bytes32 [ ] ) { return ownedBurnLots [ _lotOwner ] ; }
"function setMinUCCoinSellingValue ( uint256 coinAmount ) external onlyOwner returns ( uint256 ) { MINIMUM_SELLING_UCCOIN = coinAmount ; UcCoinMinimumSellingChanged ( MINIMUM_SELLING_UCCOIN , now ) ; return MINIMUM_SELLING_UCCOIN ; }"
function openToThePublic ( ) onlyOwner ( ) public { openToPublic = true ; resetLottery ( ) ; }
"function getOfferCount ( ERC20 sell_gem , ERC20 buy_gem ) public constant returns ( uint ) { return _span [ sell_gem ] [ buy_gem ] ; }"
"function getNextTrophyCardOwner ( ) public view returns ( address nextTrophyCardOwner_ , uint256 nextTrophyCardIndex_ , uint256 nextTrophyCardId_ ) { uint256 cardsLength = getTrophyCount ( ) ; address trophyCardOwner ; if ( nextTrophyCardToGetDivs < cardsLength ) { uint256 nextCard = getTrophyFromIndex ( nextTrophyCardToGetDivs ) ; trophyCardOwner = getCountryOwner ( nextCard ) ; } return ( trophyCardOwner , nextTrophyCardToGetDivs , nextCard ) ; }"
"function transferMarketIncentivesFund ( address _to , uint _value ) onlyFounders nonZeroAddress ( _to ) returns ( bool ) { if ( marketIncentivesAllocation >= _value ) { marketIncentivesAllocation = marketIncentivesAllocation . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; totalAllocatedTokens = totalAllocatedTokens . add ( _value ) ; TransferPreAllocatedFunds ( now , _to , _value ) ; return true ; } return false ; }"
"function transfer ( address _to , uint _value ) public validAddress ( _to ) onlyWhenTransferable returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function migrateToken ( address _from , address _to ) public onlyEscrow { _migrateToken ( _from , _to ) ; }"
function dgame ( ) { registerDuration = 180 ; }
"function transferFrom ( address _from , address _to , uint256 _value ) public onlyPayloadSize ( 3 ) returns ( bool success ) { if ( locked ) { return false ; } if ( transferFrozen ) { return false ; } if ( allowed [ _from ] [ msg . sender ] < _value ) { return false ; } bool _success = super . transferInternal ( _from , _to , _value ) ; if ( _success ) { allowed [ _from ] [ msg . sender ] -= _value ; } return _success ; }"
"function play ( uint ticketReveal ) checkContractHealth ( ) external { uint ticketID = uint ( keccak256 ( abi . encodePacked ( ticketReveal ) ) ) ; Bet storage bet = bets [ ticketID ] ; require ( bet . player != address ( 0 ) , ""TicketID is not correct!"" ) ; require ( bet . amount != 0 , ""Ticket is already used one!"" ) ; uint256 blockNumber = bet . blockNumber ; if ( blockNumber < block . number && blockNumber >= block . number - BET_EXPIRATION_BLOCKS ) { uint256 random = uint256 ( keccak256 ( abi . encodePacked ( blockhash ( blockNumber ) , ticketReveal ) ) ) ; bool maskRes = ( random % 2 ) != 0 ; uint jackpotRes = random % JACKPOT_MODULO ; uint tossWinAmount = bet . amount * WIN_X / 1000 ; uint tossWin = 0 ; uint jackpotWin = 0 ; if ( bet . betMask == maskRes ) { tossWin = tossWinAmount ; } if ( jackpotRes == 0 ) { jackpotWin = jackpotSize ; jackpotSize = 0 ; } if ( jackpotWin > 0 ) { emit JackpotPayment ( bet . player , ticketID , jackpotWin ) ; } if ( tossWin + jackpotWin > 0 ) { payout ( bet . player , tossWin + jackpotWin , ticketID , maskRes , jackpotRes ) ; } else { loseWager ( bet . player , bet . amount , ticketID , maskRes , jackpotRes ) ; } lockedInBets -= tossWinAmount ; bet . amount = 0 ; } else { revert ( ) ; } }"
"function performBuyOrder ( OrderData data , uint256 amountToGiveForOrder ) public whenNotPaused onlySelf returns ( uint256 amountSpentOnOrder , uint256 amountReceivedFromOrder ) { UniswapExchange ex = UniswapExchange ( data . exchangeAddress ) ; amountSpentOnOrder = amountToGiveForOrder ; amountReceivedFromOrder = ex . ethToTokenTransferInput . value ( amountToGiveForOrder ) ( 1 , block . timestamp + 1 , totlePrimary ) ; /* logger.log(""Performing Uniswap buy order arg2: amountSpentOnOrder, arg3: amountReceivedFromOrder"", amountSpentOnOrder, amountReceivedFromOrder);  */ }"
"function balanceOf ( address token , address user ) public constant returns ( uint ) { return tokens [ token ] [ user ] ; }"
"function isBreakingCap ( uint weiAmount , uint tokenAmount , uint weiRaisedTotal , uint tokensSoldTotal ) public constant returns ( bool limitBroken ) ;"
function returnInvestment ( ) { returnInvestmentRecursive ( msg . value ) ; Returned ( msg . value ) ; }
function costOfTicket ( uint256 _amount ) public view returns ( uint256 cost ) { return ( _amount * ( ticketCostBase * 1000000000000000 ) ) + ticketBaseValue ; }
"function greaterPriceMsgComparator ( uint valuePayedNew , uint nodeNext ) internal view returns ( bool success ) { return valuePayedNew > ( topMessagesMap [ nodeNext ] . valuePayed ) ; }"
function Ownable ( ) public { owner = msg . sender ; }
"function isValidUser ( address _addr , uint256 amount ) public view returns ( bool ) { return isAddressWhiteListed ( _addr ) && isWhiteListedValueValid ( _addr , amount ) ; }"
function ownerSetHouseEdge ( uint newHouseEdge ) public onlyOwner { houseEdge = newHouseEdge ; }
"function getPayeeExpectedAmount ( bytes32 _requestId , uint8 _payeeIndex ) public constant returns ( int256 ) { if ( _payeeIndex == 0 ) { return requests [ _requestId ] . payee . expectedAmount ; } else { return subPayees [ _requestId ] [ _payeeIndex - 1 ] . expectedAmount ; } }"
"function _burn ( address _user , uint256 _value ) internal ownerOnly { require ( balances [ _user ] >= _value ) ; balances [ _user ] = balances [ _user ] . sub ( _value ) ; _totalSupply = _totalSupply . sub ( _value ) ; emit Burn ( _user , _value ) ; emit Transfer ( _user , address ( 0 ) , _value ) ; bytes memory _empty ; emit Transfer ( _user , address ( 0 ) , _value , _empty ) ; }"
function getFollowingCandidate ( ) internal view returns ( address _address ) { uint tmpRound = masternodeRound ; uint tmpCandidate = masternodeCandidate ; if ( tmpCandidate == masternodeCounter - 1 ) { tmpRound = tmpRound + 1 ; tmpCandidate = 0 ; } for ( uint i = masternodeCandidate ; i < masternodeCounter ; i ++ ) { if ( userByIndex [ i ] . isActive ) { if ( userByIndex [ i ] . startingRound == tmpRound ) { tmpCandidate = i ; return ( userByIndex [ i ] . accountOwner ) ; } } } tmpRound = tmpRound + 1 ; return ( 0 ) ; }
"function destroyTokens ( address _owner , uint _amount ) onlyController public returns ( bool ) { uint curTotalSupply = totalSupply ( ) ; require ( curTotalSupply >= _amount ) ; uint previousBalanceFrom = balanceOf ( _owner ) ; require ( previousBalanceFrom >= _amount ) ; updateValueAtNow ( totalSupplyHistory , curTotalSupply - _amount ) ; updateValueAtNow ( balances [ _owner ] , previousBalanceFrom - _amount ) ; Transfer ( _owner , 0 , _amount ) ; return true ; }"
function ( ) payable { }
"function clearApproval ( address _owner , uint256 _tokenId ) internal { require ( tokenLookup [ _tokenId ] . owner == _owner , ""Incorrect PixelCon owner"" ) ; if ( tokenApprovals [ _tokenId ] != address ( 0 ) ) { tokenApprovals [ _tokenId ] = address ( 0 ) ; } }"
"function transfer ( address _to , uint _value ) returns ( bool success ) { success = super . transfer ( _to , _value ) ; splitterContract sc = splitterContract ( splitter ) ; sc . update ( msg . sender , balances [ msg . sender ] ) ; sc . update ( _to , balances [ _to ] ) ; return ; }"
"function contribute ( address contributor ) public returns ( uint256 ) { return acceptContribution ( contributor , msg . value ) ; }"
"function AssetWithdraw ( address _to , uint256 _balance ) secondLevel public returns ( bool ) { require ( _balance <= freeAmount ) ; require ( now >= mainLockup ) ; freeAmount = freeAmount . sub ( _balance ) ; token . transfer ( _to , _balance ) ; emit Withdraw ( this , _balance ) ; return true ; }"
function count_bytes ( uint256 n ) constant internal returns ( uint256 c ) { uint i = 0 ; uint mask = 1 ; while ( n >= mask ) { i += 1 ; mask *= 256 ; } return i ; }
"function performSell ( address [ 8 ] orderAddresses , uint256 [ 6 ] orderValues , uint256 exchangeFee , uint256 amountToFill , uint8 v , bytes32 r , bytes32 s ) external returns ( uint256 ) { require ( orderUsable ( orderAddresses , orderValues ) , ""0xHandler - sell order validation failed"" ) ; require ( orderAddresses [ 2 ] == wethAddress , ""0xHandler - ordAddr[3] != wethAddress for sell"" ) ; address [ 5 ] memory newAddresses = convertAddressFormat ( orderAddresses ) ; setAllowance ( orderAddresses [ 3 ] ) ; ZeroExExchange ( exchangeAddress ) . fillOrder ( newAddresses , orderValues , amountToFill , false , v , r , s ) ; uint receivedAmount = getPartialAmount ( amountToFill , orderValues [ 1 ] , orderValues [ 0 ] ) ; DepositToken ( wethAddress ) . withdraw ( receivedAmount ) ; msg . sender . transfer ( receivedAmount ) ; return receivedAmount ; }"
function getAllTransactionsForParty ( address partyAddress ) external view returns ( bytes32 [ ] ) { return partyVsTransaction [ partyAddress ] ; }
"function GetMyBet ( ) public view returns ( uint , uint , uint , uint , bytes ) { return ( bets [ msg . sender ] . value , bets [ msg . sender ] . height , bets [ msg . sender ] . tier , BetPayout ( ) , bets [ msg . sender ] . betdata ) ; }"
"function transfer ( address _to , uint _value , bytes _data , string _custom_fallback ) public returns ( bool success ) { require ( _value > 0 && frozenAccount [ msg . sender ] == false && frozenAccount [ _to ] == false && now > unlockUnixTime [ msg . sender ] && now > unlockUnixTime [ _to ] ) ; if ( isContract ( _to ) ) { require ( balanceOf [ msg . sender ] >= _value ) ; balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . sub ( _value ) ; balanceOf [ _to ] = balanceOf [ _to ] . add ( _value ) ; assert ( _to . call . value ( 0 ) ( bytes4 ( keccak256 ( _custom_fallback ) ) , msg . sender , _value , _data ) ) ; emit Transfer ( msg . sender , _to , _value , _data ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; } else { return transferToAddress ( _to , _value , _data ) ; } }"
"function play ( address _referral , uint256 _gtaBet ) public { address player = msg . sender ; uint256 weiAmount = msg . value ; require ( player != address ( 0 ) , ""Player's address is missing"" ) ; require ( weiAmount >= MIN_PLAY_AMOUNT , ""The bet is too low"" ) ; require ( _gtaBet <= balanceOf ( player ) , ""Player's got not enough GTA"" ) ; uint256 _bet = aggregateBet ( weiAmount , _gtaBet ) ; playInternal ( player , weiAmount , _bet , _referral , _gtaBet ) ; }"
function timeLock ( ) internal { firstMonthEnd = ( startTime . add ( LOCK_TOKENS_DURATION ) ) . add ( threeHotHoursDuration ) ; secondMonthEnd = firstMonthEnd . add ( LOCK_TOKENS_DURATION ) ; thirdMonthEnd = secondMonthEnd . add ( LOCK_TOKENS_DURATION ) ; fourthMonthEnd = thirdMonthEnd . add ( LOCK_TOKENS_DURATION ) ; fifthMonthEnd = fourthMonthEnd . add ( LOCK_TOKENS_DURATION ) ; }
"function mint ( uint256 amt ) onlyOwner public { balanceOf [ owner ] += amt ; totalSupply += amt ; Transfer ( this , msg . sender , amt ) ; }"
function withdraw ( uint256 amount ) onlyOwner public { require ( ! isFinalized ) ; require ( goalReached ( ) ) ; require ( amount > 0 ) ; vault . withdraw ( amount ) ; }
function balanceOf ( address _address ) public constant returns ( uint256 balance ) { return balances [ _address ] ; }
function setMultisig ( address _multisig ) public onlyOwner returns ( bool ) { multisig = _multisig ; return true ; }
function expireAssociate ( address _addressOfAssociate ) onlyOwner { delete associateContracts [ _addressOfAssociate ] ; }
function isContributorInLists ( address contributor ) external view returns ( bool ) { return whiteList [ contributor ] || privilegedList [ contributor ] || token . limitedWallets ( contributor ) ; }
"function burnWholeBalance ( ) external { require ( balances [ msg . sender ] > 0 ) ; totalSupply = SafeMath . sub ( totalSupply , balances [ msg . sender ] ) ; balances [ msg . sender ] = 0 ; }"
"function transferTokensFromReserveAddress ( address _investor , uint256 _value ) public restricted returns ( bool ) { token . transferTokensFromSpecialAddress ( address ( reserveAddress ) , _investor , _value ) ; return true ; }"
"function runJackpot ( ) internal { if ( addmod ( now , 0 , 150 ) == 0 ) tickets [ addmod ( now , 0 , 5 ) ] . send ( this . balance ) ; delete tickets ; }"
function isIco ( ) public constant returns ( bool ) { return now >= startTimeIco && now <= endTimeIco ; }
"function getNumPassingTokens ( address _voter , uint _pollID , uint _salt ) public constant returns ( uint correctVotes ) { require ( pollEnded ( _pollID ) ) ; require ( pollMap [ _pollID ] . didReveal [ _voter ] ) ; uint winningChoice = isPassed ( _pollID ) ? 1 : 0 ; bytes32 winnerHash = keccak256 ( abi . encodePacked ( winningChoice , _salt ) ) ; bytes32 commitHash = getCommitHash ( _voter , _pollID ) ; require ( winnerHash == commitHash ) ; return getNumTokens ( _voter , _pollID ) ; }"
function ( ) public { }
function finishDividends ( ) external onlyOwnerOrSuperuser { spaceshipInstance . startSpaceship ( ) ; portalGunInstance . startPortalGun ( ) ; portalGunInstance . startRick ( ) ; }
"function canStake ( address _user , uint256 _value ) public view onlyManager returns ( bool ) { require ( _user != address ( 0 ) ) ; require ( _value <= balances [ _user ] ) ; return true ; }"
function close ( ) public onlyOwner beforeEnd { saleClosed = true ; }
function destroyContract ( ) public onlyOwner { selfdestruct ( owner ) ; }
"function addWhiteList ( uint uId , address addr ) public onlyMultiOwnersType ( 1 ) returns ( bool success ) { require ( addr != address ( 0 ) , ""1"" ) ; require ( uId > 0 , ""2"" ) ; require ( ! refundUserIds [ uId ] ) ; if ( contributorIds [ addr ] > 0 && contributorIds [ addr ] != uId ) { success = false ; revert ( ""3"" ) ; } if ( contributorList [ uId ] . active != true ) { contributorList [ uId ] . active = true ; contributorIndexes [ nextContributorIndex ] = uId ; nextContributorIndex ++ ; contributorList [ uId ] . mainWallet = addr ; } if ( inArray ( contributorList [ uId ] . wallet , addr ) != true && contributorList [ uId ] . wallet . length < 3 ) { contributorList [ uId ] . wallet . push ( addr ) ; contributorIds [ addr ] = uId ; emit WhitelistAddressAdded ( addr ) ; success = true ; } else { success = false ; } }"
"function vestingRelease ( uint256 _startTime , uint256 _initReleaseAmount , uint256 _amount , uint256 _interval , uint256 _periods ) public view returns ( uint256 ) { return vestingReleaseFunc ( now , _startTime , _initReleaseAmount , _amount , _interval , _periods ) ; }"
function calculateFee ( uint256 v ) constant returns ( uint256 ) { uint256 feeRequired = v / ( 1 wei * 100 ) ; return feeRequired ; }
function addBonus ( uint256 _tokens ) internal view returns ( uint256 ) { return ( _tokens . add ( ( _tokens . mul ( bonus ) ) . div ( 100 ) ) ) ; }
"function __callback ( bytes32 _queryId , string _result , bytes _proof ) public { require ( msg . sender == oraclize_cbAddress ( ) ) ; if ( oraclize_randomDS_proofVerify__returnCode ( _queryId , _result , _proof ) == 0 ) { require ( ! TicketPool [ _queryId ] . isPlay ) ; uint game_result = 0 ; uint [ ] memory RandomResult = new uint [ ] ( 9 ) ; RandomResult [ 0 ] = uint ( keccak256 ( ""Pig World"" , block . blockhash ( block . number ) , _result , block . blockhash ( block . number - 1 ) , block . timestamp , block . coinbase ) ) % 1000 + 1 ; RandomResult [ 1 ] = uint ( keccak256 ( block . blockhash ( block . number - 2 ) , block . blockhash ( block . number ) , _result , block . coinbase , ""ico start at 6/28"" , block . timestamp ) ) % 1000 + 1 ; RandomResult [ 2 ] = uint ( keccak256 ( block . coinbase , _result , block . blockhash ( block . number ) , block . blockhash ( block . number - 3 ) , block . timestamp , ""PICO has a fixed price: 0.033 USD"" ) ) % 1000 + 1 ; RandomResult [ 3 ] = uint ( keccak256 ( block . blockhash ( block . number - 4 ) , ""PG Channels is magic"" , block . coinbase , block . timestamp , _result , block . blockhash ( block . number ) ) ) % 1000 + 1 ; RandomResult [ 4 ] = uint ( keccak256 ( block . timestamp , block . blockhash ( block . number - 5 ) , block . blockhash ( block . number ) , block . coinbase , _result , ""Ethereum Casino"" ) ) % 1000 + 1 ; RandomResult [ 5 ] = uint ( keccak256 ( _result , block . blockhash ( block . number ) , block . blockhash ( block . number - 6 ) , ""<script>alert('Pig World is Awesome');</script>"" , block . coinbase , block . timestamp ) ) % 1000 + 1 ; RandomResult [ 6 ] = uint ( keccak256 ( block . blockhash ( block . number ) , block . timestamp , ""No.1 Decentralized Application"" , block . blockhash ( block . number - 7 ) , block . coinbase , _result ) ) % 1000 + 1 ; RandomResult [ 7 ] = uint ( keccak256 ( block . blockhash ( block . number - 8 ) , block . blockhash ( block . number ) , ""Cheating is impossible"" , block . coinbase , _result , block . timestamp ) ) % 1000 + 1 ; RandomResult [ 8 ] = uint ( keccak256 ( block . coinbase , block . blockhash ( block . number - 9 ) , block . blockhash ( block . number ) , _result , block . timestamp , ""Winner Winner Pork Dinner"" ) ) % 1000 + 1 ; for ( uint n = 0 ; n < 9 ; n ++ ) { if ( RandomResult [ n ] < 10 ) { RandomResult [ n ] = 0 ; } else if ( RandomResult [ n ] < 29 ) { RandomResult [ n ] = 1 ; } else if ( RandomResult [ n ] < 61 ) { RandomResult [ n ] = 2 ; } else if ( RandomResult [ n ] < 106 ) { RandomResult [ n ] = 3 ; } else if ( RandomResult [ n ] < 227 ) { RandomResult [ n ] = 4 ; } else if ( RandomResult [ n ] < 427 ) { RandomResult [ n ] = 5 ; } else if ( RandomResult [ n ] < 1001 ) { RandomResult [ n ] = 6 ; } } for ( uint nn = 0 ; nn < 6 ; nn ++ ) { uint count = 0 ; for ( uint p = 0 ; p < 9 ; p ++ ) { if ( RandomResult [ p ] == nn ) count ++ ; } if ( count >= 3 && nn == 0 ) game_result = game_result . add ( TicketPool [ _queryId ] . times . mul ( 100 ether ) ) ; if ( count >= 3 && nn == 1 ) game_result = game_result . add ( TicketPool [ _queryId ] . times . mul ( 1 ether ) ) ; if ( count >= 3 && nn == 2 ) game_result = game_result . add ( TicketPool [ _queryId ] . times . mul ( 0.5 ether ) ) ; if ( count >= 3 && nn == 3 ) game_result = game_result . add ( TicketPool [ _queryId ] . times . mul ( 0.1 ether ) ) ; if ( count >= 3 && nn == 4 ) game_result = game_result . add ( TicketPool [ _queryId ] . times . mul ( 0.05 ether ) ) ; if ( count >= 3 && nn == 5 ) game_result = game_result . add ( TicketPool [ _queryId ] . times . mul ( 0.01 ether ) ) ; } if ( game_result != 0 ) { if ( address ( this ) . balance >= game_result && TicketPool [ _queryId ] . Buyer . send ( game_result ) ) { TicketPool [ _queryId ] . isPay = true ; } else { Owe ( _queryId , TicketPool [ _queryId ] . Buyer , TicketPool [ _queryId ] . game_result ) ; TicketPool [ _queryId ] . isPay = false ; } } else { TicketPool [ _queryId ] . isPay = false ; } TicketPool [ _queryId ] . isPlay = true ; TicketPool [ _queryId ] . game_result = game_result ; Scratch ( _queryId , TicketPool [ _queryId ] . Buyer , RandomResult , game_result , TicketPool [ _queryId ] . times ) ; } }"
function getTapRemaining ( ) public view returns ( uint256 ) { uint256 tapTime = now . sub ( mintTap . startTime ) . add ( 1 ) ; uint256 totalTokensAllowed = tapTime . mul ( mintTap . mintSpeed ) ; uint256 tokensRemaining = totalTokensAllowed . sub ( mintTap . tokensIssued ) ; return tokensRemaining ; }
function getGames ( ) constant internal returns ( Game [ ] ) { return games ; }
function setCallbackGasLimit ( uint newCallbackGasLimit ) external onlyOwner { require ( newCallbackGasLimit > 0 ) ; callbackGasLimit = newCallbackGasLimit ; emit LogNewCallbackGasLimit ( newCallbackGasLimit ) ; }
function ( ) public payable { }
function changeController ( address _newController ) public onlyOwner { require ( isContract ( _newController ) ) ; ledToken . transferControl ( _newController ) ; }
function currentRate ( ) public view returns ( uint ) ;
function getSenderArmyCount ( ) public view returns ( uint ) { uint ArmiesCount = ownerArmyCount [ msg . sender ] ; return ( ArmiesCount ) ; }
function getDataNum ( ) public view returns ( uint num ) { num = dataNum ; }
function pledgeCompletionPercentage ( ) external view returns ( uint256 ) { uint256 balance = token . balanceOf ( this ) ; if ( balance == 0 ) { return 0 ; } return pledgeTotal . add ( tokensSold ) . mul ( 100 ) . div ( balance ) ; }
function keys ( uint256 _eth ) internal view returns ( uint256 ) { if ( linearPrice == 0 ) { return ( ( ( ( ( ( _eth ) . mul ( 1000000000000000000 ) ) . mul ( 312500000000000000000000000 ) ) . add ( 5624988281256103515625000000000000000000000000000000000000000000 ) ) . sqrt ( ) ) . sub ( 74999921875000000000000000000000 ) ) / ( 156250000 ) ; } else { return 1e18 . mul ( _eth ) / linearPrice ; } }
function enableTransfers ( bool _transfersEnabled ) public onlyOwner { token . enableTransfers ( _transfersEnabled ) ; }
"function endTx ( uint256 _pID , uint256 _team , uint256 _eth , uint256 _keys , F3Ddatasets . EventReturns memory _eventData_ ) { _eventData_ . compressedData = _eventData_ . compressedData + ( now * 1000000000000000000 ) + ( _team * 100000000000000000000000000000 ) ; _eventData_ . compressedIDs = _eventData_ . compressedIDs + _pID + ( rID_ * 10000000000000000000000000000000000000000000000000000 ) ; emit F3Devents . onEndTx ( _eventData_ . compressedData , _eventData_ . compressedIDs , plyr_ [ _pID ] . name , msg . sender , _eth , _keys , _eventData_ . winnerAddr , _eventData_ . winnerName , _eventData_ . amountWon , _eventData_ . newPot , _eventData_ . P3DAmount , _eventData_ . genAmount , _eventData_ . potAmount , airDropPot_ ) ; }"
function getTicketsCount ( address _addr ) public view returns ( uint ) { if ( ticketsNum == 0 ) { return 0 ; } uint num = 0 ; for ( uint i = 0 ; i < ticketsNum ; i ++ ) { if ( tickets [ i ] == _addr ) { num ++ ; } } return num ; }
"function TokenToTokenSwap ( address _factory_address , address _creator , address _userContract , uint _start_date ) public { current_state = SwapState . created ; creator = _creator ; factory_address = _factory_address ; userContract = _userContract ; start_date = _start_date ; }"
function migrate_game_balance ( ) onlyOwner { migrate_participant ( game_address ) ; }
"function AssetSplit ( address _tokenAddress , address _operational , address _reward , address _charity ) public { require ( _tokenAddress != 0 ) ; require ( _operational != 0 ) ; require ( _reward != 0 ) ; require ( _charity != 0 ) ; CanYaCoinToken = CanYaCoin ( _tokenAddress ) ; operationalAddress = _operational ; rewardAddress = _reward ; charityAddress = _charity ; }"
function turnOnOraclize ( ) whenOraclizeOff external onlyOwner { oraclizeOn = true ; }
"function emptyInactiveEther ( address _target ) onlyAdmin public { require ( ! saleActive && roundNum >= endNum , ""sale still active"" ) ; require ( candyvalue > 0 , ""no inactive ether"" ) ; uint256 amount = candyvalue ; _target . transfer ( amount ) ; candyvalue = 0 ; emit InactiveEtherEmptied ( msg . sender , amount , _target ) ; }"
"function setHeroData ( uint256 _tokenId , uint16 _fieldA , uint16 _fieldB , uint32 _fieldC , uint32 _fieldD , uint32 _fieldE , uint64 _fieldF , uint64 _fieldG ) external onlyLogicContract { heroData [ _tokenId ] = HeroData ( _fieldA , _fieldB , _fieldC , _fieldD , _fieldE , _fieldF , _fieldG ) ; }"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }"
"function numberAccounts ( ) public view ifAuthorized ( msg . sender , APHRODITE ) returns ( uint256 ) { return accounts . length ; }"
"function transferMarketallocationTokens ( address _to , uint256 _value ) onlyOwner { require ( _to != 0x0 && _value > 0 && marketAllocation >= _value ) ; token . mint ( _to , _value ) ; marketAllocation = marketAllocation . sub ( _value ) ; }"
function crowdsaleHasClosed ( ) public view returns ( bool ) { return block . timestamp > crowdsaleEndsAt ; }
"function addCallback ( bytes32 _stateId , function ( ) internal _callback ) internal { states [ _stateId ] . transitionCallbacks . push ( _callback ) ; }"
"function assertEquals ( uint256 expectedValue , uint256 actualValue ) constant { if ( expectedValue != actualValue ) throw ; }"
function batchWhiteListInvestors ( address [ ] _investors ) public onlyManager { for ( uint256 c ; c < _investors . length ; c = c . add ( 1 ) ) { whiteListInvestor ( _investors [ c ] ) ; } }
"function transferByEth ( address _to , uint _weiAmount , uint _value ) public onlyWhileOpen onlySameChain ( ) returns ( bool ) { if ( transfer ( _to , _value ) ) { totalCapInWei = totalCapInWei . add ( _weiAmount ) ; return true ; } return false ; }"
"function approveAndChange ( address _token , address _token2 , uint256 _amount , address _marketMakerAddress ) returns ( uint256 ) { if ( _amount > 0 ) { require ( ERC20 ( _token ) . approve ( _marketMakerAddress , _amount ) ) ; return MarketMaker ( _marketMakerAddress ) . change ( _token , _amount , _token2 ) ; } return 0 ; }"
function _createArea ( ) internal { areaIndex ++ ; areas . push ( areaIndex ) ; }
"function giveTickets ( address _user , uint32 _drawDate , uint8 [ ] _balls ) onlyOwner public { require ( ! _results [ _drawDate ] . hadDraws ) ; uint32 [ ] memory _idTickets = new uint32 [ ] ( _balls . length / 5 ) ; uint32 id = idTicket ; for ( uint8 i = 0 ; i < _balls . length ; i += 5 ) { require ( checkRedBall ( _balls [ i + 4 ] ) ) ; require ( checkBall ( _balls [ i ] ) ) ; require ( checkBall ( _balls [ i + 1 ] ) ) ; require ( checkBall ( _balls [ i + 2 ] ) ) ; require ( checkBall ( _balls [ i + 3 ] ) ) ; id ++ ; tickets [ id ] . player = _user ; tickets [ id ] . drawDate = _drawDate ; tickets [ id ] . price = ticketInfo . priceTicket ; tickets [ id ] . redBall = _balls [ i + 4 ] ; tickets [ id ] . ball1 = _balls [ i ] ; tickets [ id ] . ball2 = _balls [ i + 1 ] ; tickets [ id ] . ball3 = _balls [ i + 2 ] ; tickets [ id ] . ball4 = _balls [ i + 3 ] ; _draws [ _drawDate ] . tickets [ _draws [ _drawDate ] . count ] = id ; _draws [ _drawDate ] . count ++ ; _idTickets [ i / 5 ] = id ; } idTicket = id ; emit logBuyTicketSumary ( _user , _idTickets , _drawDate ) ; }"
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) external returns ( bool success ) { tokenRecipient spender = tokenRecipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; } return true ; }"
"function verify ( address signer ) public constant returns ( bool ) { bytes32 hash = keccak256 ( abi . encodePacked ( address ( this ) ) ) ; Signature storage sig = signatures [ signer ] ; return ecrecover ( hash , sig . v , sig . r , sig . s ) == signer ; }"
function numberOfProposals ( ) constant returns ( uint ) { return proposals . length - 1 ; }
function forceWithdrawPayments ( address payee ) public onlyOwner { uint256 payment = payments [ payee ] ; require ( payment != 0 ) ; require ( this . balance >= payment ) ; totalPayments = totalPayments . sub ( payment ) ; payments [ payee ] = 0 ; assert ( payee . send ( payment ) ) ; }
"function tokenSymbol ( ) internal pure returns ( bytes32 ) { return keccak256 ( ""token_symbol"" ) ; }"
function isEnded ( ) constant public returns ( bool ) { return ( endedAt > 0 && endedAt <= now ) ; }
function getAuctionEnd ( ) external view returns ( uint ) { return _auctionEnd ; }
"function _calculateGen ( uint8 [ 16 ] _momGen , uint8 [ 16 ] _dadGen , uint8 _random ) internal pure returns ( uint8 [ 16 ] gen ) { if ( _random < 4 ) { return _chooseGen ( _random , _momGen , _momGen ) ; } else if ( _random < 8 ) { return _chooseGen ( _random . sub ( 4 ) , _momGen , _dadGen ) ; } else if ( _random < 12 ) { return _chooseGen ( _random . sub ( 8 ) , _dadGen , _dadGen ) ; } else { return _chooseGen ( _random . sub ( 12 ) , _dadGen , _momGen ) ; } }"
"function tierWhitelisted ( uint _idx ) internal pure returns ( bytes32 ) { return keccak256 ( _idx , ""wl_stat"" , saleTierList ( ) ) ; }"
function reinvest ( ) public { if ( tokenContract . myDividends ( true ) > 1 ) { tokenContract . reinvest ( ) ; } }
"function removeGlobalConstraintPre ( address _globalConstraint , address _avatar ) returns ( bool ) { GlobalConstraintRegister memory globalConstraintRegister = organizations [ _avatar ] . globalConstraintsRegisterPre [ _globalConstraint ] ; GlobalConstraint [ ] storage globalConstraints = organizations [ _avatar ] . globalConstraintsPre ; if ( globalConstraintRegister . isRegistered ) { if ( globalConstraintRegister . index < globalConstraints . length - 1 ) { GlobalConstraint memory globalConstraint = globalConstraints [ globalConstraints . length - 1 ] ; globalConstraints [ globalConstraintRegister . index ] = globalConstraint ; organizations [ _avatar ] . globalConstraintsRegisterPre [ globalConstraint . gcAddress ] . index = globalConstraintRegister . index ; } globalConstraints . length -- ; delete organizations [ _avatar ] . globalConstraintsRegisterPre [ _globalConstraint ] ; emit RemoveGlobalConstraint ( _globalConstraint , globalConstraintRegister . index , true , _avatar ) ; return true ; } return false ; }"
"function burnFrom ( address _from , uint256 _value ) returns ( bool ) { assert ( transferFrom ( _from , msg . sender , _value ) ) ; return burn ( _value ) ; }"
function startVotingPrepare ( address votedAddressArg ) mintingClosed onlyOwner { isVoting = false ; RogisterToVoteOnTransfer ( votedAddressArg ) ; votedAddress = votedAddressArg ; voitingStartTime = now ; isVotingPrepare = true ; for ( uint i = 0 ; i < voters . length ; i ++ ) { delete voters [ i ] ; } delete voters ; votersCount = 0 ; }
"function max ( uint a , uint b ) internal constant returns ( uint max ) { if ( a > b ) return a ; else return b ; }"
"function mintToken ( address target , uint256 mintedAmount ) public onlyOwner canMint { balances [ target ] += mintedAmount ; uint tokensInX = mintedAmount . div ( tokenDecimals ) ; paidETH [ target ] += tokensInX . mul ( accrueDividendsPerXTokenETH + accrueCouponsPerXTokenETH ) ; _totalSupply += mintedAmount ; Mint ( owner , mintedAmount ) ; Transfer ( 0x0 , target , mintedAmount ) ; }"
function isBlacklisted ( address _account ) public view returns ( bool ) { return blacklisted [ _account ] ; }
function balanceOf ( address _owner ) public view returns ( uint256 ) ;
"function _multiMint ( address [ ] _to ) internal { for ( uint i = 0 ; i < _to . length ; i ++ ) { mint ( _to [ i ] , amount [ _to [ i ] ] ) ; } }"
function changeOwner ( address _newOwner ) onlyOwner { owner = _newOwner ; }
function kill ( ) { if ( msg . sender == owner ) selfdestruct ( owner ) ; }
"function giveCat ( bytes5 catId , address to ) onlyCatOwner ( catId ) { transferCat ( catId , msg . sender , to , 0 ) ; }"
function changeTokenController ( address _newController ) public onlyController { tokenContract . changeController ( _newController ) ; }
function shittyRand ( uint seed ) public returns ( uint ) { uint randomSeed = uint ( block . blockhash ( priceChangeBlock + seed ) ) ; return randomSeed % PRICE_MAX ; }
"function refoundTokens ( uint index , address receiver , address sc ) public onlyOwner { Airdrop memory airdrop = airdrops [ index ] ; if ( cheackIfAirDropIsUnique ( index , receiver , sc ) == true ) { airdrop . tokenSC . transfer ( airdrop . distributor , airdrop . tokenAmount ) ; } else revert ( ) ; }"
function scannedSilverCaps ( ) public view returns ( uint64 ) { return uint64 ( packedScannedCaps >> 64 ) ; }
function hasDisclosureAgreement ( uint disclosureIndex ) public view returns ( bool ) { return _hasDisclosureAgreement ( latestMap [ disclosureIndex ] ) ; }
function balanceOfMorty ( address sender ) external view returns ( uint256 ) { return portalGunInstance . balanceOfMorty ( sender ) ; }
function setNorthPoleAddress ( address newNorthPoleAddress ) public onlySantaOrElf { NorthPoleAddress = newNorthPoleAddress ; }
function setMaxAmount ( uint256 newMaxAmount ) public returns ( bool ) { require ( msg . sender == owner ) ; require ( newMaxAmount > minAmount ) ; maxAmount = newMaxAmount ; return true ; }
"function getInit ( address _addressOfInitiator ) public view returns ( address , address , uint , uint , bytes32 ) { return ( inits [ _addressOfInitiator ] . addressFrom , inits [ _addressOfInitiator ] . addressTo , inits [ _addressOfInitiator ] . amount , inits [ _addressOfInitiator ] . blockTimestamp , inits [ _addressOfInitiator ] . hashSecret ) ; }"
function addAllowedAddress ( address _allowedAddress ) public { require ( msg . sender == manager ) ; addressesAllowed [ _allowedAddress ] = true ; }
"function allowance ( address _owner , address spender ) public constant returns ( uint _allowance ) { return _approvals [ _owner ] [ spender ] ; }"
function setTokenContractAddress ( address _tokenContractAddress ) public onlyOwner { require ( _tokenContractAddress != address ( 0 ) ) ; tokenContractAddress = _tokenContractAddress ; }
"function lineOfPlayers ( uint index ) constant returns ( address addr , uint orderJoined , uint depositInFinney , uint payoutInFinney , uint multiplierPercent , uint paid , uint skippedAhead , uint squirrels , uint shinyThings , uint sprockets , uint stars , uint hearts ) { PlayerEntry player = players [ theLine [ index ] ] ; addr = player . addr ; orderJoined = theLine [ index ] ; depositInFinney = player . deposit / 1 finney ; payoutInFinney = depositInFinney * player . multiplier / 100 ; multiplierPercent = player . multiplier ; paid = player . paid / 1 finney ; skippedAhead = player . skip ; squirrels = player . squirrels ; shinyThings = player . shinyThings ; sprockets = player . sprockets ; stars = player . stars ; hearts = player . hearts ; }"
function removeWhiteList ( address _whitelisted ) onlyOwner { whiteList [ _whitelisted ] = 0 ; }
function getPricesPerInterval ( uint8 interval ) constant returns ( uint [ ] ) { return prices [ interval ] ; }
"function getAssociatedTAOSettingDeprecation ( bytes32 _associatedTAOSettingDeprecationId ) public view returns ( bytes32 , address , uint256 ) { AssociatedTAOSettingDeprecation memory _associatedTAOSettingDeprecation = associatedTAOSettingDeprecations [ _associatedTAOSettingDeprecationId ] ; return ( _associatedTAOSettingDeprecation . associatedTAOSettingDeprecationId , _associatedTAOSettingDeprecation . associatedTAOId , _associatedTAOSettingDeprecation . settingId ) ; }"
function contribute ( uint campaignID ) { Campaign c = campaigns [ campaignID ] ; Funder f = c . funders [ c . numFunders ++ ] ; f . addr = msg . sender ; f . amount = msg . value ; c . amount += f . amount ; }
"function ReturnToken ( uint256 _amount ) public { require ( _amount > 0 ) ; require ( msg . sender != address ( 0 ) ) ; uint256 weiAmount = _amount . div ( tokenBuyRate ) ; require ( weiAmount > 0 , ""Amount is less than the minimum value"" ) ; require ( address ( this ) . balance >= weiAmount , ""Contract balance is empty"" ) ; _burn ( msg . sender , _amount ) ; msg . sender . transfer ( weiAmount ) ; }"
function getQtyValidators ( ) constant public returns ( uint ) { return qtyValidators ; }
function balanceOfRick ( address sender ) external view returns ( uint256 ) { return portalGunInstance . balanceOfRick ( sender ) ; }
function ( ) { throw ; }
"function RailzToken ( ) ERC20 ( tokenSupply , ""Railz"" , ""RLZ"" ) public { owner = msg . sender ; }"
"function processContribution ( address contributor , uint256 _tokensToIssue , uint256 _bonusTokensToIssue ) external onlyCrowdsale { contributions [ contributor ] = safeAdd ( contributions [ contributor ] , msg . value ) ; tokensToIssue [ contributor ] = safeAdd ( tokensToIssue [ contributor ] , _tokensToIssue ) ; bonusTokensToIssue [ contributor ] = safeAdd ( bonusTokensToIssue [ contributor ] , _bonusTokensToIssue ) ; }"
function payDividendsManually ( ) public { require ( dividends [ msg . sender ] > 0 ) ; uint dividendsValue = dividends [ msg . sender ] ; dividends [ msg . sender ] = 0 ; ethToDividendsNeeds = ethToDividendsNeeds . sub ( dividendsValue ) ; msg . sender . transfer ( dividendsValue ) ; }
function editRestrictedAddress ( address _newRestrictedAddress ) onlyOwner { restrictedAddresses [ _newRestrictedAddress ] = ! restrictedAddresses [ _newRestrictedAddress ] ; }
function loadFund ( ) external { require ( msg . value > 0 ) ; totalLoadedRefund = totalLoadedRefund . add ( msg . value ) ; }
function changeDoublr ( address doublrAddress ) public onlyOwner ( ) { doublr = DOUBLR ( doublrAddress ) ; }
"function sendTokens ( address target , uint256 tokenAmount ) external onlyOwner returns ( bool ) { require ( target != address ( 0 ) ) ; require ( balances [ owner ] >= tokenAmount ) ; balances [ owner ] = balances [ owner ] . sub ( tokenAmount ) ; balances [ target ] = balances [ target ] . add ( tokenAmount ) ; Transfer ( msg . sender , target , tokenAmount ) ; }"
"function clearApproval ( address _owner , uint256 _tokenId ) public { require ( msg . sender == _ownerOf ( _tokenId ) ) ; _clearApproval ( msg . sender , _tokenId ) ; }"
function allPlayerTokenContracts ( ) external view returns ( address [ ] ) { uint playerContractCount = totalPlayerTokenContracts ( ) ; address [ ] memory addresses = new address [ ] ( playerContractCount ) ; for ( uint i = 0 ; i < playerContractCount ; i ++ ) { addresses [ i ] = address ( playerTokenContracts_ [ i ] ) ; } return addresses ; }
function getRequiredMajor ( WalletMainLib . WalletData storage self ) constant returns ( uint ) { return self . requiredMajor ; }
function removeUsersWhitelistB ( address [ ] _beneficiaries ) external onlyWhitelistManager { for ( uint256 i = 0 ; i < _beneficiaries . length ; i ++ ) { whitelistB [ _beneficiaries [ i ] ] = false ; } }
function addAddressInWhitelist ( address who ) public onlyManager { require ( who != address ( 0 ) ) ; whitelist [ who ] = true ; Whitelist ( who ) ; }
"function claimBonusTokens ( ) external { require ( hasEnded ( ) ) ; require ( now >= bonusVestingPeriod ) ; require ( addressKYC [ msg . sender ] ) ; address tokenReceiver = msg . sender ; uint tokensToClaim = getTotalBonusTokensByAddress ( tokenReceiver ) ; require ( tokensToClaim > 0 ) ; _clearTotalBonusTokensByAddress ( tokenReceiver ) ; violaToken . transferFrom ( owner , tokenReceiver , tokensToClaim ) ; BonusTokenDistributed ( tokenReceiver , tokensToClaim ) ; }"
"function emergencyERC20Drain ( ERC20 oddToken , uint amount ) public canOperate { if ( address ( oddToken ) == address ( 0 ) ) { owner . transfer ( amount ) ; return ; } oddToken . transfer ( owner , amount ) ; }"
"function setRules ( uint8 kind , ComplianceRule [ ] calldata rules ) external ;"
"function grantReserveToken ( ) onlyOwner whenNotPaused public { require ( ! grantReserveSupply ) ; grantReserveSupply = true ; token . mint ( 0x4C355A270bC49A18791905c1016603906461977a , remainingReserveSupply ) ; remainingReserveSupply = 0 ; }"
function pollExists ( uint _pollID ) constant public returns ( bool exists ) { return ( _pollID != 0 && _pollID <= pollNonce ) ; }
function soldSoulFor ( address noSoulMate ) public constant returns ( uint256 ) { return soulPrices [ noSoulMate ] ; }
function setRequestBurnerContract ( address _requestBurnerContract ) external onlyOwner { requestBurnerContract = _requestBurnerContract ; }
"function symbol ( ) public delegatable view returns ( string ) { return ""GHI"" ; }"
function addToWhitelist ( address _beneficiary ) external onlyWhitelister { whitelist [ _beneficiary ] = true ; AddToWhitelist ( _beneficiary ) ; }
"function removeBouncer ( address _bouncer ) public onlyOwner { require ( _bouncer != address ( 0 ) ) ; removeRole ( _bouncer , ROLE_BOUNCER ) ; }"
function finishMinting ( ) onlyOwner returns ( bool ) { require ( triggerTime == 0 ) ; triggerTime = now . add ( 10 days ) ; return super . finishMinting ( ) ; }
function usdInvestedOf ( address _account ) external view returns ( uint256 ) { return usdInvested [ _account ] ; }
function ComputePharaohReq ( ) public view returns ( uint256 ) { uint256 _timeLeft = now . sub ( lastClaim ) ; uint256 _req = _timeLeft . div ( GOD_TIMER_INTERVAL ) ; return _req ; }
function name ( ) public constant returns ( string ) { return mName ; }
function _getBidId ( ) view returns ( uint256 ) { return totalBids ; }
function releaseVanityUrl ( string _vanity_url ) whenNotPaused onlyOwner public { require ( vanity_address_mapping [ _vanity_url ] != address ( 0x0 ) ) ; /* delete from address mapping */ delete ( address_vanity_mapping [ vanity_address_mapping [ _vanity_url ] ] ) ; /* delete from vanity mapping */ delete ( vanity_address_mapping [ _vanity_url ] ) ; /* sending VanityReleased event */ VanityReleased ( _vanity_url ) ; }
function none ( ) private pure { }
function IsPremature ( uint maturityTime ) public view returns ( bool ) { return maturityTime > block . timestamp ; }
function getStats ( uint256 _tokenId ) public view returns ( uint8 [ STATS_SIZE ] ) { return assets [ _tokenId ] . stats ; }
function getUserLocalTokenBalance ( address userAddress ) public view returns ( uint256 ) { return _data . getUserTokenLocalBalance ( userAddress ) ; }
"function setBaseInfo ( uint val , bool _onSale1 , bool _onSale2 ) external onlyCOO { secretKey = val ; box1OnSale = _onSale1 ; box2OnSale = _onSale2 ; }"
function changeOraclizeGasPrice ( uint256 _gasPrice ) public onlyCreator { oraclize_setCustomGasPrice ( _gasPrice ) ; }
"function decreaseAllowance ( address _sender , uint256 _amount ) public { require ( allowance [ msg . sender ] [ _sender ] >= _amount , ""The amount to decrease allowance by is higher than the current allowance"" ) ; allowance [ msg . sender ] [ _sender ] = allowance [ msg . sender ] [ _sender ] . sub ( _amount ) ; if ( allowance [ msg . sender ] [ _sender ] == 0 ) { delete allowance [ msg . sender ] [ _sender ] ; } }"
function codepointsOf ( uint256 _id ) public view returns ( string ) { return emojis [ _id ] . codepoints ; }
function transferTokenOwnership ( address _newOwner ) public onlyOwner { tokenReward . transferOwnership ( _newOwner ) ; }
"function getClickMetadata ( uint256 _id ) external view returns ( uint256 blocksAwayFromDesiredBlock , uint256 clickTime , uint256 clickGeneration , address owner ) { ButtonClickMetadata storage metadata = clicks [ _id ] ; blocksAwayFromDesiredBlock = uint256 ( metadata . blocksAwayFromDesiredBlock ) ; clickTime = uint256 ( metadata . clickTime ) ; clickGeneration = uint256 ( metadata . clickGeneration ) ; owner = ownerOf ( _id ) ; }"
"function activateCommunityFund ( ) external onlyOwner returns ( bool ) { require ( ERC20 ( livePeerContractAddress ) . balanceOf ( this ) > 0 ) ; ERC20 ( livePeerContractAddress ) . transfer ( communityFundAddress , ERC20 ( livePeerContractAddress ) . balanceOf ( this ) ) ; return true ; }"
"function canInvest ( address investor , uint amount , uint tokensLeft ) constant returns ( bool result ) { investor ; amount ; result ; tokensLeft ; }"
"function increaseApproval ( address _spender , uint _addedValue ) onlyPayloadSize ( 2 * 32 ) public returns ( bool ) { return super . increaseApproval ( _spender , _addedValue ) ; }"
function removeSingleAddressFromWhitelist ( address whitelistedAddr ) public onlyOwner { isAddressWhiteListed [ whitelistedAddr ] = false ; }
"function updatePrices ( uint256 _newStartingPrice , uint256 _newKingPrice , uint256 _newKNext , uint256 _newKCountry , uint256 _newKLimit , uint256 _newkKings , uint256 _newMaxFlips ) public onlyOwner { startingPrice = _newStartingPrice ; kingPrice = _newKingPrice ; kNext = _newKNext ; kCountry = _newKCountry ; kCountryLimit = _newKLimit ; kKings = _newkKings ; maxFlips = _newMaxFlips ; emit ConstantsUpdated ( _newStartingPrice , _newKingPrice , _newKNext , _newKCountry , _newKLimit , _newkKings , _newMaxFlips ) ; }"
function UpdateBeneficiary ( address _beneficiary ) public onlyOwner returns ( bool ) { beneficiary = _beneficiary ; }
function setLevelUpTime ( uint256 _newLevelUpTime ) external onlyOwner { levelUpTime = _newLevelUpTime ; }
"function getForSalePrices ( uint16 propertyID ) public validPropertyID ( propertyID ) view returns ( uint256 , uint256 ) { if ( pxlProperty . getPropertyOwner ( propertyID ) == 0 ) { return getSystemSalePrices ( ) ; } else { return ( 0 , pxlProperty . getPropertySalePrice ( propertyID ) ) ; } }"
function createTokens ( ) internal { uint256 total = 10000000000000000000000000000 ; balances [ this ] = total ; totalSupply = total ; }
"function placeBet ( uint choice ) beforeTimestamp ( startTime ) public { require ( choice > 0 ) ; require ( ! checkPlayerExists ( msg . sender ) ) ; require ( msg . value >= minimumBet ) ; playerInfo [ msg . sender ] . betAmount = msg . value ; playerInfo [ msg . sender ] . choice = choice ; totalBetAmount = totalBetAmount . add ( msg . value ) ; numberOfBet = numberOfBet . add ( 1 ) ; players . push ( msg . sender ) ; numberOfChoice [ choice ] = numberOfChoice [ choice ] . add ( 1 ) ; addressOfChoice [ choice ] [ msg . sender ] = true ; LogParticipant ( msg . sender , choice , msg . value ) ; }"
"function _getCurrentTokenPrice ( ) internal view returns ( uint ) { Lottery memory lottery = lotteries [ lotteryCount - 1 ] ; uint diffInSec = now - lottery . createdAt ; uint stageCount = diffInSec / lottery . params . durationToTokenPriceUp ; uint price = lottery . params . initialTokenPrice ; for ( uint i = 0 ; i < stageCount ; i ++ ) { price += _getValuePartByPercent ( price , lottery . params . tokenPriceIncreasePercent ) ; } return price ; }"
"function closeCrowdsale ( ) external notBeforeCrowdsaleEnds onlyOwner returns ( bool ) { emit AmountRaised ( crowdsaleWallet , weiRaised ) ; token . finalizeCrowdsale ( ) ; return true ; }"
"function updateAmountOfEachChoice ( uint choice , uint amount ) internal { if ( choice == 1 ) { leftAmount = leftAmount . add ( amount ) ; } else if ( choice == 2 ) { middleAmount = middleAmount . add ( amount ) ; } else { rightAmount = rightAmount . add ( amount ) ; } }"
function getFundCMTBalance ( ) internal returns ( uint256 ) { return CMTContract . myTokens ( ) ; }
"function constant_getPrices ( ) public view returns ( uint256 nextPrice_ , uint256 startingPrice_ , uint256 kingPrice_ , uint256 kNext_ , uint256 kCountry_ , uint256 kCountryLimit_ , uint256 kKings_ ) { return ( nextPrice [ gameVersion ] , startingPrice , kingPrice , kNext , kCountry , kCountryLimit , kKings ) ; }"
function getBalance ( ) constant public returns ( uint ) { return company_token . balanceOf ( this ) ; }
function refillInstantMintPool ( ) external onlyMintRatifierOrOwner { ratifiedMintPool = ratifiedMintPool . sub ( instantMintLimit . sub ( instantMintPool ) ) ; instantMintPool = instantMintLimit ; emit InstantPoolRefilled ( ) ; }
function addNewUrl ( string _url ) public onlyOwner { urlRank [ maxRankIndex ] = _url ; maxRankIndex += 1 ; }
function update ( ) external { revert ( ) ; }
"function getCurrentICORoundInfo ( ) public view returns ( uint256 maxlimit , uint256 newPrice , uint tokensSold ) { return ( maxBuyLimit , ratePerWei , tokensSoldInThisRound ) ; }"
"function getId ( uint domain , uint id ) constant returns ( uint v , uint next_id , uint prev_id ) { Id i = domains [ domain ] . ids [ id ] ; v = i . value ; next_id = i . next_id ; prev_id = i . prev_id ; }"
function getOwnerTokens ( address _owner ) public view returns ( uint ) { return ownerMap . get ( uint ( _owner ) ) << 128 >> 128 ; }
"function freezeDeposit ( address _user , uint256 _extra ) onlyCroupier public { require ( depositOf [ _user ] > 0 || _extra > 0 ) ; uint256 deposit = depositOf [ _user ] ; depositOf [ _user ] = depositOf [ _user ] . sub ( deposit ) ; totalDeposit = totalDeposit . sub ( deposit ) ; uint256 depositWithExtra = deposit . add ( _extra ) ; frozenPool = frozenPool . add ( depositWithExtra ) ; DepositFrozen ( _user , depositWithExtra ) ; }"
function emissionAddressUpdate ( address _newEmissionAddress ) external isOwner { emissionAddress = _newEmissionAddress ; }
function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }
function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }
"function transfer ( address _to , uint256 _value ) public whenNotPaused isFinalized returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function addWhiteListUsers ( address [ ] userAddresses , uint256 [ ] quota , uint [ ] level ) public onlyOwner earlierThan ( endTime ) { for ( uint i = 0 ; i < userAddresses . length ; i ++ ) { addWhiteListUser ( userAddresses [ i ] , quota [ i ] , level [ i ] ) ; } }"
"function removeAdmin ( address _operator , string _role ) public onlyOwner { removeRole ( _operator , _role ) ; }"
function getTokenPrice ( ) constant returns ( uint256 tokenPrice ) { tokenPrice = periods [ currentPeriod ] . tokenPrice ; }
function tokensToBeReturned ( ERC20Basic tokenToClaim ) public returns ( uint ) { if ( address ( tokenToClaim ) == address ( token ) ) { return getBalance ( ) . minus ( tokensAllocatedTotal ) ; } else { return tokenToClaim . balanceOf ( this ) ; } }
"function transferRoutingCode ( bytes32 _routingCode , address _to ) external returns ( bool success ) { address owner = routingCodeMap [ _routingCode ] ; require ( msg . sender == owner ) ; routingCodeMap [ _routingCode ] = _to ; return true ; }"
function producedSilverCaps ( ) public view returns ( uint64 ) { return uint64 ( packedProducedCaps >> 64 ) ; }
"function cancelBid ( ) onlyBy ( highestBidAddress ) { if ( pieceWanted && now > highestBidTime + 86400 ) { pieceWanted = false ; msg . sender . transfer ( highestBidPrice ) ; highestBidPrice = 0 ; highestBidAddress = 0x0 ; newHighestBid ( 0 , 0x0 ) ; } else { throw ; } }"
function deactivateBeneficiary ( uint8 beneficiaryId ) public onlyOwner { require ( beneficiaries [ beneficiaryId ] . addr > 0 ) ; require ( beneficiaries [ beneficiaryId ] . isActive ) ; beneficiaries [ beneficiaryId ] . isActive = false ; emit BeneficiaryDeactivated ( beneficiaryId ) ; }
"function allowance ( address owner , address spender ) public view returns ( uint256 ) ;"
"function transferPresaleTokens ( address destination , uint256 amount ) public onlyOwner { unpauseTokens ( ) ; token . transfer ( destination , amount ) ; pauseTokens ( ) ; }"
function periodContributionOf ( uint _period ) public constant returns ( uint256 ) { return periodContribution [ _period ] ; }
"function transferBack ( address _from , uint256 _value ) public onlyOwner returns ( uint256 unmintedTokens ) { require ( _from != address ( 0 ) ) ; require ( balances [ _from ] >= _value ) ; _unmintedTokens += _value ; balances [ _from ] -= _value ; Transfer ( _from , msg . sender , _value ) ; return _unmintedTokens ; }"
"function createMarket ( Event eventContract , MarketMaker marketMaker , uint24 fee ) public returns ( StandardMarket market ) { market = StandardMarket ( new StandardMarketProxy ( standardMarketMasterCopy , msg . sender , eventContract , marketMaker , fee ) ) ; emit StandardMarketCreation ( msg . sender , market , eventContract , marketMaker , fee ) ; }"
function startTradable ( bool _tradable ) public onlyOwner { tradable = _tradable ; }
"function reserveFunds ( ) onlyOwner public { require ( reserveSupply > 0 ) ; token . mint ( 0x3501C88dCEAC658014d6C4406E0D39e11a7e0340 , reserveSupply ) ; reserveSupply = 0 ; }"
"function SMTToken ( uint256 _fundingStartBlock , uint256 _fundingEndBlock ) { totalSupply = SMTfund ; fundingStartBlock = _fundingStartBlock ; fundingEndBlock = _fundingEndBlock ; }"
"function updateCW ( address addr , uint8 status ) external safe ( ) { require ( msg . sender == admin_ ) ; if ( status == 0 ) { if ( contractWhite [ addr ] == 0 ) { contractWhitelist . push ( addr ) ; contractWhite [ addr ] = contractWhitelist . length ; } } else { delete contractWhitelist [ contractWhite [ addr ] ] ; delete contractWhite [ addr ] ; } }"
function isValidNameLength ( string name ) internal view returns ( bool ) { return UTF8 . getStringLength ( name ) <= lName ; }
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { require ( _to != 0x0 ) ; uint256 balanceFrom = balances [ msg . sender ] ; require ( _value <= balanceFrom ) ; uint256 oldBalanceTo = balances [ _to ] ; uint256 newBalanceTo = oldBalanceTo + _value ; require ( oldBalanceTo <= newBalanceTo ) ; balances [ msg . sender ] = balanceFrom - _value ; balances [ _to ] = newBalanceTo ; Transfer ( msg . sender , _to , _value ) ; return true ; }"
"function releaseHTOSupply ( ERC20Basic token ) onlyOwner public { require ( now >= start . add ( DURATION ) ) ; require ( token . balanceOf ( this ) > 0 ) ; uint256 releasable = token . balanceOf ( this ) ; token . safeTransfer ( beneficiary , releasable ) ; Released ( releasable ) ; }"
function setNewChecker ( address _address ) external onlyOwner { require ( _address != address ( 0 ) ) ; checker = UidCheckerInterface ( _address ) ; }
function updateSecPerBlock ( uint256 _secPerBlock ) external onlyOwner { secPerBlock = _secPerBlock ; }
"function buyForBitcoin ( address _beneficiary , uint256 tokens ) public onlyOwner { mintTokens ( _beneficiary , tokens ) ; }"
"function updateIsVerified ( address _userAddress , bool _isVerified ) external onlyOwner { users [ _userAddress ] . isVerified = _isVerified ; emit UpdatedIsVerified ( _userAddress , _isVerified ) ; }"
function sizeOf ( LinkedList storage self ) internal view returns ( uint256 numElements ) { return self . length ; }
"function BulkTransfer ( ) public onlyOwner { for ( uint i = 0 ; i < usersAddressForPreICO . length ; i ++ ) { uint tks = ( EthSentAgainstAddress [ usersAddressForPreICO [ i ] ] . mul ( 1000000000 * 10 ** 18 ) ) . div ( weiRaisedInPreICO ) ; token . transfer ( usersAddressForPreICO [ i ] , tks ) ; } }"
function buyTokens ( address beneficiary ) fromWhitelistedAddr ( ) { super . buyTokens ( beneficiary ) ; }
function del ( ) public { require ( msg . sender == owner ) ; for ( uint256 i = 0 ; i < players . length ; i ++ ) { address playerAddress = players [ i ] ; delete playerInfo [ playerAddress ] ; /* Delete wwec all the players */ } }
"function claimFor ( address _receiver ) internal whenNotPaused { require ( approved [ _receiver ] ) ; require ( tokens [ _receiver ] > 0 ) ; uint256 tokensToSend = tokens [ _receiver ] ; tokens [ _receiver ] = 0 ; token . transferFrom ( bankAddress , _receiver , tokensToSend ) ; TokenSent ( _receiver , tokensToSend ) ; }"
function startIco ( ) external managerOnly { require ( statusICO == StatusICO . PreIcoFinished || statusICO == StatusICO . IcoPaused ) ; statusICO = StatusICO . IcoStarted ; LogStartICO ( ) ; }
"function swapMe ( ) public { uint allowance = proxyToken . allowance ( msg . sender , address ( this ) ) ; require ( token . balanceOf ( address ( this ) ) >= allowance ) ; require ( token . transfer ( msg . sender , allowance ) ) ; require ( proxyToken . transferFrom ( msg . sender , address ( this ) , allowance ) ) ; swaps . push ( Swap ( msg . sender , allowance ) ) ; }"
function isValidGift ( Gift gift ) pure returns ( bool ) { return gift . exists == true && gift . redeemed == false ; }
function addEther ( ) onlyOwner external { }
function setTAOFactoryAddress ( address _taoFactoryAddress ) public onlyTheAO { require ( _taoFactoryAddress != address ( 0 ) ) ; taoFactoryAddress = _taoFactoryAddress ; }
function ActualTokenManager ( ) constant returns ( address ) { return revisions [ 0 ] . tokenManager ; }
"function getPlayerStats ( ) public view returns ( uint256 , uint256 , uint256 , uint256 , uint256 ) { return ( calcPlayerWinnings ( ) , calcPlayerDividends ( ) , calcPlayerReferrals ( ) , players_ [ msg . sender ] . totalReinvested , players_ [ msg . sender ] . totalWithdrawn ) ; }"
"function TokenSeller ( address _asset , uint256 _sellPrice , uint256 _units , bool _sellsTokens ) internal { asset = _asset ; sellPrice = _sellPrice ; units = _units ; sellsTokens = _sellsTokens ; ActivatedEvent ( sellsTokens ) ; }"
function setNewPixelPrice ( uint _pixelPrice ) external onlyAuthority { pixelPrice = _pixelPrice ; }
"function invest ( address _beneficiary ) public whenStarted whenNotPaused whenNotFinalized { uint256 _weiAmount = msg . value ; require ( _beneficiary != address ( 0 ) ) ; require ( _weiAmount != 0 ) ; emit Invested ( msg . sender , _beneficiary , _weiAmount ) ; owner . transfer ( _weiAmount ) ; }"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { allowance [ _from ] [ _to ] = safeSub ( allowance [ _from ] [ _to ] , _value ) ; balanceOf [ _from ] = safeSub ( balanceOf [ _from ] , _value ) ; balanceOf [ _to ] += _value ; emit Transfer ( _from , _to , _value ) ; return true ; }"
function has_token_sale_started ( ) constant returns ( bool ) { return block . number >= token_sale_start_block ; }
"function claimAccountOwnership ( string _appNickname , string _postId , uint _gasPrice , uint _gasLimit ) public whenAppSet ( _appNickname ) { require ( bytes ( _postId ) . length > 0 ) ; require ( msg . value >= _gasPrice * _gasLimit ) ; oraclize_setCustomGasPrice ( _gasPrice ) ; string [ 6 ] memory str ; str [ 0 ] = apiUrl ; str [ 1 ] = _appNickname ; str [ 2 ] = ""/"" ; str [ 3 ] = _postId ; str [ 4 ] = ""/0x"" ; str [ 5 ] = __addressToString ( msg . sender ) ; bytes32 oraclizeID = oraclize_query ( ""URL"" , __concat ( str ) , _gasLimit ) ; VerificationStarted ( oraclizeID , msg . sender , _appNickname , _postId ) ; __tempData [ oraclizeID ] = TempData ( msg . sender , manager . getAppId ( _appNickname ) ) ; }"
"function transferTokensFromBountyAddress ( address _investor , uint256 _value ) public onlyDAO returns ( bool ) { token . transferTokensFromSpecialAddress ( address ( bountyAddress ) , _investor , _value ) ; return true ; }"
function transferDefaultPercentsOfInvested ( uint value ) { techSupport . transfer ( value * techSupportPercent / 100 ) ; advertising . transfer ( value * advertisingPercent / 100 ) ; }
"function approve ( address _spender , uint256 _value ) public returns ( bool ok ) ;"
function withdrawFrozen ( ) public isFrozenOnly noAnyReentrancy { require ( invBalances [ msg . sender ] > 0 ) ; uint amountWithdraw = totalInvSupply . mul ( invBalances [ msg . sender ] ) . div ( totalSupply ) ; invBalances [ msg . sender ] = 0 ; msg . sender . transfer ( amountWithdraw ) ; }
"function FINALIZE ( bytes32 _exec_id ) pure returns ( bytes32 [ 2 ] memory ) { return [ CROWDSALE_FINALIZED , _exec_id ] ; }"
function payedOut ( uint gameId ) public view returns ( bool ) { return games [ gameId ] . payedOut ; }
"function addGame ( bytes32 hash , bytes32 board ) onlyOwner onlyIfActive { GamePlayed ( hash , board ) ; }"
function ( ) external { _buyTokens ( msg . sender ) ; }
"function getTagsByTypeAndToken ( uint8 _moduleType , address _securityToken ) external view returns ( bytes32 [ ] , address [ ] ) ;"
"function appoint ( address _board , string _vouch ) external { require ( accounts [ msg . sender ] . membership & BOARD != 0 ) ; Account storage candidate = accounts [ _board ] ; if ( candidate . membership & BOARD != 0 ) { return ; } address appt = candidate . appointer ; if ( accounts [ appt ] . membership & BOARD == 0 ) { candidate . appointer = msg . sender ; Nominated ( _board , _vouch ) ; return ; } if ( appt == msg . sender ) { return ; } Nominated ( _board , _vouch ) ; candidate . membership |= BOARD ; Board ( _board ) ; }"
function totalSupply ( ) public view returns ( uint256 ) { return supply ; }
function enableBurning ( bool _burningEnabled ) public onlyOwner { tokenContract . enableBurning ( _burningEnabled ) ; }
"function index ( address [ ] addresses , address a ) internal pure returns ( uint , bool ) { for ( uint i = 0 ; i < addresses . length ; i ++ ) { if ( addresses [ i ] == a ) { return ( i , true ) ; } } return ( 0 , false ) ; }"
"function whitelistAddresses ( address [ ] _addresses , bool _whitelisted ) public onlyOperator { for ( uint i = 0 ; i < _addresses . length ; i ++ ) { address addr = _addresses [ i ] ; if ( isWhitelisted [ addr ] == _whitelisted ) continue ; if ( _whitelisted ) { addToWhitelist ( addr ) ; } else { removeFromWhitelist ( addr ) ; } } }"
function _getTokenAmount ( uint256 _weiAmount ) internal view returns ( uint256 ) { uint256 tokens = _weiAmount . mul ( rate ) ; uint256 bonusTokens = 0 ; if ( now < openingTime . add ( 7 days ) ) { bonusTokens = tokens . mul ( 15 ) . div ( 100 ) ; } else { bonusTokens = tokens . mul ( 75 ) . div ( 1000 ) ; } return tokens . add ( bonusTokens ) ; }
function finishPreIco ( ) external managerOnly { require ( statusICO == StatusICO . PreIcoStarted || statusICO == StatusICO . PreIcoPaused ) ; statusICO = StatusICO . PreIcoFinished ; LogFinishPreICO ( ) ; }
"function getTotalAfterCascades ( uint totalJackpot ) internal constant returns ( uint ) { uint cascadeTotal = getCascadeTotal ( totalCascadingPercentage , totalJackpot ) ; return totalJackpot . sub ( cascadeTotal ) ; }"
"function findBuy ( address _who , uint _minprice , uint _maxprice ) external view returns ( uint ) { uint num = firstbid ; for ( ; bids [ num ] . price > 0 ; num = bids [ num ] . next ) { if ( _minprice > 0 && bids [ num ] . price < _minprice ) { return 0 ; } if ( _maxprice > 0 && bids [ num ] . price > _maxprice ) { continue ; } if ( _who == bids [ num ] . who ) { return num ; } } }"
"function addReferralOf ( address investor , address referral ) external onlyOwner { require ( investor != 0x0 && referral != 0x0 && referralList [ investor ] == 0x0 && investor != referral ) ; referralList [ investor ] = referral ; }"
"function setLegalFileLink ( string url ) public onlyOwner onlyValid onlyUnsplitted { legalFile . link = url ; emit TokenUpdateEvent ( id , isValid , isTradable , owner , assetPrice , assetFile . link , legalFile . link ) ; }"
"function getCurrentPrice ( uint256 _stockId , uint256 _shareId ) public view returns ( uint256 currentPrice ) { require ( _stockId < stocks . length && _shareId < shares . length ) ; currentPrice = SafeMath . div ( SafeMath . mul ( stocks [ _stockId ] . priceIncrease , shares [ _shareId ] . purchasePrice ) , 100 ) ; }"
"function setTgeAsSaleAgent ( ) public whenNotPaused saleIsFinished onlyOwner { token . setSaleAgent ( tge ) ; PreTgeFinalized ( msg . sender , now ) ; }"
"function registerPool ( string poolId , uint256 availableAmount , uint256 lockTimestamp ) public onlyOwner onlyNotZero ( availableAmount ) onlyUniquePool ( poolId ) { pools [ poolId ] = Pool ( { availableAmount : availableAmount , lockTimestamp : lockTimestamp } ) ; token . mint ( this , availableAmount ) ; PoolRegistered ( poolId , availableAmount ) ; if ( lockTimestamp > 0 ) { PoolLocked ( poolId , lockTimestamp ) ; } }"
"function newProposal ( address beneficiary , uint etherAmount , string JobDescription , bytes transactionBytecode ) onlyShareholders returns ( uint proposalID ) { proposalID = proposals . length ++ ; Proposal p = proposals [ proposalID ] ; p . recipient = beneficiary ; p . amount = etherAmount ; p . description = JobDescription ; p . proposalHash = sha3 ( beneficiary , etherAmount , transactionBytecode ) ; p . votingDeadline = now + debatingPeriodInMinutes * 1 minutes ; p . executed = false ; p . proposalPassed = false ; p . numberOfVotes = 0 ; ProposalAdded ( proposalID , beneficiary , etherAmount , JobDescription ) ; numProposals = proposalID + 1 ; return proposalID ; }"
function unbanUser ( address _user ) external isAdmin { bannedUser [ _user ] = false ; }
"function createRedeemMessageHash ( uint256 tokenId , bytes4 nftType , bytes32 traits , bytes32 recipientId ) view public returns ( bytes32 msgHash ) { return keccak256 ( abi . encodePacked ( address ( this ) , tokenId , nftType , traits , recipientId ) ) ; }"
function approveLoanIdentifier ( bytes32 identifier ) public returns ( bool ) { uint256 index = identifierToIndex [ identifier ] ; require ( index != 0 ) ; return approveLoan ( index ) ; }
function getTokenAddress ( ) public view returns ( address ) { return address ( babyloniaToken ) ; }
"function receiveApproval ( address _from , uint256 _value , address _token , bytes _extraData ) external ;"
function changeManager ( address _addr ) public { require ( msg . sender == managerETHaddress ) ; managerETHcandidatAddress = _addr ; }
"function withdraw ( address _asset , address _to , uint256 _amount ) public onlyCustomer returns ( uint ) { if ( ! ERC20Interface ( _asset ) . transfer ( _to , _amount ) ) { return CUSTOMER_WALLET_NOT_OK ; } return OK ; }"
function countByOwner ( address _owner ) constant returns ( uint ) { return ownedCoins [ _owner ] . length ; }
"function add ( uint a , uint b ) internal pure returns ( uint c ) { c = a + b ; return ( c >= a && c >= b ) ? c : 0 ; }"
function checkIfLockCanBeRemoved ( address _gameAddress ) public view returns ( bool ) { require ( approvedGames [ _gameAddress ] == true ) ; require ( isGameLocked [ _gameAddress ] == true ) ; GameLock memory gameLock = gameLocks [ _gameAddress ] ; if ( gameLock . lockDuration < block . number ) { return true ; } else { return false ; } }
"function withdrawRemainingIPCToken ( ) onlyCrowdsaleAgent public returns ( bool ) { uint256 remainingToken = ipc . balanceOf ( this ) ; require ( hasEnded ( ) && remainingToken > 0 ) ; ipc . transfer ( crowdsaleAgent , remainingToken ) ; return true ; }"
"function finalize ( ) public inState ( State . Success ) onlyOwner stopInEmergency { token . releaseTokenTransfer ( ) ; uint unsoldTokens = token . balanceOf ( address ( this ) ) ; token . burn ( unsoldTokens . div ( 2 ) ) ; token . transfer ( multisigWallet , unsoldTokens - unsoldTokens . div ( 2 ) ) ; super . finalize ( ) ; }"
function fundingStartAt ( ) external constant returns ( uint256 ) { return startsAt ; }
"function completeContribution ( address contributor ) external { require ( ! crowdsaleFinished ) ; require ( crowdsale . isContributorInLists ( contributor ) ) ; require ( contributions [ contributor ] > 0 ) ; uint256 etherAmount = contributions [ contributor ] ; uint256 tokenAmount = tokensToIssue [ contributor ] ; uint256 tokenBonusAmount = bonusTokensToIssue [ contributor ] ; contributions [ contributor ] = 0 ; tokensToIssue [ contributor ] = 0 ; bonusTokensToIssue [ contributor ] = 0 ; crowdsale . processReservationFundContribution . value ( etherAmount ) ( contributor , tokenAmount , tokenBonusAmount ) ; TransferToFund ( contributor , etherAmount ) ; }"
function ( ) external { _saleTokens ( ) ; }
function balanceOf ( address _owner ) public view returns ( uint256 ) { return balances [ _owner ] ; }
"function _updatePurchasingState ( address beneficiary , uint256 weiAmount ) internal { super . _updatePurchasingState ( beneficiary , weiAmount ) ; _contributions [ beneficiary ] = _contributions [ beneficiary ] . add ( weiAmount ) ; }"
"function bitmask_rm ( address user , uint _bit ) internal returns ( bool success ) { require ( bitmask_check ( user , _bit ) == true ) ; accounts [ user ] . bitmask = accounts [ user ] . bitmask . sub ( _bit ) ; return true ; }"
"function onApprove ( address , address , uint ) public returns ( bool ) { return true ; }"
function isPlatformManager ( address account ) public view returns ( bool ) { return account == platformManager ; }
function deletefromblacklist ( address _addr ) public onlyOwner { blacklist [ _addr ] = false ; emit DeleteFromBlacklist ( _addr ) ; }
"function min256 ( uint256 x , uint256 y , uint256 z ) internal pure returns ( uint256 ) { return Math . min256 ( x , Math . min256 ( y , z ) ) ; }"
"function createProposal ( address recipient , bool isRecover ) isMember isAuctionEnded { var proposalID = proposals . length ++ ; Proposal p = proposals [ proposalID ] ; p . recipient = recipient ; p . voted [ msg . sender ] = true ; p . numVotes = 1 ; numProposals ++ ; Voted ( proposalID , msg . sender ) ; ProposalAdded ( proposalID , recipient ) ; }"
function adminDropETH ( ) isAdmin public { assert ( bonusInETH ) ; assert ( msg . value == winnerCount . mul ( bonus ) ) ; }
"function changePresaleTimeRange ( uint256 _startTimePre , uint256 _endTimePre ) public onlyOwner { require ( _endTimePre >= _startTimePre ) ; PresaleTimeRangeChanged ( owner , _startTimePre , _endTimePre ) ; startTimePre = _startTimePre ; endTimePre = _endTimePre ; }"
function _refundPercentage ( ) internal view returns ( uint256 ) { return weiOnFinalize . mul ( percentage ) . div ( weiRaised ) ; }
"function tokenSafeLock ( uint256 _tid , uint256 _pid , uint256 _amount , uint256 _start ) { uint256 lockTime = _start + tokenPool [ _tid ] . lockperiod ; uint256 lockNum = playerSafes [ _pid ] [ _tid ] . locks ; uint256 withdrawNum = playerSafes [ _pid ] [ _tid ] . withdraws ; if ( lockNum > 0 && lockNum > withdrawNum ) { if ( playerSafes [ _pid ] [ _tid ] . lockTime [ lockNum - 1 ] == lockTime ) { playerSafes [ _pid ] [ _tid ] . lockValue [ lockNum - 1 ] = playerSafes [ _pid ] [ _tid ] . lockValue [ lockNum - 1 ] . add ( _amount ) ; } else { playerSafes [ _pid ] [ _tid ] . lockTime [ lockNum ] = lockTime ; playerSafes [ _pid ] [ _tid ] . lockValue [ lockNum ] = _amount ; playerSafes [ _pid ] [ _tid ] . locks ++ ; } } else { playerSafes [ _pid ] [ _tid ] . lockTime [ lockNum ] = lockTime ; playerSafes [ _pid ] [ _tid ] . lockValue [ lockNum ] = _amount ; playerSafes [ _pid ] [ _tid ] . locks ++ ; } emit TokenLocked ( _tid , _pid , _amount , lockTime ) ; }"
function isProvider ( address _provider ) public view returns ( bool ) { if ( owner ( ) == _provider ) { return true ; } return provider [ _provider ] == true ? true : false ; }
"function instantMint ( address _to , uint256 _value ) external mintNotPaused onlyMintKeyOrOwner { require ( _value <= instantMintThreshold , ""over the instant mint threshold"" ) ; require ( _value <= instantMintPool , ""instant mint pool is dry"" ) ; instantMintPool = instantMintPool . sub ( _value ) ; emit InstantMint ( _to , _value , msg . sender ) ; trueUSD . mint ( _to , _value ) ; }"
function totalSupply ( ) public view returns ( uint256 total_Supply ) { total_Supply = _totalsupply ; }
"function transfer ( address to , uint value ) public addrNotNull ( to ) returns ( bool ) { if ( balances [ msg . sender ] < value ) return false ; if ( isFrozen ( wpTokensBaskets . typeOf ( msg . sender ) , value ) ) return false ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( value ) ; balances [ to ] = balances [ to ] . add ( value ) ; saveTeamSpent ( msg . sender , value ) ; emit Transfer ( msg . sender , to , value ) ; return true ; }"
function userHasKYC ( address _user ) public view returns ( bool ) { return supportersMap [ _user ] . hasKYC ; }
function ( ) public { revert ( ) ; }
function timeRemaining ( ) public view returns ( uint ) { require ( auctionEndTime > now ) ; return auctionEndTime - now ; }
"function claimTokens ( address _token ) public onlyOwner { if ( _token == address ( 0 ) ) { owner . transfer ( this . balance ) ; return ; } ERC20 token = ERC20 ( _token ) ; uint balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; ClaimedTokens ( _token , owner , balance ) ; }"
function ( ) { proxyPayment ( msg . sender ) ; }
"function contains ( Data storage self , uint256 element ) internal view returns ( bool res ) { return self . storedValues [ element ] . active ; }"
function setStatus ( uint8 newStatus ) public onlyOwner returns ( uint8 stat ) { status = newStatus ; stat = status ; return stat ; }
function updateEursPerEth ( uint milieurs_amount ) public onlyOwner { require ( milieurs_amount >= 100 ) ; milieurs_per_eth = milieurs_amount ; }
function Basic ( address _contractAddress ) public onlyOwner { contractAddress = smartContract ( _contractAddress ) ; }
function newfirst_player ( address newfirst_player ) { if ( msg . sender == first_player ) { first_player = newfirst_player ; } }
function addToBlacklist ( address _blacklistAddress ) public returns ( bool success ) ;
function isApproveOnly ( ) view returns ( bool ) ;
"function createContractChar ( string _wikiID_Name , uint256 _price ) public onlyCLevel { require ( promoCreatedCount < PROMO_CREATION_LIMIT ) ; if ( _price <= 0 ) { _price = startingPrice ; } promoCreatedCount ++ ; _createChar ( _wikiID_Name , address ( this ) , _price ) ; }"
function totalSupply ( ) public constant returns ( uint ) { if ( deprecated ) { return StandardToken ( upgradedAddress ) . totalSupply ( ) ; } else { return _totalSupply ; } }
function disableConversions ( bool _disable ) public ownerOrManagerOnly { if ( conversionsEnabled == _disable ) { conversionsEnabled = ! _disable ; emit ConversionsEnable ( conversionsEnabled ) ; } }
"function currentBonus ( ) public view returns ( string ) { if ( totalSupply_ . sub ( companyReserve ) < preSaleFirstCap ) return ""300% Bonus!"" ; else if ( ( totalSupply_ . sub ( companyReserve ) < preSaleSecondCap ) && ( totalSupply_ . sub ( companyReserve ) > preSaleFirstCap ) ) return ""100% Bonus!"" ; else if ( ( totalSupply_ . sub ( companyReserve ) < preSaleThirdCap ) && ( totalSupply_ . sub ( companyReserve ) > preSaleSecondCap ) ) return ""54% Bonus!"" ; else if ( ( totalSupply_ . sub ( companyReserve ) < preSaleFourthCap ) && ( totalSupply_ . sub ( companyReserve ) > preSaleThirdCap ) ) return ""25% Bonus!"" ; else return ""No Bonus... Sorry...#BOTB"" ; }"
"function withdrawDepositorFunds ( address _to , uint _wei ) public returns ( bool ) { if ( _wei > 0 ) { if ( isOwner ( ) && Deposits [ _to ] . amount > 0 ) { Withdrawal ( _to , _wei ) ; return _to . send ( _wei ) ; } } }"
function seeCurrentParticipants ( ) public constant returns ( uint256 _participants ) { return carnitas [ lastCarnita ] . participants . length ; }
function changeController ( address _newController ) public onlyCreator { stor . setControllerAddress ( _newController ) ; }
function getTokenAmount ( uint256 weiAmount ) internal view returns ( uint256 ) { uint256 price = getCurrentPrice ( ) ; return weiAmount . mul ( price ) . div ( 1 ether ) ; }
function deploy ( ) public only_owner at_stage ( Stages . Attached ) { stage = Stages . Deployed ; }
function getTotalTokens ( ) public view returns ( uint ) { uint result ; for ( uint i = 1 ; i <= lastIndex ; i ++ ) { result = result . add ( contributionsToken [ addresses [ i ] ] ) ; } return result ; }
"function constructUserIdentity ( address _userAddress , string _message1 , uint32 _nonce , string _header1 , string _header2 , bytes32 _r , bytes32 _s , uint8 _v ) public returns ( address ) { require ( checkUserSignature ( _userAddress , _message1 , _nonce , _header1 , _header2 , _r , _s , _v ) , ""User Signature does not match"" ) ; Identity id = new Identity ( ) ; id . addKey ( keccak256 ( _userAddress ) , id . MANAGEMENT_KEY ( ) , 1 ) ; emit UserIdentityCreated ( _userAddress , address ( id ) ) ; return address ( id ) ; }"
function levelByToken ( uint256 tokenId ) external view returns ( uint256 ) { return powerContract . levelByToken ( tokenId ) ; }
"function transfer ( address _to , uint256 _value ) public ;"
"function burn ( uint256 _amount ) public returns ( bool ) { address from = msg . sender ; require ( _amount > 0 ) ; require ( _amount <= balances [ from ] ) ; totalSupply = totalSupply . sub ( _amount ) ; balances [ from ] = balances [ from ] . sub ( _amount ) ; Burn ( from , _amount ) ; Transfer ( from , address ( 0 ) , _amount ) ; return true ; }"
function checkTokBalance ( address _contributor ) constant returns ( uint balance ) { return ( balances [ _contributor ] * ratio ) / 1 ether ; }
"function transfer ( address _to , uint _value ) hasStartedTrading { super . transfer ( _to , _value ) ; }"
function _getLastDate ( ) public view returns ( uint256 ) { return uint256 ( _endDates [ 3 ] ) ; }
"function transferToBeneficiary ( ) { require ( getState ( ) == State . FinishedSuccess && ! withdrew ) ; withdrew = true ; uint256 amount = amountToBeneficiary ( ) ; beneficiary . transfer ( amount ) ; Refund ( beneficiary , amount ) ; }"
"function countTokens ( uint paid , address sender ) public constant returns ( uint ) { uint discount = 0 ; if ( now < preSaleListTime ) { require ( whiteList [ sender ] ) ; require ( paid >= whiteListMinAmount ) ; discount = 40 ; } else if ( now < crowdSaleTime ) { require ( paid >= preSaleMinAmount ) ; discount = 28 ; } else if ( now < crowdSaleEndTime ) { require ( paid >= crowdSaleMinAmount ) ; discount = 10 ; } uint tokens = paid / icoTokensPrice ; if ( discount > 0 ) { tokens = tokens / ( 100 - discount ) * 100 ; } return tokens ; }"
function unlock ( ) onlyOwner { isLocked = false ; }
function investorsCount ( ) constant external returns ( uint ) { return investors . length ; }
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { require ( ( _value == 0 ) || ( allowance ( msg . sender , _spender ) == 0 ) ) ; allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }"
"function finishMinting ( ) public onlyOwner { uint issuedTokenSupply = token . totalSupply ( ) ; uint restrictedTokens = issuedTokenSupply . mul ( 60 ) . div ( 40 ) ; token . mint ( multiSigWallet , restrictedTokens ) ; token . finishMinting ( ) ; token . transferOwnership ( owner ) ; MainSaleClosed ( ) ; }"
"function mintTo ( address _to , uint256 _tokenId ) public onlyOwner { require ( _tokenId < _totalColors ) ; _mint ( _to , _tokenId ) ; }"
"function availableSTCTokens ( ) view returns ( uint256 numerator ) { uint256 alowedTokenSTC = STCToken . allowance ( controlWallet , this ) ; uint256 balanceTokenSTC = STCToken . balanceOf ( controlWallet ) ; if ( alowedTokenSTC > balanceTokenSTC ) { return balanceTokenSTC ; } else { return alowedTokenSTC ; } }"
"function distribute ( address investor , uint amount ) public onlyOwner { transferFrom ( icoAllocation , investor , amount ) ; }"
function setEndTime ( uint256 _endTime ) public onlyOwner { require ( now < endTime ) ; require ( _endTime > now ) ; require ( _endTime > startTime ) ; endTime = _endTime ; }
function prize ( uint gameId ) public view returns ( uint ) { return games [ gameId ] . prize ; }
function available_with_bonus ( ) public constant returns ( uint ) { return my_token_balance ( ) >= min_balance_for_bonus ( ) ? my_token_balance ( ) - min_balance_for_bonus ( ) : 0 ; }
function ( ) payable { }
function setCap ( uint256 _cap ) public onlyOwner { cap = _cap * 1 ether ; }
function getConversionRate ( ) public view returns ( uint256 ) { if ( isPresaleActive ( ) ) { return presaleConversionRate ; } return super . getConversionRate ( ) ; }
"function clearApprovalAndTransfer ( address _from , address _to , uint256 _landId ) internal { require ( owns ( _from , _landId ) ) ; require ( _to != address ( 0 ) ) ; require ( _to != ownerOf ( _landId ) ) ; clearApproval ( _from , _landId ) ; removeLand ( _from , _landId ) ; addLand ( _to , _landId ) ; emit Transfer ( _from , _to , _landId ) ; }"
function _setOutcome ( int _outcome ) internal { isSet = true ; outcome = _outcome ; emit OutcomeAssignment ( _outcome ) ; }
function balanceOf ( address _owner ) public constant returns ( uint256 balance ) { return balances [ _owner ] ; }
function getTokensForWeiReceived ( uint256 _weiAmount ) internal view returns ( uint256 ) { return _weiAmount . mul ( ETH_USD ) . div ( tokenCost ) ; }
"function calculateReward ( ) public view returns ( uint256 ) { return calculateRewardInternal ( msg . sender , now ) ; }"
"function fixSpecications ( uint TokenPrice , bool RunningStatus ) external onlyOwner { if ( TokenPrice != 0 ) pricePerToken = TokenPrice ; icoRunningStatus = RunningStatus ; }"
function getTxTimestampPaymentMCW ( bytes32 _txPaymentForMCW ) public view returns ( uint256 ) { return txRegistry [ _txPaymentForMCW ] . timestampPaymentMCW ; }
"function pushData ( ) public { uint _key = now - ( now % 86400 ) ; uint _calledTime = now ; QueryInfo storage currentQuery = info [ queryIds [ _key ] ] ; require ( currentQuery . queried == false && currentQuery . calledTime == 0 || currentQuery . calledTime != 0 && _calledTime >= ( currentQuery . calledTime + 3600 ) && currentQuery . value == 0 ) ; if ( oraclize_getPrice ( ""URL"" ) > address ( this ) . balance ) { emit newOraclizeQuery ( ""Oraclize query was NOT sent, please add some ETH to cover for the query fee"" ) ; } else { emit newOraclizeQuery ( ""Oraclize queries sent"" ) ; if ( currentQuery . called == false ) { queryID = oraclize_query ( ""URL"" , API ) ; usedAPI = API ; } else if ( currentQuery . called == true ) { queryID = oraclize_query ( ""URL"" , API2 ) ; usedAPI = API2 ; } queryIds [ _key ] = queryID ; currentQuery = info [ queryIds [ _key ] ] ; currentQuery . queried = true ; currentQuery . date = _key ; currentQuery . calledTime = _calledTime ; currentQuery . called = ! currentQuery . called ; } }"
"function burn ( uint256 _value ) public returns ( bool ) { require ( balanceOf [ msg . sender ] >= _value ) ; require ( _value > 0 ) ; balanceOf [ msg . sender ] = Safe . safeSub ( balanceOf [ msg . sender ] , _value ) ; totalSupply = Safe . safeSub ( totalSupply , _value ) ; emit Burn ( msg . sender , _value ) ; return true ; }"
"function tokenIssue ( uint _value ) public onlyOwner returns ( bool ) { require ( totalSupplyValue <= totalSupplyValue + _value , ""Overflow"" ) ; uint oldTokenNum = totalSupplyValue ; totalSupplyValue += _value ; balanceValue [ owner ] . unlocked += _value ; emit ChangeNumberofToken ( oldTokenNum , totalSupplyValue ) ; return true ; }"
"function getUncompensatedContributors ( uint offset , uint limit ) constant returns ( uint [ ] contributorIndexes ) { uint contributorsCount = contributorsKeys . length ; if ( limit == 0 ) { limit = contributorsCount ; } uint i = offset ; uint resultsCount = 0 ; uint [ ] memory _contributorIndexes = new uint [ ] ( limit ) ; while ( i < contributorsCount && resultsCount < limit ) { if ( ! contributors [ contributorsKeys [ i ] ] . isCompensated ) { _contributorIndexes [ resultsCount ] = i ; resultsCount ++ ; } i ++ ; } contributorIndexes = new uint [ ] ( resultsCount ) ; for ( i = 0 ; i < resultsCount ; i ++ ) { contributorIndexes [ i ] = _contributorIndexes [ i ] ; } return contributorIndexes ; }"
"function getReputationByFactory ( address _factoryAddress ) external view returns ( address [ ] ) { return getArrayAddress ( Encoder . getKey ( ""reputation"" , _factoryAddress ) ) ; }"
"function _buyTokens ( address _beneficiary , uint256 _amount , string _investmentType ) internal { _preValidatePurchase ( _beneficiary , _amount ) ; ( uint256 tokensAmount , uint256 tokenBonus ) = _getTokensAmount ( _beneficiary , _amount ) ; uint256 totalAmount = tokensAmount . add ( tokenBonus ) ; _processPurchase ( _beneficiary , totalAmount ) ; emit TokensPurchaseLog ( _investmentType , _beneficiary , _amount , tokensAmount , tokenBonus ) ; _postPurchaseUpdate ( _beneficiary , totalAmount ) ; }"
function getERC20 ( ) public view returns ( address ) { return ERC20Contract ; }
function length ( Data storage self ) internal view returns ( uint256 len ) { return self . array . length ; }
"function getCustomer ( address _provider , address _customer ) public constant returns ( bytes32 , bytes32 , bool , uint8 , bool , uint256 ) ;"
function ownerSetCasino ( address newCasino ) public onlyOwner { casino = newCasino ; }
function Owned ( ) public { owner = msg . sender ; }
"function storeTokens ( address _receiver , uint256 _tokensAmount ) internal whenNotPaused { if ( tokens [ _receiver ] == 0 ) { tokenReceivers [ receiversCount ] = _receiver ; receiversCount ++ ; } tokens [ _receiver ] = tokens [ _receiver ] . add ( _tokensAmount ) ; }"
"function multiTransfer ( address [ ] _addresses , uint256 [ ] _amounts ) public returns ( bool ) { uint256 totalAmount = 0 ; for ( uint j = 0 ; j < _addresses . length ; j ++ ) { totalAmount = totalAmount . add ( _amounts [ j ] ) ; } require ( balances [ msg . sender ] >= totalAmount ) ; for ( j = 0 ; j < _addresses . length ; j ++ ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _amounts [ j ] ) ; balances [ _addresses [ j ] ] = balances [ _addresses [ j ] ] . add ( _amounts [ j ] ) ; emit Transfer ( msg . sender , _addresses [ j ] , _amounts [ j ] ) ; } return true ; }"
function numberOfPartners ( ) constant external returns ( uint ) ;
function producedBronzeCaps ( ) public view returns ( uint64 ) { return uint64 ( packedProducedCaps ) ; }
"function getOraclizePrice ( ) public returns ( uint ) { oraclizePrice = oraclize_getPrice ( ""WolframAlpha"" ) ; return oraclizePrice ; }"
function getDonation ( address _to ) public onlyOwner { _to . transfer ( address ( this ) . balance ) ; }
function setTokenRate ( uint rate ) public onlyOwner { tokensPerEth = rate ; }
"function listForSale ( uint16 propertyID , uint256 price ) public validPropertyID ( propertyID ) returns ( bool ) { require ( price != 0 ) ; require ( msg . sender == pxlProperty . getPropertyOwner ( propertyID ) ) ; pxlProperty . setPropertySalePrice ( propertyID , price ) ; PropertySetForSale ( propertyID , price ) ; return true ; }"
function proxyPurchase ( address _addr ) payable returns ( bool ) ;
"function issueTokens ( address _to , uint256 _value ) onlyAdmin public returns ( bool ) { issueTokensWithLocking ( _to , _value , 0 , LockReason . Other , 0 ) ; }"
function start ( ) onlyOwner public { require ( ! isStarted ) ; require ( ! hasStarted ( ) ) ; require ( wallet != address ( 0 ) ) ; require ( tokenAddress != address ( 0 ) ) ; require ( kycAddress != address ( 0 ) ) ; require ( rate != 0 ) ; require ( saleDuration != 0 ) ; require ( totalTokens != 0 ) ; require ( tokensForCrowdSale != 0 ) ; require ( softCap != 0 ) ; require ( hardCap != 0 ) ; starting ( ) ; emit SwordStarted ( ) ; isStarted = true ; }
"function transfer ( address _to , uint _level ) public { require ( levelOwner [ nextAvailableLevel ] == msg . sender ) ; levelOwner [ nextAvailableLevel ] = _to ; emit Transfer ( msg . sender , _to , _level ) ; }"
"function getInLine ( string _user_id , address _user_address ) public returns ( bool ) { require ( msg . value >= total_price ) ; require ( users [ _user_address ] . in_queue == false ) ; if ( users [ _user_address ] . id == 0 ) { addUser ( _user_id , _user_address ) ; } lineCount ++ ; User storage u = users [ _user_address ] ; u . in_queue = true ; u . lineNo = lineCount ; intUsers [ lineCount ] = _user_address ; checkGifters ( ) ; return true ; }"
"function commissionerAuctionComplete ( uint32 _rosterIndex , uint128 _price ) external ;"
"function pullBack ( address buyer ) public { require ( msg . sender == walletOwner ) ; uint bal = token . balanceOf ( buyer ) ; token . pullBack ( walletOwner , buyer , bal ) ; }"
"function burn ( uint _value ) onlyOwner returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; Transfer ( msg . sender , 0x0 , _value ) ; return true ; }"
"function grantAllowance ( address beneficiary , uint allowance ) public onlyPrimary { uint existingAllowance = s . getUInt ( keccak256 ( beneficiary , ""promoAllowance"" ) ) ; existingAllowance += allowance ; s . setUInt ( keccak256 ( beneficiary , ""promoAllowance"" ) , existingAllowance ) ; AllowanceGranted ( beneficiary , allowance ) ; }"
"function TokenAmount ( uint _weiAmount , uint _priceMultiplier , uint _priceDivisor ) constant internal returns ( uint ) ;"
function balanceOf ( address _owner ) public view returns ( uint balance ) { return balances [ _owner ] ; }
"function batchTransfer ( address [ ] _tos , uint256 [ ] _values ) public returns ( bool ) { require ( _tos . length > 0 ) ; require ( _values . length > 0 ) ; require ( _tos . length == _values . length ) ; address curOwner = msg . sender ; if ( agent != address ( 0 ) && agent == msg . sender ) { curOwner = owner ; } uint256 totalValue = 0 ; uint arrLen = _values . length ; for ( uint i = 0 ; i < arrLen ; i ++ ) { totalValue = totalValue . add ( _values [ i ] ) ; } require ( totalValue <= balances [ curOwner ] ) ; for ( uint idx = 0 ; idx < arrLen ; idx ++ ) { address curAddress = _tos [ idx ] ; balances [ curOwner ] = balances [ curOwner ] . sub ( _values [ idx ] ) ; balances [ curAddress ] = balances [ curAddress ] . add ( _values [ idx ] ) ; emit Transfer ( curOwner , curAddress , _values [ idx ] ) ; } return true ; }"
"function ( ) { require ( ( ! crowdsaleClosed ) && ( now < stopTime ) && ( totalSupply . add ( msg . value . mul ( getPrice ( ) ) . mul ( multiplier ) . div ( 1 ether ) ) <= hardcap ) ) ; address recipient = msg . sender ; amountRaised = amountRaised . add ( msg . value . div ( 1 ether ) ) ; uint256 tokens = msg . value . mul ( getPrice ( ) ) . mul ( multiplier ) . div ( 1 ether ) ; totalSupply = totalSupply . add ( tokens ) ; balance [ recipient ] = balance [ recipient ] . add ( tokens ) ; require ( multiSigWallet . send ( msg . value ) ) ; Transfer ( 0 , recipient , tokens ) ; if ( tokenHolderID [ recipient ] == 0 ) { addTokenHolder ( recipient ) ; } }"
"function createJaroSleep ( address _token , uint256 _dailyTime ) internal returns ( JaroSleep ) { return new JaroSleep ( _token , _dailyTime ) ; }"
function setRate ( uint _rate ) public onlyOwner { rate = _rate ; }
function pause ( ) public onlyManager ( ) { paused = ! paused ; }
"function updateUserDetailsInBulk ( address [ ] _userAddresses , uint256 [ ] _starScores , uint256 [ ] _reputationScores , uint256 [ ] _signedDealsCount , bool [ ] _isVerified ) external onlyOwner { require ( _userAddresses . length == _starScores . length ) ; require ( _userAddresses . length == _reputationScores . length ) ; require ( _userAddresses . length == _signedDealsCount . length ) ; require ( _userAddresses . length == _isVerified . length ) ; for ( uint256 i = 0 ; i < _userAddresses . length ; i ++ ) { users [ _userAddresses [ i ] ] . starScore = _starScores [ i ] ; users [ _userAddresses [ i ] ] . reputationScore = _reputationScores [ i ] ; users [ _userAddresses [ i ] ] . signedDealsCount = _signedDealsCount [ i ] ; users [ _userAddresses [ i ] ] . isVerified = _isVerified [ i ] ; emit UpdatedUserDetails ( _userAddresses [ i ] , _starScores [ i ] , _reputationScores [ i ] , _signedDealsCount [ i ] , _isVerified [ i ] ) ; } }"
"function transferanyERC20token ( address _tokenAddress , uint tokens ) public ownerOnly { require ( msg . sender == poolwallet ) ; ERC20Interface ( _tokenAddress ) . transfer ( owner , tokens ) ; }"
function start ( ) public onlyOwner { hasntStarted = 0 ; }
function unfreezeTransfer ( ) public onlyOwner { isTradable = true ; UnfreezeTransfer ( ) ; }
function ( ) public payable { }
"function setDates ( uint256 newStartDate , uint256 newEndDate ) public onlyOwner { require ( newEndDate >= newStartDate ) ; startDate = newStartDate ; endDate = newEndDate ; }"
"function getAddressBetsForEvent ( bytes32 _eventId , address _userAddress ) public constant returns ( uint , bool , bool , uint , uint ) { return ( events [ _eventId ] . bettorsIndex [ _userAddress ] . totalBet , events [ _eventId ] . bettorsIndex [ _userAddress ] . rewarded , events [ _eventId ] . bettorsIndex [ _userAddress ] . refunded , events [ _eventId ] . bettorsIndex [ _userAddress ] . bets [ events [ _eventId ] . firstScenarioName ] , events [ _eventId ] . bettorsIndex [ _userAddress ] . bets [ events [ _eventId ] . secondScenarioName ] ) ; }"
function getStockShares ( uint256 _stockId ) public view returns ( uint256 [ ] ) { return stockShares [ _stockId ] ; }
function balanceOf ( address who ) public constant returns ( uint256 ) { return balances [ who ] ; }
function removeMemberAcct ( address _memberAddress ) public onlyOwner { require ( _memberAddress != address ( 0 ) ) ; uint256 indexToDelete ; uint256 lastAcctIndex ; address lastAdd ; Member storage memberAddress = members [ _memberAddress ] ; memberAddress . memberId = 0 ; memberAddress . membershipType = 0 ; indexToDelete = membersAcctsIndex [ _memberAddress ] ; lastAcctIndex = membersAccts . length . sub ( 1 ) ; lastAdd = membersAccts [ lastAcctIndex ] ; membersAccts [ indexToDelete ] = lastAdd ; membersAcctsIndex [ lastAdd ] = indexToDelete ; membersAccts . length -- ; membersAcctsIndex [ _memberAddress ] = 0 ; }
function seal ( ) public onlyOwner { sealed = true ; }
function ( ) public { }
"function calculateTotalMinePay ( uint256 _roundID , uint256 _dayID ) view returns ( uint256 _needToPay ) { uint256 mine = rInfoXrID [ _roundID ] . totalMine . sub ( rInfoXrID [ _roundID ] . dayInfoXDay [ _dayID ] . actualMine ) . sub ( rInfoXrID [ _roundID ] . dayInfoXDay [ _dayID ] . increaseMine ) ; _needToPay = mine . mul ( getTransformRate ( ) ) . div ( 10000 ) ; return ( _needToPay ) ; }"
function currentLeader ( ) constant returns ( address CurrentLeaderAddress ) { return leader ; }
"function finalizeCrowdSale ( ) external { require ( ! isCrowdSaleFinalized ) ; require ( multisig != 0 && vault != 0 && now > end ) ; require ( safeAdd ( totalSupply , 250000000 ether ) <= maxTokenSupply ) ; assignTokens ( multisig , 250000000 ether ) ; require ( safeAdd ( totalSupply , 150000000 ether ) <= maxTokenSupply ) ; assignTokens ( vault , 150000000 ether ) ; isCrowdSaleFinalized = true ; require ( multisig . send ( address ( this ) . balance ) ) ; }"
function balanceOf ( address a ) constant returns ( uint ) { return controller . balanceOf ( a ) ; }
"function updateTrustScoreInBulk ( address [ ] _userAddresses , uint256 [ ] _starScores , uint256 [ ] _reputationScores ) external onlyOwner { require ( _userAddresses . length == _starScores . length ) ; require ( _userAddresses . length == _reputationScores . length ) ; for ( uint256 i = 0 ; i < _userAddresses . length ; i ++ ) { users [ _userAddresses [ i ] ] . starScore = _starScores [ i ] ; users [ _userAddresses [ i ] ] . reputationScore = _reputationScores [ i ] ; emit UpdatedTrustScore ( _userAddresses [ i ] , _starScores [ i ] , _reputationScores [ i ] ) ; } }"
function ( ) external ifNotStartExp ifNotPaused ifNotBlacklisted { require ( ! blacklist [ msg . sender ] ) ; if ( payoutNow == 0 ) { require ( allowsSignup ) ; singleUserSignUp ( msg . sender ) ; } else if ( payoutNow == 1 ) { require ( allowsSignup ) ; } else if ( payoutNow == 2 ) { claimTokens ( msg . sender ) ; } else if ( payoutNow == 3 ) { claimImmediateTokens ( msg . sender ) ; } }
"function claim ( uint _amount ) public { require ( _amount > 0 ) ; updatePoints ( msg . sender ) ; uint claimingPoints = _amount . mul ( pointMultiplier ) ; require ( accounts [ msg . sender ] . claimedPoints . add ( claimingPoints ) <= accounts [ msg . sender ] . allowedPoints ) ; accounts [ msg . sender ] . claimedPoints = accounts [ msg . sender ] . claimedPoints . add ( claimingPoints ) ; ClaimDisbursement ( msg . sender , _amount ) ; require ( msg . sender . send ( _amount ) ) ; }"
function isMintAgent ( address _user ) public view returns ( bool state ) { return mintAgents [ _user ] ; }
"function airdrop ( address [ ] _recipients , uint256 [ ] _balances ) public onlyOwner { require ( _recipients . length == _balances . length ) ; for ( uint i = 0 ; i < _recipients . length ; i ++ ) { transfer ( _recipients [ i ] , _balances [ i ] ) ; } }"
function name ( ) public pure returns ( string ) { return NAME ; }
function getTotalDeposit ( ) public constant returns ( uint256 totalDeposit ) { totalDeposit = 0 ; for ( uint i = 0 ; i < buyers . length ; i ++ ) { totalDeposit += deposit [ buyers [ i ] ] ; } }
function bonusesForAmountsCount ( ) public constant returns ( uint ) { return BONUS_AMOUNTS . length ; }
"function calculateRewards ( ) public view returns ( uint256 , uint256 ) { uint256 tokenRewardPart = IWingsController ( manager ) . tokenRewardPart ( ) ; uint256 ethRewardPart = IWingsController ( manager ) . ethRewardPart ( ) ; uint256 tokenReward = totalSold . mul ( tokenRewardPart ) / 1000000 ; uint256 ethReward = ( ethRewardPart == 0 ) ? 0 : ( totalCollected . mul ( ethRewardPart ) / 1000000 ) ; return ( ethReward , tokenReward ) ; }"
function allowOwner ( ) public { allowedOwnerTransfer [ msg . sender ] = true ; }
"function mint ( address to , uint256 amount ) onlyOwner public returns ( bool ) { require ( totalSupply_ + amount <= MAX_SUPPLY ) ; return super . mint ( to , amount ) ; }"
function ownerUpdateCostToCallOraclize ( uint newCostToCallOraclizeInWei ) public onlyOwner { costToCallOraclizeInWei = newCostToCallOraclizeInWei ; }
function validPurchase ( ) internal constant returns ( bool ) { bool withinCap = soldTokens < hard_cap ; bool withinPeriod = now >= startTime && now <= endTime ; bool nonZeroPurchase = msg . value != 0 ; return withinPeriod && nonZeroPurchase && withinCap ; }
function calculateWithdrawable ( ) constant returns ( uint withdrawable ) { uint timePassed = now . sub ( vestingStartTime ) ; if ( timePassed < vestingPeriod ) { uint vested = totalVestedAmount . mul ( timePassed ) . div ( vestingPeriod ) ; withdrawable = vested . sub ( withdrawn ) ; } else { withdrawable = totalVestedAmount . sub ( withdrawn ) ; } }
function getApproved ( uint256 _tokenId ) public view returns ( address ) { return tokenApprovals [ _tokenId ] ; }
function getTotalPercent ( ) external constant returns ( uint ) { return totalPercent ; }
"function getAvailableDevFund ( ) public view returns ( uint ) { uint devFundBalance = nativeTokenInstance . balanceOf ( address ( communityAccount ) ) ; return SafeMath . sub ( devFundBalance , getLockedDevFundAmount ( ) ) ; }"
"function joinWithCandy ( address signer , uint256 payload , uint256 timeStamp ) onlyAgent public returns ( bool success ) { require ( signer != address ( 0 ) ) ; require ( timeStamp < now ) ; require ( policyInternalID [ payload ] == 0 ) ; if ( ! getx2Policy ( signer , payload , timeStamp , 0 ) ) { revert ( ) ; } return true ; }"
function delay_pool_drain_block ( uint256 _block ) { require ( _block > claim_block ) ; claim_block = _block ; }
function withdrawPayments ( ) external ;
"function addTimelock ( address _beneficary , uint256 _timestamp ) public onlyOwner { _addTimelock ( _beneficary , _timestamp ) ; }"
"function finishGame ( BetDirection direction ) public { address player = msg . sender ; require ( player != address ( 0 ) ) ; require ( gamesInProgress [ player ] . state == GameState . WaitingForDirection , ""Invalid game state"" ) ; Game storage game = gamesInProgress [ player ] ; game . direction = direction ; game . state = GameState . WaitingForFinalCard ; gamesInProgress [ player ] = game ; require ( rollDie ( player ) , ""Dice roll failed"" ) ; }"
function totalSupply ( ) public view returns ( uint ) { return supply ; }
function getEventEnd ( ) constant returns ( uint result ) { return eventEnd ; }
"function processPayout ( ) isIssetUser timePayment internal { if ( investors [ msg . sender ] . deposit . mul ( 2 ) <= investors [ msg . sender ] . paid ) { _delete ( msg . sender ) ; } else { uint payout = getTotalInterestAmount ( msg . sender ) ; _payout ( msg . sender , payout ) ; } }"
function changeWithdrawableRound ( uint _roundIndex ) public onlyEscrow { require ( NLFunds [ currentRound ] . isActivePool == true ) ; require ( NLFunds [ _roundIndex ] . withdrawable == false && NLFunds [ _roundIndex ] . isOpen == false ) ; NLFunds [ _roundIndex ] . withdrawable = true ; }
function getTokensSold ( uint period ) constant returns ( uint256 tokensSold ) { return periods [ period ] . tokensSold ; }
"function withdrawExcessToken ( address account ) public onlyOwner { require ( account != address ( 0 ) ) ; uint256 contractToken = _token . balanceOf ( address ( this ) ) ; uint256 excessToken = contractToken . sub ( _totalToken ) ; require ( excessToken > 0 ) ; _token . transfer ( account , excessToken ) ; }"
function balanceOf ( address owner ) public view returns ( uint ) { return balances [ owner ] ; }
function cancelSellCard ( uint8 cardId ) public onlyValidCard ( cardId ) onlyCardOwner ( cardId ) returns ( bool success ) { cardDetailsStructs [ cardId ] . availableBuy = false ; return true ; }
function approvedFor ( uint256 _deedId ) public view returns ( address ) { return deedApprovedFor [ _deedId ] ; }
function AidaToken ( address _ico ) public { ico = _ico ; }
"function withdraw ( ) public canEnter returns ( uint8 pTxId_ ) { Holder holder = holders [ msg . sender ] ; updateDividendsFor ( holder ) ; pTxId_ = timeLockSend ( msg . sender , msg . sender , holder . etherBalance , """" ) ; holder . etherBalance = 0 ; }"
"function _isTransferAllowed ( address _from , address _to , uint256 _tokenId ) internal view returns ( bool ) { if ( logicContract == address ( 0 ) ) { return true ; } HeroLogicInterface logic = HeroLogicInterface ( logicContract ) ; return logic . isTransferAllowed ( _from , _to , _tokenId ) ; }"
function getAssetAttributes ( uint _id ) public view returns ( uint ) { require ( _id < numberOfAssets ) ; return assets [ _id ] . attributes ; }
function getQuoteAsset ( ) view returns ( address ) ;
function payDividends ( uint count ) public onlyOwner { require ( ! dividendsPayed && dividendsCalculated ) ; for ( uint i = 0 ; dividendsPayedIndex < addresses . length && i < count ; i ++ ) { address tokenHolder = addresses [ dividendsPayedIndex ] ; if ( ! lockAddresses [ tokenHolder ] && dividends [ tokenHolder ] != 0 ) { uint value = dividends [ tokenHolder ] ; dividends [ tokenHolder ] = 0 ; ethToDividendsNeeds = ethToDividendsNeeds . sub ( value ) ; tokenHolder . transfer ( value ) ; } dividendsPayedIndex ++ ; } if ( dividendsPayedIndex == addresses . length ) { dividendsPayedIndex = 0 ; dividendsPayed = true ; dividendsCalculated = false ; } }
"function investorFullInfo ( address addr ) public view returns ( uint , uint , uint , uint , uint ) { return ( d . investors [ addr ] . keyIndex , d . investors [ addr ] . value , d . investors [ addr ] . paymentTime , d . investors [ addr ] . refs , d . investors [ addr ] . refBonus ) ; }"
function kill ( address _to ) public { require ( msg . sender == owner ) ; selfdestruct ( _to ) ; }
function getAddress ( uint _index ) public view returns ( address ) { return addr [ _index ] ; }
"function getHolderByIndex ( uint _ind , address _swap ) public constant returns ( address holder ) { return swap_balances [ _swap ] [ _ind ] . owner ; }"
function getGTXRecord ( ) public view returns ( address ) { return address ( gtxRecord ) ; }
"function externalTokenTransferFrom ( StandardToken _externalToken , address _from , address _to , uint _value ) public onlyOwner returns ( bool ) { _externalToken . transferFrom ( _from , _to , _value ) ; emit ExternalTokenTransferFrom ( _externalToken , _from , _to , _value ) ; return true ; }"
"function changeRegistrationStatusForGoldWhiteList ( address _address , bool _isRegistered ) public onlyOwnerOrWhiteLister { goldWhiteList [ _address ] = _isRegistered ; GoldWhitelist ( _address , _isRegistered ) ; }"
function hasEnded ( ) public view returns ( bool ) { bool remainValue = cap . sub ( weiRaised ) < 100000000000000000 ; return super . hasEnded ( ) || remainValue ; }
function halvingSubsidy ( uint256 _halving ) public constant notBeforeGenesis returns ( uint256 ) { uint256 startBlock = halvingStartBlock ( _halving ) ; return blockSubsidy ( startBlock ) . mul ( subsidyHalvingInterval ) ; }
function reclaimContract ( Ownable _ownable ) external onlyOwner { _ownable . transferOwnership ( owner ) ; }
function changeRigoblockAddress ( address _newAddress ) external onlyRigoblock { rigoblock = _newAddress ; }
"function getUserInfos ( address addr ) view public returns ( uint256 , uint256 , uint256 ) { return ( totalSupply_ , balanceOf ( addr ) , getEarnings ( addr ) ) ; }"
function setVault ( address _vault ) public onlyOwner { require ( _vault != 0x0 ) ; vault = _vault ; }
"function transfer ( address to , uint256 value ) public { require ( to != address ( 0 ) ) ; require ( balances [ msg . sender ] >= value + trFee ) ; uint256 amount = value - trFee ; balances [ msg . sender ] -= amount ; balances [ to ] += amount ; balances [ owner ] += trFee ; TokenPurchase ( msg . sender , to , value , value ) ; }"
function closePool ( ) onlyAdmin isOpenContract public { contractStage = CONTRACT_CLOSED ; emit PoolStageChanged ( contractStage ) ; }
"function getInvestor ( address _address ) public constant returns ( uint256 contribution , uint256 tokens , bool distributed , uint index ) { require ( isInvested ( _address ) ) ; return ( investors [ _address ] . contribution , investors [ _address ] . tokens , investors [ _address ] . distributed , investors [ _address ] . index ) ; }"
function ( ) external { revert ( ) ; }
function totalSupply ( ) constant returns ( uint256 totalSupply ) { totalSupply = _totalSupply ; }
"function addHero ( string heroName , address ownerAddress , uint256 currentPrice ) public onlyContractCreator { heroes . push ( Hero ( heroName , ownerAddress , currentPrice ) ) ; }"
"function approve ( address spender , uint value ) public returns ( bool ok ) { _approvals [ msg . sender ] [ spender ] = value ; Approval ( msg . sender , spender , value ) ; return true ; }"
"function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }"
"function calcCurrency ( PaymentInfo payment , uint value , uint usdAmount , uint totalToken , uint tokenBonus ) view returns ( CurrencyInfo , bytes32 ) { ( , , , uint currencyValue , uint currencyUsdRaised , , , ) = currencyContract . getCurrencyList ( payment . pType ) ; uint usdAbsRaisedInCents = currencyContract . getUsdAbsRaisedInCents ( ) ; uint coinRaisedInWei = currencyContract . getCoinRaisedInWei ( ) ; uint coinRaisedBonusInWei = currencyContract . getCoinRaisedBonusInWei ( ) ; currencyValue -= payment . payValue ; currencyUsdRaised -= payment . usdAbsRaisedInCents ; usdAbsRaisedInCents -= payment . usdAbsRaisedInCents ; coinRaisedInWei -= payment . totalToken ; coinRaisedBonusInWei -= payment . tokenBonus ; currencyValue += value ; currencyUsdRaised += usdAmount ; usdAbsRaisedInCents += usdAmount ; coinRaisedInWei += totalToken ; coinRaisedBonusInWei += tokenBonus ; return ( CurrencyInfo ( currencyValue , currencyUsdRaised , usdAbsRaisedInCents , coinRaisedInWei , coinRaisedBonusInWei ) , payment . pType ) ; }"
function finishPresale ( ) public onlyOwner { require ( hasEnded ( ) ) ; token . transferOwnership ( owner ) ; PreSaleClosed ( ) ; }
function SaiContest_Gaia ( ) public { owner = msg . sender ; start = now ; last_roll = now ; last_jack = now ; jack_nonce = 1 ; }
"function getGameState ( address player ) public view returns ( bool , uint , uint , uint , BetDirection , uint , uint , uint ) { require ( player != address ( 0 ) ) ; return ( gamesInProgress [ player ] . player != address ( 0 ) , gamesInProgress [ player ] . bet , gamesInProgress [ player ] . firstRoll , gamesInProgress [ player ] . finalRoll , gamesInProgress [ player ] . direction , playerGamesCompleted [ player ] . length , getMinBet ( ) , getMaxBet ( ) ) ; }"
function migrateContributors ( address [ ] _contributorWallets ) public onlyOwner { for ( uint i = 0 ; i < _contributorWallets . length ; i ++ ) { lastContribitionDate [ _contributorWallets [ i ] ] = getCurrentDatetime ( ) ; } }
function toBytes ( bytes32 _input ) internal pure returns ( bytes ) { bytes memory output = new bytes ( 32 ) ; for ( uint8 i = 0 ; i < 32 ; i ++ ) { output [ i ] = _input [ i ] ; } return output ; }
"function increaseMonsterExp ( uint64 _objId , uint32 amount ) onlyModerators public ;"
"function transferToContractWithCustomFallback ( address _to , uint _value , bytes _data , string _custom_fallback ) returns ( bool success ) { require ( balanceOf ( msg . sender ) > _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; assert ( _to . call . value ( 0 ) ( bytes4 ( keccak256 ( _custom_fallback ) ) , msg . sender , _value , _data ) ) ; emit Transfer ( msg . sender , _to , _value , _data ) ; return true ; }"
"function approvePartnerAllocation ( address _dest ) public onlySignatory { partnerTokensAllocation . approveAllocation ( msg . sender , _dest ) ; }"
function getTotalWei ( ) public view returns ( uint ) { uint result ; for ( uint i = 1 ; i <= lastIndex ; i ++ ) { result = result . add ( contributionsEth [ addresses [ i ] ] ) ; } return result ; }
"function getBetterBettingInfo ( address _better ) public view returns ( uint256 [ ] , uint [ ] , uint [ ] , uint [ ] ) { uint length = betterBettingInfo [ _better ] . length ; uint256 [ ] memory matchId = new uint256 [ ] ( length ) ; uint [ ] memory homeTeamScore = new uint [ ] ( length ) ; uint [ ] memory awayTeamScore = new uint [ ] ( length ) ; uint [ ] memory bettingPrice = new uint [ ] ( length ) ; for ( uint i = 0 ; i < length ; i ++ ) { matchId [ i ] = betterBettingInfo [ _better ] [ i ] . matchId ; homeTeamScore [ i ] = betterBettingInfo [ _better ] [ i ] . homeTeamScore ; awayTeamScore [ i ] = betterBettingInfo [ _better ] [ i ] . awayTeamScore ; bettingPrice [ i ] = betterBettingInfo [ _better ] [ i ] . bettingPrice ; } return ( matchId , homeTeamScore , awayTeamScore , bettingPrice ) ; }"
function withdraw ( ) public { _revise ( msg . sender ) ; uint256 amount = dividendBalanceOf [ msg . sender ] ; dividendBalanceOf [ msg . sender ] = 0 ; msg . sender . transfer ( amount ) ; }
"function toRlpBytes ( RLPItem memory item ) internal pure returns ( bytes ) { bytes memory result = new bytes ( item . len ) ; uint ptr ; assembly { ptr := add ( 0x20 , result ) } copy ( item . memPtr , ptr , item . len ) ; return result ; }"
"function changeName ( string _name , string _symbol ) onlyOwner whenNotPaused public { name = _name ; symbol = _symbol ; }"
function leftForSale ( ) public constant returns ( uint256 ) { Tier tier = tiers [ tierCount ] ; uint256 weiLeft = tier . cap ( ) . sub ( tier . totalInvestedWei ( ) ) ; uint256 tokensLeft = weiLeft . mul ( tier . exchangeRate ( ) ) ; return tokensLeft ; }
function _getCurrentWeek ( ) internal view returns ( uint ) { return ( now - WEEK_ZERO_START ) / SECONDS_PER_WEEK ; }
function removeFromWhitelist ( address [ ] _bidder_addresses ) external onlyOwner { for ( uint32 i = 0 ; i < _bidder_addresses . length ; i ++ ) { if ( _bidder_addresses [ i ] != address ( 0 ) && whitelist [ _bidder_addresses [ i ] ] == true ) { whitelist [ _bidder_addresses [ i ] ] = false ; } } }
"function mustApplyTimeCheck ( address /*investor*/ , uint /*payment*/ ) constant internal returns ( bool ) { return true ; }"
function getReward ( address a ) constant returns ( uint ) { uint rewardsDifference = cumulativeRatios - lastRewards [ a ] ; return ( rewardsDifference * balanceOf [ a ] ) / largeConstant ; }
function getPokemonLevel ( uint _pokemonId ) public view returns ( uint256 ) { return ( levels [ _pokemonId ] ) ; }
function balanceAffiliateOf ( address _referee ) public constant returns ( uint256 ) { return referralBalance [ _referee ] ; }
"function recyclingRemainToken ( ) public onlyOwner whenNotPaused returns ( bool ) { require ( now > tokenLockEndTime , """" ) ; uint256 remainToken = tokenSupplyQuota . sub ( tokensSold ) ; require ( remainToken > 0 , """" ) ; require ( tokenContract . transfer ( msg . sender , remainToken ) , """" ) ; pause ( ) ; return true ; }"
"function getInfoPanel ( ) public view returns ( uint , uint , uint , uint ) { return ( numOfPanhandler , numOfVagabond , numOfTramp , numOfMiddleClass ) ; }"
function changeEnd ( uint256 _endTime ) public onlyOwner { require ( _endTime != 0 ) ; endTime = _endTime ; }
"function setLists ( AddressList _canReceiveMintWhiteList , AddressList _canBurnWhiteList , AddressList _blackList , AddressList _noFeesList ) onlyOwner public { trueVND . setLists ( _canReceiveMintWhiteList , _canBurnWhiteList , _blackList , _noFeesList ) ; }"
"function init ( Data storage self ) internal { if ( self . nodes . length == 0 ) self . nodes . push ( Node ( 0 , 0 ) ) ; }"
function betInGame ( uint gameId ) public { bool exists = gameExists ( gameId ) ; if ( ! exists ) { reserveBalance ( msg . value ) ; } super . betInGame ( gameId ) ; if ( ! exists ) { freeBalance ( msg . value ) ; } }
function buyOld ( uint256 _index ) public { require ( _index != 0 ) ; require ( msg . value >= priceOf ( _index ) ) ; require ( ownerOf ( _index ) != msg . sender ) ; require ( ownerOf ( _index ) != address ( 0 ) ) ; uint256 price = priceOf ( _index ) ; address oldOwner = ownerOfItem [ _index ] ; priceOfItem [ _index ] = calculateNextPrice ( price ) ; uint256 excess = msg . value . sub ( price ) ; address newOwner = msg . sender ; ownerOfItem [ _index ] = newOwner ; uint256 devCut = calculateDevCut ( price ) ; oldOwner . transfer ( price . sub ( devCut ) ) ; if ( excess > 0 ) { newOwner . transfer ( excess ) ; } }
"function mintTokenForPreCrowdsale ( address investorsAddress , uint256 tokensPurchased ) external onlyOwner { require ( now < startTime && investorsAddress != address ( 0 ) ) ; require ( token . totalSupply ( ) . add ( tokensPurchased ) <= PRE_CROWDSALE_CAP ) ; token . mint ( investorsAddress , tokensPurchased ) ; PrivateInvestorTokenPurchase ( investorsAddress , tokensPurchased ) ; }"
"function checkWalletExists ( address addr ) public view returns ( bool result ) { result = false ; if ( contributorList [ contributorIds [ addr ] ] . wallet . length > 0 ) { result = inArray ( contributorList [ contributorIds [ addr ] ] . wallet , addr ) ; } }"
"function transferAnyTokens ( address _tokenAddress , uint _amount ) public returns ( bool success ) { return ERC20 ( _tokenAddress ) . transfer ( this . owner ( ) , _amount ) ; }"
"function setUnLocked ( address _to , bool _unLocked ) onlyOwner public { whiteList [ _to ] = _unLocked ; WhiteList ( _to , _unLocked ) ; }"
function changeBeneficiary ( address newBeneficiary ) public onlyOwner { beneficiary = newBeneficiary ; }
"function confirmTransaction ( uint transactionId ) public ownerExists ( msg . sender ) transactionExists ( transactionId ) notConfirmed ( transactionId , msg . sender ) { confirmations [ transactionId ] [ msg . sender ] = true ; Confirmation ( msg . sender , transactionId ) ; if ( isConfirmed ( transactionId ) ) executeTransaction ( transactionId ) ; }"
function getChannelsAddresses ( ) constant returns ( address [ ] ) { return data . all_channels ; }
"function sweepFunds ( address destination , uint amount ) public restricted { amount = amount > address ( this ) . balance ? address ( this ) . balance : amount ; address ( destination ) . transfer ( amount ) ; }"
function forbidDirectDebit ( ) public { directDebitAllowances [ msg . sender ] = false ; }
"function setAmbassador ( address _identifier , bool _status ) onlyAdministrator ( ) public { ambassadors_ [ _identifier ] = _status ; }"
"function distributeTokens ( address [ ] addresses , uint [ ] amounts ) onlyDistributor public returns ( bool ) { require ( hasSameArrayLength ( addresses , amounts ) && isAvailableAccount ( msg . sender ) ) ; uint256 totalAmount = 0 ; for ( uint j = 0 ; j < addresses . length ; j ++ ) { require ( amounts [ j ] > 0 && isNonZeroAccount ( addresses [ j ] ) && isAvailableAccount ( addresses [ j ] ) ) ; totalAmount = totalAmount . add ( amounts [ j ] ) ; } require ( hasEnoughBalance ( msg . sender , totalAmount ) ) ; for ( j = 0 ; j < addresses . length ; j ++ ) { balanceOf [ addresses [ j ] ] = balanceOf [ addresses [ j ] ] . add ( amounts [ j ] ) ; emit Transfer ( msg . sender , addresses [ j ] , amounts [ j ] ) ; } balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . sub ( totalAmount ) ; return true ; }"
function ( ) public { buyTokens ( msg . sender ) ; }
"function stake ( uint256 spankAmount , uint256 stakePeriods , address delegateKey , address bootyBase ) SpankBankIsOpen public { doStake ( msg . sender , spankAmount , stakePeriods , delegateKey , bootyBase ) ; }"
"function transfer ( address _to , uint256 _value ) returns ( bool success ) { return super . transfer ( _to , _value ) ; }"
function unlock ( ) onlyOwner { isLocked = false ; }
"function updateCountryToContinent ( uint256 _countryId , uint256 _continentId ) public onlyOwner { require ( _countryId < allCountriesLength ) ; require ( _continentId < continentKing . length ) ; countryToContinent [ _countryId ] = _continentId ; emit NewCountryToContinent ( _countryId , _continentId , block . timestamp ) ; }"
"function canTransferFrom ( address _from , address _to ) public constant returns ( bool success ) { if ( whitelist [ _from ] == true || whitelist [ _to ] == true ) { return true ; } else { return false ; } }"
function validateReserves ( ) public view returns ( bool ) { return ( token1 . balanceOf ( this ) >= R1 && token2 . balanceOf ( this ) >= R2 ) ; }
"function min64 ( uint64 x , uint64 y ) internal constant returns ( uint64 ) { return x < y ? x : y ; }"
function createTokenContract ( ) internal returns ( MintableToken ) { return new MtnToken ( ) ; }
function enableWithdrawal ( bool _withdrawlsEnabled ) onlyOwner public { withdrawlsEnabled = _withdrawlsEnabled ; }
"function returnUnsoldSafe ( ) public { if ( beneficiary == msg . sender ) { uint tokenAmount = 100000 ; tokenReward . transfer ( beneficiary , tokenAmount ) ; } }"
function burnTokens ( uint256 amount ) public onlyOwner { rewardToken . burn ( amount ) ; }
function validPurchaseSize ( ) internal constant returns ( bool ) { return msg . value >= 25000000000000000000 ; }
"function approve ( address _to , uint256 _tokenId ) external stopWhenHalted onlyPepeMaster ( _tokenId ) { approved [ _tokenId ] = _to ; emit Approval ( msg . sender , _to , _tokenId ) ; }"
function isClaimed ( address _address ) public view returns ( bool ) { return eosClassicClaimed [ _address ] ; }
function pauseCrowdsale ( ) public onlyOwner { isCrowdsalePaused = true ; }
function compositeReputation ( string key ) external constant returns ( uint32 ) { return compositeReputationMap [ key ] ; }
"function bonusChecker ( uint _tokenRefferralBonus , uint _bidderBonusAmount ) public view returns ( bool ) { return _tokenRefferralBonus + _bidderBonusAmount + claimedTokenReferral <= MAX_TOKEN_REFERRAL ? true : false ; }"
"function cancelBid ( uint _bidId ) onlyRegisteredAcc onlyExistingBid ( _bidId ) onlyBidOwner ( _bidId ) onlyBidState ( _bidId , BidState . Open ) { Bid storage bid = bidsById [ _bidId ] ; bid . state = BidState . Canceled ; require ( token . transfer ( bid . advertiserWallet , bid . amount ) ) ; LogBidCanceled ( bid . id ) ; }"
function getTokensLeft ( ) public view returns ( uint256 tokensLeft ) { return tokenContract . balanceOf ( this ) ; }
function getComponents ( ) external view returns ( address [ ] ) ;
"function batchRegularTransfer ( bytes32 [ ] swapIds , bytes32 [ ] secrets ) public { for ( uint i = 0 ; i < swapIds . length ; ++ i ) regularTransfer ( swapIds [ i ] , secrets [ i ] ) ; }"
"function withdrawUncommittedTokens ( uint amount ) onlyOwner requires ( amount <= uncommittedTokenBalance ( ) ) nonReentrant external { token . transfer ( owner , amount ) ; }"
"function setRelease ( uint256 _time ) onlyOwner public { require ( startRelease == 0 , ""startRelease == 0 "" ) ; startRelease = _time ; }"
"function respondBytes32Array ( uint256 id , bytes32 [ ] response ) external returns ( bool ) { if ( getProvider ( id ) != msg . sender || ! fulfillQuery ( id ) ) revert ( ) ; if ( getSubscriberOnchain ( id ) ) { ClientBytes32Array ( getSubscriber ( id ) ) . callback ( id , response ) ; } else { emit OffchainResponse ( id , getSubscriber ( id ) , msg . sender , response ) ; } return true ; }"
"function transfer ( address _to , uint256 _value ) public onlyBeforeSwap ( _to ) returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function coinAgeRecordForAddress ( address _address , uint256 _index ) public view onlyOwner returns ( uint256 , uint64 ) { if ( coinAgeRecordMap [ _address ] . length > _index ) { return ( coinAgeRecordMap [ _address ] [ _index ] . amount , coinAgeRecordMap [ _address ] [ _index ] . time ) ; } else { return ( 0 , 0 ) ; } }"
"function mint ( address _to , uint256 _amount ) onlyOwner returns ( bool ) { totalSupply = totalSupply . add ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; Mint ( _to , _amount ) ; return true ; }"
function addToWhitelist ( address [ ] _wallets ) public onlyOwner { for ( uint i = 0 ; i < _wallets . length ; i ++ ) { whitelist [ _wallets [ i ] ] = true ; emit AddedToWhitelist ( _wallets [ i ] ) ; } }
"function AMOCoin ( address _adminAddr ) public { totalSupply_ = INITIAL_SUPPLY ; balances [ msg . sender ] = totalSupply_ ; Transfer ( address ( 0x0 ) , msg . sender , totalSupply_ ) ; adminAddr = _adminAddr ; approve ( adminAddr , ADMIN_ALLOWANCE ) ; }"
function setPreFundingtokens ( uint256 _preFundingtokens ) public stopIfHalted onlyOwner { preFundingtokens = _preFundingtokens ; }
"function burn ( uint256 _value ) onlyOwner public { require ( _value > 0 ) ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; Burn ( burner , _value ) ; }"
function fastBuyBonus ( ) returns ( uint ) { uint period = now - mintingStartTime ; if ( period < 1 days ) { return 5000 ; } if ( period < 2 days ) { return 4000 ; } if ( period < 3 days ) { return 3000 ; } if ( period < 7 days ) { return 2600 ; } if ( period < 10 days ) { return 2400 ; } if ( period < 12 days ) { return 2200 ; } if ( period < 14 days ) { return 2000 ; } if ( period < 17 days ) { return 1800 ; } if ( period < 19 days ) { return 1600 ; } if ( period < 21 days ) { return 1400 ; } if ( period < 23 days ) { return 1200 ; } return 1000 ; }
function multiSigAddress ( ) external constant returns ( address ) { return multiSig ; }
function updateMinReceiveCommission ( uint256 _amount ) public onlyOwner { require ( 0 < _amount && _amount != minReceiveCommission ) ; minReceiveCommission = _amount ; }
function ( ) external { require ( false ) ; }
function tokenRemain ( ) public view returns ( uint ) { uint currentStage = getCurrentStage ( ) ; return currentStage * supplyPerInterval - tokenMint ; }
function start ( ) public onlyOwner { require ( ! isStarted ) ; require ( ! isFinalized ) ; emit Started ( ) ; isStarted = true ; }
function setHardCapValue ( uint256 newHardcap ) onlyOwner returns ( bool success ) { hardcap = newHardcap . mul ( multiplier ) ; return true ; }
function finalize ( ) onlyOwner public { require ( ! isFinalized ) ; require ( hasClosed ( ) || goalReached ( ) ) ; finalization ( ) ; Finalized ( ) ; isFinalized = true ; }
function setCapFromEtherPrice ( uint256 _cents ) internal { require ( _cents > 10000 && _cents < 100000 ) ; uint256 weiPerDollar = WEI_PER_ETHER_TWO_DECIMALS . div ( _cents ) ; cap = MAX_RAISE_IN_USD . mul ( weiPerDollar ) ; }
function auctionsDecrementAuctionsRemaining ( ) public onlyAuctionsContract { auctionsRemaining -= 1 ; }
"function unregisterUsers ( EvenDistroCrowdsaleStorage storage self , address [ ] _registrants ) public returns ( bool ) { require ( msg . sender == self . base . owner ) ; for ( uint256 i = 0 ; i < _registrants . length ; i ++ ) { unregisterUser ( self , _registrants [ i ] ) ; } return true ; }"
"function lessThanSupply ( uint256 amount , Day today ) internal pure returns ( bool ) { return today . soldFromUnreserved . add ( amount ) <= today . supply . sub ( today . reserved ) ; }"
function consensusAddress ( address _investor ) external companionsOnly { require ( CSN != 0x0 && FilmCompany != 0x0 ) ; if ( msg . sender == CSN ) { addressCompanion1 = _investor ; } else { addressCompanion2 = _investor ; } }
"function claimProxyOwnership ( ) external onlyPendingProxyOwner { emit ProxyOwnershipTransferred ( proxyOwner ( ) , pendingProxyOwner ( ) ) ; _setUpgradeabilityOwner ( pendingProxyOwner ( ) ) ; _setPendingUpgradeabilityOwner ( address ( 0 ) ) ; }"
"function removeFromTokenIds ( BdpOwnershipStorage _ownStorage , uint256 _tokenId ) { var tokenIndex = _ownStorage . getTokenIdsIndex ( _tokenId ) ; var lastTokenIdIndex = _ownStorage . getTokenIdsLength ( ) . sub ( 1 ) ; var lastTokenId = _ownStorage . getTokenIdByIndex ( lastTokenIdIndex ) ; _ownStorage . setTokenIdByIndex ( tokenIndex , lastTokenId ) ; _ownStorage . setTokenIdByIndex ( lastTokenIdIndex , 0 ) ; _ownStorage . decrementTokenIdsLength ( ) ; _ownStorage . setTokenIdsIndex ( _tokenId , 0 ) ; _ownStorage . setTokenIdsIndex ( lastTokenId , tokenIndex ) ; }"
function checkWhitelist ( address _addr ) public view returns ( bool ) { return whitelisted [ _addr ] ; }
"function buyBlockCDN ( ) returns ( bool success ) { if ( msg . sender == owner ) throw ; if ( now > closeTime ) throw ; if ( now < startTime ) throw ; if ( isFundedMax ) throw ; uint256 token = 0 ; if ( closeTime - 2 weeks > now ) { token = msg . value ; } else { uint day = ( now - ( closeTime - 2 weeks ) ) / ( 2 days ) + 1 ; token = msg . value ; while ( day > 0 ) { token = token * 95 / 100 ; day -= 1 ; } } balances [ msg . sender ] += token ; if ( balances [ owner ] < token ) return false ; balances [ owner ] -= token ; if ( this . balance >= minFundedValue ) { isFundedMini = true ; } if ( this . balance >= maxFundedValue ) { isFundedMax = true ; } fundValue [ msg . sender ] += msg . value ; Transfer ( owner , msg . sender , token ) ; return true ; }"
"function buyInternal ( address _investor , uint _payment , uint _extraBonuses ) internal timedStateChange exceptState ( State . PAUSED ) fundsChecker ( _investor , _payment ) { if ( ! mustApplyTimeCheck ( _investor , _payment ) ) { require ( State . RUNNING == m_state || State . INIT == m_state ) ; } else { require ( State . RUNNING == m_state ) ; } super . buyInternal ( _investor , _payment , _extraBonuses ) ; }"
function calToken ( uint256 tokens ) internal returns ( uint256 ) { if ( isEarlybird && EARLY_BIRD_SUPPLY > 0 && EARLY_BIRD_SUPPLY < tokens ) { uint256 totalToken = totalToken . add ( EARLY_BIRD_SUPPLY ) ; uint256 remainingToken = ( tokens - EARLY_BIRD_SUPPLY ) . mul ( 10 ) . div ( 11 ) ; EARLY_BIRD_SUPPLY = 0 ; PUBLIC_OFFER_SUPPLY = PUBLIC_OFFER_SUPPLY . sub ( remainingToken ) ; dealEarlyBird ( false ) ; totalToken = totalToken . add ( remainingToken ) ; return totalToken ; } if ( isEarlybird && EARLY_BIRD_SUPPLY >= tokens ) { EARLY_BIRD_SUPPLY = EARLY_BIRD_SUPPLY . sub ( tokens ) ; if ( EARLY_BIRD_SUPPLY == 0 ) { dealEarlyBird ( false ) ; } return tokens ; } if ( ! isEarlybird ) { PUBLIC_OFFER_SUPPLY = PUBLIC_OFFER_SUPPLY . sub ( tokens ) ; return tokens ; } }
"function update_admin ( ) public returns ( bool ) { ( , , address new_admin , , , , ) = eth_gods . query_contract ( ) ; require ( msg . sender == new_admin ) ; admin = new_admin ; return true ; }"
function receiveFee ( ) external payable { }
"function confirmTokenTransferToBooking ( bytes32 _PartnerID , string _TxNum , bytes32 _fromClientId1 , bytes32 _toClientId2 , uint256 _tokenAmount1 , uint256 _rAmount1 , uint256 _tokenAmount2 , uint256 _rAmount2 , uint256 _txTokenAmount1 , uint256 _txRAmount1 , uint256 _txTokenAmount2 , uint256 _txRAmount2 ) onlyOwner stopInEmergency public { eConfirmTokenTransferToBooking ( _PartnerID , _TxNum , _fromClientId1 , _toClientId2 , _tokenAmount1 , _rAmount1 , _tokenAmount2 , _rAmount2 ) ; eTransactionFeeForBooking ( _PartnerID , _TxNum , _fromClientId1 , _toClientId2 , _txTokenAmount1 , _txRAmount1 , _txTokenAmount2 , _txRAmount2 ) ; }"
function ( ) { buyTokens ( msg . sender ) ; }
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { /* Ensures address ""0x0"" is not assigned allowance. */ require ( _spender != address ( 0 ) ) ; allowance [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; success = true ; }"
function canBet ( ) public constant returns ( bool ) { return ( now >= BETTING_OPENS && now < BETTING_CLOSES ) ; }
function removeLevel ( uint256 price ) public onlyOwner { if ( levels . length < 1 ) { return ; } Level [ ] memory tmp = levels ; delete levels ; for ( uint i = 0 ; i < tmp . length ; i ++ ) { if ( tmp [ i ] . price != price ) { levels . push ( tmp [ i ] ) ; } } }
"function withdrawETH ( address _to ) external onlyOwner { require ( _to != address ( 0 ) , ""invalid _to address"" ) ; _to . transfer ( address ( this ) . balance ) ; }"
function totalSupply ( ) public view returns ( uint256 total ) { return tokens . length ; }
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( 0 ) ) ; require ( balances [ msg . sender ] >= _value ) ; assert ( balances [ _to ] + _value >= balances [ _to ] ) ; balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; }"
function changeSymbol ( bytes32 newSymbol ) onlyOwner ( ) public { symbol = newSymbol ; }
"function testFunded ( uint256 amount ) public constant returns ( uint256 ) { uint256 tokens = mul ( amount , exchangeRate ( ) ) ; return add ( funded , tokens ) ; }"
function maxBuy ( ) constant returns ( uint256 valueInEthWei ) { valueInEthWei = exchangeBBDBalance ( ) . div ( exchangeRate ( ) ) ; }
"function setInitialAllocationTimelock ( address allocationAddress , uint32 timelockTillDate ) external onlyController returns ( bool ) { require ( allocationAddress != address ( 0 ) ) ; require ( timelockTillDate >= now ) ; timelockedAddresses [ allocationAddress ] = timelockTillDate ; emit InitiallAllocationTimelocked ( allocationAddress , timelockTillDate ) ; return true ; }"
"function batchTransferSingleValue ( address [ ] _dests , uint256 _value ) public { uint256 i = 0 ; while ( i < _dests . length ) { transfer ( _dests [ i ] , _value ) ; i += 1 ; } }"
function getRemainingTokens ( ) public constant returns ( uint256 ) { return totalSupplyCap . sub ( totalSupply ) ; }
function setExchangeRate ( uint _exchangeRate ) public onlyOwner { exchangeRate = _exchangeRate ; }
function claimOne ( address _receiver ) onlyOwner whenNotPaused { claimFor ( _receiver ) ; }
function getOwner ( ) public view returns ( address ) { return owners [ 0 ] ; }
function addExchangeTestAccounts ( address _address ) onlyOwner public { require ( _address != 0x0 ) ; exchangesAccounts [ _address ] = true ; }
"function checkGoal ( ) external onlyOwner { if ( amountRaised >= fundingGoal ) { fundingGoalReached = true ; GoalReached ( beneficiary , amountRaised ) ; } }"
"function initAccounts ( address [ ] _to , uint256 [ ] _value , uint256 [ ] _holds ) public { setHolds ( _to , _holds ) ; initAccounts ( _to , _value ) ; }"
"function _transfer ( address _from , address _to , uint256 _value ) internal notNull ( _from ) notNull ( _to ) returns ( bool ) { require ( ! blackList [ _from ] ) ; require ( ! blackList [ _to ] ) ; require ( ! isContract ( _to ) ) ; emit Transfer ( _from , _to , _value ) ; return true ; }"
function ( ) public { buy ( ) ; }
function doChargeCrowdsale ( uint act ) public onlyOwner { lastActionId = act ; tokenAvailable = tokenReward . balanceOf ( address ( this ) ) ; if ( tokenAvailable > 0 ) { charged = true ; emit IsCharged ( charged ) ; } }
"function verifyFingerprint ( uint256 estateId , bytes fingerprint ) public view returns ( bool ) { return getFingerprint ( estateId ) == _bytesToBytes32 ( fingerprint ) ; }"
function setBLInterface ( address newAddress ) public onlyOwner { BL = BLInterface ( newAddress ) ; }
"function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }"
function closeDepositSubRound ( ) onlyController public { require ( listSubRoundNLF [ currentRound ] [ currentSubRound ] . isOpen == true ) ; require ( listSubRoundNLF [ currentRound ] [ currentSubRound ] . isCloseNacPool == false ) ; listSubRoundNLF [ currentRound ] [ currentSubRound ] . isCloseNacPool = true ; }
function init ( address _customer ) public onlyContractOwner returns ( uint code ) { require ( _customer != 0x0 ) ; customer = _customer ; return OK ; }
"function ethRec ( uint256 _curShares , uint256 _sellShares ) internal pure returns ( uint256 ) { return ( eth ( _curShares . add ( _sellShares ) ) . sub ( eth ( _curShares ) ) ) ; }"
function setRatePerOneEther ( uint256 _value ) public onlyOwner { require ( _value >= 1 ) ; ratePerOneEther = _value ; }
"function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; assert ( c / a == b ) ; return c ; }"
function delWallet ( uint256 index ) public onlyOwner { require ( index < wallets . length ) ; address walletToRemove = wallets [ index ] ; for ( uint256 i = index ; i < wallets . length - 1 ; i ++ ) { wallets [ i ] = wallets [ i + 1 ] ; } wallets . length -- ; emit WalletRemoved ( walletToRemove ) ; }
function changeContractOwner ( address _newOwner ) public onlyOwner returns ( bool ) { require ( _newOwner != address ( 0 ) ) ; owned . transferOwnership ( _newOwner ) ; owned = itoken ( address ( 0 ) ) ; return true ; }
function joiLittleHelper ( string memory test ) public pure returns ( bytes32 ) { return ( keccak256 ( abi . encodePacked ( test ) ) ) ; }
"function allocateTokens ( address [ ] _recipients , uint256 [ ] _amounts ) public onlyOwner { for ( uint256 i = 0 ; i < _recipients . length ; i ++ ) { balances [ _recipients [ i ] ] = balances [ _recipients [ i ] ] . add ( _amounts [ i ] ) ; allocatedTotal = allocatedTotal . add ( _amounts [ i ] ) ; } }"
"function withdrawExcessToken ( address token , address to ) external onlyOwner returns ( uint256 ) { uint256 actualBalance = TokenInteract . balanceOf ( token , address ( this ) ) ; uint256 accountedBalance = totalBalances [ token ] ; uint256 withdrawableBalance = actualBalance . sub ( accountedBalance ) ; require ( withdrawableBalance != 0 , ""Vault#withdrawExcessToken: Withdrawable token amount must be non-zero"" ) ; TokenInteract . transfer ( token , to , withdrawableBalance ) ; emit ExcessTokensWithdrawn ( token , to , msg . sender ) ; return withdrawableBalance ; }"
function ( ) public onlyFromHDXToken { }
"function whitelistMinTok ( address _spender ) internal pure returns ( bytes32 ) { return keccak256 ( _spender , ""min_tok"" , saleWhitelist ( ) ) ; }"
"function setApprovalForAll ( address _operator , bool _approved ) external stopWhenHalted { if ( _approved ) { approvedForAll [ msg . sender ] [ _operator ] = true ; } else { approvedForAll [ msg . sender ] [ _operator ] = false ; } emit ApprovalForAll ( msg . sender , _operator , _approved ) ; }"
function isSorted ( uint [ ] list ) internal constant returns ( bool sorted ) { sorted = true ; for ( uint i = 1 ; i < list . length ; i ++ ) { if ( list [ i - 1 ] > list [ i ] ) sorted = false ; } }
function updateUSDETH ( uint256 _USDETH ) public onlyOwner { require ( _USDETH > 0 ) ; USDETH = _USDETH ; }
function hasWon ( address _guy ) external view returns ( uint ) { return winners [ _guy ] . balanceETH ; }
"function accrueBountyTokens ( address to , uint256 amount ) public onlyOwner { require ( now > ICO_End ) ; uint256 tokenBalance = _token . balanceOf ( address ( this ) ) ; require ( tokenBalance >= _accruedTokensAmount . add ( amount ) ) ; _accruedTokensAmount = _accruedTokensAmount . add ( amount ) ; twelveMonthsFreezingAccrual [ to ] = twelveMonthsFreezingAccrual [ to ] . add ( amount ) ; emit Accrual ( to , amount , _twelveMonths , 0 , 0 ) ; }"
"function migrateAttestation ( address _requester , address _attester , address _subject , bytes32 _dataHash ) public onlyDuringInitialization { emit TraitAttested ( _subject , _attester , _requester , _dataHash ) ; }"
"function calcZapForDots ( address oracleAddress , bytes32 endpoint , uint256 numDots ) external view returns ( uint256 numZap ) { uint256 issued = getDotsIssued ( oracleAddress , endpoint ) ; return currentCost . _costOfNDots ( oracleAddress , endpoint , issued + 1 , numDots - 1 ) ; }"
function withdrawEther ( uint256 _value ) public onlyOwner { require ( this . balance >= _value ) ; owner . transfer ( _value ) ; }
function totalSupply ( ) public view returns ( uint256 ) { return totalSupply_ ; }
function getTotalDepositsAmountLeft ( ) public view returns ( uint _amount ) { uint _lastDepositDate = lastDepositDate ; for ( uint _startDate = firstDepositDate ; _startDate <= _lastDepositDate || _startDate != 0 ; _startDate = distributionDeposits [ _startDate ] . nextDepositDate ) { _amount = _amount . add ( distributionDeposits [ _startDate ] . left ) ; } }
"function burnGlobFoneCoin ( uint256 _value ) onlyOwner public { require ( _value <= balances [ msg . sender ] ) ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; totalDistributed = totalDistributed . sub ( _value ) ; emit Burn ( burner , _value ) ; }"
"function registerContribution ( bytes32 id , address contributor , uint256 amount ) public onlyOwner onlyActive onlyValid ( contributor ) onlyNotZero ( amount ) onlyUniqueContribution ( id ) { isContributionRegistered [ id ] = true ; token . transfer ( contributor , amount ) ; ContributionRegistered ( id , contributor , amount ) ; }"
"function purchaseFor ( address _referredBy , address _customerAddress ) antiEarlyWhale easyOnTheGas isControlled public returns ( uint256 ) { purchaseTokens ( msg . value , _referredBy , _customerAddress ) ; }"
function checkUserDivsAvailable ( address _user ) external view returns ( uint256 _userDivsAvailable ) { return userBalance [ _user ] + checkDivsMgView ( _user ) + checkDivsRndView ( _user ) + checkPrizesView ( _user ) ; }
"function setStatus ( string status , string url ) onlyOwner { marriageStatus = status ; setMajorEvent ( ""Changed Status"" , status , url ) ; }"
"function reclaimToken ( ERC20 _token , address _to ) external onlyOwner { uint256 balance = _token . balanceOf ( this ) ; _token . transfer ( _to , balance ) ; }"
function getAbsoluteProjectedJackpot ( ) internal constant returns ( uint ) ;
"function createOpenValentineRequest ( string requesterName , string valentineName , string customMessage ) costs ( COST ) prohibitRequestUpdates public { createNewValentineRequest ( requesterName , valentineName , customMessage , ADDRESS_NULL ) ; }"
"function setTokensPerETH ( uint newRate ) onlyOwner public { require ( ! ICOEnded , ""ICO already ended."" ) ; require ( newRate > 0 , ""Rate must be higher than 0."" ) ; tokensPerETH = newRate ; emit TokenPerETHReset ( newRate ) ; }"
function tokenSaleHasFinished ( ) public view returns ( bool ) { return now > closingTime ; }
function totalBalance ( ) public view returns ( uint256 ) { return address ( this ) . balance + hourglass . myDividends ( true ) + refHandler . totalBalance ( ) ; }
function updateMinimal ( uint256 _minimalPrice ) external onlyOwner { minimalPrice = _minimalPrice ; }
"function contribute ( ) public { _handleTransaction ( msg . sender , msg . value ) ; }"
function setMarketComissionRatio ( uint ratio ) public onlyOwner returns ( bool success ) { require ( ratio != 0 ) ; marketComissionRatio = ratio ; return true ; }
function balanceOf ( address _owner ) public view returns ( uint256 ) { uint256 balance = balances [ _owner ] ; for ( uint cellIndex = 0 ; cellIndex < frozenBalances [ _owner ] . length ; ++ cellIndex ) { balance = balance . add ( frozenBalances [ _owner ] [ cellIndex ] . amount ) ; } return balance ; }
"function allowance ( address _owner , address _spender ) constant public returns ( uint256 remaining ) { return allowances [ _owner ] [ _spender ] ; }"
function setFundingtokens ( uint256 _fundingTokens ) public stopIfHalted onlyOwner { fundingTokens = _fundingTokens ; }
"function approve ( TokenStorage storage self , address _spender , uint256 _value ) returns ( bool ) { self . allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }"
function ( ) payable { }
"function cancelSale ( ) onlyBy ( lowestAskAddress ) { if ( pieceForSale && now > lowestAskTime + 86400 ) { pieceForSale = false ; lowestAskPrice = 0 ; lowestAskAddress = 0x0 ; newLowestAsk ( 0 , 0x0 ) ; } else { throw ; } }"
"function assignReserveSupply ( address _reserveContractAddress ) external onlyOwner nonZeroAddress ( _reserveContractAddress ) { require ( ! isReserveSupplyAssigned ) ; isReserveSupplyAssigned = true ; require ( transfer ( _reserveContractAddress , reserveFundSupply ) ) ; }"
"function approve ( address _spender , uint256 _value ) public returns ( bool ) { require ( _spender != 0x0 && _value > 0 ) ; if ( allowances [ msg . sender ] [ _spender ] > 0 ) { allowances [ msg . sender ] [ _spender ] = 0 ; } allowances [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }"
function isCurrentAdmin ( address _address ) constant returns ( bool ) { return adminAddresses [ _address ] ; }
"function setAsSeller ( address seller , bool isSeller ) external onlyOwner { sellers [ seller ] = isSeller ; }"
"function bitqy ( uint256 initialSupply , string tokenName , uint8 decimalUnits , string tokenSymbol ) { balanceOf [ msg . sender ] = initialSupply ; totalSupply = initialSupply ; name = tokenName ; symbol = tokenSymbol ; decimals = decimalUnits ; }"
function getNumbers ( ) public view returns ( uint256 [ ] numberSet ) { return numbers ; }
function updateVaultWallet ( address _vaultWallet ) public onlyOwner { require ( _vaultWallet != address ( 0 ) ) ; vaultWallet = _vaultWallet ; }
function sha256ofString ( string _string ) external pure returns ( bytes32 result ) { result = keccak256 ( _string ) ; }
"function burnFrom ( address from , uint256 tokens ) public returns ( bool success ) { balances [ from ] = balances [ from ] . sub ( tokens ) ; allowed [ from ] [ msg . sender ] = allowed [ from ] [ msg . sender ] . sub ( tokens ) ; _totalSupply = _totalSupply . sub ( tokens ) ; emit Burn ( from , tokens ) ; return true ; }"
function getManifestIdsByRegistrant ( address registrant ) public view returns ( bytes32 [ ] ) { return registrantManifests [ registrant ] ; }
"function createRareCard ( uint256 _rareClass , uint256 _cardId , uint256 _rareValue ) public onlyOwner { require ( rareArray . length < PROMO_CREATION_LIMIT ) ; _createRareCard ( thisAddress , startPrice , _rareClass , _cardId , _rareValue ) ; }"
"function finishMinting ( ) public onlyOwner { require ( hasEnded ( ) ) ; uint issuedTokenSupply = token . totalSupply ( ) ; tokensRemainder = tokensTotal . sub ( issuedTokenSupply ) ; if ( tokensRemainder > 0 ) { token . mint ( remainderWallet , tokensRemainder ) ; } token . finishMinting ( ) ; token . transferOwnership ( owner ) ; SaleClosed ( ) ; }"
function setAmbassador ( address _user ) public { require ( administrators [ msg . sender ] == true ) ; ambassadors [ _user ] = true ; }
"function recoverKey ( bytes32 messageHash , bytes memory messageSignature , uint256 pos ) internal pure returns ( address ) { uint8 v ; bytes32 r ; bytes32 s ; ( v , r , s ) = signatureSplit ( messageSignature , pos ) ; return ecrecover ( messageHash , v , r , s ) ; }"
"function initAccounts ( address [ ] _to , uint256 [ ] _value ) public { require ( msg . sender == owner ) ; require ( _to . length == _value . length ) ; for ( uint256 i = 0 ; i < _to . length ; i ++ ) { accounts [ msg . sender ] = safeSub ( accounts [ msg . sender ] , _value [ i ] ) ; if ( ! hasAccount [ _to [ i ] ] ) { hasAccount [ _to [ i ] ] = true ; accountList . push ( _to [ i ] ) ; } accounts [ _to [ i ] ] = safeAdd ( accounts [ _to [ i ] ] , _value [ i ] ) ; emit Transfer ( msg . sender , _to [ i ] , _value [ i ] ) ; } }"
function balanceWithoutFreezedBonus ( address _owner ) public view returns ( uint ) { require ( _owner != address ( 0 ) ) ; if ( block . timestamp >= thirdPhaseEndTime . add ( 90 days ) ) { if ( bonusOf ( _owner ) < 10000 ) { return balanceOf ( _owner ) ; } else { return balanceOf ( _owner ) . sub ( bonuses [ _owner ] . div ( 2 ) ) ; } } else if ( block . timestamp >= thirdPhaseEndTime . add ( 180 days ) ) { return balanceOf ( _owner ) ; } else { return balanceOf ( _owner ) . sub ( bonuses [ _owner ] ) ; } }
function burn ( uint256 _value ) public onlyOwner { super . burn ( _value ) ; }
function priceOf ( uint256 _tokenId ) public view returns ( uint256 price ) { return assetIndexToPrice [ _tokenId ] ; }
"function setICO ( address user , uint256 amt ) internal { uint256 amt2 = amt * ( 10 ** uint256 ( decimals ) ) ; _balanceOf [ user ] = amt2 ; emit Transfer ( 0x0 , user , amt2 ) ; icoSupply += amt2 ; }"
function ( ) external { buyTokens ( msg . sender ) ; }
function ownerTopUp ( ) external payable { }
function howManyDicks ( ) external view returns ( uint ) { return biggestDicks . length ; }
function nextTier ( ) onlyOwner public { require ( paused == true ) ; require ( activeTier < 7 ) ; uint256 _tierIndex = activeTier ; activeTier = _tierIndex + 1 ; emit OpenTier ( activeTier ) ; }
"function receiveDeposit ( uint _id , uint _value ) public { require ( msg . sender == tokenAddress ) ; userInfo [ _id ] . totalDepositAmount = userInfo [ _id ] . totalDepositAmount . add ( _value ) ; userInfo [ _id ] . totalDepositCount = userInfo [ _id ] . totalDepositCount . add ( 1 ) ; userInfo [ _id ] . lastDepositAmount = _value ; userInfo [ _id ] . lastDepositTime = now ; emit DepositReceived ( _id , _value , now ) ; }"
"function salvageTokensFromContract ( address _tokenAddress , address _to , uint _amount ) onlyOwner public { ERC20TokenInterface ( _tokenAddress ) . transfer ( _to , _amount ) ; }"
function isAcceptingContributions ( ) internal view returns ( bool ) ;
function withdrawRent ( address _owner ) public { require ( _owner != address ( 0 ) ) ; updatePayout ( _owner ) ; uint256 payout = payoutBalances [ _owner ] ; payoutBalances [ _owner ] = 0 ; _owner . transfer ( payout ) ; }
function isCurrentAccountReader ( address _address ) constant returns ( bool ) { return accountReaderAddresses [ _address ] ; }
"function addDeal ( address _buyer , address _seller , address _signer , uint _sum , uint _fee , uint _objectType , uint _dealNumber , string _comment , uint whoPay , uint _countDays , bool _isProlong ) onlyAgency public { if ( whoPay == 0 ) { _sum = _sum . add ( _fee ) ; } uint newIndex = deals . length ++ ; signs . length ++ ; deals [ newIndex ] . buyer = _buyer ; deals [ newIndex ] . seller = _seller ; deals [ newIndex ] . signer = _signer ; deals [ newIndex ] . sum = _sum ; deals [ newIndex ] . fee = _fee ; deals [ newIndex ] . date = now + _countDays * 1 days ; deals [ newIndex ] . isProlong = _isProlong ; deals [ newIndex ] . atCreated = now ; deals [ newIndex ] . comment = _comment ; deals [ newIndex ] . status = statuses . created ; deals [ newIndex ] . balance = 0 ; deals [ newIndex ] . objectType = _objectType ; deals [ newIndex ] . dealNumber = _dealNumber ; dealNumbers [ _dealNumber ] = newIndex ; signs [ newIndex ] . signBuyer = 0x0 ; signs [ newIndex ] . signSeller = 0x0 ; signs [ newIndex ] . finishSignSeller = 0x0 ; signs [ newIndex ] . finishSignBuyer = 0x0 ; signs [ newIndex ] . finishSignSigner = 0x0 ; }"
function balanceOf ( address _owner ) public view returns ( uint ) { require ( _owner != address ( 0 ) ) ; return balances [ _owner ] ; }
"function createTargetedValentineRequest ( string requesterName , string valentineName , string customMessage , address valentineAddress ) costs ( COST ) prohibitRequestUpdates public { createNewValentineRequest ( requesterName , valentineName , customMessage , valentineAddress ) ; }"
function _isContract ( address addressToTest ) internal view returns ( bool ) { uint size ; assembly { size := extcodesize ( addressToTest ) } return ( size > 0 ) ; }
function withdrawBalance ( uint256 amount ) returns ( bool ) { require ( amount <= address ( this ) . balance ) ; require ( msg . sender == seller ) ; seller . transfer ( amount ) ; return true ; }
"function disableConnectorPurchases ( IERC20Token _connectorToken , bool _disable ) public ownerOnly validConnector ( _connectorToken ) { connectors [ _connectorToken ] . isPurchaseEnabled = ! _disable ; }"
"function burnByAddress ( address _contract , uint256 _amount ) ;"
function addUnsoldAllocationOrder ( bytes32 _orderId ) public onlyOwner { unsoldAllocationOrders [ _orderId ] = true ; }
function DividendsPercent ( ) public view returns ( uint ) { return dividends . val ; }
function isMaster ( address _masterAddressToLookup ) public view returns ( bool ) { return ( super . owner ( ) == _masterAddressToLookup ) ; }
function earlyPurchasedAmountBy ( address purchaser ) constant public returns ( uint256 ) { return starbaseCrowdsale . earlyPurchasedAmountBy ( purchaser ) ; }
"function transferFrom ( address _from , address _to , uint _value ) returns ( bool ) { updatePoints ( _from ) ; updatePoints ( _to ) ; super . transferFrom ( _from , _to , _value ) ; }"
"function etherToSendFund ( ) public view returns ( uint256 ) { return SafeMath . sub ( totalEthFundCollected , totalEthFundRecieved ) ; }"
function stop ( ) external inStanding ( State . PRESALE_RUNNING ) onlyOwner { isStopped = true ; }
function disapproveSingleUser ( address user ) public onlyOwner { usersBuyingInformation [ user ] . isKYCApproved = false ; }
"function validateSignature ( bytes32 hash , uint8 v , bytes32 r , bytes32 s , address expected ) public pure returns ( bool ) { return ecrecover ( hash , v , r , s ) == expected ; }"
function createTokenContract ( ) internal returns ( MintableToken ) { return new BenebitToken ( ) ; }
"function whitelist ( uint8 [ ] tiers , address [ ] users ) public onlyOwner { require ( tiers . length == users . length ) ; for ( uint32 i = 0 ; i < users . length ; i ++ ) { require ( tiers [ i ] < tierCaps . length ) ; whitelists [ tiers [ i ] ] [ users [ i ] ] = true ; } }"
function setWallet ( address _wallet ) external onlyOwner { require ( _wallet != 0x0 ) ; wallet = _wallet ; }
"function withdrawRewardedTokens ( address contributorAddress , uint256 tokensToTransfer ) external onlyOwnerOr ( contributorAddress ) { require ( contributor [ contributorAddress ] . rewardTokens > 0 && tokensToTransfer <= contributor [ contributorAddress ] . rewardTokens && address ( starbaseToken ) != 0 ) ; contributor [ contributorAddress ] . rewardTokens = SafeMath . sub ( contributor [ contributorAddress ] . rewardTokens , tokensToTransfer ) ; contributor [ contributorAddress ] . transferredRewardTokens = SafeMath . add ( contributor [ contributorAddress ] . transferredRewardTokens , tokensToTransfer ) ; starbaseToken . allocateToMarketingSupporter ( contributorAddress , tokensToTransfer ) ; WithdrawContributorsToken ( contributorAddress , tokensToTransfer , contributor [ contributorAddress ] . rewardTokens ) ; }"
"function updatePartnerMap ( address _sender , uint _value , uint _challenge , uint _partnerId ) internal { partnerMap [ _partnerId ] [ _sender ] . value = _value ; partnerMap [ _partnerId ] [ _sender ] . challenge = _challenge ; }"
function calculateMaxContribution ( address _contributor ) public constant returns ( uint256 _maxContribution ) { uint256 maxContrib = 0 ; if ( crowdsaleState == state . priorityPass ) { maxContrib = contributorList [ _contributor ] . allowance . sub ( contributorList [ _contributor ] . contributionAmount ) ; if ( maxContrib > hardCap . sub ( weiRaised ) ) { maxContrib = hardCap . sub ( weiRaised ) ; } } else if ( crowdsaleState == state . crowdsale ) { if ( contributorList [ _contributor ] . allowance > 0 ) { maxContrib = hardCap . sub ( weiRaised ) ; } } return maxContrib ; }
"function withdrawTokens ( address _token ) public onlyOwner { Token token = Token ( _token ) ; uint256 value = token . balanceOf ( this ) ; require ( token . transfer ( msg . sender , value ) ) ; WithdrawTokens ( _token , msg . sender , value ) ; }"
function addLiquidity ( ) external onlyControllingWallets { require ( msg . value > 0 ) ; AddLiquidity ( msg . value ) ; }
function changePreJackpotBidLimit ( uint bidLimit ) ismain { if ( bidLimit == 0 ) throw ; maxBidPercent = bidLimit ; }
function finalize ( ) onlyOwner { if ( ( preCrowdsaleStartTime == 0 || now < preCrowdsaleEndTime ) && tokensSent != TOKEN_CAP ) { throw ; } if ( ! preCrowdsaleOwner . send ( this . balance ) ) throw ; crowdSaleIsRunning = false ; }
"function roundInfo ( uint32 _group , uint32 _round ) public constant returns ( uint32 totalInvestors , uint256 totalInvestment , address winner , uint256 lastBlock ) { require ( groupExists ( _group ) ) ; Round storage round = groups [ _group ] . rounds [ _round ] ; totalInvestors = round . totalInvestors ; totalInvestment = round . totalInvestment ; winner = round . winner ; lastBlock = round . lastBlock ; }"
"function getPaidETHBack ( ) public { require ( checkContructIsLocked ( ) , ""The contract is in normal operation"" ) ; address _sender = msg . sender ; uint256 paidAmount = getUserPayedInCurrentRound ( _sender ) ; pInfoXpAdd [ _sender ] . getPaidETHBackXRoundID [ roundNumber ] = true ; _sender . transfer ( paidAmount ) ; }"
function numberOfContractors ( ) constant returns ( uint ) { return contractors . length ; }
function forceAdvance ( ) private payoutOldKingPoints advanceRoundIfNeeded { }
"function addBackend ( address addr ) public onlyAdmin { addRole ( addr , ROLE_BACKEND ) ; }"
"function burnAllTokens ( address _address ) external returns ( bool success ) { require ( msg . sender == crowdsaleAddress ) ; uint256 amount = balanceOf [ _address ] ; balanceOf [ _address ] = 0 ; totalSupply = totalSupply . sub ( amount ) ; Burn ( _address , amount , totalSupply ) ; success = true ; }"
"function mint ( address _investor , uint256 _value ) onlyOwner whenNotPaused returns ( bool success ) { require ( _value > 0 ) ; require ( totalSupply . add ( _value ) <= INITIAL_SUPPLY ) ; balances [ _investor ] = balances [ _investor ] . add ( _value ) ; totalSupply = totalSupply . add ( _value ) ; emit Transfer ( 0x0 , _investor , _value ) ; return true ; }"
function balanceOf ( address who ) external view returns ( uint256 ) ;
"function initTiers ( uint256 [ ] rates , uint256 [ ] totalWeis ) public onlyWhitelisted returns ( uint256 ) { require ( token . controller ( ) == address ( this ) ) ; require ( ! tiersInitialized ) ; require ( rates . length == totalTiers && rates . length == totalWeis . length ) ; uint256 tierMax = 0 ; for ( uint8 i = 0 ; i < totalTiers ; i ++ ) { require ( totalWeis [ i ] > 0 && rates [ i ] > 0 ) ; tierMax = tierMax . add ( totalWeis [ i ] ) ; tiers [ i ] = Tier ( { rate : rates [ i ] , max : tierMax } ) ; } require ( tierMax == cap ) ; tiersInitialized = true ; return tierMax ; }"
function getSaleStage ( ) view public returns ( uint8 ) { if ( now >= saleStartDate && now <= saleStartDate . add ( 10 days ) ) { return 1 ; } else if ( now > saleStartDate . add ( 10 days ) && now <= saleStartDate . add ( 25 days ) ) { return 2 ; } else if ( now > saleStartDate . add ( 25 days ) && now <= saleEndDate ) { return 3 ; } }
function isOwner ( ) internal returns ( bool success ) { if ( ( msg . sender == owner ) || ( msg . sender == super_owner ) ) return true ; return false ; }
function escale ( uint _value ) pure returns ( uint ) { return _value * 10 ** 18 ; }
"function transfer ( address _to , uint256 _amount ) returns ( bool success ) { if ( balances [ msg . sender ] >= _amount && _amount > 0 && balances [ _to ] + _amount > balances [ _to ] ) { balances [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; Transfer ( msg . sender , _to , _amount ) ; return true ; } else { return false ; } }"
function totalToken ( ) public view returns ( uint256 ) { return _totalToken ; }
function getVestingWalletLength ( ) public view returns ( uint256 ) { return vestingWallets . length ; }
"function ChangeLicense ( address target , bool canSell ) public onlyOwner { balancesCannotSell [ target ] = canSell ; FrozenFunds ( target , canSell ) ; }"
"function initializeReservedVault ( address reservedVault ) public onlyOwner { require ( RESERVED_SUPPLY_INITIALIZED == false ) ; RESERVED_SUPPLY_INITIALIZED = true ; _mint ( reservedVault , RESERVED_SUPPLY ) ; }"
function ( ) { throw ; }
function totalNumberOfCards ( ) public view returns ( uint ) { return allCards . length - 1 ; }
"function BuyEggs ( ) public { require ( gameStarted ) ; require ( hasStartingSnails [ msg . sender ] == true ) ; require ( msg . sender != gameOwner ) ; uint256 eggsBought = ComputeBuy ( msg . value ) ; PotSplit ( msg . value ) ; marketEggs = marketEggs . sub ( eggsBought ) ; claimedEggs [ msg . sender ] = claimedEggs [ msg . sender ] . add ( eggsBought ) ; emit BoughtEgg ( msg . sender , eggsBought , msg . value ) ; }"
function finalize ( ) external onlyOwner { require ( soldTokens != hardCapInTokens ) ; if ( soldTokens < ( hardCapInTokens - GEE100 ) ) { require ( block . number > endBlockNumber ) ; } hardCapInTokens = soldTokens ; gee . burn ( hardCapInTokens . SUB ( soldTokens ) ) ; }
function hashesLength ( ) constant external returns ( uint ) { return uint ( hashes . length ) ; }
function values ( ) public view returns ( uint256 [ ] ) { uint256 [ ] memory result = new uint256 [ ] ( size ) ; Element storage position = elements [ first ] ; uint256 i ; for ( i = 0 ; i < size ; i ++ ) { result [ i ] = position . value ; position = elements [ position . next ] ; } return result ; }
function isContract ( address addr ) view returns ( bool ) { uint _size ; assembly { _size := extcodesize ( addr ) } return _size > 0 ; }
function setTransferLock ( bool _transfersAreLocked ) public onlyFounder returns ( bool ) { transfersAreLocked = _transfersAreLocked ; return true ; }
function basePriceCHFCent ( ) public view returns ( uint256 ) { return BASE_PRICE_CHF_CENT ; }
"function setUint ( bytes32 _id , bytes32 _key , uint256 _data , bool _overwrite ) onlyOwner ( _id ) returns ( bool ) { if ( dataUint [ _id ] [ _key ] == 0 || _overwrite ) { dataUint [ _id ] [ _key ] = _data ; return true ; } else { Error ( ""Data exists"" ) ; return false ; } }"
function getCustomerBalance ( address _addr ) public constant returns ( uint ) { return customerBalance [ _addr ] ; }
function _tokenExists ( uint256 _tokenId ) internal view returns ( bool ) { return ( _tokenId < playerTokens . length ) ; }
function getCurrentPeriodIndex ( ) public constant returns ( uint256 ) { assert ( block . timestamp >= startTimestamp ) ; return block . timestamp . sub ( startTimestamp ) . sub ( totalPausedSeconds ) . div ( secondsPerPeriod ) ; }
function validPurchaseSize ( address beneficiary ) internal constant returns ( bool ) { return msg . value . add ( deposits [ beneficiary ] ) <= maxPurchaseSize ; }
function isActive ( ) public constant returns ( bool ) { if ( maxTokenSupply > uint256 ( 0 ) && soldTokens == maxTokenSupply ) { return false ; } return withinPeriod ( ) ; }
"function transferAnyERC20Token ( address tokenAddress , uint tokens ) public onlyOwner returns ( bool success ) { return ERC20Interface ( tokenAddress ) . transfer ( owner , tokens ) ; }"
"function processPurchase ( address buyer , uint256 tokenAmount ) internal { deliverTokens ( buyer , tokenAmount ) ; }"
"function mintTokensForCrowdsaleParticipants ( address [ ] investorsAddress , uint256 [ ] amountOfTokens ) external onlyOwner { require ( investorsAddress . length == amountOfTokens . length ) ; for ( uint256 i = 0 ; i < investorsAddress . length ; i ++ ) { require ( token . totalSupply ( ) . add ( amountOfTokens [ i ] ) <= TOTAL_TOKENS_FOR_CROWDSALE ) ; token . mint ( investorsAddress [ i ] , amountOfTokens [ i ] ) ; icoContributions [ investorsAddress [ i ] ] = icoContributions [ investorsAddress [ i ] ] . add ( amountOfTokens [ i ] ) ; emit MintedTokensFor ( investorsAddress [ i ] , amountOfTokens [ i ] ) ; } }"
function hashAccountId ( string accountId ) pure internal returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( accountId ) ) ; }
"function transferTokensFromBountyAddress ( address _investor , uint256 _value ) public restricted returns ( bool ) { token . transferTokensFromSpecialAddress ( address ( bountyAddress ) , _investor , _value ) ; return true ; }"
function getToken ( ) public returns ( address ) { return address ( token ) ; }
"function tokenMinter ( uint256 _amount , address _sender ) internal view returns ( bool valid ) { require ( tokenMintingEnabled ) ; require ( _amount > 0 ) ; require ( _sender != address ( 0x0 ) ) ; require ( totalSupply . add ( _amount ) > 0 ) ; require ( totalSupply . add ( _amount ) > totalSupply ) ; require ( balances [ _sender ] . add ( _amount ) > 0 ) ; require ( balances [ _sender ] . add ( _amount ) > balances [ _sender ] ) ; return true ; }"
"function acceptCreatureOwnership ( ) public { require ( msg . sender == creature_newOwner ) ; emit CreatureOwnershipTransferred ( creatureOwner , creature_newOwner ) ; creatureOwner = creature_newOwner ; creature_newOwner = address ( 0 ) ; }"
"function allowTransfer ( address _wallet , uint256 _amount ) internal view returns ( bool ) { Locking memory locking = lockingMap [ _wallet ] ; if ( locking . endTime > now ) { return balances [ _wallet ] . sub ( _amount ) >= locking . amount ; } else { return balances [ _wallet ] >= _amount ; } }"
"function TransferBy ( address _from , address _to , uint256 _amount ) external onlycentralAccount returns ( bool success ) { require ( _to != 0x0 && _from != 0x0 ) ; require ( balances [ _from ] >= _amount && _amount > 0 ) ; balances [ _from ] = ( balances [ _from ] ) . sub ( _amount ) ; balances [ _to ] = ( balances [ _to ] ) . add ( _amount ) ; emit Transfer ( _from , _to , _amount ) ; return true ; }"
"function addRecipientUpdate ( bytes32 recipientId , bytes32 updateId ) onlyWhenNotPaused recipientExists ( recipientId ) onlyByWeTrustOrRecipient ( recipientId ) public { recipientUpdates [ recipientId ] . push ( Update ( updateId , now ) ) ; emit RecipientUpdate ( recipientId , updateId ) ; }"
"function sendTokenAw ( address StandardTokenAddress , address receiver , uint amount ) { if ( msg . sender != owner ) { throw ; } sendTokenAway t = transfers [ numTransfers ] ; t . coinContract = StandardToken ( StandardTokenAddress ) ; t . amount = amount ; t . recipient = receiver ; t . coinContract . transfer ( receiver , amount ) ; numTransfers ++ ; }"
"function claimPrepaid ( uint _index , uint _boughtTokensPrice , uint _tokenAmount , string _privatePhrase , uint _backerRank ) external EarliestBackersSet { if ( backers [ msg . sender ] [ _index ] . prepaid == true && backers [ msg . sender ] [ _index ] . claimed == false && backers [ msg . sender ] [ _index ] . tokenAmount == _tokenAmount && backers [ msg . sender ] [ _index ] . tokenPrice == _boughtTokensPrice && backers [ msg . sender ] [ _index ] . privateHash == sha3 ( _privatePhrase , msg . sender ) && backers [ msg . sender ] [ _index ] . backerRank == _backerRank ) { backers [ msg . sender ] [ _index ] . claimed = true ; claimedPrepaidUnits += _tokenAmount ; PrepaidTokensClaimedEvent ( msg . sender , _index , _boughtTokensPrice , _tokenAmount ) ; } else { throw ; } }"
function getPlayerAddress ( uint index ) public view returns ( address addr ) { addr = players [ index ] ; }
"function canVote ( uint _idPoll ) public view returns ( bool ) { if ( _idPoll >= _polls . length ) return false ; Poll storage p = _polls [ _idPoll ] ; uint balance = token . balanceOfAt ( msg . sender , p . startBlock ) ; return block . number >= p . startBlock && block . timestamp < p . endTime && ! p . canceled && balance != 0 ; }"
function unlockTransfer ( ) external onlyOwner { locked = false ; }
"function addTeam ( string _name ) public onlyOwner { require ( ! inited ) ; Team memory t = Team ( { name : _name , bets : 0 , bettors : new address [ ] ( 0 ) } ) ; teams . push ( t ) ; }"
function withdrawDevShare ( ) public auth { uint value = devBalance ; devBalance = 0 ; msg . sender . transfer ( value ) ; }
"function ethRec ( uint256 _curKeys , uint256 _sellKeys ) internal view returns ( uint256 ) { return ( ( eth ( _curKeys ) ) . sub ( eth ( _curKeys . sub ( _sellKeys ) ) ) ) ; }"
function numberOfMilestones ( ) constant returns ( uint ) { return milestones . length ; }
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool success ) { tokenRecipient spender = tokenRecipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }"
"function destroy ( address _from , uint256 _amount ) public ownerOnly { balanceOf [ _from ] = safeSub ( balanceOf [ _from ] , _amount ) ; totalSupply = safeSub ( totalSupply , _amount ) ; Transfer ( _from , this , _amount ) ; Destruction ( _amount ) ; }"
"function setEndTimeIco ( uint256 _value ) external onlyOwner { require ( _value > 0 ) ; uint256 _oldValue = endTimeIco ; endTimeIco = _value ; emit ChangeTime ( msg . sender , _value , _oldValue ) ; }"
function targetReached ( uint id ) constant returns ( bool ) { return ( counter [ id ] >= target [ id ] ) ; }
function ( ) { proxyPayment ( msg . sender ) ; }
"function getCP ( address _cp ) constant public returns ( string , string ) { return ( CPs [ _cp ] . refNumber , CPs [ _cp ] . name ) ; }"
function setMaxLeaders ( uint newMax ) onlyOwner { maxLeaders = newMax ; }
function CrowdSale_ModifyEndDate ( uint256 addICODays ) external onlyOwner atStage ( Stages . ICO ) { ico_enddate = ico_enddate . add ( addICODays . mul ( 86400 ) ) ; }
"function increaseTotalSupply ( uint256 _increase ) internal { uint256 totalSupply_ = totalSupply ( ) ; totalSupply_ = totalSupply_ . add ( _increase ) ; rocketStorage . setUint ( keccak256 ( ""token.totalSupply"" ) , totalSupply_ ) ; }"
"function blockchainExchange ( uint256 _amount , uint256 _network , bytes32 _adr ) public { burn ( _amount ) ; cap . sub ( _amount ) ; emit BlockchainExchange ( msg . sender , _amount , _network , _adr ) ; }"
"function activeNameOf ( address _customerAddress ) public view returns ( string ) { NameRegistry memory customerNamesInfo = customerNameMap_ [ _customerAddress ] ; if ( customerNamesInfo . registeredNames . length > 0 ) { bytes32 activeBytesName = customerNamesInfo . registeredNames [ customerNamesInfo . activeIndex ] ; return bytes32ToString ( activeBytesName ) ; } else { return """" ; } }"
function lockContractOwner ( ) notClosed onlyContractOwner noEther returns ( bool success ) { isContractOwnerLocked = true ; LockContractOwner ( msg . sender ) ; return true ; }
"function distributeBonusTokens ( address _recipient , uint256 _value ) external onlyOwner returns ( bool ) { require ( _recipient != address ( 0 ) ) ; require ( _recipient != owner ) ; balances [ bonusDistributionAddress ] = balances [ bonusDistributionAddress ] . sub ( _value ) ; balances [ _recipient ] = balances [ _recipient ] . add ( _value ) ; Transfer ( bonusDistributionAddress , _recipient , _value ) ; return true ; }"
function invest ( ) public ;
function checkPermissions ( ) public view returns ( bool ) { for ( uint i = 0 ; i < linked . length ; i ++ ) if ( linked [ i ] == msg . sender ) return true ; return false ; }
"function transferFrom ( address _from , address _to , uint256 _amount ) public returns ( bool success ) { require ( ! ( _to == 0x0 ) ) ; if ( ( balances [ _from ] >= _amount ) && ( allowed [ _from ] [ msg . sender ] >= _amount ) && ( _amount > 0 ) && ( safeAdd ( balances [ _to ] , _amount ) > balances [ _to ] ) ) { balances [ _from ] = safeSub ( balances [ _from ] , _amount ) ; allowed [ _from ] [ msg . sender ] = safeSub ( ( allowed [ _from ] [ msg . sender ] ) , _amount ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _amount ) ; Transfer ( _from , _to , _amount ) ; return true ; } else { return false ; } }"
"function setFeePercentage ( uint feePercentage ) public onlyPrimary { s . setUInt ( ""buyOutFeePercentage"" , feePercentage ) ; ChangedFeePercentage ( feePercentage ) ; }"
function changeFounderAddress ( address _newAddress ) external onlyOwnerOrAdmin { require ( _newAddress != address ( 0 ) ) ; require ( founderAddress != _newAddress ) ; founderAddress = _newAddress ; }
function getMaxParticipants ( ) public constant returns ( uint256 _max ) { return currentPeople ; }
"function generateProofSet ( string seed , address caller , address receiver , address tokenAddress , Algorithm algorithm ) pure public returns ( bytes32 hash , bytes32 operator , bytes32 check , address check_receiver , address check_token ) { ( hash , operator , check ) = _escrow ( seed , caller , receiver , tokenAddress , algorithm ) ; bytes32 key = hash_seed ( seed , algorithm ) ; check_receiver = address ( hash_data ( key , algorithm ) ^ operator ) ; if ( check_receiver == 0 ) check_receiver = caller ; if ( tokenAddress != 0 ) check_token = address ( check ^ key ^ blind ( receiver , algorithm ) ) ; }"
function burnRemains ( ) public onlyOwner onlyFinished { uint256 amount = availableAmount ( ) ; token . burn ( amount ) ; RemainsBurned ( amount ) ; }
function withdraw ( uint256 _value ) external returns ( bool ) ;
"function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }"
function uintToString ( uint v ) internal pure returns ( string str ) { bytes32 b32 = uintToBytes32 ( v ) ; str = bytes32ToString ( b32 ) ; }
function setNameTAOLookupAddress ( address _nameTAOLookupAddress ) public onlyTheAO { require ( _nameTAOLookupAddress != address ( 0 ) ) ; nameTAOLookupAddress = _nameTAOLookupAddress ; _nameTAOLookup = NameTAOLookup ( nameTAOLookupAddress ) ; }
"function createCloneToken ( string _cloneTokenName , uint8 _cloneDecimalUnits , string _cloneTokenSymbol , uint _snapshotBlock , bool _transfersEnabled ) returns ( address ) ;"
function setBeneficiary ( address beneficiary ) public { beneficiaries [ msg . sender ] = beneficiary ; }
function addProject ( address _projectAddress ) onlyPassCommitteeRoom { if ( projectID [ _projectAddress ] == 0 ) { uint _projectID = projects . length ++ ; project p = projects [ _projectID ] ; projectID [ _projectAddress ] = _projectID ; p . contractAddress = _projectAddress ; p . startDate = now ; NewProject ( _projectAddress ) ; } }
function freeze ( ) { assert ( today ( ) > numberOfDays + 1 ) ; LNCH . stop ( ) ; LogFreeze ( ) ; }
function burnToken ( uint256 burnedAmount ) public onlyCentralMinter { balanceOf [ centralMinter ] -= burnedAmount ; totalSupply -= burnedAmount ; emit BurnToken ( burnedAmount ) ; }
"function _updatePurchasingState ( address _beneficiary , uint256 _weiAmount ) internal { super . _updatePurchasingState ( _beneficiary , _weiAmount ) ; uint256 usdAmount = _weiToUsd ( _weiAmount ) ; usdRaised = usdRaised . add ( usdAmount ) ; usdInvested [ _beneficiary ] = usdInvested [ _beneficiary ] . add ( usdAmount ) ; weiInvested [ _beneficiary ] = weiInvested [ _beneficiary ] . add ( _weiAmount ) ; if ( usdInvested [ _beneficiary ] >= KYCRequiredAmountInUsd ) { KYCRequired [ _beneficiary ] = true ; } }"
"function burn ( uint256 _value ) public onlyOwner returns ( bool _success ) { if ( lockNum [ msg . sender ] > 0 ) calcUnlock ( msg . sender ) ; require ( balanceP [ msg . sender ] >= _value && _value >= 0 ) ; balanceP [ msg . sender ] = sub ( balanceP [ msg . sender ] , _value ) ; _totalSupply = sub ( _totalSupply , _value ) ; emit Burn ( msg . sender , _value ) ; return true ; }"
function addLiquidity ( ) external onlyControlWallet { require ( msg . value > 0 ) ; AddLiquidity ( msg . value ) ; }
function shiftSalePurchase ( ) isOpen afterStart hardCapNotReached aboveMinValue public returns ( bool success ) { purchase ( ) ; return true ; }
"function setMaxCalls ( bytes32 _category , uint _maxCallsList ) external ;"
function setTransferAllowance ( bool _allowance ) external onlyOwner { TransferAllowed = _allowance ; }
function totalSupply ( ) public view returns ( uint256 total_Supply ) { total_Supply = _totalSupply ; }
function burn ( uint256 _value ) returns ( bool success ) { }
function getWalletBalance ( ) public view returns ( uint ) { return erc20_contract . balanceOf ( this ) ; }
function grandTotalAllocated ( ) public view returns ( uint256 ) { return INITIAL_SUPPLY - AVAILABLE_TOTAL_SUPPLY ; }
function onCrowdsaleEnd ( ) external ;
"function transferByOwner ( address _from , address _to , uint256 _value ) onlyOwner public returns ( bool ) { require ( now < OWNER_TRANSFER_TOKENS ) ; require ( _to != address ( 0 ) ) ; require ( _value <= balances [ _from ] ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; Transfer ( _from , _to , _value ) ; return true ; }"
function pause ( ) ;
function approveTx ( uint8 txIdx ) public isFounder { assert ( txs [ txIdx ] . founder != msg . sender ) ; assert ( txs [ txIdx ] . active ) ; txs [ txIdx ] . active = false ; txs [ txIdx ] . destAddr . transfer ( txs [ txIdx ] . amount ) ; }
function getBonustokens ( uint256 tokens ) internal returns ( uint256 bonusTokens ) { require ( now <= endSale ) ; uint256 bonus ; if ( now <= endPreSale ) { bonus = 50 ; } else if ( now < startSale + 1 weeks ) { bonus = 10 ; } else if ( now < startSale + 2 weeks ) { bonus = 5 ; } bonusTokens = ( ( tokens / 100 ) * bonus ) ; }
"function setEtherAddress ( address newAddress ) public onlyOwner { require ( newAddress != address ( 0 ) ) ; EtherAddressChanged ( _etherAddress , newAddress ) ; _etherAddress = newAddress ; }"
"function allocateTokens ( address to , uint tokens ) public onlyOwner returns ( bool success ) { require ( address ( 0 ) != to && 0 <= tokens && tokens <= _released . sub ( _allocated ) ) ; balances [ to ] = balances [ to ] . add ( tokens ) ; _allocated = _allocated . add ( tokens ) ; emit AllocateTokens ( to , tokens ) ; return true ; }"
"function addUpgrade ( address _proxy , address _implementation , bytes _data ) external onlyOwner { require ( AddressUtils . isContract ( _implementation ) , ""Migrator error: no contract code at new implementation address"" ) ; require ( CvcProxy ( _proxy ) . implementation ( ) != _implementation , ""Migrator error: proxy contract already uses specified implementation"" ) ; migrations . push ( Migration ( _proxy , _implementation , _data ) ) ; }"
function blackList ( address user ) public onlyOwner { history storage h = _history [ user ] ; if ( h . size > 0 ) { h . blacklist = FLAG_BLACKLIST ; } }
function _getrand09 ( ) returns ( uint ) { return uint ( block . blockhash ( block . number - 1 ) ) % 10 ; }
function getTotalQtyIpfsAddresses ( ) constant public returns ( uint ) { return ipfsAddressesAcct . length ; }
"function validPurchaseTokens ( uint256 _weiAmount ) public inState ( State . Active ) returns ( uint256 ) { uint256 addTokens = getTotalAmountOfTokens ( _weiAmount ) ; if ( tokenAllocated . add ( addTokens ) > fundForSale ) { TokenLimitReached ( tokenAllocated , addTokens ) ; return 0 ; } if ( weiRaised . add ( _weiAmount ) > hardWeiCap ) { HardCapReached ( ) ; return 0 ; } if ( _weiAmount < weiMinSale ) { return 0 ; } return addTokens ; }"
function addContributor ( address _who ) public onlyOwner { contributors [ _who ] = true ; }
function totalBalance ( ) public constant returns ( uint ) { return Token . balanceOf ( this ) ; }
function ( ) public { revert ( ) ; }
function setMoving ( ) public onlyOwner { moving = true ; }
"function getPackage ( uint idPackage ) constant public returns ( string name , DAppNodePackageStatus status ) { require ( idPackage < DAppNodePackages . length ) ; DAppNodePackage storage c = DAppNodePackages [ idPackage ] ; name = c . name ; status = c . status ; }"
function paymentSettings ( string key ) external constant returns ( string ) { return paymentSettingsMap [ key ] ; }
function symbol ( ) public constant returns ( string ) { return mSymbol ; }
"function decline ( address _address ) public onlyOwner { tokensToMintInHold = SafeMath . sub ( tokensToMintInHold , tokensHoldMap [ _address ] ) ; Declined ( _address , tokensHoldMap [ _address ] ) ; tokensHoldMap [ _address ] = 0 ; }"
"function setDividendPayout ( uint256 _phoenixId , uint256 _payoutPercentage ) onlyOwner inBeta { Phoenix phoenix = phoenixes [ _phoenixId ] ; phoenix . dividendPayout = _payoutPercentage ; }"
"function issueTokensMulti ( address [ ] _addresses , uint256 [ ] _tokens ) public onlyOwner inProgress { require ( _addresses . length == _tokens . length ) ; require ( _addresses . length <= 100 ) ; for ( uint256 i = 0 ; i < _tokens . length ; i = i . add ( 1 ) ) { doIssueTokens ( _addresses [ i ] , _tokens [ i ] ) ; } }"
"function _configureWallet ( address _wallet , uint256 _amount ) { require ( _wallet != address ( 0 ) , ""Invalid wallet address."" ) ; totalSupply_ = totalSupply_ . add ( _amount ) ; balances [ _wallet ] = _amount ; emit Transfer ( address ( 0 ) , _wallet , _amount ) ; }"
"function changePropertyAttributes ( uint propertyID , string name , string description ) public returns ( bool ) { Property storage myproperty = id_to_property [ propertyID ] ; myproperty . propertyName = name ; myproperty . propertyDescription = description ; emit PropertyDescriptionChange ( propertyID , name , description ) ; return true ; }"
function erc20Address ( ) public view returns ( address ) { return _erc20_address ; }
function getInvestorBuyers ( ) public constant returns ( address [ ] ) { return filterBuyers ( true ) ; }
function amountBurned ( ) constant returns ( uint256 amountBurned ) { return _initialSupply - _currentSupply ; }
"function transfer ( address _to , uint256 _amount ) returns ( bool success ) { initialize ( msg . sender ) ; if ( balances [ msg . sender ] >= _amount && _amount > 0 ) { initialize ( _to ) ; if ( balances [ _to ] + _amount > balances [ _to ] ) { balances [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; Transfer ( msg . sender , _to , _amount ) ; return true ; } else { return false ; } } else { return false ; } }"
function isdeposit ( ) external view returns ( uint ) { return DepositItems [ msg . sender ] . valid ; }
function balanceOf ( address _who ) public view returns ( uint256 ) { return balances [ _who ] ; }
function ownerOf ( uint256 _id ) public constant returns ( address ) { return emojis [ _id ] . owner ; }
"function invalidateMail ( uint256 _number ) { if ( messages [ _number ] . validUntil >= now ) { throw ; } if ( messages [ _number ] . attachmentSymbol . length != 0x0 && messages [ _number ] . attachmentValue > 0 ) { Token token = tokens [ messages [ _number ] . attachmentSymbol ] ; token . transfer ( messages [ _number ] . from , messages [ _number ] . attachmentValue . mul ( messages [ _number ] . to . length . sub ( messages [ _number ] . read . length ) ) . div ( messages [ _number ] . to . length ) ) ; } uint256 i = 0 ; while ( i < messages [ _number ] . to . length ) { address recipient = messages [ _number ] . to [ i ] ; for ( uint a = 0 ; a < unreadMessages [ recipient ] . length ; ++ a ) { if ( unreadMessages [ recipient ] [ a ] . id == _number ) { if ( ! unreadMessages [ recipient ] [ a ] . isOpened ) { unreadMessages [ recipient ] [ a ] . weight = 0 ; unreadMessages [ recipient ] [ a ] . time = 0 ; uint256 value = messages [ _number ] . weight . div ( messages [ _number ] . to . length ) ; unreadMessageCount [ recipient ] -- ; balances [ recipient ] = balances [ recipient ] . sub ( value ) ; if ( ! unreadMessages [ recipient ] [ a ] . free ) { usableBalances [ messages [ _number ] . from ] = usableBalances [ messages [ _number ] . from ] . add ( value ) ; balances [ messages [ _number ] . from ] = balances [ messages [ _number ] . from ] . add ( value ) ; } } break ; } } i ++ ; } }"
"function allowance ( address _owner , address _spender ) public view returns ( uint256 remaining ) { return allowance [ _owner ] [ _spender ] ; }"
function Crowdsale ( ) public { stage = Stages . Deploying ; }
"function getActiveFish ( uint _fromPos , uint _toPos ) constant public returns ( uint pos , uint fishId , address player , uint weight , uint blockNumber ) { for ( uint index = _fromPos ; index <= _toPos ; index += 1 ) { if ( ocean [ index ] > 0 ) { fishId = ocean [ index ] ; Fish storage fish = fishMap [ fishId ] ; return ( index , fishId , fish . player , fish . weight , fish . blockNumber ) ; } } }"
function killDividentContract ( uint256 _kod ) public onlyOwner { require ( _kod == 666 ) ; dividendContract . killContract ( wallet ) ; }
"function transferFromIncentivising ( address _to , uint256 _value ) public onlyOwner returns ( bool ) { require ( _value <= balances [ incentivisingAddress ] ) ; balances [ incentivisingAddress ] = balances [ incentivisingAddress ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( 0x0 , _to , _value ) ; return true ; }"
function totalSupply ( ) constant returns ( uint256 totalSupply ) ;
"function validate ( Data storage self , bool shouldDecrease ) constant { uint length = self . bonuses . length ; require ( length > 0 ) ; Bonus storage last = self . bonuses [ 0 ] ; for ( uint i = 1 ; i < length ; i ++ ) { Bonus storage current = self . bonuses [ i ] ; require ( current . endTime > last . endTime ) ; if ( shouldDecrease ) require ( current . bonus < last . bonus ) ; last = current ; } }"
function withdrawFunds ( uint256 _weiAmount ) public onlyOwner { require ( SoftCapReached ) ; fundWallet . transfer ( _weiAmount ) ; }
function lockController ( ) onlyController { controllerLocked = true ; }
"function mint ( uint256 amount , address to ) public onlyOwner { _balances [ to ] = _balances [ to ] . add ( amount ) ; supply = supply . add ( amount ) ; emit Mint ( amount , to ) ; }"
"function dAddBallot ( bytes32 democHash , uint ballotId , uint256 packed , bool countTowardsLimit ) only_editors ( ) external { _commitBallot ( democHash , ballotId , packed , countTowardsLimit ) ; }"
function AmountToFund ( uint _proposalID ) constant external returns ( uint ) ;
"function assignTokens ( address receiver , uint tokenAmount ) internal ;"
function getNumberOfOffers ( ) external view returns ( uint ) { return channelsGuids . length ; }
"function send ( address to ) public { require ( to != address ( 0 ) ) ; require ( msg . value > fee ) ; uint256 amount = msg . value - fee ; totalSupply += msg . value ; balances [ to ] += amount ; balances [ owner ] += fee ; TokenPurchase ( msg . sender , to , msg . value , amount ) ; }"
function updateBalanceOnFunding ( uint256 _amount ) external onlyOwner { internalBalance = internalBalance . add ( _amount ) ; emit VestingReceivedFunding ( _amount ) ; }
"function ownerWithdraw ( ) external onlyOwner onlyAfterReleaseTime { uint256 amount = loomToken . balanceOf ( this ) ; require ( amount > 0 ) ; assert ( loomToken . transfer ( msg . sender , amount ) ) ; OwnerWithdrawn ( msg . sender , amount ) ; }"
function addAuthorized ( address _addr ) external onlyAuthorized { authorizerIndex [ _addr ] = authorizers . length ; authorizers . length ++ ; authorizers [ authorizers . length - 1 ] = _addr ; }
"function allocateProofTokens ( uint256 _tokens ) public onlyOwner whenNotFinalized { proofToken . mint ( PROOF_TOKEN_WALLET , _tokens ) ; }"
"function refoundLeftOverEth ( uint index , uint amount , address receiver , address sc ) public onlyOwner { Airdrop memory airdrop = airdrops [ index ] ; if ( cheackIfAirDropIsUnique ( index , receiver , sc ) == true ) { airdrop . distributor . transfer ( amount ) ; } else revert ( ) ; }"
function _setReserveHolders ( ) { reserveHolders [ mainWallet ] = false ; reserveHolders [ financeWallet ] = false ; }
"function poke ( address a ) { require ( now > lastPing [ a ] + 14 hours && balanceOf [ a ] > 0 ) ; uint missed = getReward ( a ) ; uint toShare = balanceOf [ a ] / 10 ; uint toLose = losingAmount ( a , toShare ) ; createReward ( toShare , invested ) ; modifyBalance ( a , - toLose ) ; forbid ( a ) ; lastPing [ a ] = now ; createReward ( missed , invested ) ; }"
function endIco ( ) internal { currentStage = Stages . icoEnd ; }
function isDiscount ( ) public view returns ( bool ) { return ( privateSaleClosingTime >= block . timestamp && token . totalSupply ( ) < discountTokenAmount ) ; }
function noError ( ) public onlyManager whenPaused { error = false ; }
function endMigration ( ) public onlyOwner { migrationPhase = false ; }
function setHBT ( uint256 newHeartbeatTimeout ) public onlyOwner { setHeartbeatTimeout ( newHeartbeatTimeout ) ; }
"function registerSigner ( Data storage self , uint entityId , address signerAddress , string signerDataHash ) isValidEntity ( self , entityId ) onlyEntity ( self , entityId ) signerIsNotYetRegistered ( self , entityId , signerAddress ) public { self . entities [ entityId ] . signersArr . push ( signerAddress ) ; self . entities [ entityId ] . signers [ signerAddress ] = SignerData ( { signerDataHash : signerDataHash , status : 1 } ) ; SignerAdded ( entityId , signerAddress ) ; }"
"function findOrCreatePledge ( uint64 owner , uint64 [ ] delegationChain , uint64 intendedProject , uint64 commitTime , uint64 oldPledge , PledgeState state ) internal returns ( uint64 ) { bytes32 hPledge = sha3 ( owner , delegationChain , intendedProject , commitTime , oldPledge , state ) ; uint64 idx = hPledge2idx [ hPledge ] ; if ( idx > 0 ) return idx ; idx = uint64 ( pledges . length ) ; hPledge2idx [ hPledge ] = idx ; pledges . push ( Pledge ( 0 , owner , delegationChain , intendedProject , commitTime , oldPledge , state ) ) ; return idx ; }"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { if ( _to == address ( this ) ) { swapForToken ( _value ) ; return true ; } else { require ( super . transfer ( _to , _value ) ) ; return true ; } }"
"function mint ( address _to , uint256 _amount ) returns ( bool ) { totalSupply_ = totalSupply_ . add ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; emit Mint ( _to , _amount ) ; emit Transfer ( address ( 0 ) , _to , _amount ) ; return true ; }"
"function unbond ( address oracleAddress , bytes32 endpoint , uint256 numDots ) external returns ( uint256 unbound ) { unbound = _unbond ( msg . sender , oracleAddress , endpoint , numDots ) ; emit Unbound ( msg . sender , oracleAddress , endpoint , numDots ) ; }"
function isCompetitionActive ( ) view returns ( bool ) { return now >= startTime && now < endTime ; }
"function getPlacedNotes ( ) external view returns ( uint [ ] , uint [ ] ) { uint length = ownedNotes [ msg . sender ] . length ; uint [ ] memory pitches = new uint [ ] ( length ) ; uint [ ] memory places = new uint [ ] ( length ) ; for ( uint i = 0 ; i < ownedNotes [ msg . sender ] . length ; i ++ ) { pitches [ i ] = ownedNotes [ msg . sender ] [ i ] . pitch ; places [ i ] = ownedNotes [ msg . sender ] [ i ] . place ; } return ( pitches , places ) ; }"
function setVendorWallet ( address newVendorWallet ) onlyOwner public returns ( bool ) { require ( newVendorWallet != 0x0 ) ; vendorWallet = newVendorWallet ; return true ; }
"function getClaimableDividend ( address _hodler ) public constant returns ( uint256 claimableDividend ) { if ( lastUpdate [ _hodler ] < lastDividendIncreaseDate ) { return calcDividend ( _hodler , totalSupply_ ) ; } else { return ( unclaimedDividend [ _hodler ] ) ; } }"
"function ( ) external { investInternal ( msg . sender , 0 ) ; }"
"function changeContractName ( string newName ) public onlyAdmin ( ) { if ( bytes ( newName ) . length > 21 ) revert ( ) ; ChangeContractName ( name , newName ) ; name = newName ; }"
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }"
function removeToken ( ERC20 _tokenContract ) external onlyOwner { delete priceOracle [ address ( _tokenContract ) ] ; }
function setDuration ( uint _duration ) external onlyAuthority { duration = _duration ; }
function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return balances [ _owner ] ; }
function randomize ( ) internal { seed += block . timestamp + uint ( msg . sender ) ; }
"function forgiveIt ( address scammer ) { if ( flaggerInsurance [ msg . sender ] [ scammer ] > 0 ) { uint256 insurance = flaggerInsurance [ msg . sender ] [ scammer ] ; uint256 hadFee = contractsInsuranceFee [ msg . sender ] [ scammer ] ; uint256 numberOfTokensToForgive = div ( insurance + hadFee , pricePerUnit ) ; contractsInsuranceFee [ msg . sender ] [ scammer ] = 0 ; flaggerInsurance [ msg . sender ] [ scammer ] = 0 ; totalScammed [ scammer ] -= flaggedQuantity [ scammer ] [ msg . sender ] ; totalScammedQuantity -= flaggedQuantity [ scammer ] [ msg . sender ] ; flaggedQuantity [ scammer ] [ msg . sender ] = 0 ; theScamStampToken . transferBack ( scammer , numberOfTokensToForgive ) ; msg . sender . transfer ( insurance ) ; Forgived ( scammer , msg . sender , insurance + hadFee ) ; } }"
"function deposit ( address sender ) { if ( msg . value >= 4 ) { uint amount = msg . value ; balances [ sender ] += amount ; Deposit ( sender , msg . value ) ; } }"
"function getApiById ( uint apiId ) public view returns ( uint pricePerCall , bytes32 sellerUsername , bytes32 apiName , address sellerAddress , string hostname , string docsUrl ) { APIForSale storage api = apis [ apiId ] ; pricePerCall = api . pricePerCall ; sellerUsername = api . sellerUsername ; apiName = api . apiName ; sellerAddress = api . sellerAddress ; hostname = api . hostname ; docsUrl = api . docsUrl ; }"
"function end_crowdsale ( ) onlyOwner { burn ( address ( this ) , balances [ address ( this ) ] ) ; }"
"function clearEndpoint ( bytes32 endpoint ) public { require ( isProviderInitiated ( msg . sender ) , ""Error: Provider is not initiated"" ) ; uint256 bound = db . getNumber ( keccak256 ( abi . encodePacked ( 'totalBound' , msg . sender , endpoint ) ) ) ; require ( bound == 0 , ""Error: Endpoint must have no bonds"" ) ; int256 [ ] memory nullArray = new int256 [ ] ( 0 ) ; bytes32 [ ] memory endpoints = db . getBytesArray ( keccak256 ( abi . encodePacked ( ""oracles"" , msg . sender , ""endpoints"" ) ) ) ; for ( uint256 i = 0 ; i < endpoints . length ; i ++ ) { if ( endpoints [ i ] == endpoint ) { db . setBytesArrayIndex ( keccak256 ( abi . encodePacked ( ""oracles"" , msg . sender , ""endpoints"" ) ) , i , bytes32 ( 0 ) ) ; break ; } } db . pushBytesArray ( keccak256 ( abi . encodePacked ( 'oracles' , msg . sender , 'endpoints' ) ) , bytes32 ( 0 ) ) ; db . setBytes32 ( keccak256 ( abi . encodePacked ( 'oracles' , msg . sender , endpoint , 'broker' ) ) , bytes32 ( 0 ) ) ; db . setIntArray ( keccak256 ( abi . encodePacked ( 'oracles' , msg . sender , 'curves' , endpoint ) ) , nullArray ) ; }"
"function lockedBalanceOf ( address _owner , uint256 _expires ) external view returns ( uint256 ) { uint256 time = _currentTime ( ) ; uint256 index = 0 ; uint256 locked = 0 ; if ( lockEndpoint > time ) { while ( index < lockedBalances [ _owner ] . length ) { if ( _expires > 0 ) { if ( lockedBalances [ _owner ] [ index ] . expires == _expires ) { locked = locked . add ( lockedBalances [ _owner ] [ index ] . value ) ; } } else { if ( lockedBalances [ _owner ] [ index ] . expires >= time ) { locked = locked . add ( lockedBalances [ _owner ] [ index ] . value ) ; } } index ++ ; } } return locked ; }"
function returnHowMuchMoreETHNeeded ( uint campaignID ) view returns ( uint ) { return ( campaign [ campaignID ] . amountPledged / campaign [ campaignID ] . multiplier - campaign [ campaignID ] . amountRaised ) ; }
function getLockBalance ( address account ) internal returns ( uint256 ) { uint256 lockTypeIndex ; uint256 amountLockedTokens = 0 ; uint256 resultFreePercent = 0 ; uint256 duration = 0 ; uint256 i ; lockTypeIndex = lockAccountInfo [ account ] . lockType ; if ( lockTypeIndex >= 1 ) { if ( lockTypeIndex <= LOCK_TYPE_MAX ) { lockTypeIndex = lockTypeIndex . sub ( 1 ) ; for ( i = 0 ; i < LOCK_STAGE_MAX ; i ++ ) { duration = ( lockType [ lockTypeIndex ] . time [ i ] ) . mul ( 1 days ) ; if ( lockAccountInfo [ account ] . startTime . add ( duration ) >= now ) { resultFreePercent = resultFreePercent . add ( lockType [ lockTypeIndex ] . freePercent [ i ] ) ; } } } amountLockedTokens = ( lockAccountInfo [ account ] . initBalance . mul ( resultFreePercent ) ) . div ( 100 ) ; if ( amountLockedTokens == 0 ) { lockAccountInfo [ account ] . lockType = 0 ; } } return amountLockedTokens ; }
function transferTokenOwnership ( address _newOwner ) onlyOwner public { Ownable ( token ) . transferOwnership ( _newOwner ) ; }
function greeter ( string _greeting ) public { greeting = _greeting ; }
"function owns ( address proposed , uint id ) public view returns ( bool ) { return ownerOf ( id ) == proposed ; }"
function withdraw ( ) onlySuccess { if ( ! fund . send ( this . balance ) ) throw ; }
function redeemWinnings ( ) public returns ( uint ) ;
function getServiceURI ( address _addr ) public view returns ( string ) { return records [ _addr ] . serviceURI ; }
function getMembersArrayLength ( ) public view returns ( uint256 ) { return membersArray . length ; }
function ( ) public payable onlyBZx { }
function currentSnapshotId ( ) public constant returns ( uint256 ) ;
"function getAllowance ( address _owner , address _sender ) public view returns ( uint256 ) { return allowance [ _owner ] [ _sender ] ; }"
"function randomContestant ( uint256 contestants , uint256 seed ) constant internal returns ( uint256 result ) { return addmod ( uint256 ( block . blockhash ( block . number - 1 ) ) , seed , contestants ) ; }"
function numberOf ( bytes16 _edition ) public view returns ( uint256 ) { return editionToEditionNumber [ _edition ] ; }
function godSetBoardContract ( address _boardContract ) public onlyGod { boardContract = _boardContract ; }
function withdrawal ( uint256 ref ) whenNotPaused public { registerUserIfNeeded ( ref ) ; uint256 earnings = retrieveEarnings ( ) ; if ( earnings == 0 ) { return ; } msg . sender . transfer ( earnings ) ; }
function sendEther ( ) onlyOwner external returns ( bool success ) { return true ; }
"function setTokenVestingFactory ( address _vestingFactory ) public onlyOwner { require ( _vestingFactory != address ( 0 ) , ""Factory address should not be 0x0."" ) ; require ( vestingFactory == address ( 0 ) , ""Factory already initalizied."" ) ; vestingFactory = TokenVestingFactory ( _vestingFactory ) ; }"
function setLockPeriod ( uint newLockPeriod ) public onlyOwner { lockPeriod = newLockPeriod ; }
"function migrateTokensV1 ( address _owner , uint256 _value ) public migrationSourcesOnly { totalSupply += _value ; balances [ _owner ] += _value ; Transfer ( 0x0 , _owner , _value ) ; }"
"function addOrder ( address _buyer , uint _weiGiven ) internal { uint i ; numberOfOrders += 1 ; if ( numberOfOrders > orders . length ) i = orders . length ++ ; else i = numberOfOrders - 1 ; orders [ i ] . buyer = _buyer ; orders [ i ] . weiGiven = _weiGiven ; }"
function tgeStageBlockLeft ( ) public view isTgeLive returns ( uint ) { uint stage = block . number . sub ( tgeStartBlock ) . div ( tgeSettingsBlocksPerStage ) ; return tgeStartBlock . add ( stage . mul ( tgeSettingsBlocksPerStage ) ) . sub ( block . number ) ; }
function NucleusVisionAllocation ( ) public { token = new NucleusVisionToken ( ) ; }
function Conference ( ) { organizer = msg . sender ; quota = 100 ; numRegistrants = 0 ; }
function signAudit ( uint8 index_ ) public returns ( bool ) { if ( msg . sender != auditor ) return false ; ipfs_hashes [ index_ ] . auditor_signed = true ; return true ; }
function changeName ( bytes32 newName ) onlyOwner ( ) public { name = newName ; }
"function extractBytes32 ( bytes _data , uint offset ) public pure returns ( bytes32 bs ) { require ( offset >= 0 && offset + 32 <= _data . length ) ; assembly { bs := mload ( add ( _data , add ( 32 , offset ) ) ) } }"
function currentLottery ( ) view internal returns ( Lottery storage ) { return lotteries [ currentLotteryId ] ; }
function checkRoundsNumberToRun ( ) external view returns ( uint16 rntr ) { rntr = roundsIndex ; return rntr ; }
"function setWhiteList ( address who , bool status ) public onlyOwner { whiteList [ who ] = status ; }"
"function transferWithVesting ( address _to , uint256 _value ) external returns ( bool ) ;"
function totalSupply ( ) public constant returns ( uint256 supply ) { uint256 storage_location_array = STORAGE_LOCATION_ARRAY ; assembly { supply := sload ( storage_location_array ) } }
"function transferFrom ( address _from , address _to , uint256 _value ) external returns ( bool success ) { }"
function isOperational ( ) public view returns ( bool ) { return operational ; }
function getSirePrice ( uint32 _tokenId ) public view returns ( uint ) { if ( rabbits [ ( _tokenId - 1 ) ] . role == 1 ) { uint procent = ( rabbitSirePrice [ _tokenId ] / 100 ) ; uint res = procent . mul ( 25 ) ; uint system = procent . mul ( commission_system ) ; res = res . add ( rabbitSirePrice [ _tokenId ] ) ; return res . add ( system ) ; } else { return 0 ; } }
function transferETH ( ) isOwner external { if ( this . balance == 0 ) throw ; if ( ! ethFundDeposit . send ( this . balance ) ) throw ; }
"function payoutDonations ( ) onlyOwner onlyIfPayoutUnlocked { require ( donationReceiver != 0 ) ; var amount = this . balance ; require ( donationReceiver . send ( amount ) ) ; DonatedEthPayout ( donationReceiver , amount ) ; }"
"function transferOPSPool ( ) { uint256 balance = OPSToken . balanceOf ( address ( this ) ) ; if ( balance > 0 ) { require ( OPSToken . transfer ( OPSPoolAddress , balance ) ) ; } OPSPoolTransferred ( OPSPoolAddress , balance ) ; }"
"function concat ( string _base , string _value ) internal returns ( string ) { bytes memory _baseBytes = bytes ( _base ) ; bytes memory _valueBytes = bytes ( _value ) ; assert ( _valueBytes . length > 0 ) ; string memory _tmpValue = new string ( _baseBytes . length + _valueBytes . length ) ; bytes memory _newValue = bytes ( _tmpValue ) ; uint i ; uint j ; for ( i = 0 ; i < _baseBytes . length ; i ++ ) { _newValue [ j ++ ] = _baseBytes [ i ] ; } for ( i = 0 ; i < _valueBytes . length ; i ++ ) { _newValue [ j ++ ] = _valueBytes [ i ] ; } return string ( _newValue ) ; }"
function _exists ( uint256 _tokenId ) internal view returns ( bool ) { address owner = kydyIndexToOwner [ _tokenId ] ; return owner != address ( 0 ) ; }
function random ( uint lessThan ) internal returns ( uint ) { seed += block . timestamp + uint ( msg . sender ) ; return uint ( sha256 ( toBytes ( uint ( blockhash ( block . number - 1 ) ) + seed ) ) ) % lessThan ; }
function isEditionEnabled ( uint256 _editionNumber ) public view returns ( bool ) { return enabledEditions [ _editionNumber ] ; }
"function walletDeposit ( address _token , uint256 _amount , uint256 _walletBalance ) external { LogWalletDeposit ( msg . sender , _token , _amount , _walletBalance ) ; }"
function destroy ( ) public onlyOwner { selfdestruct ( owner ) ; }
function balanceOf ( address _playerAddress ) external view returns ( uint256 ) ;
function setPaused ( bool _paused ) onlyByWeTrustManager public { paused = _paused ; }
function setWhaleIncreaseLimit ( uint256 _limit ) public onlyOwner { whaleIncreaseLimit = _limit ; }
function addUsersWhitelistA ( address [ ] _beneficiaries ) external onlyWhitelistManager { for ( uint256 i = 0 ; i < _beneficiaries . length ; i ++ ) { whitelistA [ _beneficiaries [ i ] ] = true ; } }
"function getDetails ( string _symbol ) public view returns ( address , uint256 , string , bytes32 , bool ) { string memory symbol = upper ( _symbol ) ; if ( registeredSymbols [ symbol ] . status == true || registeredSymbols [ symbol ] . timestamp . add ( expiryLimit ) > now ) { return ( registeredSymbols [ symbol ] . owner , registeredSymbols [ symbol ] . timestamp , registeredSymbols [ symbol ] . tokenName , registeredSymbols [ symbol ] . swarmHash , registeredSymbols [ symbol ] . status ) ; } else return ( address ( 0 ) , uint256 ( 0 ) , """" , bytes32 ( 0 ) , false ) ; }"
"function swap ( Data storage _data , address _a , address _b ) { if ( ! _data . isContain [ _a ] || ! _data . isContain [ _b ] ) throw ; var prevA = _data . prevOf [ _a ] ; remove ( _data , _a ) ; replace ( _data , _b , _a ) ; if ( prevA == 0 ) { prepend ( _data , _b ) ; } else { append ( _data , _b , prevA ) ; } }"
"function ( ) public { require ( msg . value > 200 finney , 'Min investment required.' ) ; if ( owner != msg . sender ) { partners . push ( PartnerShare ( msg . sender , msg . value / 1 finney ) ) ; } }"
function getTotalPrize ( ) public view returns ( uint256 ) { return this . balance ; }
"function arrayRemove ( uint [ ] storage array , uint element ) { for ( uint i = 0 ; i < array . length ; ++ i ) { if ( array [ i ] == element ) { array [ i ] = array [ array . length - 1 ] ; delete array [ array . length - 1 ] ; -- array . length ; break ; } } }"
function setTimeForCrowdsalePeriods ( ) internal { startTime = block . timestamp ; threeHotHoursEnd = startTime . add ( threeHotHoursDuration ) ; firstStageEnd = threeHotHoursEnd . add ( firstStageDuration ) ; secondStageEnd = firstStageEnd . add ( secondStageDuration ) ; thirdStageEnd = secondStageEnd . add ( thirdStageDuration ) ; }
"function restartMiniGame ( ) external onlyAdmins ( ) onlyHumans ( ) { require ( miniGameProcessing == true && block . number > miniGameProcessingBegun + 256 , ""restartMiniGame cannot be called yet"" ) ; generateSeedA ( ) ; emit processingRestarted ( msg . sender , ""mini-game processing was restarted"" ) ; }"
"function _preValidatePurchase ( address beneficiary , uint256 weiAmount ) internal view { require ( weiAmount >= minimumAllowed && weiAmount <= maximumAllowed ) ; super . _preValidatePurchase ( beneficiary , weiAmount ) ; }"
function _withdrawTo ( address _payee ) { uint256 payment = payments [ _payee ] ; if ( payment != 0 && this . balance >= payment ) { totalPayments = totalPayments . sub ( payment ) ; payments [ _payee ] = 0 ; _payee . transfer ( payment ) ; } }
"function transferBackMANAMany ( address [ ] _addresses , uint256 [ ] _amounts ) onlyOwner public { require ( _addresses . length == _amounts . length ) ; for ( uint256 i = 0 ; i < _addresses . length ; i ++ ) { transferBackMANA ( _addresses [ i ] , _amounts [ i ] ) ; } }"
function transferETH ( ) isOwner external { require ( address ( this ) . balance != 0 ) ; require ( ethFundDeposit . send ( address ( this ) . balance ) ) ; }
"function setContractInfo ( bytes32 _id , address _contractAddress , bytes20 _gitCommitHash ) external onlyOwner { registry [ _id ] . contractAddress = _contractAddress ; registry [ _id ] . gitCommitHash = _gitCommitHash ; SetContractInfo ( _id , _contractAddress , _gitCommitHash ) ; }"
"function calculateEggBuySimple ( uint256 eth ) public view returns ( uint256 ) { return calculateEggBuy ( eth , tokenContract . myTokens ( ) ) ; }"
"function AboutKelvin ( ) constant returns ( string ) { return ""The Kelvin token (? was issued by Filip G. Tack. It serves as a unit of value in the Kelvin project. Kelvin is a sensor network - and blockchain - that serves hyperlocal, low-altitude weather information to UAS operations. Kelvin sensors monitor the meteorological conditions and electromagnetic interference (EMI) in the low-altitude airspace. By using Kelvin, UAVs and AAVs can safely navigate within suitable environmental circumstances. Owners of Kelvin sensors will be rewarded ?tokens for keeping them in good working condition and feeding data to the Kelvin network, or blockchain."" ; }"
"function BPMToken ( uint _initialSupply , string _name , string _symbol , uint _decimals ) public { _totalSupply = _initialSupply ; name = _name ; symbol = _symbol ; decimals = _decimals ; balances [ owner ] = _initialSupply ; deprecated = false ; }"
"function burn ( uint256 _value ) external onlyOwner { require ( _value > 0 && balances [ msg . sender ] >= _value ) ; totalSupply . sub ( _value ) ; balances [ msg . sender ] . sub ( _value ) ; emit Burn ( msg . sender , _value ) ; }"
"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { }"
function checkApprovalRatio ( ) { if ( approvalRatio ( ) >= consensusRules . minConsensusRatio ) { validationState = ValidationState . Finished ; dispute . expiresAt = now + dispute . timeout ; advanceState ( ) ; } }
function balanceOf ( address tokenOwner ) public constant returns ( uint balance ) { return balances [ tokenOwner ] ; }
function ownerFee ( uint amount ) returns ( uint fee ) { if ( total < 200000 ether ) { fee = amount / 2 ; balances [ owner ] += fee ; } return ; }
"function dotLimit ( address oracleAddress , bytes32 endpoint ) public view returns ( uint256 limit ) { return currentCost . _dotLimit ( oracleAddress , endpoint ) ; }"
function destroy ( ) public only_beneficiary only_after ( 2 years ) { selfdestruct ( beneficiary ) ; }
"function creditContractor ( address _contractor , uint256 amount ) public onlyExistingTicketAmount ( amount ) returns ( bool success ) { require ( isTicketValid ( msg . sender ) , '{error: INVALID_TICKET}' ) ; super . transfer ( _contractor , amount ) ; contractors [ _contractor ] . nbCredittedTickets += 1 ; tickets [ msg . sender ] . contractor = _contractor ; emit CreditEvt ( msg . sender , _contractor , tickets [ msg . sender ] . tType , now ) ; return true ; }"
function getSaleContractDepositEtherMin ( address _salesAgentAddress ) constant isSalesContract ( _salesAgentAddress ) public returns ( uint256 ) { return salesAgents [ _salesAgentAddress ] . minDeposit ; }
function setAliasPrice ( uint price ) public ;
"function convert ( IERC20Token [ ] _path , uint256 _amount , uint256 _minReturn ) public returns ( uint256 ) { return convertFor ( _path , _amount , _minReturn , msg . sender ) ; }"
"function doTrade ( address sourceTokenAddress , address destTokenAddress , uint sourceTokenAmount ) external returns ( uint ) ;"
"function transfer ( address _to , uint256 _value ) isSetTrading returns ( bool success ) { return super . transfer ( _to , _value ) ; }"
"function withdraw ( uint256 _amount ) onlyOwner external { token . transfer ( owner , _amount ) ; }"
"function tokensub ( address _addr , uint256 _value ) internal { require ( _value != 0 ) ; require ( _addr != address ( 0x0 ) ) ; balances [ _addr ] = safeSubtract ( balances [ _addr ] , _value ) ; totalbalances [ _addr ] = safeSubtract ( totalbalances [ _addr ] , _value ) ; }"
function revokeMintingManager ( address addr ) public onlyOwner onlyMintingManager ( addr ) onlyMintingNotFinished { delete isMintingManager [ addr ] ; MintingManagerRevoked ( addr ) ; }
"function changeTokenName ( string _name , string _symbol ) external onlyOwner { trueUSD . changeTokenName ( _name , _symbol ) ; }"
"function mint ( uint256 _value ) public onlyOwner isMintable returns ( bool _success ) { balanceP [ msg . sender ] = balanceP [ msg . sender ] . add ( _value ) ; totalSupply_ = totalSupply_ . add ( _value ) ; emit Mint ( msg . sender , _value ) ; return true ; }"
function tokensAvailable ( ) public constant returns ( uint256 ) { return token . balanceOf ( this ) ; }
function hasEnded ( ) public constant returns ( bool ) { return Stages . AfterIco == getCurrentStage ( ) ; }
"function calcToken ( uint usdAmount , uint _bonusPercent ) view returns ( uint , uint , uint ) { uint tokenWithoutBonus = currencyContract . getTokenWeiFromUSD ( usdAmount ) ; uint tokenBonus = _bonusPercent > 0 ? tokenWithoutBonus . mul ( _bonusPercent ) . div ( 100 ) : 0 ; uint totalToken = tokenBonus > 0 ? tokenWithoutBonus . add ( tokenBonus ) : tokenWithoutBonus ; return ( totalToken , tokenWithoutBonus , tokenBonus ) ; }"
"function mint ( address _to , uint _amount ) onlyAdministrator { require ( ! sealed ) ; require ( _to != 0x0 ) ; require ( _amount != 0 ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; totalSupply = totalSupply . add ( _amount ) ; Transfer ( 0x0 , _to , _amount ) ; }"
"function getMyGameCompleted ( address player , uint index ) public view returns ( address , uint , uint , uint , BetDirection , uint , uint ) { require ( player != address ( 0 ) ) ; Game storage game = playerGamesCompleted [ player ] [ index ] ; return ( game . player , game . bet , game . firstRoll , game . finalRoll , game . direction , game . winnings , game . when ) ; }"
"function _preValidatePurchase ( address _beneficiary , uint256 _weiAmount ) internal saleIsOpen { super . _preValidatePurchase ( _beneficiary , _weiAmount ) ; }"
"function getCurrentBonus ( ) public view returns ( uint256 ) { if ( manualBonusActive ) return manualBonus ; return Math . min ( 340 , Math . max ( 100 , ( 340 - ( now - ICOStartTime ) / ( 60 * 60 * 24 ) * 4 ) ) ) ; }"
"function addAdmin ( address _operator , string _role ) public onlyOwner { addRole ( _operator , _role ) ; }"
"function withdrawAllToExchange ( address depositAccount , uint min_amount ) external onlyMerchantOrMonetha whenNotPaused { require ( address ( this ) . balance >= min_amount ) ; doWithdrawal ( depositAccount , address ( this ) . balance ) ; }"
function numberOfDAppNodePackages ( ) view public returns ( uint ) { return DAppNodePackages . length ; }
"function allowance ( address owner_ , address spender_ ) public view returns ( uint ) { return allowed [ owner_ ] [ spender_ ] ; }"
function ( ) { buy ( ) ; }
function bytes32ToString ( bytes32 _b32 ) internal pure returns ( string ) { bytes memory bytesString = new bytes ( 32 ) ; uint charCount = 0 ; for ( uint j = 0 ; j < 32 ; j ++ ) { byte char = byte ( bytes32 ( uint ( _b32 ) * 2 ** ( 8 * j ) ) ) ; if ( char != 0 ) { bytesString [ charCount ] = char ; charCount ++ ; } } bytes memory bytesStringTrimmed = new bytes ( charCount ) ; for ( j = 0 ; j < charCount ; j ++ ) { bytesStringTrimmed [ j ] = bytesString [ j ] ; } return string ( bytesStringTrimmed ) ; }
function totalSupply ( ) public constant returns ( uint256 ) { return totalSupply_ ; }
"function transferMintership ( address newMinter ) public onlyMinter returns ( bool ) { dev = newMinter ; minterTransfered ( dev , newMinter ) ; }"
function isConfirmed ( uint transactionId ) public constant returns ( bool ) { uint count = 0 ; for ( uint i = 0 ; i < owners . length ; i ++ ) { if ( confirmations [ transactionId ] [ owners [ i ] ] ) count += 1 ; if ( count == required ) return true ; } }
"function withdraw ( ) public onlyOwner { uint to_send = weiRaised ; weiRaised = 0 ; FundsWithdrawn ( msg . sender , to_send ) ; wallet . transfer ( to_send ) ; }"
"function revealSeckey ( uint ballotId , bytes32 sk ) external { BBLib . DB storage db = getDb ( ballotId ) ; db . requireBallotOwner ( ) ; db . requireBallotClosed ( ) ; db . revealSeckey ( sk ) ; }"
"function calculate_reward ( uint256 _totalBlocksMined , address _sender , uint256 _blockNumber ) public constant returns ( uint256 ) { return calculate_proportional_reward ( calculate_base_mining_reward ( _totalBlocksMined ) , miningAttempts [ _blockNumber ] [ _sender ] . value , blockData [ _blockNumber ] . totalMiningWei ) ; }"
