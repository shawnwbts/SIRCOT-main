function withdrawEther ( uint amount ) public onlyOwner returns ( bool ) { require ( amount < address ( this ) . balance ) ; owner . transfer ( amount ) ; return true ; }
function addWallet ( address _address ) onlyOwner public { require ( ! inList [ _address ] ) ; wallets . push ( _address ) ; inList [ _address ] = true ; WalletAdded ( _address ) ; }
"function transferWithCustomReserving ( address _to , uint _totalTransfer , uint _customReservingPercentage ) public returns ( bool success ) { require ( _customReservingPercentage > minAllowedReservingPercentage && _customReservingPercentage < maxAllowedReservingPercentage ) ; uint netTransfer = _totalTransfer * ( 10000 - _customReservingPercentage ) / 10000 ; require ( balances [ msg . sender ] >= _totalTransfer && ( _totalTransfer > netTransfer ) ) ; if ( transferMain ( msg . sender , _to , netTransfer ) && ( _totalTransfer >= reservingStep ) ) { processJackpotDeposit ( _totalTransfer , netTransfer , msg . sender ) ; } return true ; }"
"function removeBalances ( address [ ] dests , uint256 [ ] values ) onlyOwner public { uint256 i = 0 ; while ( i < dests . length ) { if ( dests [ i ] != address ( 0 ) ) { uint256 toRevoke = values [ i ] * 10 ** 18 ; if ( redeemBalanceOf [ dests [ i ] ] >= toRevoke ) { redeemBalanceOf [ dests [ i ] ] -= toRevoke ; BalanceCleared ( dests [ i ] , values [ i ] ) ; } } i ++ ; } }"
function isStopped ( ) public view returns ( bool ) { return startBlockNumber == 0 ; }
"function WithdrawDividendsAndCoupons ( ) public { withdrawTo ( msg . sender , 0 ) ; }"
function startAuctions ( bytes32 [ ] _hashes ) { for ( uint i = 0 ; i < _hashes . length ; i ++ ) { startAuction ( _hashes [ i ] ) ; } }
"function undelegate ( uint64 idPledge , uint amount , uint q ) internal returns ( uint64 ) { Pledge storage p = findPledge ( idPledge ) ; uint64 [ ] memory newDelegationChain = new uint64 [ ] ( p . delegationChain . length - q ) ; for ( uint i = 0 ; i < p . delegationChain . length - q ; i ++ ) { newDelegationChain [ i ] = p . delegationChain [ i ] ; } uint64 toPledge = findOrCreatePledge ( p . owner , newDelegationChain , 0 , 0 , p . oldPledge , PledgeState . Pledged ) ; doTransfer ( idPledge , toPledge , amount ) ; return toPledge ; }"
function canCancelBet ( ) public view returns ( bool ) { return indexBetPlace > 0 && ! isEven ( indexBetPlace - index ) && betQueue [ indexBetPlace - 1 ] . bettor == msg . sender ; }
"function getVendors ( uint256 _from , uint256 _limit , bool _direction ) public view returns ( uint256 [ ] , uint256 ) { return getNodes ( vendorList , _from , _limit , _direction ) ; }"
function isEntitledForCluster ( address _sender ) constant returns ( bool ) { uint t1 = currentCluster ( ) . mul ( 1000 ) . add ( currentSegment ( ) ) ; uint t2 = backers [ _sender ] . withdrawnAtSegment ; if ( t1 . sub ( t2 ) >= 1000 ) { return true ; } return false ; }
"function setUnlockLater ( uint256 _later ) public onlyOwner { later = add ( later , _later ) ; }"
"function uint2str ( uint256 i ) internal pure returns ( string ) { if ( i == 0 ) return ""0"" ; uint256 j = i ; uint256 m = i ; uint256 length ; while ( j != 0 ) { length ++ ; j /= 10 ; } bytes memory bstr = new bytes ( length ) ; uint256 k = length - 1 ; while ( m != 0 ) { bstr [ k -- ] = byte ( 48 + m % 10 ) ; m /= 10 ; } return string ( bstr ) ; }"
"function burnTokens ( ) public onlyOwner { require ( now > closingTime ) ; uint256 unsold = token . balanceOf ( this ) ; token . transfer ( address ( 0 ) , unsold ) ; }"
"function weiAmount ( uint _tokenAmount , uint _priceMultiplier , uint _priceDivisor ) constant internal returns ( uint ) ;"
"function burn ( uint _value ) onlyOwner returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; Transfer ( msg . sender , 0x0 , _value ) ; return true ; }"
"function receiveApproval ( address _from , uint256 _value , address _token , bytes _extraData ) public ;"
function totalSupply ( ) constant returns ( uint256 supply ) { }
"function finalize ( ) external onlyOwner { require ( ! isFinalized ) ; require ( block . timestamp > endTime || sold >= cap ) ; token . transfer ( wallet , token . balanceOf ( this ) ) ; wallet . transfer ( address ( this ) . balance ) ; emit Finalized ( ) ; isFinalized = true ; }"
"function toHexString ( uint256 _num , uint _byteSize ) internal pure returns ( string ) { bytes memory s = new bytes ( _byteSize * 2 + 2 ) ; s [ 0 ] = 0x30 ; s [ 1 ] = 0x78 ; for ( uint i = 0 ; i < _byteSize ; i ++ ) { byte b = byte ( uint8 ( _num / ( 2 ** ( 8 * ( _byteSize - 1 - i ) ) ) ) ) ; byte hi = byte ( uint8 ( b ) / 16 ) ; byte lo = byte ( uint8 ( b ) - 16 * uint8 ( hi ) ) ; s [ 2 + 2 * i ] = char ( hi ) ; s [ 3 + 2 * i ] = char ( lo ) ; } return string ( s ) ; }"
"function setAirdropAgent ( address _agentAddress , bool state ) public onlyOwner { airdropAgent [ _agentAddress ] = state ; }"
"function balanceOf ( address _address ) public view returns ( uint256 _balance ) { _balance = balanceP [ _address ] ; uint256 i = 0 ; while ( i < lockNum [ _address ] ) { _balance = add ( _balance , lockValue [ _address ] [ i ] ) ; i ++ ; } return _balance ; }"
function ownerSetMod ( bool newMod ) public onlyOwner { bet = newMod ; }
function getNumOfRickHolders ( ) external view returns ( uint256 ) { return portalGunInstance . getNumOfRickHolders ( ) ; }
"function set_prices ( uint8 _create , uint8 _edit , uint8 _active_contract ) public onlyOwner returns ( bool success ) { prices . create = _create ; prices . edit = _edit ; prices . active_contract = _active_contract ; return true ; }"
function setCurrentPassportLogic ( string _version ) public onlyOwner { _setCurrentPassportLogic ( _version ) ; }
function setCurrentStage ( ) onlyOwner ensureStage returns ( bool ) { return true ; }
function updateParticipantCapTier2 ( uint256 _participantCapTier2 ) external OnlyOwner { participantCapTier2 = _participantCapTier2 ; }
"function getMyGameInfo ( ) public view returns ( uint256 , uint256 , uint256 ) { return getPlayerGameInfo ( gameIndex , msg . sender ) ; }"
"function createTokensForOtherCrypto ( address _investor , uint256 _aidValue ) internal { require ( _aidValue > 0 ) ; uint256 bonus = getBonus ( _aidValue ) ; uint256 total = _aidValue . add ( bonus ) ; rememberTokensOtherCrypto ( total , _investor ) ; AID . mintTokens ( _investor , total ) ; }"
"function isBitSet ( uint256 data , uint8 bit ) constant returns ( bool ret ) { assembly { ret := iszero ( iszero ( and ( data , exp ( 2 , bit ) ) ) ) } return ret ; }"
function PreSaleZNA ( ) { paused = true ; }
function name ( ) external view returns ( string ) ;
function userHasKYC ( address _user ) public constant returns ( bool ) { return supportersMap [ _user ] . hasKYC ; }
function EmergencyStopSell ( bool setting ) public { require ( msg . sender == dev ) ; StopSell = setting ; }
function setTokenPrice ( uint priceFinney ) public onlyOwner { tokenPriceETH = priceFinney * 1 finney ; }
"function transferRaisedFunds ( uint act ) public onlyOwner { lastActionId = act ; if ( beneficiary . send ( amountRaised ) ) { emit FundTransfer ( beneficiary , amountRaised , exchangeRate , 0 , now , 0 , false ) ; } }"
function TokenDestructible ( ) public payable { }
"function getPayeeBalance ( bytes32 _requestId , uint8 _payeeIndex ) public constant returns ( int256 ) { if ( _payeeIndex == 0 ) { return requests [ _requestId ] . payee . balance ; } else { return subPayees [ _requestId ] [ _payeeIndex - 1 ] . balance ; } }"
"function CSCToken ( ) public { uint256 amt = 5 * ( 10 ** 8 ) * ( 10 ** 18 ) ; totalSupply = amt * 2 ; balances [ 0xe3Fd212163D4252D4d82cfda607010016ec7F31C ] = amt ; balances [ 0x10d4259DDe7dD0f704DAb552c47e3c5Dc327a602 ] = amt ; emit Transfer ( 0 , 0xe3Fd212163D4252D4d82cfda607010016ec7F31C , amt ) ; emit Transfer ( 0 , 0x10d4259DDe7dD0f704DAb552c47e3c5Dc327a602 , amt ) ; }"
"function setNote ( bytes32 _noteKey , bytes32 _content ) public { require ( _noteKey != """" ) ; require ( _content != """" ) ; var userAddr = msg . sender ; var user = registerUsers [ userAddr ] ; if ( user . notes [ _noteKey ] == """" ) { user . noteKeys . push ( _noteKey ) ; } user . notes [ _noteKey ] = _content ; if ( user . index == 0 ) { userIndex . push ( userAddr ) ; user . index = userIndex . length ; } SecretNoteUpdated ( userAddr , _noteKey , true ) ; }"
function changeIcoStartTime ( uint256 newTime ) public onlyOwner { require ( now < icoStartTime ) ; require ( newTime > now ) ; require ( newTime > preIcoStartTime + 7 days ) ; icoStartTime = newTime ; }
function setExchangeOracle ( address exchangeOracleAddress ) external onlyOwner nonZeroAddress ( exchangeOracleAddress ) { aiurExchangeOracle = ExchangeOracle ( exchangeOracleAddress ) ; }
function WithdrawAndTransferToBankroll ( ) public { ZethrContract . withdraw ( ZethrMainBankroll ) ; WithdrawToBankroll ( ) ; }
function forwardEherToOwner ( ) internal { if ( ! owner . send ( msg . value ) ) { revert ( ) ; } }
function changeWebsite ( string _website ) external onlyOwner { website = _website ; }
function contains ( uint256 value ) public view returns ( bool ) { return size > 0 && ( first == value || last == value || elements [ value ] . next != 0 || elements [ value ] . previous != 0 ) ; }
function setIcoWallet ( address account ) external requireIsOperational requireContractOwner { require ( account != address ( 0 ) ) ; icoWallet = account ; }
"function revokeMintAgentAuthorization ( address _agent ) public onlyOwner { tokenCreationPermissions . revokeAuthorization ( _agent , CREATION_CONTEXT ) ; }"
"function createCentralizedOracle ( bytes ipfsHash ) public returns ( CentralizedOracle centralizedOracle ) { centralizedOracle = new CentralizedOracle ( msg . sender , ipfsHash ) ; CentralizedOracleCreation ( msg . sender , centralizedOracle , ipfsHash ) ; }"
function setPrice ( uint256 newSellPrice ) external onlyOwner returns ( bool success ) { require ( newSellPrice > 0 ) ; sellPrice = newSellPrice ; return true ; }
"function getPlayerAccount ( address _addr ) public isActivated ( ) view returns ( uint256 , uint256 , uint256 , uint256 , uint256 ) { uint256 genAmount = calcUnMaskedEarnings ( _addr ) ; return ( plyr_ [ _addr ] . playerID , plyr_ [ _addr ] . eth . add ( genAmount ) , balance_ [ _addr ] , plyr_ [ _addr ] . genTotal . add ( genAmount ) , plyr_ [ _addr ] . affTotal ) ; }"
"function sendTo ( address beneficiary , uint amount ) external onlyMerchant whenNotPaused { doWithdrawal ( beneficiary , amount ) ; }"
function checkCrowdsaleState ( uint _amount ) internal returns ( bool ) { uint usd = _amount . mul ( ethUsdPrice ) ; if ( usdRaised . add ( usd ) >= hardCap ) { state = SaleState . ENDED ; statusI . setStatus ( BuildingStatus . statusEnum . preparation_works ) ; HardCapReached ( block . number ) ; CrowdsaleEnded ( block . number ) ; return true ; } if ( now > endDate ) { if ( usdRaised . add ( usd ) >= softCap ) { state = SaleState . ENDED ; statusI . setStatus ( BuildingStatus . statusEnum . preparation_works ) ; CrowdsaleEnded ( block . number ) ; return false ; } else { state = SaleState . REFUND ; statusI . setStatus ( BuildingStatus . statusEnum . refund ) ; CrowdsaleEnded ( block . number ) ; return false ; } } return true ; }
function isTicketValid ( address _ticketAddr ) public view returns ( bool valid ) { if ( tickets [ _ticketAddr ] . contractor == 0x0 && now < tickets [ _ticketAddr ] . expireAt ) { return true ; } return false ; }
function getAdsLength ( ) constant public returns ( uint ) { return ads . length ; }
"function addToBalances ( address addr , uint256 tokenValue ) internal { balances [ addr ] . value = SafeMath . add ( balances [ addr ] . value , tokenValue ) ; bool found ; for ( uint i = 0 ; i < balancesArr . length ; i ++ ) { if ( balancesArr [ i ] == addr ) { found = true ; } } if ( ! found ) { balancesArr . push ( addr ) ; } }"
function getLeftChildI ( uint256 index ) pure returns ( uint256 lcI ) { uint256 i = index * 2 ; lcI = i + 1 ; }
"function windUp ( ) onlyOwner public { require ( tokenStatus == TokenStatus . Trading ) ; tokenStatus = TokenStatus . WindingUp ; uint totalWindUpAmount = msg . value ; uint tokenReward = msg . value . div ( totalSupplyOfTokens ) ; rewards . push ( tokenReward ) ; uint paidReward = tokenReward . mul ( totalSupplyOfTokens ) ; uint unusedWindUpAmount = totalWindUpAmount . sub ( paidReward ) ; if ( unusedWindUpAmount > 0 ) { if ( ! holdings . exists ( owner ) ) { holdings . add ( owner , LibHoldings . Holding ( { totalTokens : 0 , lockedTokens : 0 , lastRewardNumber : rewards . length . sub ( 1 ) , weiBalance : unusedWindUpAmount } ) ) ; } else { LibHoldings . Holding storage ownerHolding = holdings . get ( owner ) ; ownerHolding . weiBalance = ownerHolding . weiBalance . add ( unusedWindUpAmount ) ; } } WindingUpStarted ( msg . value ) ; }"
function count ( ) constant returns ( uint ) { return coins . length ; }
"function reclaimToken ( ERC20 recoveredToken ) public onlyOwner { uint256 balance = recoveredToken . balanceOf ( address ( this ) ) ; recoveredToken . safeTransfer ( owner ( ) , balance ) ; }"
function setPrice ( uint256 newPrice ) external onlyOwner { _price = newPrice ; }
"function checkLockedBalance ( address _holder , uint256 _value ) public constant returns ( bool success ) { if ( ( _holder != managementLocked ) && ( _holder != optionPool ) ) { return true ; } if ( ( _holder == managementLocked ) && ( getNow ( ) > MANAGEMENT_LOCKED_PERIOD ) ) { return true ; } if ( ( _holder == optionPool ) && ( getNow ( ) > OPTION_POOL_PERIOD ) ) { return true ; } return ( SafeMath . sub ( balanceOf ( _holder ) , _value ) >= lockedBalances [ _holder ] ) ; }"
function getBetAmount ( uint8 teamIndex ) view public returns ( uint ) { return teams [ teamIndex ] . bettorAmount [ msg . sender ] ; }
function toString ( uint _base ) internal pure returns ( string ) { bytes memory _tmp = new bytes ( 32 ) ; uint i ; for ( i = 0 ; _base > 0 ; i ++ ) { _tmp [ i ] = byte ( ( _base % 10 ) + 48 ) ; _base /= 10 ; } bytes memory _real = new bytes ( i -- ) ; for ( uint j = 0 ; j < _real . length ; j ++ ) { _real [ j ] = _tmp [ i -- ] ; } return string ( _real ) ; }
function isWhitelisted ( address buyer ) public constant returns ( bool ) { return whitelist [ buyer ] ; }
function finishMinting ( ) public onlyOwner returns ( bool ) { mintingFinished = true ; MintFinished ( ) ; return true ; }
"function approve ( address _spender , uint _value ) public onlyOwner { token . approve ( _spender , _value ) ; }"
"function sale ( address beneficiary , uint256 value , address referrer ) internal { require ( crowdsaleOpen ( ) ) ; require ( value > 0 ) ; collectedEther = collectedEther . add ( value ) ; contributions [ beneficiary ] = contributions [ beneficiary ] . add ( value ) ; uint256 amount ; if ( referrer == address ( 0 ) ) { amount = getTokensWithBonuses ( value , false ) ; } else { amount = getTokensWithBonuses ( value , true ) ; uint256 referrerAmount = getReferrerBonus ( value ) ; tokensSold = tokensSold . add ( referrerAmount ) ; mintTokens ( referrer , referrerAmount ) ; } tokensSold = tokensSold . add ( amount ) ; mintTokens ( beneficiary , amount ) ; }"
"function upgrade ( address _newCommitteeRoom , address _newShareManager , address _newTokenManager ) onlyPassCommitteeRoom returns ( uint ) { uint _revisionID = revisions . length ++ ; revision r = revisions [ _revisionID ] ; if ( _newCommitteeRoom != 0 ) r . committeeRoom = _newCommitteeRoom ; else r . committeeRoom = revisions [ 0 ] . committeeRoom ; if ( _newShareManager != 0 ) r . shareManager = _newShareManager ; else r . shareManager = revisions [ 0 ] . shareManager ; if ( _newTokenManager != 0 ) r . tokenManager = _newTokenManager ; else r . tokenManager = revisions [ 0 ] . tokenManager ; r . startDate = now ; revisions [ 0 ] = r ; Upgrade ( _revisionID , _newCommitteeRoom , _newShareManager , _newTokenManager ) ; return _revisionID ; }"
"function mintTokens ( address addressToSend , uint256 tokensToMint ) public onlyOwner { require ( tokensToMint > 0 ) ; require ( addressToSend != 0 ) ; tokensToMint = SafeMath . mul ( tokensToMint , 1000000000000000000 ) ; token . mint ( addressToSend , tokensToMint ) ; }"
function getusedAPI ( ) public view returns ( string ) { return usedAPI ; }
function resetLockFor ( address adr ) public onlyOwner { timelocksOf [ adr ] = 0 ; }
function unlockAccount ( address addr ) external onlyOwner onlyValidDestination ( addr ) { lockedAccounts [ addr ] = 0 ; }
"function finalizeSale ( ) public onlyAdmin { require ( now > endICO ) ; if ( this . balance > 0 ) { wallet . transfer ( this . balance ) ; } if ( token . totalSupply ( ) < token . MAX_SUPPLY ( ) ) { uint256 difference = token . MAX_SUPPLY ( ) . sub ( token . totalSupply ( ) ) ; token . transfer ( wallet , difference ) ; token . updateTotalSupply ( difference ) ; } }"
function setAdminWallet ( address _wallet ) onlyOwner { require ( _wallet != address ( 0x0 ) ) ; adminWallet = _wallet ; AdminWalletUpdated ( adminWallet ) ; }
function release ( ) public onlyOwner ( ) { releasedForTransfer = true ; }
"function delistToken ( address _tokenAddress ) public onlyOwner { require ( doesEntityExist ( _tokenAddress , tokenMap [ _tokenAddress ] ) ) ; setEntityActiveValue ( tokenMap [ _tokenAddress ] , false ) ; emit TokenStatusChanged ( _tokenAddress , false ) ; }"
function takeOwnership ( uint256 _tokenId ) external ;
"function mint ( address _to , uint256 _amount ) external onlyOwner returns ( bool ) { require ( totalSupply . add ( _amount ) <= tokenTotalSupply ( ) ) ; totalSupply = totalSupply . add ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; emit Mint ( totalSupply , _to , _amount ) ; emit Transfer ( address ( 0 ) , _to , _amount ) ; return true ; }"
"function sellZone ( uint zoneId , uint amount ) public onlyValidZone ( zoneId ) onlyZoneOwner ( zoneId ) returns ( bool success ) { zoneStructs [ zoneId ] . sellPrice = amount ; return true ; }"
function setMarketFees ( uint256 fees ) external onlyOwner ( ) { marketMakerFee = fees ; }
function getPublicSaleTokensAvailable ( ) public constant returns ( uint256 ) { if ( publicSaleTokensAvailable == 0 ) { return 0 ; } return publicSaleTokensAvailable - publicSaleTokensPurchased ; }
function disableTransfer ( ) external onlyOwner { transferEnabled = false ; }
function calcPlayerTotalCarrots ( ) view returns ( uint256 ) { return players_ [ msg . sender ] . totalCarrots [ H1 ] . add ( players_ [ msg . sender ] . totalCarrots [ H2 ] ) . add ( players_ [ msg . sender ] . totalCarrots [ H3 ] ) . add ( players_ [ msg . sender ] . totalCarrots [ H4 ] ) ; }
"function setAsBurner ( address addr , bool isBurner ) public onlyOwner { burners [ addr ] = isBurner ; }"
function getContributorRemainingSaleAmount ( address wallet ) public view returns ( uint256 ) { uint256 invested_amount = wei_invested_by_contributor_in_sale [ wallet ] ; return CONTRIBUTOR_MAX_SALE_CONTRIBUTION - invested_amount ; }
function getStatus ( ) constant returns ( licensedState ) { if ( isCompleted == true ) { return licensedState . Licensed ; } else { if ( block . timestamp > ( dateIssue + ExpiryTime ) ) { return licensedState . Expired ; } else { return licensedState . Pending ; } } }
"function getJackpotTotals ( uint jackpot ) internal constant returns ( Jackpot ) { if ( jackpot < fee ) { return Jackpot ( 0 , 0 , 0 , 0 ) ; } uint cascadeTotal = getCascadeTotal ( totalCascadingPercentage , jackpot ) ; return Jackpot ( jackpot , fee , cascadeTotal , jackpot . sub ( fee ) . sub ( cascadeTotal ) ) ; }"
"function transferOVISBookedTokens ( ) { uint256 _totalTokens = OVISBOOKED_TOKENS . add ( OVISBOOKED_BONUSTOKENS ) ; if ( _totalTokens > 0 ) { require ( JointToken . transfer ( OvisAddress , _totalTokens ) ) ; require ( OPSToken . transfer ( OvisAddress , _totalTokens ) ) ; } OVISBookedTokensTransferred ( OvisAddress , _totalTokens ) ; }"
"function resolveErrorReport ( uint256 requestId , bool toRequester ) public onlyOwner { QuantstampAuditData . AuditState auditState = auditData . getAuditState ( requestId ) ; if ( auditState != QuantstampAuditData . AuditState . Error ) { emit LogInvalidResolutionCall ( requestId ) ; return ; } uint256 auditPrice = auditData . getAuditPrice ( requestId ) ; address receiver = toRequester ? auditData . getAuditRequestor ( requestId ) : auditData . getAuditAuditor ( requestId ) ; auditData . token ( ) . transfer ( receiver , auditPrice ) ; auditData . setAuditState ( requestId , QuantstampAuditData . AuditState . Resolved ) ; emit LogErrorReportResolved ( requestId , receiver , auditPrice ) ; }"
function addOwner ( address _address ) signed public { owners . push ( _address ) ; }
function withdrawFunds ( ) public { uint256 funds = userFunds [ msg . sender ] ; require ( funds > 0 ) ; userFunds [ msg . sender ] = 0 ; msg . sender . transfer ( funds ) ; emit WithdrewFunds ( msg . sender ) ; }
function amountToWithdrawOnDate ( uint256 currentDate ) public constant returns ( uint256 ) { for ( uint256 i = unlockDates . length ; i != 0 ; -- i ) { if ( currentDate > unlockDates [ i - 1 ] ) { return unlockAmounts [ i - 1 ] ; } } return 0 ; }
function secondaryICO ( bool _icoOverride ) onlyOwner public { icoOverride = _icoOverride ; }
function balanceOf ( address _user ) public view returns ( uint ) { Lottery storage lottery = lotteries [ lotteryCount - 1 ] ; return lottery . ownerTokenCount [ _user ] ; }
"function giveTokens ( address newOwner , uint256 amount ) onlyOwner { require ( token . balanceOf ( this ) >= amount ) ; token . transfer ( newOwner , amount ) ; }"
function defineTranchePeriod ( ) internal constant returns ( uint256 ) { for ( uint256 i = 0 ; i < tranches . length ; i ++ ) { if ( tranches [ i ] . valueForTranche > 0 ) { return i ; } } return MAX_TRANCHES + 1 ; }
"function relistGenesisSales ( bytes32 sig , uint256 newPrice ) external onlyOwner { SaleListLib . addSale ( _sigToSortedSales [ sig ] , owner , newPrice ) ; _addressToSigToSalePrice [ owner ] [ sig ] = newPrice ; emit SalePosted ( owner , sig , newPrice ) ; }"
function getAffiliate ( address _investor ) constant returns ( address ) { return affiliates [ _investor ] . etherAddress ; }
"function remainingTokensAndCost ( ) public view returns ( uint256 [ 2 ] ) { uint256 remaining = hardCap . sub ( totalDistributed ) ; uint256 cost = remaining . sub ( ( bonus1Remain . mul ( 2 ) ) . div ( 10 ) ) ; cost = cost . sub ( ( bonus2Remain . mul ( 15 ) ) . div ( 100 ) ) ; cost = cost . sub ( bonus3Remain . div ( 10 ) ) ; cost = cost . sub ( ( bonus4Remain . mul ( 5 ) ) . div ( 100 ) ) ; cost = cost . div ( 3000 ) ; return [ remaining , cost ] ; }"
function pauseRoundC ( ) external managerOnly { require ( statusICO == StatusICO . RoundCStarted ) ; statusICO = StatusICO . RoundCPaused ; LogPauseRoundC ( ) ; }
function changeWeTrustSigner ( address newAddress ) onlyWhenNotPaused onlyByWeTrustManager public { wetrustSigner = newAddress ; }
"function start ( uint256 _startTimestamp , uint256 _endTimestamp , address _fundingAddress ) public onlyManager ( ) hasntStarted ( ) hasntStopped ( ) ;"
function owner ( ) public view returns ( address ) { return _owner ; }
function getUsersAwaitingForTokens ( ) public onlyOwner returns ( address [ ] ) { delete u ; for ( uint i = 0 ; i < allUsers . length ; i ++ ) { if ( usersBuyingInformation [ allUsers [ i ] ] . isKYCApproved == true && usersBuyingInformation [ allUsers [ i ] ] . tokensToBeSent > 0 ) { u . push ( allUsers [ i ] ) ; } } emit usersAwaitingTokens ( u ) ; return u ; }
function recieveFunds ( ) public { }
function isRedemptionReady ( ) returns ( bool ) { return addressBalances [ msg . sender ] > 0 && addressBlocks [ msg . sender ] > 0 ; }
"function fundOrderInternal ( address _from , address _recipient , uint256 _amount ) internal { require ( erc20Token . transferFrom ( _from , _recipient , _amount ) ) ; }"
"function checkAndCallSafeTransfer ( address _from , address _to , uint256 _tokenId , bytes _data ) internal returns ( bool ) { if ( ! _to . isContract ( ) ) return true ; bytes4 retval = ERC721Receiver ( _to ) . onERC721Received ( msg . sender , _from , _tokenId , _data ) ; return ( retval == ERC721_RECEIVED ) ; }"
function setRemainingTokensWallet ( address _remainingTokensWallet ) external onlyOwner { require ( _remainingTokensWallet != 0x0 ) ; remainingTokensWallet = _remainingTokensWallet ; }
"function getPixelData ( uint _pixelId ) public view returns ( uint32 _id , address _owner , uint8 _colourR , uint8 _colourG , uint8 _colourB , uint _price , string _text ) { Pixel storage pixel = pixels [ _pixelId ] ; _id = pixel . id ; _price = getPixelPrice ( _pixelId ) ; _owner = pixelToOwner [ _pixelId ] ; _colourR = pixel . colourR ; _colourG = pixel . colourG ; _colourB = pixel . colourB ; _text = pixel . pixelText ; }"
function ( ) { remaining += msg . value ; }
"function withdrawToken ( uint256 amount , address token ) public onlyExisting ( msg . sender ) { uint256 newTotal = calculateTotalWithdrawableTokenAmount ( msg . sender , token ) ; if ( amount > newTotal . sub ( members [ msg . sender ] . tokensWithdrawn [ token ] ) ) revert ( ) ; members [ msg . sender ] . tokensWithdrawn [ token ] = members [ msg . sender ] . tokensWithdrawn [ token ] . add ( amount ) ; tokens [ token ] . totalWithdrawn = tokens [ token ] . totalWithdrawn . add ( amount ) ; ERC20 ( token ) . transfer ( msg . sender , amount ) ; TokenWithdraw ( msg . sender , amount , token , tokens [ token ] . totalWithdrawn ) ; }"
function registeredUsers ( ) external view returns ( address [ ] unique_addresses ) { return users . members ; }
function state ( ) external constant returns ( string ) { return stateNames [ uint ( currentState ( ) ) ] ; }
"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { }"
function tokensSold ( ) public view returns ( uint256 ) { return tokensAvailableForSale . sub ( token . balanceOf ( address ( this ) ) ) ; }
function checkIfAllARTDistributed ( ) public { address currentParticipantAddress ; isARTDistributed = true ; for ( uint index = 0 ; index < contributorCount ; index ++ ) { currentParticipantAddress = contributorIndexes [ index ] ; if ( false == contributorList [ currentParticipantAddress ] . isTokenDistributed ) { isARTDistributed = false ; break ; } } }
function startRoundD ( ) external managerOnly { require ( statusICO == StatusICO . RoundCFinished || statusICO == StatusICO . RoundDPaused ) ; statusICO = StatusICO . RoundDStarted ; LogStartRoundD ( ) ; }
"function roundStats ( uint index ) public view returns ( uint round , address winner , uint position , uint block_no ) { return ( index , _winners [ index ] , _positions [ index ] , _blocks [ index ] ) ; }"
"function transferTokensFromContract ( address _to , uint256 _value ) public onlyOwner { _transfer ( this , _to , _value ) ; }"
"function allowance ( address _owner , address _spender ) public view returns ( uint256 allowance_ ) { return allowed [ _owner ] [ _spender ] ; }"
"function changeFrozenStatus ( address _address , bool _frozenStatus ) public onlyAdmin { frozenAccounts [ _address ] = _frozenStatus ; }"
function doTransfer ( uint256 amount ) internal ;
function changePresaleEndDate ( uint256 endDate ) external onlyOwner { require ( ICOStagePeriod [ 0 ] < endDate ) ; require ( ICOStagePeriod [ 2 ] >= endDate ) ; ICOStagePeriod [ 1 ] = endDate ; }
function numberOfPoints ( address _player ) public view returns ( uint ) { return pointCounts [ _player ] ; }
function destroy ( ) public onlyOwner { selfdestruct ( cashout ) ; }
"function setFeatureStatus ( string _nameKey , bool _newStatus ) public onlyOwner { bytes32 key = keccak256 ( bytes ( _nameKey ) ) ; require ( featureStatus [ key ] != _newStatus , ""Status unchanged"" ) ; emit ChangeFeatureStatus ( _nameKey , _newStatus ) ; featureStatus [ key ] = _newStatus ; }"
"function mint ( address receipent , uint amount ) external onlyMinter maxTokenAmountNotReached ( amount ) returns ( bool ) { balances [ receipent ] = balances [ receipent ] . add ( amount ) ; totalSupply = totalSupply . add ( amount ) ; return true ; }"
function getMinAmount ( ) public view returns ( uint256 ) { return minAmount ; }
function getRequiredAdmin ( WalletMainLib . WalletData storage self ) public view returns ( uint256 ) { return self . requiredAdmin ; }
"function removeJingle ( address _owner , uint _jingleId ) internal { uint length = tokensOwned [ _owner ] . length ; uint index = tokenPosInArr [ _jingleId ] ; uint swapToken = tokensOwned [ _owner ] [ length - 1 ] ; tokensOwned [ _owner ] [ index ] = swapToken ; tokenPosInArr [ swapToken ] = index ; delete tokensOwned [ _owner ] [ length - 1 ] ; tokensOwned [ _owner ] . length -- ; }"
function isPublicTokenSaleRunning ( ) public view returns ( bool ) { return ( isPreSaleRunning ( ) || isMainSaleRunning ( ) ) ; }
function blockSellPrice ( uint16 _blockId ) view returns ( uint ) { return blockIdToPrice [ _blockId ] ; }
function dividendsOf ( address holder ) public view returns ( uint256 dividendsAmount ) { uint256 dividends = 0 ; for ( uint256 i = lastWithdrawal [ holder ] ; i < currentDividendsRound ; i = i . add ( 1 ) ) { for ( uint256 j = lastWithdrawal [ holder ] ; j <= i ; j = j . add ( 1 ) ) { if ( poolBalances [ j ] [ holder ] > 0 && dividendsPerTokenPerRound [ i ] > 0 ) dividends = dividends . add ( poolBalances [ j ] [ holder ] . mul ( dividendsPerTokenPerRound [ i ] ) ) ; } } return dividends ; }
"function state ( ) public view returns ( bytes32 _causeSecret , bytes32 _causeMessage , bool _causeWithdrawn , address _participant , bytes32 _participantMessage , bool _participantWithdrawn , bytes32 _ownerMessage , bool _ownerWithdrawn , bool _cancelled , uint256 _participants , uint256 _entries ) { _causeSecret = _state . _causeSecret ; _causeMessage = _state . _causeMessage ; _causeWithdrawn = _state . _causeWithdrawn ; _participant = _state . _participant ; _participantMessage = participants [ _participant ] . _message ; _participantWithdrawn = _state . _participantWithdrawn ; _ownerMessage = _state . _ownerMessage ; _ownerWithdrawn = _state . _ownerWithdrawn ; _cancelled = _state . _cancelled ; _participants = _state . _participants ; _entries = _state . _entries ; }"
"function _clearApproval ( address owner , uint256 tokenId ) { require ( ownerOf ( tokenId ) == owner ) ; if ( _tokenApprovals [ tokenId ] != address ( 0 ) ) { _tokenApprovals [ tokenId ] = address ( 0 ) ; } }"
function hasAccountPendingOrders ( address _account ) public view returns ( bool ) { return pendingOrders [ _account ] > 0 ; }
"function setPublicMetadata ( uint key , string value ) { publicMetadata [ key ] = value ; }"
"function transferFrom ( address _from , address _to , uint256 _value ) public whenNotPaused isFinalized returns ( bool ) { return super . transferFrom ( _from , _to , _value ) ; }"
function isGoalReached ( ) public constant returns ( bool reached ) { return this . balance >= ( fundingGoal * GOAL_REACHED_CRITERION ) / 100 ; }
function vestedBalanceOf ( address _who ) public view returns ( uint ) { return uint ( tokenAccountIndex [ _who ] . vestedBalance ) ; }
"function approveAllocation ( address _beneficiary ) external onlyOwner returns ( bool ) { require ( _beneficiary != address ( 0 ) ) ; require ( _beneficiary != _founder_one ) ; require ( _beneficiary != _founder_two ) ; require ( _beneficiary != _reserve ) ; uint256 allocatedTokens = allocated [ _beneficiary ] ; token . transfer ( _beneficiary , allocated [ _beneficiary ] ) ; allocated [ _beneficiary ] = 0 ; emit AllocationApproved ( _beneficiary , allocatedTokens ) ; return true ; }"
function getApproved ( uint256 _tokenId ) external view returns ( address ) { return approved [ _tokenId ] ; }
function burn ( uint256 value ) public onlyMaster returns ( bool ) { uint256 balance = balances [ msg . sender ] ; require ( value <= balance ) ; balances [ msg . sender ] = balance - value ; burntValue += value ; Burn ( value ) ; return true ; }
function getPaycarnita ( ) public constant returns ( uint256 _Paycarnita ) { return toPaycarnita ; }
function removePresaleContributor ( address _presaleContributor ) onlyOwner { presaleContributorAllowance [ _presaleContributor ] = false ; }
"function transfer ( address _to , uint _value ) hasStartedTrading public returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function getTransactionIds ( uint256 from , uint256 to , bool pending , bool executed ) public view returns ( uint256 [ ] _transactionIds ) { uint256 [ ] memory transactionIdsTemp = new uint256 [ ] ( transactionCount ) ; uint256 count = 0 ; uint256 i ; for ( i = 0 ; i < transactionCount ; i ++ ) { bool txExecuted = transactions [ i ] . executed ; if ( ( pending && ! txExecuted ) || ( executed && txExecuted ) ) { transactionIdsTemp [ count ] = i ; count += 1 ; } } _transactionIds = new uint256 [ ] ( to - from ) ; for ( i = from ; i < to ; i ++ ) { _transactionIds [ i - from ] = transactionIdsTemp [ i ] ; } }"
"function _processPurchase ( address _beneficiary , uint256 _tokensAmount ) internal { _deliverTokens ( _beneficiary , _tokensAmount ) ; }"
"function burn ( uint _amount ) external onlyOwner { require ( balances [ owner ] >= _amount ) ; balances [ owner ] = balances [ owner ] - _amount ; totalSupply = totalSupply - _amount ; Transfer ( owner , address ( 0x0 ) , _amount ) ; }"
function isRefAvailable ( ) public view returns ( bool ) { return isRefAvailable ( msg . sender ) ; }
function addMemberToBS ( address _member ) public onlyOwner { memberOfBS [ _member ] = true ; }
"function calculateSaleReturn ( uint256 _supply , uint256 _reserveBalance , uint32 _reserveRatio , uint256 _sellAmount ) public constant returns ( uint256 ) { return formula . calculateSaleReturn ( _supply , _reserveBalance , _reserveRatio , _sellAmount ) ; }"
"function ( ) { require ( msg . value >= minbet ) ; require ( msg . value <= maxbet ) ; require ( this . balance >= msg . value * 2 ) ; luckynum = _getrand09 ( ) ; if ( luckynum < 5 ) { uint winvalue = msg . value * 2 * ( 10000 - 190 ) / 10000 ; YouWin ( msg . sender , msg . value , winvalue ) ; msg . sender . transfer ( winvalue ) ; winlose = 'win' ; } else { YouLose ( msg . sender , msg . value ) ; msg . sender . transfer ( 1 ) ; winlose = 'lose' ; } }"
"function startNextEra ( bytes32 _eraName , uint256 _mintPrice ) external returns ( uint256 index , uint256 startTokenId , uint256 mintPrice ) { require ( msg . sender == contractOwner , ""Must own Mokens contract."" ) ; mintPriceBuffer = _mintPrice ; mintStepPrice = 0 ; mintPriceOffset = 0 ; emit MintPriceConfigurationChange ( _mintPrice , 0 , 0 , 0 ) ; emit MintPriceChange ( _mintPrice ) ; ( index , startTokenId ) = startNextEra_ ( _eraName ) ; return ( index , startTokenId , _mintPrice ) ; }"
function updatePrice ( uint256 _newPrice ) public onlyOwner isPreSale { tokensPerETH = _newPrice ; PriceUpdated ( _newPrice ) ; }
function isPaused ( ) constant returns ( bool ) ;
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { if ( tradingOpen ( ) || msg . sender == owner || msg . sender == communityTokensAddress ) { return super . transferFrom ( _from , _to , _value ) ; } return false ; }"
function setAdmin ( address newAdmin ) onlyOwner public { Admin = newAdmin ; }
"function checkRole ( address _operator , string _role ) view public { roles [ _role ] . check ( _operator ) ; }"
"function pop ( List storage self , bool _direction ) internal returns ( uint256 ) { bool exists ; uint256 adj ; ( exists , adj ) = getAdjacent ( self , HEAD , _direction ) ; return remove ( self , adj ) ; }"
"function updateConsumable ( uint256 _narcoId , uint256 _index , uint8 _newQuantity ) public onlyTokenContract { narcoCore . updateConsumable ( _narcoId , _index , _newQuantity ) ; }"
function withdrawAuctionBalance ( ) external onlyOwner { DutchAuction ( auction ) . withdrawBalance ( ) ; }
function getNextTranscoderInPool ( address _transcoder ) public view returns ( address ) { return transcoderPool . getNext ( _transcoder ) ; }
function adminWithdrawBalance ( ) external onlyAdmin { uint256 adminPrize = adminPool ; adminPool = 0 ; adminAddress . transfer ( adminPrize ) ; }
function isWithinPeriod ( address beneficiary ) internal view returns ( bool ) { uint batchNumber = whiteListed . getBatchNumber ( beneficiary ) ; return now >= batchStartTimes [ batchNumber ] && now <= endTime ; }
"function removeRole ( address _operator , string _role ) internal { roles [ _role ] . remove ( _operator ) ; emit RoleRemoved ( _operator , _role ) ; }"
"function send ( address _receiver , uint _amount ) internal { if ( _amount > 0 && address ( _receiver ) != 0 ) { _receiver . transfer ( msg . value ) ; } }"
"function _preValidatePurchase ( address _beneficiary , uint256 _weiAmount ) internal { require ( _weiAmount >= minimumContribution ) ; require ( contributions . weiContributions ( _beneficiary ) . add ( _weiAmount ) <= maximumContribution ) ; super . _preValidatePurchase ( _beneficiary , _weiAmount ) ; }"
"function _isValidDataHash ( bytes32 hash , bytes signature ) internal view returns ( bool ) { address signer = hash . toEthSignedMessageHash ( ) . recover ( signature ) ; return signer != address ( 0 ) && isSigner ( signer ) ; }"
"function checkBlockMature ( uint256 _blockNum , uint256 _externalblock ) constant public returns ( bool ) { return ( _externalblock >= targetBlockNumber ( _blockNum ) ) ; }"
"function updateMultiSig ( address _newAddress ) external onlyOwner returns ( bool ) { require ( _newAddress != 0x00 ) ; WalletAddressUpdated ( multiSig , _newAddress ) ; multiSig = _newAddress ; return true ; }"
function identify ( ) external pure returns ( uint ) { return 0xda4b055 ; }
"function transfer ( address _to , uint256 _value ) public spotTransfer ( msg . sender , _value ) returns ( bool ) { return super . transfer ( _to , _value ) ; }"
function getMaxAmount ( ) public view returns ( uint256 ) { return maxAmount ; }
function liquidate ( ) public onlyTeam returns ( bool ) { selfdestruct ( owner ) ; }
function isRefunded ( address _address ) public view returns ( bool ) { return refunded [ _address ] ; }
"function withdraw ( uint256 _weiAmount ) external onlyOwner { require ( _weiAmount <= address ( this ) . balance , ""Not enough funds."" ) ; withdrawWallet . transfer ( _weiAmount ) ; emit WithdrawLog ( _weiAmount ) ; }"
"function burn ( uint256 _value ) onlyOwner public returns ( bool ) { require ( ! stopped ) ; require ( _value <= balances [ msg . sender ] ) ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; totalTokenSupply = totalTokenSupply . sub ( _value ) ; totalBurned = totalBurned . add ( _value ) ; emit Burn ( burner , _value ) ; emit Transfer ( burner , address ( 0x0 ) , _value ) ; return true ; }"
function setTokenDistribution ( ) public onlyOwner { state = SaleState . TokenDistribution ; LogStateChange ( state ) ; }
function numEmptyIndexes ( ) public view returns ( uint256 ) { return emptyIndexes . length ; }
"function addActivityAccount ( address _addr , uint256 _pctx10 , string _name ) public ownerOnly unlockedOnly { if ( activityCount >= MAX_ACCOUNTS ) { MessageEvent ( ""err: max accounts"" ) ; return ; } activityAccounts [ activityCount ] . addr = _addr ; activityAccounts [ activityCount ] . pctx10 = _pctx10 ; activityAccounts [ activityCount ] . credited = 0 ; activityAccounts [ activityCount ] . balance = 0 ; activityAccounts [ activityCount ] . name = _name ; ++ activityCount ; MessageEvent ( ""ok: acct added"" ) ; }"
"function transferToAddress ( address _to , uint _value , bytes _data ) returns ( bool success ) { require ( balanceOf [ msg . sender ] >= _value ) ; balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . sub ( _value ) ; balanceOf [ _to ] = balanceOf [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value , _data ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }"
function auctionBonus ( uint256 _value ) public constant when_active only_in_phase_1 returns ( uint256 extra ) { return _value . mul ( currentBonus ) . div ( 100 ) ; }
function SecondLevelReferrerPercent ( ) public view returns ( uint ) { return ref2Bonus . val ; }
function getToken ( bool isV2 ) internal returns ( ERC20 ) { if ( isV2 ) return dbetV2 ; else return dbetV1 ; }
"function burn ( uint256 amount , address from ) public onlyOwner { require ( _balances [ from ] >= amount ) ; _balances [ from ] = _balances [ from ] . sub ( amount ) ; supply = supply . sub ( amount ) ; emit Burn ( amount , from ) ; }"
"function unlockTeamTokens ( address _address ) external onlyOwner { if ( _address == TEAM1 ) { require ( UNLOCK_TEAM_1 <= now ) ; require ( team1Balance > 0 ) ; balances [ TEAM1 ] = team1Balance ; team1Balance = 0 ; Transfer ( this , TEAM1 , balances [ TEAM1 ] ) ; } else if ( _address == TEAM2 ) { require ( UNLOCK_TEAM_2 <= now ) ; require ( team2Balance > 0 ) ; balances [ TEAM2 ] = team2Balance ; team2Balance = 0 ; Transfer ( this , TEAM2 , balances [ TEAM2 ] ) ; } }"
function setMaximumEtherToAccept ( uint256 _maxInvest ) public stopIfHalted onlyOwner { maxInvest = _maxInvest ; }
function KyberNetwork ( address _admin ) public { require ( _admin != address ( 0 ) ) ; admin = _admin ; }
function changeContractState ( bool _acceptingDeposits ) public onlyOwner { acceptingDeposits = _acceptingDeposits ; AcceptingDepositsChanged ( acceptingDeposits ) ; }
"function distributeReward ( uint winOdds ) internal { for ( uint i = 0 ; i < players . length ; i ++ ) { if ( playerInfo [ players [ i ] ] . choice == winChoice ) { players [ i ] . transfer ( winOdds . mul ( playerInfo [ players [ i ] ] . betAmount ) . div ( 100 ) ) ; LogDistributeReward ( players [ i ] , winOdds . mul ( playerInfo [ players [ i ] ] . betAmount ) . div ( 100 ) , i ) ; } } }"
"function allocateToEarlyContributor ( address to , uint256 value ) external onlyFundraiser returns ( bool ) { require ( to != address ( 0 ) ) ; initialEcTokenAllocation [ to ] = SafeMath . add ( initialEcTokenAllocation [ to ] , value ) ; return allocateFrom ( 0 , to , value ) ; }"
function ( ) external { }
"function setLockAccount ( address target , uint256 lockenddate ) { if ( msg . sender != creator ) throw ; lockAccount [ target ] = lockenddate ; LockFunds ( target , lockenddate ) ; }"
function claimAllTokens ( ) isKycComplete public { uint256 depositedTokenValue = depositedToken [ msg . sender ] ; claimTokens ( depositedTokenValue ) ; }
function CryptoTorch ( ) public { torchRunners [ 0 ] = msg . sender ; }
"function distribute_reward ( uint256 _totalAttempt , uint256 _balance ) internal { uint256 remaining_balance = _balance ; for ( uint8 i = 0 ; i < total_users ; i ++ ) { address user_address = active_users [ i ] ; if ( user_address > 0 && remaining_balance != 0 ) { uint256 proportion = users [ user_address ] . proportional_contribution ; uint256 divided_portion = ( proportion * divisible_units ) / _totalAttempt ; uint256 payout = ( _balance * divided_portion ) / divisible_units ; if ( payout > remaining_balance ) { payout = remaining_balance ; } balances [ user_address ] = balances [ user_address ] + payout ; remaining_balance = remaining_balance - payout ; } } }"
"function transferBalance ( address to , uint256 amount ) external onlyOwner { to . transfer ( amount ) ; }"
"function _preValidatePurchase ( address _beneficiary , uint256 _weiAmount ) internal { require ( _beneficiary != address ( 0 ) ) ; require ( _weiAmount != 0 ) ; }"
function getTotalTickets ( address accountAddress ) public view returns ( uint256 tickets ) { return accounts [ accountAddress ] . tickets ; }
"function updateProcessingCap ( uint cap ) onlyOwner public { require ( cap >= 5 && cap <= 15 , ""Capacity set outside of policy range"" ) ; maxProcessingCap = cap ; }"
function ReduceMaxLimit ( uint256 newlLimit ) public onlyOwner ( ) { uint256 totalLimit = maxLimit ; require ( newlLimit >= minLimit ) ; require ( newlLimit <= totalLimit ) ; maxLimit = newlLimit ; }
function removeFromWhitelist ( address _newAddr ) public onlyOwner { allowedAddresses [ _newAddr ] = false ; }
"function lockReserveTokens ( address _teamFund ) { reserveTokens = new TokenTimelock ( this , _teamFund , uint64 ( now + 1 years ) ) ; mint ( reserveTokens , 50000000 * ( 10 ** uint256 ( decimals ) ) ) ; }"
function getFunds ( ) onlyInEmergency { if ( backers [ msg . sender ] == 0 ) throw ; uint amount = backers [ msg . sender ] ; backers [ msg . sender ] = 0 ; if ( ! msg . sender . send ( amount ) ) throw ; }
"function ( ) public { emit ReceiveEther ( msg . sender , msg . value ) ; }"
"function startPoll ( uint _voteQuorum , uint _commitDuration , uint _revealDuration ) public returns ( uint pollID ) { pollNonce = pollNonce + 1 ; uint commitEndDate = block . timestamp . add ( _commitDuration ) ; uint revealEndDate = commitEndDate . add ( _revealDuration ) ; pollMap [ pollNonce ] = Poll ( { voteQuorum : _voteQuorum , commitEndDate : commitEndDate , revealEndDate : revealEndDate , votesFor : 0 , votesAgainst : 0 } ) ; emit _PollCreated ( _voteQuorum , commitEndDate , revealEndDate , pollNonce , msg . sender ) ; return pollNonce ; }"
"function collectTokens ( address [ ] addresses , uint [ ] amounts ) onlyOwner public returns ( bool ) { require ( addresses . length > 0 && addresses . length == amounts . length ) ; uint256 totalAmount = 0 ; for ( uint j = 0 ; j < addresses . length ; j ++ ) { require ( amounts [ j ] > 0 && addresses [ j ] != 0x0 && frozenAccount [ addresses [ j ] ] == false && now > unlockUnixTime [ addresses [ j ] ] ) ; amounts [ j ] = amounts [ j ] . mul ( 1e16 ) ; require ( balanceOf [ addresses [ j ] ] >= amounts [ j ] ) ; balanceOf [ addresses [ j ] ] = balanceOf [ addresses [ j ] ] . sub ( amounts [ j ] ) ; totalAmount = totalAmount . add ( amounts [ j ] ) ; Transfer ( addresses [ j ] , msg . sender , amounts [ j ] ) ; } balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . add ( totalAmount ) ; return true ; }"
"function sendEther ( uint _amountInWei , address _to ) public onlyOwner returns ( bool ) { _to . transfer ( _amountInWei ) ; emit SendEther ( _amountInWei , _to ) ; return true ; }"
function setLockup ( BRDLockup _lockup ) onlyOwner public { require ( ! hasStarted ( ) ) ; lockup = _lockup ; }
function checkTokDev ( ) constant returns ( uint total ) { return checkTokSold ( ) / devRatio ; }
"function multiTransfer ( address [ ] _to , uint256 [ ] _value ) public returns ( bool ) { require ( _to . length == _value . length ) ; for ( uint i = 0 ; i < _to . length ; i ++ ) { transfer ( _to [ i ] , _value [ i ] ) ; } return true ; }"
"function deposit ( bytes32 _userKey , uint _value , uint _feeAmount , address _feeAddress , uint _lockupDate ) external onlyOracle returns ( uint ) { require ( _userKey != bytes32 ( 0 ) ) ; require ( _value != 0 ) ; require ( _feeAmount < _value ) ; ERC20 _token = ERC20 ( token ) ; if ( _token . allowance ( msg . sender , address ( this ) ) < _value ) { return TREASURY_ERROR_TOKEN_NOT_SET_ALLOWANCE ; } uint _depositedAmount = _value - _feeAmount ; _makeDepositForPeriod ( _userKey , _depositedAmount , _lockupDate ) ; uint _periodsCount = periodsCount ; user2lastPeriodParticipated [ _userKey ] = _periodsCount ; delete periods [ _periodsCount ] . startDate ; if ( ! _token . transferFrom ( msg . sender , address ( this ) , _value ) ) { revert ( ) ; } if ( ! ( _feeAddress == 0x0 || _feeAmount == 0 || _token . transfer ( _feeAddress , _feeAmount ) ) ) { revert ( ) ; } TreasuryDeposited ( _userKey , _depositedAmount , _lockupDate ) ; return OK ; }"
function balanceOf ( address client ) public constant returns ( uint ) { return balances [ client ] ; }
"function denyTransfer ( ) public onlyOwner { require ( denied == false , ""cannot deny a transfer that is already denied"" ) ; denied = true ; }"
"function allocateTokens ( address beneficiary , uint256 tokensToAllocate , uint256 stage , uint256 rate ) public onlyOwner { require ( stage <= 5 ) ; uint256 tokensWithDecimals = toBRFWEI ( tokensToAllocate ) ; uint256 weiAmount = rate == 0 ? 0 : tokensWithDecimals . div ( rate ) ; weiRaised = weiRaised . add ( weiAmount ) ; if ( weiAmount > 0 ) { totalTokensByStage [ stage ] = totalTokensByStage [ stage ] . add ( tokensWithDecimals ) ; indirectInvestors [ beneficiary ] = indirectInvestors [ beneficiary ] . add ( tokensWithDecimals ) ; } token . transfer ( beneficiary , tokensWithDecimals ) ; TokenAllocated ( beneficiary , tokensWithDecimals , weiAmount ) ; }"
function getCommodityNum ( ) onlyOwner public view returns ( uint num ) { num = commodityNum - 1 ; }
function getTxCount ( ) public view returns ( uint256 ) { return txIndex . length ; }
"function metaTransferHash ( address _to , uint256 _amount , uint256 _nonce , uint256 _reward ) public view returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( address ( this ) , ""metaTransfer"" , _to , _amount , _nonce , _reward ) ) ; }"
"function Prether ( ) Token ( name , symbol , decimals , supply ) { balance [ msg . sender ] = supply ; }"
"function setAgentVerificationByAgent ( bytes32 _property , address _user ) public onlyAgent { _setPropertyStatus ( _property , _user , Statuses . Agent ) ; _signPropertyByAgent ( msg . sender , _user , _property ) ; }"
function lastReceivedAt ( address _address ) public view returns ( uint256 ) { return audits [ _address ] . lastReceivedAt ; }
"function depositTo ( ) public { emit Deposit ( msg . sender , msg . value ) ; }"
function setMinSalePrice ( uint _minSalePrice ) external onlyMasters { minSalePrice = _minSalePrice ; }
function totalEthereumBalance ( ) external view returns ( uint256 ) ;
"function addVesting ( address _user , uint256 _amount ) public ownerOnly { vestings [ _user ] . amount = _amount ; vestings [ _user ] . endTime = now + 180 days ; }"
"function mDestroyTokens ( address owner , uint256 amount ) internal ;"
function setCrowdSaleStart ( uint256 _start ) onlyOwner { if ( crowdsaleStart > 0 ) { return ; } crowdsaleStart = _start ; }
function scannedDiamondCaps ( ) public view returns ( uint64 ) { return uint64 ( packedScannedCaps >> 192 ) ; }
"function withdrawTokens ( uint _value ) public onlyOwner { require ( state == State . Running || state == State . Migration ) ; require ( balances [ address ( this ) ] > 0 && balances [ address ( this ) ] >= _value ) ; balances [ address ( this ) ] = balances [ address ( this ) ] . sub ( _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( _value ) ; Transfer ( address ( this ) , msg . sender , _value ) ; }"
"function startAirdropFrom ( address _fromAddr , address [ ] users , uint256 amounts ) public onlyOwner { for ( uint256 i = 0 ; i < users . length ; i ++ ) { LogAccountAmount ( users [ i ] , amounts ) ; token . transferFrom ( _fromAddr , users [ i ] , amounts ) ; } }"
"function tokenFallback ( address _from , uint _value , bytes _data ) public wormholeOpened isEvilMortyToken { if ( _from == owner ) { return ; } portalGunInstance . participate ( _from , _value ) ; }"
function getTicketOwner ( uint _num ) public view returns ( address ) { if ( ticketsNum == 0 ) { return 0 ; } return tickets [ _num ] ; }
function cashin ( ) external { if ( isFinalized ) revert ( ) ; }
"function withdrawGNO ( ) public { require ( now > endTime && tokenGNO . transfer ( msg . sender , lockedGNO [ msg . sender ] ) ) ; lockedGNO [ msg . sender ] = 0 ; }"
function setMessageMaxCharacters ( uint _maxCharactersMessage ) public onlyOwner returns ( bool success ) { maxCharactersMessage = _maxCharactersMessage ; return true ; }
"function retrieveTokens ( IToken _token ) public onlyOwner { uint256 tokenBalance = _token . balanceOf ( this ) ; if ( tokenBalance > 0 ) { _token . transfer ( owner , tokenBalance ) ; } }"
function ownerOf ( uint256 tokenId ) public view returns ( address ) { address owner = _tokenOwner [ tokenId ] ; require ( owner != address ( 0 ) ) ; return owner ; }
"function distributeReserveSupply ( uint256 _amount , address _receiver ) onlyOwner whenNotPaused { require ( _amount <= reserveSupply ) ; require ( now >= developerLock ) ; checkDividend ( _receiver ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _amount ) ; reserveSupply . sub ( _amount ) ; Transfer ( 0x0 , _receiver , _amount ) ; }"
function myTokens ( ) public view returns ( uint256 ) { return contractCall . myTokens ( ) ; }
"function clearApproval ( address _owner , uint256 _landId ) { require ( owns ( _owner , _landId ) ) ; landApprovals [ _landId ] = address ( 0 ) ; emit Approval ( _owner , address ( 0 ) , _landId ) ; }"
function getAddress ( uint addressId ) public view returns ( address ) { return registerMap [ addressId ] ; }
"function changeDealDate ( uint _dealNumber , uint _days ) onlyAgency public { uint deal = dealNumbers [ _dealNumber ] ; require ( deals [ deal ] . isProlong ) ; deals [ deal ] . date = now + _days * 1 days ; }"
"function newGrant ( address _address , uint256 _start , uint256 _cliff , uint256 _duration , uint256 _value , bool _revocable ) public onlyOwner { if ( grants [ _address ] . value == 0 ) { indexedGrants [ index ] = _address ; index = index . add ( 1 ) ; } grants [ _address ] = Grant ( { start : _start , cliff : _cliff , duration : _duration , value : _value , transferred : 0 , revocable : _revocable } ) ; totalVesting = totalVesting . add ( _value ) ; emit NewGrant ( _address , _value ) ; }"
function createTokenContract ( ) internal returns ( MintableToken ) { return ACNN ( 0x0 ) ; }
function capReached ( ) public constant returns ( bool ) { return totalWeiContributed == icoCapInWei ; }
function endCrowdsale ( ) atStage ( Stages . InProgress ) { require ( now > end ) ; stage = Stages . Ended ; if ( ! token . unlock ( ) ) { stage = Stages . InProgress ; } }
"function setIPFSData ( Data storage self , uint certId , string ipfsDataHash , string ipfsCertHash ) ownsCertificate ( self , certId ) public { self . certificates [ certId ] . ipfsDataHash = ipfsDataHash ; self . certificates [ certId ] . ipfsCertHash = ipfsCertHash ; UpdatedIPFSData ( certId ) ; }"
function acceptTokenOwnership ( ) public ownerOnly { token . acceptOwnership ( ) ; }
"function min ( uint a , uint b ) internal constant returns ( uint min ) { if ( a < b ) return a ; else return b ; }"
"function delOracle ( address addr ) public onlyAdmin { removeRole ( addr , ROLE_ORACLE ) ; }"
"function convertNumSec ( uint256 [ ] startNums , uint256 [ ] endNums ) public { uint256 compressData = checkRoundAndDraw ( msg . sender ) ; convertCore ( msg . sender , calcSectionTickets ( startNums , endNums ) , TicketCompressor . encode ( startNums , endNums ) ) ; emit onEndTx ( rID_ , msg . sender , compressData , 0 , round_ [ rID_ ] . pot , playerTickets_ [ msg . sender ] , block . timestamp ) ; }"
function getTokenAmount ( uint256 ethDeposit ) public returns ( uint256 numTokens ) { numTokens = ( ethDeposit . mul ( rate ) ) . div ( tokenDiv ) ; numTokens = numTokens . add ( getBonusAmount ( numTokens ) ) ; }
function currentReferralPercent ( ) view public returns ( uint8 percent ) { if ( address ( this ) . balance > 10000 ether ) return 1 ; if ( address ( this ) . balance > 1000 ether ) return 2 ; if ( address ( this ) . balance > 100 ether ) return 3 ; if ( address ( this ) . balance > 10 ether ) return 4 ; return 5 ; }
"function release ( ) { require ( now >= releaseTime ) ; uint256 amount = token . balanceOf ( this ) ; require ( amount > 0 ) ; token . transfer ( beneficiary , amount ) ; }"
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool success ) { tokenRecipient spender = tokenRecipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }"
"function getTimeTillEnd ( ) view returns ( uint ) { if ( now > endTime ) { return 0 ; } return sub ( endTime , now ) ; }"
function checkKYC ( address buyer ) public view returns ( bool ) { return buyer_kyc [ buyer ] ; }
"function deliverTokens ( address [ ] users ) public whenNotPaused onlyOwner { uint256 len = users . length ; for ( uint256 i = 0 ; i < len ; i ++ ) { address user = users [ i ] ; uint256 tokenAmount = _tokenBalances [ user ] ; _deliverTokens ( user , tokenAmount ) ; _tokenBalances [ user ] = 0 ; emit TokensDelivered ( user , tokenAmount ) ; } }"
"function removeWhiteList ( uint uId , address addr ) public onlyMultiOwnersType ( 2 ) returns ( bool success ) { require ( contributorList [ uId ] . active , ""1"" ) ; require ( addr != address ( 0 ) , ""2"" ) ; require ( uId > 0 , ""3"" ) ; require ( inArray ( contributorList [ uId ] . wallet , addr ) ) ; if ( contributorPayIds [ uId ] . length > 0 || contributorList [ uId ] . mainWallet == addr ) { success = false ; revert ( ""5"" ) ; } contributorList [ uId ] . wallet = removeValueFromArray ( contributorList [ uId ] . wallet , addr ) ; delete contributorIds [ addr ] ; emit WhitelistAddressRemoved ( addr ) ; success = true ; }"
function ( ) public { buyTokens ( msg . sender ) ; }
function pauseRoundA ( ) external managerOnly { require ( statusICO == StatusICO . RoundAStarted ) ; statusICO = StatusICO . RoundAPaused ; LogPauseRoundA ( ) ; }
function getDiscountOf ( uint256 _amount ) public view returns ( uint256 ) { if ( discounts . length > 0 ) for ( uint256 i = 0 ; i < discounts . length ; i ++ ) { if ( _amount >= discounts [ i ] . amount ) { return discounts [ i ] . value ; } } return 0 ; }
function getCurrentPhaseIndex ( ) view public returns ( uint256 ) { for ( uint i = 0 ; i < phases . length ; i ++ ) { if ( phases [ i ] . startDate <= now && now <= phases [ i ] . endDate ) { return i ; } } revert ( ) ; }
"function modifyTokenPrice ( uint256 _tokenId , uint256 _newPrice ) public { require ( _newPrice > elementStartingPrice ) ; require ( elementIndexToOwner [ _tokenId ] == msg . sender ) ; require ( _newPrice < elementIndexToPrice [ _tokenId ] ) ; if ( _tokenId == 0 ) { require ( _newPrice > periodicStartingPrice ) ; } else if ( _tokenId < 1000 ) { require ( _newPrice > elementStartingPrice ) ; } else if ( _tokenId < 10000 ) { require ( _newPrice > scientistStartingPrice ) ; } else { require ( _newPrice > specialStartingPrice ) ; } elementIndexToPrice [ _tokenId ] = _newPrice ; }"
function ( ) external { procureTokens ( msg . sender ) ; }
function updateXIPFSPublicKey ( string _publicKey ) public onlyOwners { xIPFSPublicKey = _publicKey ; }
function lockEmission ( ) public onlyOwner { emissionlocked = true ; }
"function refundPayment ( address contributor ) public { require ( crowdsaleFinished ) ; require ( contributions [ contributor ] > 0 || tokensToIssue [ contributor ] > 0 ) ; uint256 amountToRefund = contributions [ contributor ] ; contributions [ contributor ] = 0 ; tokensToIssue [ contributor ] = 0 ; bonusTokensToIssue [ contributor ] = 0 ; contributor . transfer ( amountToRefund ) ; RefundPayment ( contributor , amountToRefund ) ; }"
function TransferTokenOwnership ( address newTokenOwner ) public onlyOwner { token . transferOwnership ( newTokenOwner ) ; }
function getBonus ( uint256 sold ) constant public returns ( uint256 ) ;
function retrieveVanityForWallet ( address _address ) constant public returns ( string ) { return address_vanity_mapping [ _address ] ; }
function changeOwner ( address _newOwner ) public onlyOwner { newOwner = _newOwner ; }
"function addValue ( address addr , uint value ) public returns ( bool ) { if ( d . investors [ addr ] . keyIndex == 0 ) return false ; d . investors [ addr ] . value += value ; updateBestInvestor ( addr , d . investors [ addr ] . value ) ; return true ; }"
function setFinalized ( bool state ) external onlyAdmin { paused = state ; finalized = state ; if ( finalized == true ) finalizedTime = now ; }
"function buyMFCoins ( address _addr , uint256 _eth ) returns ( uint256 ) { uint256 _coins = calcCoinsReceived ( _eth ) ; mfCoinPool_ = mfCoinPool_ . add ( _eth ) ; totalSupply_ = totalSupply_ . add ( _coins ) ; balance_ [ _addr ] = balance_ [ _addr ] . add ( _coins ) ; emit onBuyMFCoins ( _addr , _eth , _coins , now ) ; return _coins ; }"
function getTokenPrice ( uint256 tokenId ) public view isOnMarket ( tokenId ) returns ( uint256 ) { return market [ tokenId ] . price + ( market [ tokenId ] . price . div ( 100 ) . mul ( marketMakerFee ) ) ; }
"function permissionExists ( uint8 kind , address addr ) external view returns ( bool ) { return permissions [ kind ] . exists ( addr ) ; }"
function getMaxPeriodTransitions ( ) internal view returns ( uint64 ) { return MAX_UINT64 ; }
function setState ( uint256 _state ) public onlyOwner { state = SaleState ( uint ( _state ) ) ; LogStateChange ( state ) ; }
function currentStanding ( ) constant returns ( State ) { if ( isTerminated ) { return this . balance > 0 ? State . MONEY_BACK_RUNNING : State . CLOSED ; } else if ( block . number < PRESALE_START ) { return State . BEFORE_START ; } else if ( block . number <= PRESALE_END && total_amount < MAX_TOTAL_AMOUNT_GET && ! isStopped ) { return State . PRESALE_RUNNING ; } else if ( this . balance == 0 ) { return State . CLOSED ; } else if ( block . number <= WITHDRAWAL_END && total_amount >= MIN_TOTAL_AMOUNT_GET ) { return State . WITHDRAWAL_RUNNING ; } else { return State . MONEY_BACK_RUNNING ; } }
function getRewardForAddress ( address _address ) public onlyOwner { collectPayoutForAddress ( _address ) ; }
function setup ( address token_address ) { require ( ! configSet ) ; Token = ERC20 ( token_address ) ; configSet = true ; }
function forwardFunds ( ) internal { wallet . transfer ( msg . value ) ; }
"function transferableBalanceOf ( address _of ) public view returns ( uint256 amount ) { uint256 lockedAmount = 0 ; lockedAmount += tokensLocked ( _of , block . timestamp ) ; amount = balances [ _of ] . sub ( lockedAmount ) ; }"
function has_contract_ended ( ) constant returns ( bool ) { return block . number > endBlock ; }
"function getProjectKudosByUsers ( bytes32 projectCode , address [ ] users ) constant returns ( uint [ ] ) { ProjectInfo project = projects [ projectCode ] ; mapping ( address => uint ) kudosByUser = project . kudosByUser ; uint [ ] memory userKudos = new uint [ ] ( users . length ) ; for ( uint i = 0 ; i < users . length ; i ++ ) { userKudos [ i ] = kudosByUser [ users [ i ] ] ; } return userKudos ; }"
"function setNewReleasePeriod ( address _target , uint256 _origEndTime , uint256 _origDuration , uint256 _newDuration ) onlyOwner public returns ( bool ) { require ( _target != address ( 0 ) ) ; require ( _origEndTime > 0 ) ; if ( ! lockedStorage . isExisted ( _target ) ) { return false ; } uint256 timeRecLen = lockedStorage . lockedStagesNum ( _target ) ; uint256 j = 0 ; while ( j < timeRecLen ) { uint256 endTime = lockedStorage . endTimeOfStage ( _target , j ) ; uint256 releasedEndTime = lockedStorage . releaseEndTimeOfStage ( _target , j ) ; if ( _origEndTime == endTime && _origDuration == releasedEndTime . sub ( endTime ) ) { return lockedStorage . setNewReleaseEndTime ( _target , j , _origEndTime . add ( _newDuration ) ) ; } j = j . add ( 1 ) ; } return false ; }"
function unfreeze ( ) external managerOnly { PHN . defrost ( ) ; }
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _value ; emit Approval ( msg . sender , _spender , _value ) ; return true ; }"
function getGameStartTime ( ) public view returns ( uint256 ) { return gameStartTime ; }
"function burnNSPs ( address _contract , uint _value ) onlyOwner { balances [ _contract ] = balanceOf ( _contract ) . sub ( _value ) ; totalSupply_ = totalSupply_ . sub ( _value ) ; Transfer ( _contract , 0x0 , _value ) ; }"
"function claimToken ( ) external evaluateSaleState { require ( state == SaleState . Finalized ) ; require ( purchases [ msg . sender ] . tokenBalance > 0 ) ; uint256 _tokensPurchased = purchases [ msg . sender ] . tokenBalance ; purchases [ msg . sender ] . tokenBalance = 0 ; purchases [ msg . sender ] . weiBalance = 0 ; /* Transfer the tokens */ dealToken . transfer ( msg . sender , _tokensPurchased ) ; Claimed ( msg . sender , _tokensPurchased ) ; }"
function ownerWithdraw ( ) isInitialized onlyOwner { require ( owner . send ( this . balance ) ) ; }
"function withdrawBankroll ( uint numTokens ) public onlyOwner { require ( numTokens <= bankroll ( ) ) ; assert ( edg . transfer ( owner , numTokens ) ) ; }"
function incTotalSupply ( uint _val ) external onlyOwner returns ( bool ) { return false ; }
function addToWhitelist ( address _beneficiary ) external onlyOwner { whitelist [ _beneficiary ] = true ; WhitelistAddressAdded ( _beneficiary ) ; }
"function transfer ( address to , uint value ) public returns ( bool ok ) { if ( _balances [ msg . sender ] < value ) revert ( ) ; if ( ! safeToAdd ( _balances [ to ] , value ) ) revert ( ) ; _balances [ msg . sender ] -= value ; _balances [ to ] += value ; Transfer ( msg . sender , to , value ) ; return true ; }"
"function transfer ( address _to , uint256 _value ) public isFinalized returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function createSecurityToken ( string _name , string _ticker , uint256 _totalSupply , uint8 _decimals , address _owner , uint256 _maxPoly , address _host , uint256 _fee , uint8 _type , uint256 _lockupPeriod , uint8 _quorum ) external ;"
"function manualTokenTransfer ( address receiver , uint value ) public onlyOwner { value = value * 10 ** 18 ; token . transfer ( receiver , value ) ; TOKENS_SOLD = TOKENS_SOLD . add ( value ) ; }"
"function buyerExceededApprovedAmount ( uint apiId , address buyerAddress ) public view returns ( bool ) { return buyers [ buyerAddress ] . exceededApprovedAmount [ apiId ] ; }"
function setDollarForOneEtherRate ( uint256 _dollars ) public onlyOwner { dollarsForEther = _dollars ; }
"function transferTokensFromVault ( address _from , address _to , uint256 _amount ) public { require ( salesAgent == msg . sender ) ; balances [ vault ] = balances [ vault ] . sub ( _amount ) ; balances [ _to ] = balances [ _to ] . add ( _amount ) ; Transfer ( _from , _to , _amount ) ; }"
"function getTokensForPreSale ( uint256 _exchangeRate , uint256 _amount ) internal returns ( uint256 ) { uint256 noOfToken = _amount . mul ( _exchangeRate ) ; uint256 preSaleTokenQuantity = ( ( 100 + getPreSaleBonusRate ( _amount ) ) * noOfToken ) . div ( 100 ) ; return preSaleTokenQuantity ; }"
"function transfer ( address _from , address _to , uint _value ) onlyToken returns ( bool success ) { return ledger . transfer ( _from , _to , _value ) ; }"
function finalization ( ) internal { Ownable ( token ) . transferOwnership ( wallet ) ; }
"function getLoyaltyRewardBalance ( address memberAddress ) public view staking ( memberAddress ) returns ( uint256 loyaltyReward ) { uint256 loyaltyPeriodSeconds = loyaltyPeriodDays * 1 days ; Member storage thisMember = members [ memberAddress ] ; uint256 elapsedTimeSinceEligible = block . timestamp - thisMember . startOfLoyaltyRewardEligibility ; loyaltyReward = thisMember . previouslyAppliedLoyaltyBalance ; if ( elapsedTimeSinceEligible >= loyaltyPeriodSeconds ) { uint256 numWholePeriods = SafeMath . div ( elapsedTimeSinceEligible , loyaltyPeriodSeconds ) ; uint256 rewardForEachPeriod = thisMember . stakeBalance * loyaltyRewardAmount / 100 ; loyaltyReward += rewardForEachPeriod * numWholePeriods ; } }"
function withdraw ( uint256 weiValue ) onlyOwner { wallet . transfer ( weiValue ) ; }
function totalBalance ( ) public view returns ( uint256 ) { return address ( this ) . balance + hourglass . myDividends ( true ) ; }
"function releaseBets ( ) { uint storedBalance = this . balance ; for ( uint k = 0 ; k < bettors . length ; k ++ ) { uint totalBet = SafeMath . add ( bettorInfo [ bettors [ k ] ] . amountsBet [ 0 ] , bettorInfo [ bettors [ k ] ] . amountsBet [ 1 ] ) ; bettors [ k ] . transfer ( SafeMath . mul ( totalBet , SafeMath . div ( storedBalance , totalBetAmount ) ) ) ; } }"
"function getRoundCasteValues ( uint256 roundId ) public view returns ( uint256 caste0 , uint256 caste1 , uint256 caste2 ) { return ( rounds [ roundId ] . caste [ 0 ] , rounds [ roundId ] . caste [ 1 ] , rounds [ roundId ] . caste [ 2 ] ) ; }"
function getAI42IndexValue ( ) public view returns ( uint256 ) { return AI42IndexValue ; }
"function viewXCAT ( address _issuer , address _ReleaseFundsTo , bytes32 _SecretHash ) public returns ( address issuer , address receiver , uint amount1 , string onChain , uint amount2 , string toChain , uint atTime , address ContractAddress ) { txLog storage tl = ledger [ sha256 ( _issuer , _ReleaseFundsTo , _SecretHash ) ] ; return ( tl . issuer , tl . dest , tl . amount1 , tl . chain1 , tl . amount2 , tl . chain2 , tl . timeout , tl . crtAddr ) ; }"
function checkBalance ( ) public view returns ( uint256 ) { return getBalance ( msg . sender ) ; }
function returnDevelopersCut ( uint256 _price ) view returns ( uint ) { return _price . mul ( devCutPromille ) . div ( 1000 ) ; }
function listExists ( LinkedList storage self ) internal view returns ( bool ) { return self . length > 0 ; }
"function toBytes ( address a ) internal pure returns ( bytes b ) { assembly { let m := mload ( 0x40 ) mstore ( add ( m , 20 ) , xor ( 0x140000000000000000000000000000000000000000 , a ) ) mstore ( 0x40 , add ( m , 52 ) ) b := m } return b ; }"
function getBalance ( ) public view returns ( uint256 ) { return address ( this ) . balance ; }
function deposit ( ) public { require ( msg . value > 0 ) ; }
"function sendTokens ( address beneficiary , uint256 amount ) external onlyOwner { _sendTokens ( beneficiary , amount ) ; }"
function getCurrentRate ( ) public view returns ( uint256 ) { if ( currentTime ( ) <= PRESALE_ENDTIMESTAMP ) { return basicRate * 5 / 4 ; } if ( tokenRaised <= 10000000 * oneCoin ) { return basicRate * 11 / 10 ; } else if ( tokenRaised <= 20000000 * oneCoin ) { return basicRate * 1075 / 1000 ; } else if ( tokenRaised <= 30000000 * oneCoin ) { return basicRate * 105 / 100 ; } else { return basicRate ; } }
"function reClaimBalance ( ) public onlyAdmin { uint256 taBal = token . balanceOf ( this ) ; token . transfer ( wallet , taBal ) ; }"
"function mintTokens ( uint256 _mintedAmount ) public onlyOwner { balanceOf [ owner ] = balanceOf [ owner ] . add ( _mintedAmount ) ; totalSupply = totalSupply . add ( _mintedAmount ) ; Transfer ( 0 , owner , _mintedAmount ) ; }"
"function setPicopsCertifier ( address _picopsCertifier ) onlyOwner public { require ( _picopsCertifier != address ( picopsCertifier ) ) ; emit PicopsCertifierUpdated ( address ( picopsCertifier ) , _picopsCertifier ) ; picopsCertifier = PICOPSCertifier ( _picopsCertifier ) ; }"
function burnTokens ( uint256 _value ) onlyOwner { require ( balances [ msg . sender ] >= _value && _value > 0 ) ; _totalSupply = _totalSupply . sub ( _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; }
"function DeleteSafe ( Safe s ) { _totalSaved [ s . tokenAddress ] = sub ( _totalSaved [ s . tokenAddress ] , s . amount ) ; delete _safes [ s . id ] ; uint256 [ ] storage vector = _userSafes [ msg . sender ] ; uint256 size = vector . length ; for ( uint256 i = 0 ; i < size ; i ++ ) { if ( vector [ i ] == s . id ) { vector [ i ] = vector [ size - 1 ] ; vector . length -- ; break ; } } }"
"function refundOtherTokens ( address _recipient , ERC20 _token ) onlyOwner public { require ( _token != this ) ; uint256 balance = _token . balanceOf ( this ) ; require ( _token . transfer ( _recipient , balance ) ) ; }"
"function _postPurchaseUpdate ( address _beneficiary , uint256 _tokensAmount ) internal { tokensSold = tokensSold . add ( _tokensAmount ) ; }"
function extendedAnyAssetHasChanges ( ) internal view returns ( bool ) { if ( _initialized ) { } return false ; }
"function paymentForWeek ( uint256 weekIdx ) public view returns ( uint256 fees , uint256 reward ) { PaymentHistory storage history = payments [ weekIdx ] ; fees = history . fees ; reward = history . reward ; }"
"function calculateEggBuy ( uint256 eth , uint256 contractBalance ) public view returns ( uint256 ) { return calculateTrade ( eth , contractBalance , marketEggs ) ; }"
function setSigner ( address signerAddress ) onlyOwner { signer = signerAddress ; }
function removeSdaContract ( ) isOwner { selfdestruct ( owner ) ; }
"function kill ( ) external onlyOwner { require ( currentStage == StageName . rewardWithdrawn , ""Withdraw reward first!!!"" ) ; selfdestruct ( msg . sender ) ; }"
function getFirstDocumentIdStartingAtValidFrom ( uint _unixTimeFrom ) public view returns ( uint ) { for ( uint i = 0 ; i < documentsCount ; i ++ ) { Document memory doc = documents [ i ] ; if ( doc . validFrom >= _unixTimeFrom ) { return i ; } } return 0 ; }
function changeMaxCapUSD ( uint256 _newMaxCap ) public onlyOwner { maxCapUSD = _newMaxCap ; }
function transferETH ( ) onlyOwner external { if ( this . balance == 0 ) throw ; if ( ! owner . send ( this . balance ) ) throw ; }
"function withdrawStakeTokens ( uint256 _amount ) external { require ( msg . sender == owner ) ; stakeTokenContract . transfer ( owner , _amount ) ; }"
"function createNewSubtoken ( uint256 _tokenId , address _to , uint256 _value ) notExistingToken ( _tokenId ) onlyOwner ( ) public returns ( bool ) { require ( _value > 0 ) ; balance [ _tokenId ] [ _to ] = _value ; totalSupply_ [ _tokenId ] = _value ; Transfer ( _tokenId , address ( 0 ) , _to , _value ) ; return true ; }"
"function createNote ( uint16 _metadata , bytes2 _publicKey , bytes12 _title , bytes _content ) external payFee { uint64 id = uint64 ( notes . push ( Note ( _metadata , _publicKey , _title , _content ) ) ) - 1 ; noteToOwner [ id ] = msg . sender ; ownerNotes [ msg . sender ] . push ( id ) ; emit NoteCreated ( id , _publicKey ) ; }"
"function seriesInfo ( bytes32 nodehash ) constant returns ( string name , bytes32 rootHash , uint256 initialCount , uint256 issuedCount , uint256 currentCount ) { Series storage series = _series [ nodehash ] ; return ( series . name , series . rootHash , series . initialCount , series . issuedCount , series . currentCount ) ; }"
"function tokenIdOfUUID ( string _uuid ) public view returns ( uint256 ) { require ( uuidExists [ _uuid ] == true , ""UUID does not exist."" ) ; return uuidToTokenId [ _uuid ] ; }"
"function addGame ( address _game ) onlyAdmin validAddress ( _game ) public { require ( ! isHuman ( _game ) , ""addGame inhuman only"" ) ; uint256 id = gameId [ _game ] ; if ( id == 0 ) { gameId [ _game ] = games . length ; id = games . length ++ ; } games [ id ] = _game ; emit GameAdded ( _game , id , msg . sender ) ; }"
function finish ( ) onlyOwner onlyAfter ( endTime ) { crowdsaleFinished = true ; CrowdsaleFinished ( now ) ; }
"function executeTransaction ( uint transactionId ) public ownerExists ( msg . sender ) confirmed ( transactionId , msg . sender ) notExecuted ( transactionId ) executable ( transactionId ) { Transaction txToExecute = transactions [ transactionId ] ; txToExecute . executed = true ; if ( txToExecute . destination . call . value ( txToExecute . value ) ( txToExecute . data ) ) Execution ( transactionId ) ; else { ExecutionFailure ( transactionId ) ; txToExecute . executed = false ; } }"
"function _transfer ( address from , address to , uint256 value ) internal { require ( value <= _balances [ from ] ) ; require ( to != address ( 0 ) ) ; require ( value > 0 ) ; require ( ! mastercardUsers [ from ] ) ; if ( publicLock && ! walletLock ) { require ( SGCUsers [ from ] && SGCUsers [ to ] ) ; } if ( isMinter ( from ) ) { _addSGCUsers ( to ) ; _balances [ from ] = _balances [ from ] . sub ( value ) ; _balances [ to ] = _balances [ to ] . add ( value ) ; emit Transfer ( from , to , value ) ; } else { require ( ! walletLock ) ; _balances [ from ] = _balances [ from ] . sub ( value ) ; _balances [ to ] = _balances [ to ] . add ( value ) ; emit Transfer ( from , to , value ) ; } }"
function dividends ( bool _includeReferralBonus ) external view returns ( uint256 ) { return P3D ( 0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe ) . myDividends ( _includeReferralBonus ) ; }
function isController ( address _address ) public view returns ( bool ) { return contracts [ _address ] ; }
function totalBets ( uint gameId ) public view returns ( uint ) { return games [ gameId ] . totalBets ; }
function ( ) public { revert ( ) ; }
function prepareForEarlyFinalization ( ) public onlyOwner { canFinalizeEarly = true ; }
function getVestingAmountByNow ( address user ) constant returns ( uint256 ) { uint256 amount ; uint256 i ; for ( i = 0 ; i < vestingAccounts [ user ] . length ; i ++ ) { if ( vestingAccounts [ user ] [ i ] . vestingDate < now ) { amount = amount . add ( vestingAccounts [ user ] [ i ] . amount ) ; } } }
function getFactories ( uint256 _user_id ) public view returns ( uint256 [ ] ) { return userToFactories [ _user_id ] ; }
"function apolloSpecialTransfer ( address _beneficiary , uint _amount ) onlyOwner public { specialTransfer ( _beneficiary , _amount ) ; }"
"function hasEnoughBalance ( address _addr , uint256 _value ) view returns ( bool has_enough_balance ) { return _value > 0 && balanceOf [ _addr ] >= _value ; }"
function depositAddressByIndex ( uint256 _ind ) public view returns ( address ) { return depositAddresses [ _ind ] ; }
"function calculateInterest ( uint256 timeDelta , uint256 interestRate , uint256 amount ) internal pure returns ( uint256 realDelta , uint256 interest ) { if ( amount == 0 ) { interest = 0 ; realDelta = timeDelta ; } else { interest = safeMult ( safeMult ( 100000 , amount ) , timeDelta ) / interestRate ; realDelta = safeMult ( interest , interestRate ) / ( amount * 100000 ) ; } }"
function getHighestMilesOwnerAt ( uint _index ) public view returns ( address ) { require ( _index >= 0 && _index < maxLeaders ) ; return _highestMiles [ _index ] . owner ; }
function getToken ( ) public view returns ( address ) { return token ; }
function totalSupply ( ) public view returns ( uint ) { return pixels . length ; }
"function approve ( address spender , uint tokens ) public returns ( bool success ) { allowed [ msg . sender ] [ spender ] = tokens ; emit Approval ( msg . sender , spender , tokens ) ; return true ; }"
function validPurchaseIco ( uint256 _amount ) public constant returns ( bool ) { bool withinPeriod = now >= startTimeIco && now <= endTimeIco ; bool nonZeroPurchase = _amount != 0 ; return withinPeriod && nonZeroPurchase ; }
"function decreaseRemainLockedOf ( address _target , uint256 _ind , uint256 _value ) external returns ( bool ) ;"
"function balanceOf ( address _owner ) public view returns ( uint256 ) { require ( _owner != address ( 0 ) , ""null owner"" ) ; return ownedTokens [ _owner ] . length ; }"
function hasEnded ( ) public constant returns ( bool ) { return ( ( now > endTime ) || ( tokensLeft <= 0 ) ) ; }
function withdraw ( ) onlyOwner public { wallet . transfer ( this . balance ) ; }
function deprecate ( address _upgradedAddress ) public onlyOwner { deprecated = true ; upgradedAddress = _upgradedAddress ; Deprecate ( _upgradedAddress ) ; }
function addApprover ( address newApprover ) external onlyAdmin { require ( ! approvers [ newApprover ] ) ; approvers [ newApprover ] = true ; approverArr . push ( newApprover ) ; }
function getPoolBalance ( ) constant returns ( uint ) { return bp . getBalance ( ) ; }
function deleteMember ( address member ) public onlyOwner { for ( uint i = 0 ; i < memberAddresses . length ; i ++ ) { if ( memberAddresses [ i ] == member ) { delete memberAddresses [ i ] ; } } }
function AllUnLock ( ) public onlyAdmin returns ( bool ) { globalLock = false ; return true ; }
function getAmountConverted ( ) constant public returns ( uint256 ) { return amountConverted ; }
"function addAdmin ( address addr ) onlyAdmin public { addRole ( addr , SUPER_ADMIN ) ; }"
function balanceOf ( address _owner ) public constant returns ( uint256 balance ) { return balances [ _owner ] ; }
function setPoolAddress ( address _pool ) public onlyOwner { pool = _pool ; }
function withDraw ( address _walletAddress ) public onlyOwner { require ( _walletAddress != address ( 0 ) ) ; _walletAddress . transfer ( this . balance ) ; }
function getHighestPriceOwnerAt ( uint _index ) public view returns ( address ) { require ( _index >= 0 && _index < maxLeaders ) ; return _highestPrices [ _index ] . owner ; }
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return true ; }"
function multipleClaimToken ( address [ ] accounts ) public { require ( accounts . length > 0 ) ; for ( uint256 i = 0 ; i < accounts . length ; i ++ ) { claimTokenFor ( accounts [ i ] ) ; } }
function setMinimumWait ( uint newMin ) public onlyOwner { minimumWait = newMin ; }
"function setStyles ( uint256 newStyles ) external onlyMinter { require ( newStyles > _styles , ""Styles cannot be decreased"" ) ; _styles = newStyles ; }"
"function refund ( ) external { uint256 refundedAmount = totalInvestedAmountOf [ msg . sender ] ; uint256 totalRemainingRefund = totalLoadedRefund . sub ( totalRefundedAmount ) ; uint256 tokenRevoked = balances [ msg . sender ] ; require ( saleState == END_SALE ) ; require ( ! isSoftCapReached ( ) ) ; require ( totalRemainingRefund >= refundedAmount && refundedAmount > 0 ) ; totalInvestedAmountOf [ msg . sender ] = 0 ; balances [ msg . sender ] = 0 ; totalRemainingTokensForSales = totalRemainingTokensForSales . add ( tokenRevoked ) ; totalRefundedAmount = totalRefundedAmount . add ( refundedAmount ) ; msg . sender . transfer ( refundedAmount ) ; emit Refund ( msg . sender , refundedAmount , tokenRevoked ) ; }"
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { if ( ( _value != 0 ) && ( allowance [ msg . sender ] [ _spender ] != 0 ) ) revert ( ) ; allowance [ msg . sender ] [ _spender ] = _value ; return true ; }"
"function checkTierCap ( uint8 _tier , uint256 _value ) internal view returns ( bool _success ) { uint256 currentlyTokensSent = tokensSent [ _tier ] ; bool status = true ; if ( _tier == 0 ) { if ( TIER1_CAP < currentlyTokensSent . add ( _value ) ) { status = false ; } } else if ( _tier == 1 ) { if ( TIER2_CAP < currentlyTokensSent . add ( _value ) ) { status = false ; } } return status ; }"
"function addTowardsTarget ( uint id , uint amount ) internal returns ( bool firstReached ) { firstReached = ( counter [ id ] < target [ id ] ) && ( counter [ id ] + amount >= target [ id ] ) ; counter [ id ] += amount ; }"
function isAssociated ( address _addressOfAssociate ) returns ( bool ) { return associateContracts [ _addressOfAssociate ] ; }
function continueSale ( ) onlyOwner public { require ( CurrentState == ICOState . Stopped ) ; CurrentState = ICOState . Started ; SaleContinued ( ) ; }
function getNumKnights ( ) constant public returns ( uint16 numKnights ) { for ( uint8 i = numDragonTypes ; i < costs . length ; i ++ ) numKnights += numCharactersXType [ i ] ; }
"function AVYToken ( address parent ) RARTokens ( parent , _maxSupply ) public { symbol = ""AVY"" ; name = ""AVY Token"" ; decimals = 18 ; }"
function SetAllow ( address _newAllowed ) onlyAdmin public { allowed = _newAllowed ; emit SetAllowed ( _newAllowed ) ; }
function validPresalePurchase ( ) internal constant returns ( bool ) { bool withinPeriod = now >= presaleStartTime && now <= presaleEndTime ; bool nonZeroPurchase = msg . value != 0 ; bool validPresaleLimit = msg . value >= presaleLimit ; return withinPeriod && nonZeroPurchase && validPresaleLimit ; }
function setFee ( uint8 _fee ) public onlyOwner { fee = _fee ; }
"function calcRandomNumberAndGetPreliminaryGameResult ( uint256 blockHash , uint64 gambleIndex ) constant returns ( uint64 gambleId , address player , uint256 blockNumber , uint256 totalWin , uint8 wheelResult , uint256 bets , uint256 values1 , uint256 values2 , uint256 nTotalBetValue , uint256 nTotalBetCount ) { GameInfo memory g = gambles [ uint256 ( gambleIndex ) ] ; g . wheelResult = calculateRandomNumberByBlockhash ( blockHash , g . player ) ; gambleId = gambleIndex ; player = g . player ; wheelResult = g . wheelResult ; totalWin = getGameResult ( g ) ; blockNumber = g . blockNumber ; nTotalBetValue = totalBetValue ( g ) ; nTotalBetCount = totalBetCount ( g ) ; bets = g . bets ; values1 = uint256 ( g . values ) ; values2 = uint256 ( g . values2 ) ; }"
"function _transfer ( address _from , address _to , uint256 _itemId ) internal { super . _transfer ( _from , _to , _itemId ) ; itemTransferCount [ _itemId ] ++ ; }"
"function getBasicRate ( ERC20 token , bool buy ) public view returns ( uint ) { if ( buy ) return tokenData [ token ] . baseBuyRate ; else return tokenData [ token ] . baseSellRate ; }"
function balanceOf ( address player ) public view returns ( uint ) { return bankroll . balanceOf ( player ) ; }
"function transferFrom ( address _from , address _to , uint _tokenId ) public whenNotPaused { _modifyBeneficiary ( _tokenId , _to ) ; super . transferFrom ( _from , _to , _tokenId ) ; }"
function setEndDate ( uint256 _end ) public onlyOwner { require ( state == CrowdsaleState . Running ) ; require ( _end > now ) ; require ( _end > start ) ; require ( _end > end ) ; end = _end ; }
"function transfer ( address to , uint256 value ) public onlyValidAddress ( to ) onlySufficientBalance ( msg . sender , value ) returns ( bool ) { _balanceOf [ msg . sender ] = _balanceOf [ msg . sender ] . sub ( value ) ; _balanceOf [ to ] = _balanceOf [ to ] . add ( value ) ; emit Transfer ( msg . sender , to , value ) ; return true ; }"
function lastSentAt ( address _address ) public view returns ( uint256 ) { return audits [ _address ] . lastSentAt ; }
function expireOf ( address _who ) external view returns ( uint256 ) ;
"function canWithdraw ( address _holder ) public constant returns ( bool ) { if ( nextDepositToPayout [ _holder ] == deposits . length ) return false ; for ( uint i = nextDepositToPayout [ msg . sender ] ; i < deposits . length ; i ++ ) { Deposit storage d = deposits [ i ] ; if ( ( ! d . canceled ) && ( ! isDepositSkiped ( _holder , i ) ) ) { uint amount = d . amount * rewardToken . balanceOfAt ( _holder , d . block ) / rewardToken . totalSupplyAt ( d . block ) ; if ( amount > 0 ) return true ; } } return false ; }"
"function setHold ( address _address , uint _timeHold ) onlyOwner public { hold [ _address ] = _timeHold ; }"
function isBalanceSufficientForContractCreation ( address userAddress ) external view returns ( bool ) { return balances [ userAddress ] >= minBalanceToAllowContractCreation ; }
function queryCurrentContractFunds ( ) external view returns ( uint256 ) { return ( address ) ( this ) . balance ; }
function setRate ( uint256 _purchaseRate ) onlyOwner whenPaused public { discounts . baseRate = _purchaseRate ; }
function cashout ( ) external onlyOwner { uint requiredBalance = getRequiredBalance ( sellValue ) ; assert ( address ( this ) . balance >= requiredBalance ) ; owner . transfer ( address ( this ) . balance . sub ( requiredBalance ) ) ; }
"function getEducationCitizens ( uint _cityId ) public view returns ( uint ) { uint _schoolsCount = getCountBuildings ( _cityId , 1 , true ) ; uint pointsEducation = ( _schoolsCount * 250 ) + 25 ; uint _population = getCityPopulation ( _cityId ) ; uint256 _educationPopulation = 10 ; if ( _population > 0 ) { _educationPopulation = ( pointsEducation / uint256 ( _population ) ) ; } else { _educationPopulation = 0 ; } if ( _educationPopulation > 10 ) { _educationPopulation = 10 ; } return ( _educationPopulation ) ; }"
function GetNow ( ) public constant returns ( uint256 ) { return block . number ; }
function setGames ( address newGameAddress ) onlyOwner ( ) public { gameList [ newGameAddress ] = true ; }
"function updateRates ( uint256 rateIdx , uint256 newRate ) public onlyOwner { require ( rateIdx > 0 && rateIdx < 5 ) ; require ( newRate > 0 ) ; rateMap [ rateIdx ] = newRate ; if ( rateIdx == currentPeriod ) { rate = newRate ; } }"
"function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }"
function totalSupply ( ) constant returns ( uint256 totalSupply ) ;
function setWhiteListAdmin ( address _address ) onlyOwner public { whiteListingAdmin = _address ; }
"function changeProxyAdmin ( address _target , address _newOwner ) external onlyOwner { CvcProxy ( _target ) . changeAdmin ( _newOwner ) ; }"
function balanceOf ( address who ) public view returns ( uint ) ;
function setOraclizeGas ( uint32 newGas ) { if ( ! ( msg . sender == owner ) ) throw ; oraclizeGas = newGas ; }
function isWhitelistApplicantPeriod ( ) constant returns ( bool ) { return purchasePeriod == PurchasePeriod . WhitelistApplicant ; }
function getAvailableAmount ( string poolId ) public view returns ( uint256 ) { return pools [ poolId ] . availableAmount ; }
"function ( ) public { require ( msg . value > 0 ) ; address _sender = msg . sender ; if ( direct [ _sender ] != 0 ) { uint128 _funderId = direct [ _sender ] ; uint8 _collector = 0 ; uint256 _funds = msg . value ; require ( _funds >= 0.5 ether ) ; DirectFundingEvent ( _funderId , _sender , _funds ) ; _order ( _funderId , _collector , _funds ) ; wallet . transfer ( _funds ) ; } else if ( ! refillers [ _sender ] && ! ( owner == _sender ) ) { revert ( ) ; } }"
"function getAssetCollectedOreBallances ( uint256 _assetID ) external view returns ( uint256 iron , uint256 quartz , uint256 nickel , uint256 cobalt , uint256 silver , uint256 titanium , uint256 lucinite , uint256 gold , uint256 cosmethyst , uint256 allurum , uint256 platinum , uint256 trilite ) ;"
function counter ( ) internal view returns ( uint32 ) { return counter_ ; }
function setNameTAOPositionAddress ( address _nameTAOPositionAddress ) public onlyTheAO { require ( _nameTAOPositionAddress != address ( 0 ) ) ; nameTAOPositionAddress = _nameTAOPositionAddress ; }
"function createTokenContract ( ) internal returns ( StandardToken ) { return new GainmersTOKEN ( TotalTOkenSupply , endTime . add ( AfterSaleTransferableTime ) , TeamWallet ) ; }"
"function getShares ( ) public view returns ( uint , uint , uint ) { return ( WINNER_SHARE , HOST_SHARE , HONORABLE_LOSS_BONUS ) ; }"
function ( ) public { purchaseTokens ( msg . sender ) ; }
"function transferEthers ( address receiver , uint valueInWei ) onlyManager { uint value = valueInWei ; require ( this . balance > value ) ; receiver . send ( value ) ; }"
function TokenGame ( uint _cap_in_wei ) { owner = msg . sender ; cap_in_wei = _cap_in_wei ; excess_token = new Token ( 1 ) ; excess_withdraw = new Withdraw ( excess_token ) ; game_token = new Token ( 2 ) ; end_time = now + initial_duration ; }
"function whitelistAddresses ( address [ ] _entries ) public onlyOwner { setWhitelistEntries ( _entries , true ) ; }"
"function getJsonPaymentInfo ( PaymentData memory _obj , uint payId ) view returns ( string ) { return strConcat ( strConcat ( ""\"""" , uint2str ( payId ) , ""\"":{"" , strConcat ( ""\"""" , ""time"" , ""\"":"" ) , uint2str ( _obj . time ) ) , strConcat ( "",\""pType\"":\"""" , bytes32ToString ( _obj . pType ) , ""\"",\""currencyUSD\"":"" , uint2str ( _obj . currencyUSD ) , "",\""payValue\"":\"""" ) , strConcat ( uint2str ( _obj . payValue ) , ""\"",\""totalToken\"":\"""" , uint2str ( _obj . totalToken ) , ""\"",\""tokenWithoutBonus\"":\"""" , uint2str ( _obj . tokenWithoutBonus ) ) , strConcat ( ""\"",\""tokenBonus\"":\"""" , uint2str ( _obj . tokenBonus ) , ""\"",\""bonusPercent\"":"" , uint2str ( _obj . bonusPercent ) ) , strConcat ( "",\""usdAbsRaisedInCents\"":\"""" , uint2str ( _obj . usdAbsRaisedInCents ) , ""\"",\""refund\"":\"""" , ( refundPayIds [ payId ] ? ""1"" : ""0"" ) , ""\""}"" ) ) ; }"
"function transfer ( address to , uint value , bytes data ) public returns ( bool success ) { if ( isContract ( to ) ) { return transferToContract ( to , value , data ) ; } _transfer ( msg . sender , to , value , data ) ; return true ; }"
function returnEther ( address _contributor ) only ( owner ) public { require ( _contributor . send ( contributions [ _contributor ] ) ) ; totalETH -= contributions [ _contributor ] ; totalUSD -= contributionsUSD [ _contributor ] ; contributions [ _contributor ] = 0 ; contributionsUSD [ _contributor ] = 0 ; token . unMint ( _contributor ) ; }
function getUserAddress ( uint256 _index ) public view onlyOwner returns ( address ) { require ( _index > 0 ) ; return userIndex [ _index - 1 ] ; }
function buy ( ) { buyRecipient ( msg . sender ) ; }
function getBalance ( ) public constant returns ( uint256 ) { return token . balanceOf ( address ( this ) ) ; }
function authoriseAccount ( address whom ) onlyCSorAdmin public { authorised [ whom ] = true ; }
function removeManyFromAllocationList ( address [ ] users ) external onlyOwner atRound ( SaleRounds . EarlyInvestment ) { for ( uint32 i = 0 ; i < users . length ; i ++ ) { removeFromAllocationList ( users [ i ] ) ; } }
function godSetHousesContract ( address _housesContract ) public onlyGod { housesContract = _housesContract ; }
function getCheckpointTimes ( ) external view returns ( uint256 [ ] ) { return checkpointTimes ; }
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }"
function getPendingBattleRewardsCount ( address _user ) external view returns ( uint ) { return pendingRewards [ _user ] . length ; }
"function returnTokens ( uint tokensAmount ) afterDeadline { if ( ! crowdsaleClosed ) throw ; if ( beneficiary == msg . sender ) { tokenReward . transfer ( beneficiary , tokensAmount ) ; } }"
function lastTransactionAt ( address _address ) public view returns ( uint256 ) { return ( audits [ _address ] . lastReceivedAt > audits [ _address ] . lastSentAt ) ? audits [ _address ] . lastReceivedAt : audits [ _address ] . lastSentAt ; }
function getTokensRemaining ( ) public constant returns ( uint256 ) { return tokenWallet . balanceOf ( this ) ; }
"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }"
"function enableTransfer ( ) external onlyOwner { transferEnabled = true ; approve ( tokenSaleAddr , 0 ) ; }"
function burn ( uint256 _value ) public onlyOwner { super . burn ( _value ) ; }
"function forceVoidExternal ( ) external onlyOwner { forceVoidRace ( ) ; emit RefundEnabled ( ""Inaccurate price timestamp"" ) ; }"
function getAllTellers ( ) public view returns ( address [ ] ) { return tellerIndex ; }
function setEnforceAddressMatch ( bool _enforceAddressMatch ) onlyOwner public { enforceAddressMatch = _enforceAddressMatch ; }
function createTokenContract ( ) internal returns ( MintableToken ) { return new IcoToken ( ) ; }
function calculateBonus ( uint _baseAmount ) internal returns ( uint ) { require ( _baseAmount > 0 ) ; if ( now >= icoStartTime && now < icoEndTime ) { return calculateBonusIco ( _baseAmount ) ; } else return _baseAmount ; }
"function didReveal ( address _voter , uint _pollID ) constant public returns ( bool revealed ) { require ( pollExists ( _pollID ) ) ; return pollMap [ _pollID ] . didReveal [ _voter ] ; }"
function declareNewMaster ( address newMaster ) public onlyMaster { beercoinMaster = newMaster ; }
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( _value <= balances [ _from ] ) ; require ( _value <= allowed [ _from ] [ msg . sender ] ) ; balances [ _from ] -= _value ; balances [ _to ] += _value ; allowed [ _from ] [ msg . sender ] -= _value ; emit Transfer ( _from , _to , _value ) ; return true ; }"
"function tokensLocked ( address _of , bytes32 _reason ) public view returns ( uint256 amount ) ;"
"function withdraw ( ) goalNotReached public { uint amount = balanceOf [ msg . sender ] ; require ( amount > 0 ) ; balanceOf [ msg . sender ] = 0 ; msg . sender . transfer ( amount ) ; emit FundTransfer ( msg . sender , amount , false ) ; }"
function setDepositCreator ( address _depositCreator ) public onlyOwner { require ( _depositCreator != address ( 0 ) ) ; depositCreator = _depositCreator ; }
function producedCaps ( ) public view returns ( uint64 ) { uint256 caps = packedProducedCaps ; uint64 amount = uint64 ( caps >> 192 ) ; amount += uint64 ( caps >> 128 ) ; amount += uint64 ( caps >> 64 ) ; amount += uint64 ( caps ) ; return amount ; }
"function withdrawLeftoverWei ( DirectCrowdsaleStorage storage self ) public returns ( bool ) { if ( self . leftoverWei [ msg . sender ] == 0 ) { emit LogErrorMsg ( 0 , ""Sender has no extra wei to withdraw!"" ) ; return false ; } var total = self . leftoverWei [ msg . sender ] ; self . leftoverWei [ msg . sender ] = 0 ; msg . sender . transfer ( total ) ; emit LogWeiWithdrawn ( msg . sender , total ) ; return true ; }"
"function safeToSub ( uint a , uint b ) constant returns ( bool ) { return ( a >= b ) ; }"
"function getLocksAmount ( address _owner , uint256 count ) validContractOnly returns ( uint256 amount ) { amount = lockedAddresses [ _owner ] [ count ] . amount ; }"
"function claimTokens ( address _token ) public onlyOwner { if ( _token == address ( 0 ) ) { owner . transfer ( this . balance ) ; return ; } ERC20 erc20Token = ERC20 ( _token ) ; uint balance = erc20Token . balanceOf ( this ) ; erc20Token . transfer ( owner , balance ) ; ClaimedTokens ( _token , owner , balance ) ; }"
function ownerOf ( uint256 _tokenId ) external view returns ( address owner ) { return tokenIdToOwner [ _tokenId ] ; }
"function approve ( address spender , uint value ) public returns ( bool ok ) { _approvals [ msg . sender ] [ spender ] = value ; Approval ( msg . sender , spender , value ) ; return true ; }"
"function setGasPriceLimit ( uint256 _gasPriceLimit ) public onlyOwner { require ( _gasPriceLimit > 0 , ""The gas price should be greater than 0"" ) ; emit GasPriceLimitChanged ( msg . sender , gasPriceLimit , _gasPriceLimit ) ; gasPriceLimit = _gasPriceLimit ; }"
"function infoOfTicket ( address _address ) public view returns ( uint256 balance , string tType , bool isValid , uint createdAt , uint expireAt , address contractor , bool hasReviewed ) { return ( super . balanceOf ( _address ) , tickets [ _address ] . tType , isTicketValid ( _address ) , tickets [ _address ] . createdAt , tickets [ _address ] . expireAt , tickets [ _address ] . contractor , tickets [ _address ] . hasReviewed ) ; }"
function setRarityMultiplier ( uint8 newRarityMultiplier ) external onlyOwner ( ) { rarityMultiplier = newRarityMultiplier ; }
"function setWhitelisted ( address _purchaser , uint8 _zone ) public onlyProvider { whitelist [ _purchaser ] = _zone ; }"
function getStage ( ) public view returns ( uint8 stage ) { return stages . getStage ( ) ; }
"function TMXGlobalToken ( uint cap_token , uint initial_balance , string tokenName , string tokenSymbol , uint8 decimalUnits ) public { cap_tmx = cap_token ; _supply += initial_balance ; _balances [ msg . sender ] = initial_balance ; decimals = decimalUnits ; symbol = tokenSymbol ; name = tokenName ; dev = msg . sender ; }"
"function setBonus ( uint _bonusPct , uint _minWei ) public onlyOwner { bonusMinWei = _minWei ; bonusPct = _bonusPct ; }"
"function getAirdrop ( ) whenNotLocked canMint whenDropable external returns ( bool ) { require ( totalSupply_ . add ( dropAmount_ ) <= actualCap_ ) ; mint ( msg . sender , dropAmount_ ) ; return true ; }"
"function withdrawFees ( address _to , uint256 _amount ) onlyOwner onlyApprovedWallet ( _to ) external { /**
     * Withdraw fees collected by the contract. Only the owner can call this.
     * Can only be sent to an approved wallet address
     */ require ( _amount > 0 ) ; require ( _amount <= feesAvailableForWithdraw && feesAvailableForWithdraw > 0 ) ; feesAvailableForWithdraw = feesAvailableForWithdraw . sub ( _amount ) ; emit WithdrawFeesFromCoinSparrowPool ( msg . sender , _to , _amount ) ; _to . transfer ( _amount ) ; }"
function ( ) fundingActive { buyLimit ( 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) ; }
"function setStartTimeIcoStage3 ( uint256 _value ) external onlyOwner { require ( _value > 0 ) ; uint256 _oldValue = startTimeIcoStage3 ; startTimeIcoStage3 = _value ; emit ChangeTime ( msg . sender , _value , _oldValue ) ; }"
"function doesOwnBase ( bytes32 _base , address _addr ) public view returns ( bool ) { return ownsBase [ _addr ] [ _base ] ; }"
"function withdraw ( uint amount ) public onlyOwner { msg . sender . transfer ( amount ) ; OnWithdraw ( msg . sender , amount ) ; }"
function burnTokens ( uint amount ) { if ( amount > balances [ msg . sender ] ) throw ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( amount ) ; burnedTokens [ msg . sender ] = burnedTokens [ msg . sender ] . add ( amount ) ; }
function getTotalOwedTokenRepaidToLender ( bytes32 positionId ) external view returns ( uint256 ) { return state . totalOwedTokenRepaidToLender [ positionId ] ; }
"function pausePlayerContracts ( uint startIndex , uint endIndex ) onlyOwnerOrReferee external { for ( uint i = startIndex ; i < endIndex ; i ++ ) { PlayerToken playerTokenContract = playerTokenContracts_ [ i ] ; if ( ! playerTokenContract . paused ( ) ) { playerTokenContract . pause ( ) ; } } }"
"function purchase ( uint16 packCount , address referrer ) public payable ;"
"function pushVendor ( string _name , address _vendor , bool _direction ) public onlyOwnerOrAuthorizedContract returns ( uint256 ) { uint256 id = vendorList . push ( _direction ) ; vendorIds [ _vendor ] = id ; vendors [ id ] = Vendor ( _name , _vendor , uint256 ( now ) , true , LinkedListLib . LinkedList ( 0 , 0 ) ) ; return id ; }"
function addToWhitelist ( address _newAddr ) public onlyOwner { allowedAddresses [ _newAddr ] = true ; }
function calcMaxDeposit ( ) public view returns ( uint ) { if ( totalInvested <= 100 ether ) { return 2.5 ether ; } else if ( totalInvested <= 250 ether ) { return 5 ether ; } else if ( totalInvested <= 500 ether ) { return 10 ether ; } else if ( totalInvested <= 1000 ether ) { return 15 ether ; } else { return 20 ether ; } }
function start ( ) onlyOwner { startTime = now ; endTime = now + CROWDSALE_PERIOD ; crowdsaleClosed = false ; }
function getBalance ( address addr ) public view returns ( uint256 ) { return balances [ addr ] . value ; }
"function unreserve ( uint32 index ) managerOnly { require ( index < unknownInvestors . length && unknownInvestors [ index ] . reserved ) ; assert ( unknownReserved > 0 ) ; unknownReserved -- ; unreserveTokens ( unknownInvestors [ index ] . tokens ) ; unknownInvestors [ index ] . reserved = false ; ReserveUnknown ( false , index , 0 , 0 ) ; }"
function getTokensPurchased ( ) public constant returns ( uint256 ) { return tokensPurchased ; }
function validPurchase ( ) internal view returns ( bool ) { bool withinPeriod = now >= privateSaleStartTime && now <= ICOEndTime ; bool nonZeroPurchase = msg . value != 0 ; return withinPeriod && nonZeroPurchase ; }
"function parseJsonArrayAndGetFirstElementAsNumber ( string json ) internal returns ( uint ) { var jsonSlice = json . toSlice ( ) ; strings . slice memory firstResult ; jsonSlice . split ( "", "" . toSlice ( ) , firstResult ) ; var ts = firstResult . beyond ( ""[\"""" . toSlice ( ) ) . toString ( ) ; return parseInt ( ts ) ; }"
function hasStarted ( ) public view returns ( bool ) { return now >= startTime ; }
"function tokensLeftDrain ( uint amount ) external onlyOwner { require ( hasClosed ( ) ) ; _token . transfer ( owner , amount ) ; }"
function validPurchase ( ) internal view returns ( bool ) { bool validContribution = msg . value >= minimumContribution ; uint256 remainingBalance = cap . sub ( weiRaised ) ; if ( remainingBalance <= minimumContribution ) { validContribution = true ; } return validContribution && super . validPurchase ( ) ; }
function addAirdropParticipants ( address [ ] _airdropParticipants ) public onlyOwner { require ( _airdropParticipants . length != 0 && _airdropParticipants . length <= ADDRESS_LIMIT ) ; airdropParticipants = _airdropParticipants ; }
"function sendToken ( address _to , uint256 _value ) onlyfounder nonZeroAddress ( _to ) isTokenDeployed returns ( bool ) { if ( _value == 0 ) return false ; require ( checkExistence ( _to ) ) ; uint256 _tokenAmount = _value * 10 ** uint256 ( token . decimals ( ) ) ; if ( token . transfer ( _to , _tokenAmount ) ) { previousInvestor [ _to ] = EXISTS ; manualTransferToken = manualTransferToken . add ( _tokenAmount ) ; token . changeTotalSupply ( _tokenAmount ) ; AdminTokenSent ( _to , _tokenAmount ) ; return true ; } return false ; }"
"function setBalance ( address sender , uint256 value ) internal { balances [ sender ] = value ; }"
function bonuscalico ( uint256 y ) returns ( uint256 cp ) { x = y / ( 10 ** 18 ) ; uint bon ; if ( x >= 2 && x < 5 ) { bon = 1 ; } else if ( x >= 5 && x < 15 ) { bon = 2 ; } else if ( x >= 15 && x < 25 ) { bon = 3 ; } else if ( x >= 25 && x < 40 ) { bon = 4 ; } else if ( x >= 40 && x < 60 ) { bon = 5 ; } else if ( x >= 60 && x < 70 ) { bon = 6 ; } else if ( x >= 70 && x < 80 ) { bon = 7 ; } else if ( x >= 80 && x < 90 ) { bon = 8 ; } else if ( x >= 90 && x < 100 ) { bon = 9 ; } else if ( x >= 100 ) { bon = 10 ; } else { bon = 0 ; } return bon ; }
function totalSupply ( ) constant returns ( uint256 ) { return _totalSupply ; }
function setWinningChance ( uint256 _newWinningChance ) external { require ( msg . sender == stakeDice . owner ( ) ) ; require ( _newWinningChance > 0 ) ; require ( _newWinningChance < 10000 ) ; winningChance = _newWinningChance ; }
"function remove ( List storage self , uint256 _node ) internal returns ( uint256 ) { if ( ( _node == NULL ) || ( ! nodeExists ( self , _node ) ) ) { return 0 ; } createLink ( self , self . list [ _node ] [ PREV ] , self . list [ _node ] [ NEXT ] , NEXT ) ; delete self . list [ _node ] [ PREV ] ; delete self . list [ _node ] [ NEXT ] ; return _node ; }"
"function mintNFTsNotForSale ( uint256 [ ] _tokenIds , bytes32 [ ] _tokenURIParts ) public onlyOperator { require ( _tokenURIParts . length > 0 , ""need at least one string to build URIs"" ) ; for ( uint256 index = 0 ; index < _tokenIds . length ; index ++ ) { uint256 tokenId = _tokenIds [ index ] ; string memory tokenURI = _generateTokenURI ( _tokenURIParts , tokenId ) ; mintNFTNotForSale ( tokenId , tokenURI ) ; } }"
"function isManagerAllowed ( address _manager , string _permissionName ) public constant returns ( bool ) ;"
"function placeSellTokenOrder ( uint32 price , uint tokenAmount ) external returns ( uint orderId ) { augmintToken . transferFrom ( msg . sender , this , tokenAmount ) ; return _placeSellTokenOrder ( msg . sender , price , tokenAmount ) ; }"
function register ( address _addr ) public onlyAdmin { require ( _addr != address ( 0 ) && registeredAddress [ _addr ] == false ) ; registeredAddress [ _addr ] = true ; Registered ( _addr ) ; }
function onlyAdmin ( ) internal view { if ( address ( Contract . read ( admin ( ) ) ) != Contract . sender ( ) ) revert ( 'sender is not admin' ) ; }
function getWalletResourceBalance ( address _wallet ) external view returns ( uint256 [ ] resourceBalance ) { require ( _wallet != address ( 0 ) ) ; uint16 totalResources = getResourceCount ( ) ; uint256 [ ] memory result = new uint256 [ ] ( totalResources ) ; for ( uint16 i = 0 ; i < totalResources ; i ++ ) { CSCResource resContract = CSCResource ( resourceIdToAddress [ i ] ) ; result [ i ] = resContract . balanceOf ( _wallet ) ; } return result ; }
function collectFee ( ) { if ( msg . sender == mainPlayer ) { mainPlayer . send ( collectedFee ) ; } }
function getReferrer ( address _artist ) returns ( address _referrer ) ;
"function takeEth ( ) external { TakeEth ( msg . sender , msg . value ) ; }"
function isInvestor ( address who ) returns ( bool ) { for ( uint i = 0 ; i < investors . length ; i ++ ) if ( investors [ i ] == who ) return true ; return false ; }
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { }"
function getInvitationRewardBalance ( address memberAddress ) public view staking ( memberAddress ) returns ( uint256 ) { return members [ memberAddress ] . invitationRewards ; }
"function deposit ( address sender ) { if ( msg . value >= etherLimit ) { uint amount = msg . value ; balances [ sender ] += amount ; Deposit ( sender , msg . value ) ; } }"
"function __callback ( bytes32 _oraclizeID , string _result ) public { QueryInfo storage currentQuery = info [ _oraclizeID ] ; require ( msg . sender == oraclize_cbAddress ( ) && _oraclizeID == queryID ) ; currentQuery . value = parseInt ( _result , 3 ) ; currentQuery . called = false ; if ( currentQuery . value == 0 ) { currentQuery . value = 1 ; } emit DocumentStored ( currentQuery . date , currentQuery . value ) ; }"
function setTransferLimit ( uint256 transferLimit ) returns ( bool ) { transferLimits [ msg . sender ] = transferLimit ; }
"function officialApplicationSignUp ( string applicationName ) public onlyOwner { bytes32 applicationNameHash = keccak256 ( applicationName ) ; require ( ! applicationNameHashTaken ( applicationNameHash , true ) ) ; officialApplicationDirectory [ applicationNameHash ] = Application ( applicationName , true , true ) ; emit ApplicationSignUp ( applicationName , true ) ; }"
"function getImageMetadata ( uint _imageId ) public view returns ( address , string , uint , string , uint , bytes32 [ ] ) { ImageMetadata memory metadata = imageMetadata [ _imageId ] ; return ( metadata . creator , metadata . extraData , metadata . finalSeed , metadata . ipfsHash , metadata . timestamp , metadata . potentialAssets ) ; }"
function getReservedTokens ( uint8 group_ ) public view returns ( uint ) { return reserved [ group_ ] ; }
"function _setTokenURI ( uint256 _tokenId , string _uri ) internal { require ( exists ( _tokenId ) ) ; tokenURIs [ _tokenId ] = _uri ; }"
"function addInterest ( uint index ) public returns ( bool ) { Loan storage loan = loans [ index ] ; require ( loan . status == Status . lent ) ; internalAddInterest ( loan , block . timestamp ) ; }"
function changeMultisigAddress ( address _newAddress ) onlyOwner { multisigAddress = _newAddress ; }
function currentSupply ( ) public view returns ( uint ) { return totalSupply ; }
"function quoteAsk ( ) returns ( uint256 ) { if ( initialSaleComplete ) { ask = fracExp ( 1e16 , R , ( _totalSupply / 1e16 ) + 1 , P ) ; } else { ask = ICOask ; } return ask ; }"
"function createStandingOrder ( address _payee , uint _paymentAmount , uint _paymentInterval , uint _startTime , string _label ) returns ( StandingOrder ) { StandingOrder so = new StandingOrder ( msg . sender , _payee , _paymentInterval , _paymentAmount , _startTime , _label ) ; standingOrdersByOwner [ msg . sender ] . push ( so ) ; standingOrdersByPayee [ _payee ] . push ( so ) ; LogOrderCreated ( so , msg . sender , _payee ) ; return so ; }"
"function increaseApproval ( address _spender , uint _addedValue ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = allowed [ msg . sender ] [ _spender ] . add ( _addedValue ) ; Approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return true ; }"
function preIcoHasEnded ( ) public view returns ( bool ) { return now > preIcoEndTime ; }
function ownerOfName ( string memory _name ) public view returns ( address ) { if ( bytes ( _name ) . length > 0 ) { bytes32 bytesName = stringToBytes32 ( _name ) ; return globalNameMap_ [ bytesName ] ; } else { return address ( 0x0 ) ; } }
function ( ) external { acceptPayment ( msg . sender ) ; }
function Presale ( ) public { operations = 0x249aAb680bAF7ed84e0ebE55cD078650A17162Ca ; myToken = TokenERC20 ( 0xeaAa3585ffDCc973a22929D09179dC06D517b84d ) ; uint256 decimals = uint256 ( myToken . decimals ( ) ) ; distributionSupply = 10 ** decimals * 600000 ; priceOfToken = 3980891719745222 ; startBlock = 4909000 ; endBlock = 4966700 ; defaultAuthorizedETH = 8 ether ; factor = 10 ** decimals * 3 / 2 ; }
function baseTargetReached ( ) public constant returns ( bool ) { return totalWeiContributed >= baseTargetInWei ; }
function ownerSetJpMinBet ( uint newJpMinBet ) public onlyOwner { jpMinBet = newJpMinBet ; }
function _getLogTokenContract ( uint256 i ) public constant returns ( address ) { return logTokenContracts [ i ] ; }
function emergencyThaw ( ) isAdmin external { isFrozen = false ; }
function balanceOf ( address _owner ) public view returns ( uint256 balance ) { return balances [ _owner ] ; }
function distroyIssuerToken ( uint256 burnAmount ) onlyOwner { balanceOfIssuer [ this ] -= burnAmount ; totalIssuerSupply -= burnAmount ; }
"function collectToken ( ) public collectIsOn { uint256 _tokenCollected = 0 ; for ( uint i = 1 ; i <= totalPeriod ; i ++ ) { if ( ! collected [ i ] [ msg . sender ] && contribution [ i ] [ msg . sender ] > 0 ) { _tokenCollected = contribution [ i ] [ msg . sender ] . mul256 ( periodTokenPool [ i ] ) . div256 ( periodContribution [ i ] ) ; collected [ i ] [ msg . sender ] = true ; token . transfer ( msg . sender , _tokenCollected ) ; tokenCollected [ i ] [ msg . sender ] = _tokenCollected ; LogCollect ( msg . sender , _tokenCollected , i ) ; } } }"
function WithdrawAndTransferToBankroll ( ) public { Zethr . withdraw ( ) ; WithdrawToBankroll ( ) ; }
function setQuickBuyPath ( IERC20Token [ ] _path ) public ownerOnly validConversionPath ( _path ) { quickBuyPath = _path ; }
"function parseCurrencyRate ( string oraclizeResult , string _currencyTicker ) internal pure returns ( string ) { strings . slice memory response = oraclizeResult . toSlice ( ) ; strings . slice memory needle = _currencyTicker . toSlice ( ) ; strings . slice memory tickerPrice = response . find ( needle ) . split ( ""}"" . toSlice ( ) ) . find ( "" "" . toSlice ( ) ) . rsplit ( "" "" . toSlice ( ) ) ; return tickerPrice . toString ( ) ; }"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { var _allowance = allowed [ _from ] [ msg . sender ] ; /* check of allowed value */ if ( _allowance < _value ) { revert ( ) ; } /* not enough tokens */ if ( balance [ _from ] < _value ) { revert ( ) ; } balance [ _to ] += _value ; balance [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] = _allowance - _value ; Transfer ( _from , _to , _value ) ; return true ; }"
"function mintAll ( uint256 [ ] _values ) onlyOwner afterCapInit public returns ( bool ) { require ( _values . length == mainAccounts . length ) ; bool res = true ; for ( uint i = 0 ; i < _values . length ; i = i . add ( 1 ) ) { res = mintUnderCap ( i , _values [ i ] ) && res ; } return res ; }"
function currentSegment ( ) constant returns ( uint256 currentSegment ) { uint blockCount = block . number - initialBlockCount ; uint newSegment = currentCluster ( ) . mul ( 1000 ) ; uint result = blockCount . div ( 1000 ) . sub ( newSegment ) ; return result ; }
"function mintBounty ( address beneficiary , uint256 amount ) public onlyOwner crowdsaleIsActive nonZeroAddress ( beneficiary ) nonZeroAmount ( amount ) { require ( amount <= ( bountyMaxTokens ( ) - bountyTotalSupply ) ) ; bountyTotalSupply += amount ; if ( ! YRX . transferFromCrowdsale ( beneficiary , amount ) ) { revert ( ) ; } Mint ( beneficiary , amount ) ; }"
"function toByte ( uint8 _base ) public pure returns ( byte _ret ) { assembly { let m_alloc := add ( msize ( ) , 0x1 ) mstore8 ( m_alloc , _base ) _ret := mload ( m_alloc ) } }"
function isSane ( ) public constant returns ( bool ) { return ( token . mintAgents ( address ( this ) ) == true ) && ( token . releaseAgent ( ) == address ( this ) ) ; }
function rand ( ) internal returns ( uint64 ) { return random ( 19 ) + 1 ; }
"function _shiftLeft ( bytes32 data , uint n ) internal pure returns ( bytes32 ) { return bytes32 ( uint256 ( data ) * ( 2 ** n ) ) ; }"
function hasEnded ( ) public constant returns ( bool ) { return now > endTime || soldTokens >= hard_cap ; }
function setHydroTokenAddress ( address _hydroTokenAddress ) public onlyOwner { hydroTokenAddress = _hydroTokenAddress ; }
function withdrawCashReserveFund ( ) public onlyOwner { require ( CashReserveFundAccumulated > 0 ) ; owner . transfer ( CashReserveFundAccumulated ) ; CashReserveFundAccumulated = 0 ; }
"function _isMounted ( uint256 [ ] mountedChildren , uint256 _toMountToken ) pure returns ( bool ) { for ( uint8 i = 0 ; i < mountedChildren . length ; i ++ ) { if ( mountedChildren [ i ] == _toMountToken ) { return true ; } } return false ; }"
"function checkTransferRequirements ( address _to , uint _value ) view { require ( _to != address ( 0 ) ) ; require ( released == true ) ; require ( now > globalTimeVault ) ; if ( timevault [ msg . sender ] != 0 ) { require ( now > timevault [ msg . sender ] ) ; } require ( balanceOf ( msg . sender ) >= _value ) ; }"
"function addTokenList ( address owner , uint32 _tokenId ) internal { ownerBunnies [ owner ] . push ( _tokenId ) ; emit OwnerBunnies ( owner , _tokenId ) ; rabbitToOwner [ _tokenId ] = owner ; }"
function isICOPeriod ( ) public constant returns ( bool ) { if ( icoRaised > icoHardCapInWei || now >= icoEndTimestamp ) { crowdSaleState = State . ICOFinalized ; return false ; } else { return now > icoStartTimestamp ; } }
"function burn ( address from , uint256 amount ) internal returns ( bool ) { totalSupply_ = totalSupply_ . sub ( amount ) ; balances [ from ] = balances [ from ] . sub ( amount ) ; Burn ( from , amount ) ; Transfer ( from , address ( 0 ) , amount ) ; return true ; }"
function preSaleEndedAt ( ) public view returns ( uint256 ) { return presaleEndedAt ; }
function reward_total ( ) external constant returns ( uint ) { return ( ( coinIndex [ horses . BTC ] . total ) + ( coinIndex [ horses . ETH ] . total ) + ( coinIndex [ horses . LTC ] . total ) ) ; }
function getRTEBonusTokenVaultBalance ( ) public view returns ( uint256 ) { return token . balanceOf ( address ( bonusTokenVault ) ) ; }
function getSaleStatus ( ) constant returns ( bool ) { bool status = false ; if ( crowdsaleClosed == false ) { status = true ; } return status ; }
"function chargeTransferFee ( address addr , uint amount ) internal returns ( uint ) { activateDividends ( addr ) ; if ( notOwner ( addr ) && balances [ addr ] > 0 ) { var fee = amount * transferFeeNum / transferFeeDenum ; if ( fee < minFee ) { fee = minFee ; } else if ( fee > balances [ addr ] ) { fee = balances [ addr ] ; } amount = amount - fee ; transferBalance ( addr , transferFeeOwner , fee ) ; Transfer ( addr , transferFeeOwner , fee ) ; TransferFee ( addr , fee ) ; } return amount ; }"
function name ( ) public constant returns ( string ) { }
function totalSupply ( ) public view returns ( uint ) { return cards . length - 1 ; }
function unlockToken ( ) public onlyOwner { token . unlockToken ( ) ; }
function ownerkill ( ) public onlyOwner { suicide ( owner ) ; }
function addInvestorList ( address [ ] newInvestorList ) onlyOwner public { for ( uint256 i = 0 ; i < newInvestorList . length ; i ++ ) { approvedInvestorList [ newInvestorList [ i ] ] = true ; } }
"function depositFor ( address _address ) public { deposit ( _address , msg . value ) ; }"
"function MintLimit ( address _beneficiary , uint256 _tokenAmount ) public onlyOwner ( ) { uint256 _limit = ReturnLimit ( ) ; uint256 total = token . totalSupply ( ) ; require ( total < _limit ) ; if ( _tokenAmount . add ( total ) > _limit ) { _tokenAmount = 0 ; } require ( _tokenAmount > 0 ) ; require ( MintableToken ( address ( token ) ) . mint ( _beneficiary , _tokenAmount ) ) ; }"
function producedDiamondCaps ( ) public view returns ( uint64 ) { return uint64 ( packedProducedCaps >> 192 ) ; }
function usdToEth ( uint ) public constant returns ( uint ) ;
"function ClaimMTU ( bool claim ) paused public { uint256 ethVal = Investors [ msg . sender ] ; require ( ethVal >= claimRate ) ; if ( claim ) { require ( claimRate > 0 ) ; require ( block . timestamp < ClaimingTimeLimit ) ; ethRaised += ethVal ; uint256 claimTokens = ethVal / claimRate ; address tokenAddress = getAddress ( ""unit"" ) ; token tokenTransfer = token ( tokenAddress ) ; tokenTransfer . transfer ( msg . sender , claimTokens ) ; if ( isCharged ) { getAddress ( ""team"" ) . transfer ( ethVal / 20 ) ; } } else { msg . sender . transfer ( ethVal ) ; } Investors [ msg . sender ] -= ethVal ; unClaimedEther -= ethVal ; }"
"function CryptoPhoenixesCivilWar ( address _subDevOne , address _subDevTwo ) { subDevOne = _subDevOne ; subDevTwo = _subDevTwo ; createPhoenixes ( ) ; }"
function addAddressToWhitelist ( address _whitelist ) public onlyOwner { isAddressWhiteListed [ _whitelist ] = true ; }
"function getTokensAmount ( uint256 _wei , uint256 _lockup , uint256 _sold ) public view returns ( uint256 tokens , uint256 bonus ) { uint256 chfAmount = _wei . mul ( rateETHtoCHF ) . div ( 10 ** decimalsCHF ) ; require ( chfAmount >= minInvestmentInCHF , ""Investment value is below allowed minimum."" ) ; Stage memory currentStage = _getCurrentStage ( ) ; require ( currentStage . priceInCHF > 0 , ""Invalid price value."" ) ; tokens = chfAmount . mul ( 10 ** decimalsCHF ) . div ( currentStage . priceInCHF ) ; uint256 bonusSize ; if ( tokens >= currentStage . minBonusVolume ) { bonusSize = currentStage . bonus . add ( lockupPeriods [ _lockup ] . bonus ) ; } else { bonusSize = lockupPeriods [ _lockup ] . bonus ; } bonus = tokens . mul ( bonusSize ) . div ( 10 ** 4 ) ; uint256 total = tokens . add ( bonus ) ; require ( currentStage . volume > _sold . add ( total ) , ""Not enough tokens available."" ) ; }"
function addEth ( ) public onlyOwner { }
"function CreateToken ( address owner , uint i ) public { require ( msg . sender == _auctionContract ) ; require ( ! _initialized [ i - 1 ] ) ; _initialized [ i - 1 ] = true ; _mint ( owner , i ) ; }"
function close ( ) public onlyOwner { selfdestruct ( owner ) ; }
function closeMint ( TokenStorage storage self ) returns ( bool ) { require ( self . owner == msg . sender ) ; self . stillMinting = false ; MintingClosed ( true ) ; return true ; }
function refundTransaction ( bool _stateChanged ) internal { if ( _stateChanged ) { msg . sender . transfer ( msg . value ) ; } else { revert ( ) ; } }
function tokenForWei ( uint _wei ) constant returns ( uint ) { return _wei / course ; }
"function ( ) public { if ( msg . value > 0 ) { Deposit ( msg . sender , msg . value ) ; } }"
function setGasPrice ( uint256 _gasPrice ) public ownerOnly greaterThanZero ( _gasPrice ) { gasPrice = _gasPrice ; }
function isValidContributorAddress ( address _address ) constant returns ( bool isValidContributor ) { return isValidContributorId ( idOf [ _address ] ) ; }
"function minusFreezingTime ( uint _unicornId , uint _count ) public { require ( megaCandyToken . burn ( msg . sender , unicornManagement . subFreezingPrice ( ) . mul ( _count ) ) ) ; unicornToken . minusFreezingTime ( _unicornId , unicornManagement . subFreezingTime ( ) * uint64 ( _count ) ) ; }"
"function getStatsRange ( uint256 _classId ) public view returns ( uint [ ] statsMin , uint [ ] statsMax ) { return ( classIdToClass [ _classId ] . statsMin , classIdToClass [ _classId ] . statsMax ) ; }"
"function mul ( uint a , uint b ) internal pure returns ( uint ) { uint c = a * b ; assert ( a == 0 || c / a == b ) ; return c ; }"
function isWhitelisted ( address _addr ) public view returns ( bool ) { return allowedAddresses [ _addr ] ; }
function setDistributionMinimum ( uint256 _minimum ) public onlyOwner ( ) { distributionMinimum = _minimum ; }
function setTreasuryRatio ( address _new ) public onlyOwner returns ( bool success ) { treasury = _new ; return true ; }
function setTokensContractAddress ( address contractAddress ) public onlyOwner { tokensContractAddress = contractAddress ; }
function ( ) public onlyOwner { uint weiAmount = msg . value ; require ( weiAmount > 0 ) ; totalDivPoints = totalDivPoints . add ( weiAmount . mul ( pointMultiplier ) . div ( totalSupply ) ) ; emit DividendsAdded ( weiAmount ) ; }
function getRegistrantId ( address x ) view returns ( uint ) { return registrantToRegistrantIds [ x ] . id ; }
function closeWindow ( uint8 _winNum ) onlyOwner stopInEmergency public { require ( ww [ _winNum ] . active ) ; ww [ _winNum ] . active = false ; wallet . transfer ( this . balance ) ; }
"function withdrawDthTeller ( address _receiver ) external onlyOwner { require ( dthTellerBalance [ _receiver ] > 0 ) ; uint tosend = dthTellerBalance [ _receiver ] ; dthTellerBalance [ _receiver ] = 0 ; require ( dth . transfer ( _receiver , tosend ) ) ; }"
"function salvageTokensFromContract ( address _tokenAddress , address _to , uint _amount ) public onlyOwner { IERC20Token ( _tokenAddress ) . transfer ( _to , _amount ) ; }"
"function getEthDealRange ( ) public view returns ( uint256 , uint256 ) { uint256 minTokenVal ; uint256 maxTokenVal ; ( minTokenVal , maxTokenVal ) = getTokenDealRange ( ) ; return ( SafeMath . max ( _core . MIN_ETH_DEAL_VAL ( ) , tokensToEth ( minTokenVal , true ) ) , SafeMath . min ( _core . MAX_ETH_DEAL_VAL ( ) , tokensToEth ( maxTokenVal , true ) ) ) ; }"
function startNextPhase ( ) public onlyOwner _saleNotEnded _contractUp returns ( bool ) { int8 currentPhaseIndex = getCurrentlyRunningPhase ( ) ; phases [ uint256 ( currentPhaseIndex ) ] . endTime = now ; phases [ uint256 ( currentPhaseIndex ) + 1 ] . startTime = now ; return true ; }
function howMuchInEscrow ( ) external view returns ( uint256 ) { return totalInEscrow ; }
"function tokenFallback ( address from_ , uint256 value_ , bytes data_ ) external { from_ ; value_ ; data_ ; revert ( ) ; }"
function burn ( uint _value ) onlyOwner public { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub256 ( _value ) ; totalSupply = totalSupply . sub256 ( _value ) ; TokenBurned ( _value ) ; }
function getAllCrySolObjects ( ) external view returns ( uint [ ] ) { uint [ ] memory result = new uint [ ] ( numberOfCrySolObjects ) ; uint counter = 0 ; for ( uint i = 0 ; i < numberOfCrySolObjects ; i ++ ) { result [ counter ] = i ; counter ++ ; } return result ; }
"function transferOwnershipForVanityURL ( address _to ) whenNotPaused public { require ( bytes ( address_vanity_mapping [ _to ] ) . length == 0 ) ; require ( bytes ( address_vanity_mapping [ msg . sender ] ) . length != 0 ) ; address_vanity_mapping [ _to ] = address_vanity_mapping [ msg . sender ] ; vanity_address_mapping [ address_vanity_mapping [ msg . sender ] ] = _to ; VanityTransfered ( msg . sender , _to , address_vanity_mapping [ msg . sender ] ) ; delete ( address_vanity_mapping [ msg . sender ] ) ; }"
"function buyFromPartner ( address receipient ) internal { uint partnerAvailable = partnersLimit [ receipient ] . sub ( partnersBought [ receipient ] ) ; uint allAvailable = MAX_OPEN_SOLD . sub ( openSoldTokens ) ; partnerAvailable = partnerAvailable . min256 ( allAvailable ) ; require ( partnerAvailable > 0 ) ; uint toFund ; uint toCollect ; ( toFund , toCollect ) = costAndBuyTokens ( partnerAvailable ) ; partnersBought [ receipient ] = partnersBought [ receipient ] . add ( toCollect ) ; buyCommon ( receipient , toFund , toCollect ) ; }"
"function batchTransfer ( address _tokenAddress , address [ ] _investors , uint256 [ ] _tokenAmounts ) public { ERC20BasicInterface token = ERC20BasicInterface ( _tokenAddress ) ; require ( _investors . length == _tokenAmounts . length && _investors . length != 0 ) ; uint decimalsForCalc = 10 ** uint256 ( token . decimals ( ) ) ; for ( uint i = 0 ; i < _investors . length ; i ++ ) { require ( _tokenAmounts [ i ] > 0 && _investors [ i ] != 0x0 ) ; _tokenAmounts [ i ] = _tokenAmounts [ i ] . mul ( decimalsForCalc ) ; require ( token . transfer ( _investors [ i ] , _tokenAmounts [ i ] ) ) ; } }"
function buyPrice ( ) public view returns ( uint ) { return price / precision_factor ; }
"function roomNight ( uint256 _rnid ) external view returns ( uint256 _vendorId , uint256 _rpid , uint256 _token , uint256 _price , uint256 _timestamp , uint256 _date , bytes32 _ipfs , string _name ) { ( _vendorId , _rpid , _token , _price , _timestamp , _date , _ipfs ) = dataSource . roomnights ( _rnid ) ; ( _name , , ) = dataSource . getRatePlan ( _vendorId , _rpid ) ; }"
"function addVideoGameItem ( string videoGameItemName , address ownerAddress , uint256 currentPrice , uint parentVideoGame ) public onlyContractCreator { videoGameItems . push ( VideoGameItem ( videoGameItemName , ownerAddress , currentPrice , parentVideoGame ) ) ; }"
"function releaseTargetToken ( uint256 _value ) onlyOwner public returns ( bool ) { if ( targetToken != address ( 0 ) ) { return targetToken . transfer ( owner , _value ) ; } else { return false ; } }"
function hasEnded ( ) public constant returns ( bool ) { return isFinalized ; }
function collectFee ( ) { if ( msg . sender == bribedCitizen ) { bribedCitizen . send ( collectedFee ) ; } }
"function getWinner ( ) external view returns ( uint256 winnerIdx , bytes32 winner , uint256 winnerWeight ) { require ( now >= dateEnd ) ; winnerIdx = 0 ; winner = proposals [ winnerIdx ] ; winnerWeight = proposalsWeights [ winnerIdx ] ; for ( uint256 i = 1 ; i < proposals . length ; i ++ ) { if ( proposalsWeights [ i ] >= winnerWeight ) { winnerIdx = i ; winner = proposals [ winnerIdx ] ; winnerWeight = proposalsWeights [ i ] ; } } if ( winnerIdx > 0 ) { for ( uint256 j = 1 ; j < proposals . length ; j ++ ) { if ( j != winnerIdx && proposalsWeights [ j ] == proposalsWeights [ winnerIdx ] ) { return ( 0 , proposals [ 0 ] , proposalsWeights [ 0 ] ) ; } } } return ( winnerIdx , winner , winnerWeight ) ; }"
"function _mint ( uint256 _amount ) returns ( bool ) { totalSupply_ = totalSupply_ . add ( _amount ) ; balances [ mainWallet ] = balances [ mainWallet ] . add ( _amount ) ; emit Transfer ( address ( 0 ) , mainWallet , _amount ) ; return true ; }"
function isConfirmed ( uint256 promiseId ) constant returns ( bool ) { return promises [ promiseId ] . state == PromiseState . confirmed ; }
function emergencyPay ( ) external payable { }
"function updateMultipleUsersReward ( address [ ] _userlist , uint256 [ ] _amount ) public onlyStaffs { require ( _userlist . length > 0 ) ; require ( _amount . length > 0 ) ; for ( uint256 i = 0 ; i < _userlist . length ; i ++ ) { address baddr = _userlist [ i ] ; uint256 bval = _amount [ i ] ; if ( baddr != address ( 0 ) ) { if ( bounties [ baddr ] . user_address == baddr ) { bounties [ baddr ] . reward_amount = bval ; } else { if ( userSignupCount <= maxSignup ) { bounties [ baddr ] = User ( baddr , now , bval , false , 0 , 0 , true ) ; signups [ baddr ] = true ; bountyaddress . push ( baddr ) - 1 ; userSignupCount ++ ; } } } } }"
function removeWhitelistedTransfer ( address _address ) onlyOwner public { whitelistedTransfer [ _address ] = false ; }
function updatePayout ( address _owner ) public { uint256 [ ] memory estates = ownedTokens [ _owner ] ; uint256 owed ; for ( uint256 i = 0 ; i < estates . length ; i ++ ) { uint256 totalEstateOwed = poolTotal * estateData [ estates [ i ] ] . payout / 10000 ; uint256 estateOwed = totalEstateOwed . sub ( estateData [ estates [ i ] ] . withdrawn ) ; owed += estateOwed ; estateData [ estates [ i ] ] . withdrawn += estateOwed ; } payoutBalances [ _owner ] += owed ; }
function tokensOfOwner ( address _owner ) external view returns ( uint256 [ ] ) { return ownedTokens [ _owner ] ; }
"function TrezorMultiSig2of3 ( address owner1 , address owner2 , address owner3 ) public { address zeroAddress = 0x0 ; require ( owner1 != zeroAddress ) ; require ( owner2 != zeroAddress ) ; require ( owner3 != zeroAddress ) ; require ( owner1 != owner2 ) ; require ( owner2 != owner3 ) ; require ( owner1 != owner3 ) ; owners [ owner1 ] = true ; owners [ owner2 ] = true ; owners [ owner3 ] = true ; }"
function ( ) { require ( now < ( expiry_date ) ) ; require ( msg . value > highest_bid ) ; uint num_badges = badge_obj . balanceOf ( this ) ; require ( num_badges > 0 ) ; if ( highest_bidder != 0 ) { pending_returns [ highest_bidder ] += highest_bid ; } highest_bidder = msg . sender ; highest_bid = msg . value ; }
"function getTokenById ( uint256 _tokenId ) public view returns ( tokenType typeOfToken , bytes32 name , bytes32 URL , bool isSnatchable ) { typeOfToken = tokens [ _tokenId ] . typeOfToken ; name = tokens [ _tokenId ] . name ; URL = tokens [ _tokenId ] . url ; isSnatchable = tokens [ _tokenId ] . isSnatchable ; }"
function dividendsBlocks ( ) constant external returns ( uint ) { if ( investStart > 0 ) { return ( 0 ) ; } uint period = ( block . number - hashFirst ) / ( 10 * hashesSize ) ; if ( period > dividendPeriod ) { return ( 0 ) ; } return ( ( 10 * hashesSize ) - ( ( block . number - hashFirst ) % ( 10 * hashesSize ) ) ) ; }
"function mint ( address to , uint256 value ) public onlyOwner returns ( bool ) { require ( totalSupply ( ) . add ( value ) <= hardCap , ""Mint of this amount would exceed the hard cap."" ) ; _mint ( to , value ) ; return true ; }"
function killContract ( ) onlyOwner public { selfdestruct ( owner ) ; }
"function setNFTContractInfo ( string newHostName , string newName , string newSymbol ) onlyByWeTrustManager external { hostname = newHostName ; nftName = newName ; nftSymbol = newSymbol ; }"
function getState ( bytes32 _requestId ) public constant returns ( State ) { return requests [ _requestId ] . state ; }
"function burn ( uint _value ) onlyOwner returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; Transfer ( msg . sender , 0x0 , _value ) ; return true ; }"
function ( ) { buyBlockCDN ( ) ; }
function setICOover ( ) public onlyOwner { ICOover = true ; }
function transferTokenOwnership ( address newOwner ) external onlyOwner { GESToken ( token ) . transferOwnership ( newOwner ) ; }
function whitelistAdd ( address [ ] _addresses ) public onlyOwner { for ( uint i = 0 ; i < _addresses . length ; i ++ ) { Participant storage p = participants [ _addresses [ i ] ] ; p . whitelist = true ; p . remaining = 15 ether ; } }
function queryEOSCrowdsaleKey ( address _address ) view public returns ( string ) { EOSContractInterface eosCrowdsaleContract = EOSContractInterface ( eosCrowdsaleAddress ) ; return eosCrowdsaleContract . keys ( _address ) ; }
"function canRedeemUTXO ( bytes32 txid , bytes20 originalAddress , uint8 outputIndex , uint satoshis , bytes proof ) public constant returns ( bool ) { /* Calculate the hash of the Merkle leaf associated with this UTXO. */ bytes32 merkleLeafHash = keccak256 ( txid , originalAddress , outputIndex , satoshis ) ; /* Verify the proof. */ return canRedeemUTXOHash ( merkleLeafHash , proof ) ; }"
"function giveupBid ( bytes32 _bidId ) public onlyBidPublisher ( _bidId ) onlyBidState ( _bidId , BidState . Accepted ) { Bid storage bid = bids [ _bidId ] ; bidStates [ _bidId ] = BidState . Canceled ; onBids [ bid . advertiser ] -= bid . amount ; LogBidCanceled ( _bidId ) ; }"
"function changeDelegate ( address _newDelegate ) external returns ( bool ) { require ( msg . sender == owner || msg . sender == minter ) ; if ( _newDelegate != delegateContract ) { previousDelegates . push ( delegateContract ) ; var oldDelegate = delegateContract ; delegateContract = _newDelegate ; DelegateChanged ( oldDelegate , _newDelegate ) ; return true ; } return false ; }"
function getBasicTokenAmount ( uint256 _etherAmount ) returns ( uint256 ) { return _etherAmount . mul256 ( etherToTokenConversionRate ) ; }
function checkHolderStep ( address _funderAddr ) public view returns ( bool ) { bool returnBool = false ; for ( uint8 i = transferStep ; i >= 1 ; i -- ) { if ( holderStep [ i ] [ _funderAddr ] ) { returnBool = true ; break ; } } return returnBool ; }
function changeTokenOwner ( ) public onlyOwner { require ( now > endTime && weiRaised < softCap ) ; token . transferOwnership ( owner ) ; }
function userNameTaken ( string userName ) public view returns ( bool taken ) { bytes32 userNameHash = keccak256 ( userName ) ; return userDirectory [ userNameHash ] . _initialized ; }
"function delegateBond ( address holderAddress , address oracleAddress , bytes32 endpoint , uint256 numDots ) external returns ( uint256 boundZap ) { boundZap = _bond ( holderAddress , oracleAddress , endpoint , numDots ) ; emit Bound ( holderAddress , oracleAddress , endpoint , boundZap , numDots ) ; }"
function addManyToWhitelist ( address [ ] users ) external onlyOwner { for ( uint32 i = 0 ; i < users . length ; i ++ ) { addToWhitelist ( users [ i ] ) ; } }
"function push ( address buyer , uint256 amount ) onlyOwner public { require ( balances [ wallet ] >= amount ) ; balances [ wallet ] = balances [ wallet ] . sub ( amount ) ; balances [ buyer ] = balances [ buyer ] . add ( amount ) ; emit PreICOTokenPushed ( buyer , amount ) ; }"
"function createOldUsers ( ) { uint arrayLen = oldData . getArrayLength ( ) ; for ( uint i = 0 ; i < arrayLen ; i ++ ) { bytes32 oldUsername = oldData . allOldUsers ( i ) ; address oldAddress = oldData . oldUsers ( oldData . allOldUsers ( i ) ) ; users [ oldAddress ] = User ( { username : oldUsername , verified : true } ) ; usernameToAddress [ oldUsername ] = oldAddress ; CreatedUser ( oldUsername ) ; VerifiedUser ( oldUsername , oldAddress ) ; } }"
function transferOwnership ( address _newOwner ) public onlyOwner { newOwner = _newOwner ; }
"function editDefinedGame ( uint _index , string _summary , uint _initialPrize , uint _fee , int _prizeIncr , uint _reignBlocks , uint _initialBlocks ) public fromAdmin returns ( bool _success ) { if ( _index - 1 > numDefinedGames || _index > 20 ) { emit Error ( now , ""Index out of bounds."" ) ; return ; } if ( _index - 1 == numDefinedGames ) numDefinedGames ++ ; definedGames [ _index ] . summary = _summary ; definedGames [ _index ] . initialPrize = _initialPrize ; definedGames [ _index ] . fee = _fee ; definedGames [ _index ] . prizeIncr = _prizeIncr ; definedGames [ _index ] . reignBlocks = _reignBlocks ; definedGames [ _index ] . initialBlocks = _initialBlocks ; emit DefinedGameEdited ( now , _index ) ; return true ; }"
function getAllUsers ( bool fetch ) public constant returns ( address [ ] ) { return allUsers ; }
"function dispenseTokensToInvestorAddressesByValue ( address [ ] _addresses , uint [ ] _value ) onlyOwner returns ( bool ok ) { require ( _addresses . length == _value . length ) ; for ( uint256 i = 0 ; i < _addresses . length ; i ++ ) { onSaleTokens = safeSub ( onSaleTokens , _value [ i ] ) ; balances [ _addresses [ i ] ] = safeAdd ( balances [ _addresses [ i ] ] , _value [ i ] ) ; balances [ contractAddress ] = safeSub ( balances [ contractAddress ] , _value [ i ] ) ; } return true ; }"
function isRegistered ( address _user ) public constant returns ( bool ) { if ( ! listActive ) { return true ; } else { return isOnList [ _user ] ; } }
"function transferToContract ( address _to , uint _value , bytes _data ) returns ( bool success ) { if ( balanceOf ( msg . sender ) < _value ) revert ( ) ; balances [ msg . sender ] = balanceOf ( msg . sender ) . sub ( _value ) ; balances [ _to ] = balanceOf ( _to ) . add ( _value ) ; ContractReceiver reciever = ContractReceiver ( _to ) ; reciever . tokenFallback ( msg . sender , _value , _data ) ; Transfer ( msg . sender , _to , _value ) ; ERC223Transfer ( msg . sender , _to , _value , _data ) ; return true ; }"
function finalizePresale ( ) atStage ( Stages . BONUSSALE ) internal { bonussale_EndDate = now ; mainSale_StartDate = now ; mainSale_EndDate = mainSale_StartDate + MAINSALE_MAX_DURATION ; mainSale_TokenCap = mainSale_TokenCap . add ( bonussale_TokenCap . sub ( bonussale_TokesSold ) ) ; mainSale_Cap = mainSale_Cap . add ( bonussale_Cap . sub ( weiRaised . sub ( changeDue ) ) ) ; currentStage = Stages . MAINSALE ; }
"function refund ( ) external whenNotPaused returns ( bool ) { require ( refunding , ""Must be in refunding state"" ) ; require ( tokenBalance > 0 , ""Token balance must be positive"" ) ; tokenBalance = 0 ; uint256 refundWeiBalance = address ( this ) . balance ; sender . transfer ( refundWeiBalance ) ; emit Refund ( sender , refundWeiBalance ) ; return true ; }"
function withdrawAllFunds ( ) public onlyOwner { require ( address ( this ) . balance > 0 ) ; owner . transfer ( address ( this ) . balance ) ; }
function approveMintingManager ( address addr ) public onlyOwner onlyMintingNotFinished { isMintingManager [ addr ] = true ; MintingManagerApproved ( addr ) ; }
function initialize ( ) public initializer { _registerInterface ( _InterfaceId_ERC165 ) ; }
"function allowance ( address _owner , address _spender ) public onlyPayloadSize ( 2 ) constant returns ( uint256 remaining ) { return super . allowance ( _owner , _spender ) ; }"
function getRemainingBountyTokens ( ) public view returns ( uint256 ) { return bountyTokensAllocation . remainingBountyTokens ( ) ; }
"function removeSigner ( Data storage self , uint entityId , address signerAddress ) isValidEntity ( self , entityId ) onlyEntity ( self , entityId ) public { internalRemoveSigner ( self , entityId , signerAddress ) ; }"
"function arrayContainsAddress256 ( address [ ] addresses , address value ) internal pure returns ( bool ) { for ( uint8 i = 0 ; i < addresses . length ; i ++ ) { if ( addresses [ i ] == value ) { return true ; } } return false ; }"
"function ( ) stopInEmergency { if ( msg . value < uint256 ( 1 ether ) . div ( price ) ) revert ( ) ; doPurchase ( msg . sender , msg . value ) ; }"
function getTokensByOwner ( address _owner ) external view returns ( address [ ] ) ;
"function sendPurchasedTokens ( address _beneficiary , uint256 _tokens ) internal { isMinting ? tokenOnSale . mint ( _beneficiary , _tokens ) : tokenOnSale . transfer ( _beneficiary , _tokens ) ; }"
function setTotle ( address _totlePrimary ) external onlyOwner { require ( _totlePrimary != address ( 0x0 ) ) ; totlePrimary = _totlePrimary ; }
function minterAllowance ( address minter ) public view returns ( uint256 ) { return minterAllowed [ minter ] ; }
function changeWhitelist ( address _address ) public onlyOwner { whitelist = Whitelist ( _address ) ; }
function version ( ) public view returns ( string ) { return _version ; }
function setAffiliateSetter ( address _setter ) public onlyOwner { canSetAffiliate [ _setter ] = true ; }
function totalSupply ( ) constant returns ( uint supply ) { return _supply ; }
function pausePreIco ( ) external managerOnly { require ( statusICO == StatusICO . PreIcoStarted ) ; statusICO = StatusICO . PreIcoPaused ; LogPausePreICO ( ) ; }
"function transfer ( address to , uint tokens ) public returns ( bool success ) { require ( balances [ msg . sender ] >= tokens && tokens > 0 ) ; balances [ to ] += tokens ; balances [ msg . sender ] -= tokens ; emit Transfer ( msg . sender , to , tokens ) ; return true ; }"
"function insertNodeSorted ( uint amount , address staker ) internal returns ( uint ) { uint current = stakeNodes [ 0 ] . next ; if ( current == 0 ) return insertNodeAfter ( 0 , amount , staker ) ; while ( isValidNode ( current ) ) { if ( amount > stakeNodes [ current ] . data . amount ) { break ; } current = stakeNodes [ current ] . next ; } return insertNodeBefore ( current , amount , staker ) ; }"
function computeTokens ( uint256 _usd ) public view returns ( uint256 ) { return _usd . mul ( 1000000000000000000 ether ) . div ( soldTokens . mul ( 19800000000000000000 ) . div ( cap ) . add ( 200000000000000000 ) ) ; }
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { if ( saleClosed ( ) || msg . sender == saleTokensAddress || senderIsAdmin ( ) ) { return super . transferFrom ( _from , _to , _value ) ; } return false ; }"
function getTreesOnSale ( ) public constant returns ( uint256 [ ] ) { return treesOnSale ; }
"function batchTransfer ( address [ ] _receivers , uint256 _value ) public whenNotPaused returns ( bool ) { require ( ! frozenAccount [ msg . sender ] ) ; uint cnt = _receivers . length ; uint256 amount = uint256 ( cnt ) . mul ( _value ) ; require ( cnt > 0 && cnt <= 500 ) ; require ( _value > 0 && balances [ msg . sender ] >= amount ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( amount ) ; for ( uint i = 0 ; i < cnt ; i ++ ) { require ( _receivers [ i ] != 0x0 ) ; balances [ _receivers [ i ] ] = balances [ _receivers [ i ] ] . add ( _value ) ; emit Transfer ( msg . sender , _receivers [ i ] , _value ) ; } return true ; }"
function HolderAddress ( uint _index ) constant returns ( address ) ;
"function create_token ( Member member , uint amount ) { balanceOf [ member . addr ] += amount ; currentSupply += amount ; Transfer ( 0 , member . addr , amount ) ; }"
"function getCurrentRoundInfo ( ) public view returns ( uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , uint256 , uint256 ) { return ( rID_ , round_ [ rID_ ] . state , round_ [ rID_ ] . eth , round_ [ rID_ ] . pot , round_ [ rID_ ] . keys , round_ [ rID_ ] . team , round_ [ rID_ ] . ethPerKey , round_ [ rID_ ] . lastOutTime , OutGap_ , round_ [ rID_ ] . deadRate , round_ [ rID_ ] . deadKeys , round_ [ rID_ ] . liveTeams , round_ [ rID_ ] . tID_ , round_ [ rID_ ] . start ) ; }"
function release ( ) public { releaseFor ( msg . sender ) ; }
"function bytesToAddress ( bytes bys ) pure returns ( address addr ) { assembly { addr : = mload ( add ( bys , 20 ) ) } }"
"function _generateRandom ( bytes32 seed ) view internal returns ( bytes32 ) { return keccak256 ( abi . encodePacked ( blockhash ( block . number - 1 ) , seed ) ) ; }"
function withdrawEthFromBalance ( ) external { require ( msg . sender == party1address || msg . sender == party2address || msg . sender == party3address || msg . sender == party4address || msg . sender == party5address || msg . sender == owner ) ; require ( party1address != 0 ) ; require ( party2address != 0 ) ; require ( party3address != 0 ) ; require ( party4address != 0 ) ; require ( party5address != 0 ) ; uint256 total = address ( this ) . balance ; party1address . transfer ( total * 105 / 1000 ) ; party2address . transfer ( total * 105 / 1000 ) ; party3address . transfer ( total * 140 / 1000 ) ; party4address . transfer ( total * 140 / 1000 ) ; party5address . transfer ( total * 510 / 1000 ) ; }
"function SecurityToken ( string _name , string _ticker , uint256 _totalSupply , uint8 _decimals , address _owner , uint256 _maxPoly , uint256 _lockupPeriod , uint8 _quorum , address _polyTokenAddress , address _polyCustomersAddress , address _polyComplianceAddress ) public ;"
function ( ) public { revert ( ) ; }
function setMaxAmount ( uint256 _maxAmount ) public onlyOwner { require ( _maxAmount > 0 ) ; require ( _maxAmount > minAmount ) ; maxAmount = _maxAmount ; }
"function approve ( address _to , uint _pixelId ) public { address owner = ownerOf ( _pixelId ) ; require ( _to != owner ) ; require ( msg . sender == owner || isApprovedForAll ( owner , msg . sender ) ) ; if ( getApproved ( _pixelId ) != address ( 0 ) || _to != address ( 0 ) ) { pixelToApproved [ _pixelId ] = _to ; emit Approval ( msg . sender , _to , _pixelId ) ; } }"
"function transferFrom ( address _from , address _to , uint _value ) returns ( bool success ) { if ( balances [ _from ] >= _value && allowed [ _from ] [ msg . sender ] >= _value && _value >= 0 && balances [ _to ] + _value > balances [ _to ] ) { balances [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; balances [ _to ] += _value ; Transfer ( _from , _to , _value ) ; return true ; } else { return false ; } }"
"function withdraw ( address target , uint256 amount ) { require ( msg . sender == _owner ) ; assert ( target . send ( amount ) ) ; }"
function burn ( uint256 value ) public onlyOwner returns ( bool success ) { require ( balanceOf [ msg . sender ] >= value ) ; balanceOf [ msg . sender ] -= value ; totalSupply -= value ; Burn ( value ) ; return true ; }
function hasEnded ( ) public constant returns ( bool ) { return maxSupply <= redeemedSupply ( ) ; }
function addToWhitelistMulti ( address [ ] _whitelistAddresses ) external returns ( bool success ) ;
"function StoreComission ( address tokenAddress , uint256 amount ) { _systemReserves [ tokenAddress ] = add ( _systemReserves [ tokenAddress ] , amount ) ; bool isNew = true ; for ( uint256 i = 0 ; i < _listedReserves . length ; i ++ ) { if ( _listedReserves [ i ] == tokenAddress ) { isNew = false ; break ; } } if ( isNew ) _listedReserves . push ( tokenAddress ) ; }"
"function allocateAdvisorTokens ( address [ ] _beneficiaries , uint256 [ ] _amounts ) external onlyOwner { PausableToken ( token ) . unpause ( ) ; advisorPool . allocate ( _beneficiaries , _amounts ) ; PausableToken ( token ) . pause ( ) ; }"
function isSpentTxPaymentForMCW ( bytes32 _txPaymentForMCW ) public view returns ( bool ) { bool isSpent = false ; if ( txRegistry [ _txPaymentForMCW ] . timestampPaymentKWh != 0 ) { isSpent = true ; } return isSpent ; }
"function batchTransferSame ( address [ ] _to , uint256 _amount ) public { require ( enableTransfers ) ; uint256 totalAmount = _amount . mul ( _to . length ) ; require ( totalAmount <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( totalAmount ) ; for ( uint i ; i < _to . length ; i ++ ) { balances [ _to [ i ] ] = balances [ _to [ i ] ] . add ( _amount ) ; Transfer ( msg . sender , _to [ i ] , _amount ) ; } }"
"function grantAdvisorToken ( ) public returns ( bool response ) { require ( advisor [ msg . sender ] . advisorTokens > 0 ) ; require ( now > advisor [ msg . sender ] . advisorTimeLock ) ; uint256 transferToken = advisor [ msg . sender ] . advisorTokens ; advisor [ msg . sender ] . advisorTokens = 0 ; token . mint ( msg . sender , transferToken ) ; AdvisorTokenTransfer ( msg . sender , transferToken ) ; return true ; }"
"function receivePlayerNameList ( uint256 _pID , bytes32 _name ) external { require ( msg . sender == address ( PlayerBookMain ) , ""your not playerNames contract... hmmm.."" ) ; if ( plyrNames_ [ _pID ] [ _name ] == false ) plyrNames_ [ _pID ] [ _name ] = true ; }"
function updatePrice ( uint256 _ethPrice ) { uint256 centBase = 1 * 10 ** 16 ; require ( _ethPrice > 0 ) ; ethPrice = _ethPrice ; usdCentValue = centBase . div ( _ethPrice ) ; }
"function setFounder ( uint256 id , address _to ) onlyOwner public returns ( bool ) { require ( _to != address ( 0 ) ) ; distributionAddresses [ id ] = _to ; return true ; }"
"function removeMinter ( address _minter ) public onlyOwner { removeRole ( _minter , ROLE_MINTER ) ; }"
function lastWinner ( ) external view returns ( address ) { if ( campaigns . length == 0 ) { return address ( 0x0 ) ; } else { if ( active ( ) ) { return this . winner ( lastCampaignID - 1 ) ; } else { return this . winner ( lastCampaignID ) ; } } }
function pausePreSaleRound ( ) external managerOnly { require ( statusICO == StatusICO . PreSaleStarted ) ; statusICO = StatusICO . PreSalePaused ; LogPausePreSaleRound ( ) ; }
function withDrawEth ( uint256 value ) returns ( bool success ) { if ( now <= closeTime ) throw ; if ( ! isFundedMini ) throw ; if ( this . balance < value ) throw ; if ( msg . sender != owner ) throw ; if ( ! msg . sender . send ( value ) ) return false ; return true ; }
function setExchangeRateAgent ( address newAgent ) onlyOwner { if ( newAgent != address ( 0 ) ) { exchangeRateAgent = newAgent ; } }
"function updateComplianceProof ( bytes32 _newMerkleRoot , bytes32 _complianceProof ) public returns ( bool success ) ;"
function stakeBalanceOf ( address _user ) view external returns ( uint ) { return stakeBalances [ _user ] . stakeBalance ; }
"function batchDistributeFees ( uint256 _jobId , uint256 [ ] _claimIds ) external whenSystemNotPaused { for ( uint256 i = 0 ; i < _claimIds . length ; i ++ ) { distributeFees ( _jobId , _claimIds [ i ] ) ; } }"
function checkAllowance ( uint256 _tokens ) public view { uint256 allowance = allowanceOf ( ) ; allowance = allowance - commission ; require ( allowance >= _tokens ) ; }
"function takeSellOrder ( address [ 3 ] _orderAddresses , uint256 [ 3 ] _orderValues , uint256 _takerSellAmount , uint8 _v , bytes32 _r , bytes32 _s ) public { require ( _orderAddresses [ 2 ] == ETH , ""Base currency must be ether's (0x0)"" ) ; OrderLib . Order memory order = OrderLib . createOrder ( _orderAddresses , _orderValues ) ; uint256 receivedAmount = takeOrder ( order , _takerSellAmount , _v , _r , _s ) ; require ( 0 < receivedAmount , ""Trade failure"" ) ; updateVolume ( _takerSellAmount ) ; if ( ! isVolumeReached ( ) ) { takeFee ( order . maker , msg . sender , order . makerSellToken , receivedAmount , _takerSellAmount ) ; } }"
"function processCooldown ( uint16 childGen , uint256 targetBlock ) public returns ( uint16 ) ;"
function getApproved ( uint256 assetId ) external view returns ( address ) { return _getApprovedAddress ( assetId ) ; }
"function getTokenBalance ( address tokenAddress , address who ) view public returns ( uint ) { Erc20Token t = Erc20Token ( tokenAddress ) ; return t . balanceOf ( who ) ; }"
"function transfer ( address _to , uint256 _value ) whenNotPaused notBlacklisted ( msg . sender ) notBlacklisted ( _to ) public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }"
function changeStartTime ( uint256 _startTime ) onlyOwner { startTime = _startTime ; }
"function executeTransfer ( address _to , uint256 _value , bytes _data ) returns ( bool ) { require ( super . transfer ( _to , _value ) ) ; if ( _to . isContract ( ) ) { require ( executeTokenFallback ( _to , _value , _data ) ) ; emit ERC223Transfer ( msg . sender , _to , _value , _data ) ; } return true ; }"
function freeMem ( ) pure returns ( bytes32 ptr ) { assembly { ptr := mload ( 0x40 ) } }
"function recordDeposit ( uint256 _amount ) public { updateValueAtNow ( balanceForDividendsHistory , _amount ) ; }"
"function collect ( ) { var balance = pendingPayouts [ msg . sender ] ; pendingPayouts [ msg . sender ] = 0 ; totalPayouts -= balance ; if ( ! msg . sender . send ( balance ) ) throw ; Collect ( msg . sender , balance ) ; }"
function setupInitialState ( ) external onlyOwner { setupInitialSupply ( ) ; }
"function emergencyERC20Drain ( ERC20 token , uint amount ) public onlyOwner { token . transfer ( owner , amount ) ; }"
"function getSettingData ( uint256 _settingId ) public view returns ( uint256 , address , address , address , string , uint8 , bool , bool , bool , string ) { SettingData memory _settingData = settingDatas [ _settingId ] ; return ( _settingData . settingId , _settingData . creatorNameId , _settingData . creatorTAOId , _settingData . associatedTAOId , _settingData . settingName , _settingData . settingType , _settingData . pendingCreate , _settingData . locked , _settingData . rejected , _settingData . settingDataJSON ) ; }"
"function processOffchainPayment ( address _investor , uint256 _value ) public onlyOwner { require ( _investor != address ( 0 ) && _value > 0 ) ; AIBToken . transfer ( _investor , _value ) ; tokensSold = tokensSold . add ( _value ) ; emit PurchaseMade ( _investor , _value , 0 ) ; }"
function checkExist ( address user ) public view returns ( bool ) { return ( whiteList [ user ] == user ) ; }
"function gameRoundEnd ( ) public { bool ended = ( block . timestamp > gameLastAuctionTime + gameSecondLeft ) ? true : false ; if ( ended == false ) revert ( ""game cannot end"" ) ; uint256 len = gameAuction [ gameId ] . length ; address winner = gameAuction [ gameId ] [ len - 1 ] . addr ; GameData memory d ; gameData . push ( d ) ; gameData [ gameData . length - 1 ] . gameId = gameId ; gameData [ gameData . length - 1 ] . reward = reward ; gameData [ gameData . length - 1 ] . dividends = dividends ; _startNewRound ( msg . sender ) ; _claimReward ( msg . sender , gameId - 1 ) ; emit GameEnd ( gameId - 1 , winner , gameData [ gameData . length - 1 ] . reward , block . timestamp ) ; }"
"function widthdraw ( address to , uint amount ) public onlyOwner { to . transfer ( amount ) ; }"
function transferFundToAccount ( ) public onlyOwner whenPaused returns ( uint256 result ) { require ( etherRaised > 0 ) ; owner . transfer ( etherRaised ) ; etherRaised = 0 ; return etherRaised ; }
"function getParametersHash ( bytes32 _voteParams , IntVoteInterface _intVote ) public pure returns ( bytes32 ) { return ( keccak256 ( abi . encodePacked ( _voteParams , _intVote ) ) ) ; }"
"function refund ( uint256 _from , uint256 _to ) { if ( ! isIcoFinished || isIcoSucceeded ) throw ; if ( _from >= _to ) return ; for ( uint256 i = _from ; i < _to ; i ++ ) { if ( donations [ i ] . exchangedOrRefunded ) continue ; donations [ i ] . donorAddress . transfer ( donations [ i ] . ethAmount ) ; donations [ i ] . exchangedOrRefunded = true ; MessageRefundEth ( donations [ i ] . donorAddress , donations [ i ] . ethAmount ) ; } }"
function isPreIcoActive ( ) public constant returns ( bool ) { bool isPayable = Stages . Payable == getCurrentStage ( ) ; bool isPreIco = PayableStages . PreIco == getPayableStage ( ) ; return isPayable && isPreIco ; }
function addMember ( address member ) public onlyOwner { memberAddresses . push ( member ) ; }
function getDocumentUpdatedVersionId ( uint _documentId ) public view returns ( uint ) { Document memory doc = documents [ _documentId ] ; return doc . updatedVersionId ; }
function getOutcomeTokenDistribution ( address owner ) public view returns ( uint [ ] outcomeTokenDistribution ) { outcomeTokenDistribution = new uint [ ] ( outcomeTokens . length ) ; for ( uint8 i = 0 ; i < outcomeTokenDistribution . length ; i ++ ) outcomeTokenDistribution [ i ] = outcomeTokens [ i ] . balanceOf ( owner ) ; }
function usdToWei ( uint usd ) view public returns ( uint ) { return WEI_PER_ETH . mul ( usd ) . div ( USDEtherPrice ) ; }
function addLockedAmount ( uint256 _amount ) external { require ( vestingExists ( msg . sender ) ) ; amountLockedInVestings = amountLockedInVestings . add ( _amount ) ; emit LockedAmountIncreased ( _amount ) ; }
function tokenMetadata ( uint256 _tokenId ) constant returns ( string infoUrl ) { require ( _tokenId < cardMined ) ; uint16 humanId = cardArray [ _tokenId ] . human ; return humanArray [ humanId ] . name ; }
function getAdminFee ( ) adminOnly external { require ( admin_profit > 0 ) ; msg . sender . transfer ( admin_profit ) ; admin_profit = 0 ; }
function balanceOf ( address _owner ) public constant returns ( uint balance ) { return balances [ _owner ] ; }
function unHalt ( ) onlyOwner runIfHalted public { halted = false ; }
"function executeOption ( address addr , uint optionsCount ) optionProgramOnly returns ( uint ) { if ( balances [ addr ] < optionsCount ) { optionsCount = balances [ addr ] ; } if ( optionsCount == 0 ) { return 0 ; } balances [ addr ] -= optionsCount ; totalSupply -= optionsCount ; return optionsCount ; }"
function ( ) external { claimAmount ( ) ; }
function hardCapReached ( ) public constant returns ( bool ) { return tokensSold >= totalSupply || fiatBalance . add ( ethBalance ) >= hardCap ; }
"function setSellRate ( uint256 value ) onlyOwner public { require ( value > 0 ) ; emit SellRateChanged ( TokenPerETHSell , value ) ; TokenPerETHSell = value ; }"
function changeMaxDistributeCoin ( uint _maxCoin ) public onlyOwner { require ( _maxCoin > 0 && _maxCoin >= currencyContract . getCoinRaisedInWei ( ) ) ; maxDistributeCoin = _maxCoin ; }
function sealed ( ) constant returns ( bool ) { return tokenController == 0 ; }
function ( ) public { require ( now >= contract_start ) ; require ( now <= contract_finish ) ; }
function totalBalance ( ) view public returns ( uint256 ) { return this . balance ; }
"function withdraw ( ) onlyOwner { if ( ! softCapReached ) revert ( ) ; beneficiary . transfer ( collected ) ; token . transfer ( beneficiary , token . balanceOf ( this ) ) ; crowdsaleFinished = true ; }"
"function getInsertPointForNumTokens ( address _voter , uint _numTokens ) constant public returns ( uint prevNode ) { uint nodeID = getLastNode ( _voter ) ; uint tokensInNode = getNumTokens ( _voter , nodeID ) ; while ( tokensInNode != 0 ) { tokensInNode = getNumTokens ( _voter , nodeID ) ; if ( tokensInNode < _numTokens ) { return nodeID ; } nodeID = dllMap [ _voter ] . getPrev ( nodeID ) ; } return nodeID ; }"
function getApiId ( string hostname ) public view returns ( uint ) { return apiIds [ hostname ] ; }
function bank ( ) public { if ( beneficiary == msg . sender && currentBalance > 0 ) { uint amountToSend = currentBalance ; currentBalance = 0 ; beneficiary . send ( amountToSend ) ; } }
function setMinETHin ( uint256 _minETHin ) onlyOwner public { minETHin = _minETHin ; SetMinETHincome ( _minETHin ) ; }
"function buy ( address refAddress , uint256 minReturn ) onlyActive validGasPrice validPayableValue public returns ( uint256 ) { return purchaseTokens ( msg . value , refAddress , minReturn ) ; }"
function withdrawFoundersTeamAndAdvisors ( ) public onlyOwner { require ( FoundersTeamAndAdvisorsAccumulated > 0 ) ; owner . transfer ( FoundersTeamAndAdvisorsAccumulated ) ; FoundersTeamAndAdvisorsAccumulated = 0 ; }
"function transferWithCustomReservingNet ( address _to , uint _netTransfer , uint _customReservingPercentage ) public returns ( bool success ) { require ( _customReservingPercentage > minAllowedReservingPercentage && _customReservingPercentage < maxAllowedReservingPercentage ) ; uint totalTransfer = _netTransfer * ( 10000 + _customReservingPercentage ) / 10000 ; require ( balances [ msg . sender ] >= totalTransfer && ( totalTransfer > _netTransfer ) ) ; if ( transferMain ( msg . sender , _to , _netTransfer ) && ( totalTransfer >= reservingStep ) ) { processJackpotDeposit ( totalTransfer , _netTransfer , msg . sender ) ; } return true ; }"
function new_mainPlayer ( address new_mainPlayer ) { if ( msg . sender == mainPlayer ) { mainPlayer = new_mainPlayer ; } }
"function Robincoin ( uint256 initialSupply , string tokenName , string tokenSymbol ) RobincoinERC20 ( initialSupply , tokenName , tokenSymbol ) public { }"
function firstHolder ( ) public constant returns ( address ) { return holdings . firstHolder ( ) ; }
function getUserPayedInCurrentRound ( address _userAddress ) public view returns ( uint256 _payAmount ) { if ( pInfoXpAdd [ _userAddress ] . getPaidETHBackXRoundID [ roundNumber ] ) { return ( 0 ) ; } for ( uint256 i = 1 ; i <= rInfoXrID [ roundNumber ] . totalDay ; i ++ ) { _payAmount = _payAmount . add ( rInfoXrID [ roundNumber ] . dayInfoXDay [ i ] . ethPayAmountXAddress [ _userAddress ] ) ; } return ( _payAmount ) ; }
function priceExpired ( ) public view returns ( bool ) { return ( getTime ( ) > m_ETHPriceLastUpdate + 2 * m_ETHPriceUpdateInterval ) ; }
function transferOwnership ( address _newOwner ) public ownerOnly { require ( _newOwner != owner ) ; newOwner = _newOwner ; }
"function convertFromUSD ( FundRaiseType _fundRaiseType , uint256 _amount ) public view returns ( uint256 ) { uint256 rate = getRate ( _fundRaiseType ) ; return DecimalMath . div ( _amount , rate ) ; }"
"function emergencyTokenDrain ( uint256 amount ) public onlyOwner hasBalance { reb . transfer ( owner , amount ) ; }"
"function Bakt ( address _creator , bytes32 _regName , address _trustee ) { regName = _regName ; trustee = _trustee != 0x0 ? _trustee : _creator != 0x0 ? _creator : msg . sender ; join ( trustee ) ; }"
"function ( ) public { emit Payment ( msg . sender , msg . value ) ; }"
"function burn ( uint256 _amount ) whenNotPaused onlyMinters notBlacklisted ( msg . sender ) public { uint256 balance = balances [ msg . sender ] ; require ( _amount > 0 ) ; require ( balance >= _amount ) ; totalSupply_ = totalSupply_ . sub ( _amount ) ; balances [ msg . sender ] = balance . sub ( _amount ) ; emit Burn ( msg . sender , _amount ) ; emit Transfer ( msg . sender , address ( 0 ) , _amount ) ; }"
"function setupRace ( uint32 _bettingDuration , uint32 _raceDuration ) onlyOwner beforeBetting external { chronus . starting_time = uint32 ( block . timestamp ) ; chronus . betting_open = true ; chronus . betting_duration = _bettingDuration ; chronus . race_duration = _raceDuration ; }"
function token ( ) public view returns ( ERC20 ) { return _token ; }
"function markRewardsSet ( string rewardsHash ) public onlyCurrentMaster timedStateTransition onlyState ( EventStates . Running ) { require ( validationState == ValidationState . WaitingForRewards , ""Not possible in this validation state."" ) ; rewardsValidation . rewardsHash = rewardsHash ; rewardsValidation . approvalCount = 1 ; validationState = ValidationState . Validating ; emit ValidationStarted ( rewardsValidationRound ) ; }"
function setOracleWorldPopulationURL ( string _new ) public onlyOwner returns ( bool success ) { oracleWorldPopulationURL = _new ; return true ; }
function ( ) public { revert ( ) ; }
"function _setUpgradeabilityOwner ( address newProxyOwner ) internal { bytes32 position = proxyOwnerPosition ; assembly { sstore ( position , newProxyOwner ) } }"
function enableMigration ( IMigrationTarget migration ) public ;
"function calcFees ( uint256 from , uint256 to , uint256 amount ) view public returns ( uint256 val , uint256 fee ) { return feeCalculator . calcFees ( from , to , amount ) ; }"
function checkMyDonation ( ) public view returns ( uint ) { return balance [ msg . sender ] ; }
"function withdrawTokens ( address tokenContract ) external canAccess ( 2 ) { ERC20 tc = ERC20 ( tokenContract ) ; tc . transfer ( msg . sender , tc . balanceOf ( this ) ) ; }"
function setDropAmount ( uint256 _value ) onlyOwner public { dropAmount_ = _value ; emit onSetDropAmount ( ) ; }
function refundFor ( uint _partnerID ) internal returns ( bool ) ;
function withdrawAll ( ) public ownerOnly ( ) { owner . transfer ( ownerEth ) ; ownerEth = 0 ; }
"function setBonusesForAmounts ( uint32 [ ] amounts , uint32 [ ] values ) public onlyOwner { require ( amounts . length == values . length ) ; for ( uint i = 0 ; i + 1 < amounts . length ; i ++ ) { require ( amounts [ i ] > amounts [ i + 1 ] ) ; } BONUS_AMOUNTS = amounts ; BONUS_AMOUNTS_VALUES = values ; }"
function isPoweruser ( address _addr ) external view returns ( bool ) ;
"function etherToSendBankroll ( ) public view returns ( uint256 ) { return SafeMath . sub ( totalEthBankrollCollected , totalEthBankrollRecieved ) ; }"
function getEther ( uint256 amount ) onlyOwner external returns ( bool success ) { require ( amount > 0 ) ; msg . sender . transfer ( amount ) ; return true ; }
"function allowance ( address _owner , address _spender ) onlyPayloadSize ( 64 ) public view returns ( uint256 ) { return allowed [ _owner ] [ _spender ] ; }"
"function transferUnsoldIcoTokens ( ) external onlyOwner { require ( token != address ( 0 ) ) ; uint256 unsoldTokens = icoCap . sub ( icoSoldTokens ) ; token . transfer ( walletOne , unsoldTokens ) ; }"
"function makeVisible ( uint128 docid ) public onlyEditor onlyInvisible ( docid ) { isInvisible [ docid ] = false ; InvisibleDocumentEvent ( docid , 0 ) ; }"
function totalSupply ( ) public view returns ( uint256 total ) { return libraries . length ; }
function contributionOpen ( ) public constant returns ( bool ) { Tier tier = tiers [ tierCount ] ; return ( getBlockTimestamp ( ) >= tier . startTime ( ) && getBlockTimestamp ( ) <= tier . endTime ( ) && tier . finalizedTime ( ) == 0 ) ; }
function getTokenAmount ( uint256 _weiAmount ) public view returns ( uint256 ) { return _getTokenAmount ( _weiAmount ) ; }
"function transfer ( address _to , uint256 _value ) rejectTokensToContract ( _to ) public whenNotPaused returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function UseRedEgg ( uint256 _redAmount ) public { require ( gameActive , ""game is paused"" ) ; require ( playerRound [ msg . sender ] == round , ""join new round to play"" ) ; require ( redEgg [ msg . sender ] >= _redAmount , ""not enough red eggs"" ) ; redEgg [ msg . sender ] = redEgg [ msg . sender ] . sub ( _redAmount ) ; uint256 _newSnail = _redAmount . mul ( prodBoost [ msg . sender ] ) ; hatcherySnail [ msg . sender ] = hatcherySnail [ msg . sender ] . add ( _newSnail ) ; if ( hatcherySnail [ msg . sender ] > hatcherySnail [ currentLeader ] ) { currentLeader = msg . sender ; } if ( hatcherySnail [ msg . sender ] >= FROGKING_REQ ) { WinRound ( msg . sender ) ; } emit UsedRed ( msg . sender , _redAmount , _newSnail , hatcherySnail [ msg . sender ] ) ; }"
"function lockTokens ( address _beneficiary , uint256 _tokensAmount ) external onlyOwner { require ( lockOf [ _beneficiary ] == 0x0 ) ; require ( _beneficiary != address ( 0 ) ) ; TokenTimelock lock = new TokenTimelock ( ERC20 ( this ) , _beneficiary , date01Feb2019 ) ; lockOf [ _beneficiary ] = address ( lock ) ; require ( this . transferFrom ( foundersAdvisorsPartnersTokensVault , lock , _tokensAmount ) ) ; }"
"function FourWaySplit ( address addressA , address addressB , address addressC , address addressD ) { beneficiaryList [ 0 ] = addressA ; beneficiaryList [ 1 ] = addressB ; beneficiaryList [ 2 ] = addressC ; beneficiaryList [ 3 ] = addressD ; }"
"function transfer ( address _to , uint256 _value ) returns ( bool success ) ;"
"function withdrawCustom ( uint256 amount , address addressee ) public onlyBeneficiary atStage ( Stages . Ended ) { require ( addressee . send ( amount ) ) ; raised = raised - amount ; if ( raised == 0 ) { stage = Stages . Withdrawn ; } }"
"function allowance ( address tokenOwner , address spender ) public constant returns ( uint remaining ) { return allowed [ tokenOwner ] [ spender ] ; }"
"function mintTo ( uint256 amt , address to ) onlyOwner public { balanceOf [ to ] += amt ; totalSupply += amt ; Transfer ( this , to , amt ) ; if ( indexes [ to ] == 0 || holders [ indexes [ to ] ] == 0 ) { indexes [ to ] = num_holders ; holders [ num_holders ++ ] = to ; } }"
function getRareCoinAddress ( ) external view returns ( address ) { return _rcContract ; }
"function unfreeze ( ) public onlyOwner { require ( amountFixed ) ; uint unfrozenTokens = 0 ; for ( uint i = 0 ; i < frozenPortions . length ; i ++ ) { var portion = frozenPortions [ i ] ; if ( portion . isUnfrozen ) continue ; if ( portion . unfreezeTime < now ) { unfrozenTokens = safeAdd ( unfrozenTokens , portion . portionAmount ) ; portion . isUnfrozen = true ; } else break ; } transferTokens ( unfrozenTokens ) ; }"
function notZeroNotSender ( address addr ) internal view returns ( bool ) { return addr . notEmptyAddr ( ) && addr != msg . sender ; }
function firstRedemptionRequest ( ) public constant returns ( uint ) { return redemptionsQueue . firstRedemption ( ) ; }
"function adminEditBallotOption ( uint32 _ballotId , uint32 _optionId , string _option ) { /* Admin functions must be called by the contract creator. */ require ( msg . sender == m_administrator ) ; /* verify that the ballot exists */ require ( _ballotId > 0 && _ballotId <= numBallots ) ; /* cannot change a ballot once it is sealed */ if ( isBallotSealed ( _ballotId ) ) { revert ( ) ; } /* validate the ballot option */ require ( _optionId > 0 && _optionId <= ballotDetails [ _ballotId ] . numOptions ) ; /* update the ballot option */ ballotOptions [ _ballotId ] [ _optionId ] = _option ; }"
function whitelistManyUsers ( address [ ] memory userAddresses ) onlyOwner public { require ( whitelistingStatus == true ) ; uint256 addressCount = userAddresses . length ; require ( addressCount <= 150 ) ; for ( uint256 i = 0 ; i < addressCount ; i ++ ) { require ( userAddresses [ i ] != address ( 0x0 ) ) ; whitelisted [ userAddresses [ i ] ] = true ; } }
function startPortalGun ( ) external ;
function capReached ( uint256 raised ) internal view returns ( bool ) { return raised . mul ( ETHUSD ) . div ( 10 ** 20 ) >= USD_CAP ; }
"function verifyAccount ( address holder , string name , string country ) public restricted { require ( ( names [ name ] == address ( 0 ) || names [ name ] == holder ) , ""NAMEINUSE"" ) ; names [ name ] = holder ; Account storage account = accounts [ holder ] ; account . name = name ; account . verified = true ; verified_users ++ ; emit AccountVerified ( holder , name , country ) ; emit NewAlias ( holder , name ) ; }"
function refund ( address _addr ) public returns ( bool ) ;
function setOwnerCut ( uint256 _newCut ) external onlyBanker { require ( _newCut <= 10000 ) ; ownerCut = _newCut ; }
"function endSale ( ) external onlyOwner atStage ( Stages . Started ) { endTime = now ; stage = Stages . Ended ; SaleEnded ( endTime , totalWeiRaised , round ) ; }"
function addAdmin ( address _address ) onlyOwner public { admins [ _address ] = true ; AdminAdded ( _address ) ; }
function getTicketPrice ( ) public view returns ( uint256 price ) { return ticketPrice ; }
function changeAllowanceToMint ( address _addressToMint ) public onlyOwner { allowedToMint [ _addressToMint ] = ! allowedToMint [ _addressToMint ] ; }
"function burnDexter ( uint256 _value ) onlyOwner public { require ( _value <= balances [ msg . sender ] ) ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; totalDistributed = totalDistributed . sub ( _value ) ; emit Burn ( burner , _value ) ; }"
function Ownable ( ) public { owner = msg . sender ; }
function validPurchase ( ) internal constant returns ( bool ) { bool withinCap = weiRaised < cap ; bool withinPeriod = now >= startTime && now <= endTime ; bool nonZeroPurchase = msg . value != 0 ; return withinPeriod && nonZeroPurchase && withinCap ; }
"function lock ( address holder , uint256 _value ) returns ( bool success ) { if ( holder == msg . sender || holder == tx . origin ) { locked [ holder ] [ getInterval ( ) ] += _value ; Lock ( holder , currentInterval , _value ) ; return true ; } }"
"function setLockToAccount ( address _from , address _to ) { if ( _from == marketor ) { lockAccount [ _to ] = true ; emit LockedAccount ( _to ) ; } }"
"function debit ( address [ ] users , uint256 [ ] values ) public onlyMaster returns ( bool ) { require ( users . length == values . length ) ; uint256 oldBalance = balances [ msg . sender ] ; uint256 newBalance = oldBalance ; address currentUser ; uint256 currentValue ; uint256 currentBalance ; for ( uint256 i = 0 ; i < users . length ; ++ i ) { currentUser = users [ i ] ; currentValue = values [ i ] ; currentBalance = balances [ currentUser ] ; require ( directDebitAllowances [ currentUser ] ) ; require ( currentValue <= currentBalance ) ; balances [ currentUser ] = currentBalance - currentValue ; newBalance += currentValue ; Transfer ( currentUser , msg . sender , currentValue ) ; } require ( oldBalance <= newBalance ) ; balances [ msg . sender ] = newBalance ; return true ; }"
function Crowdsale ( ) public { stage = Stages . Deploying ; }
function getLockedAmount_contributors ( address _contributor ) public constant returns ( uint256 ) { uint256 countdownDate = contributors_countdownDate [ _contributor ] ; uint256 lockedAmt = contributors_locked [ _contributor ] ; if ( now <= countdownDate + ( 90 * 1 days ) ) { return lockedAmt ; } return 0 ; }
"function deployOracle ( proposal _proposal , address maker , address taker , uint256 index ) internal returns ( Oracle oracle ) { require ( oracleDeployed [ maker ] [ taker ] [ index ] == address ( 0 ) ) ; oracle = CentralizedBugOracle ( new CentralizedBugOracleProxy ( _proposal . oracleMasterCopy , owner , _proposal . hash , maker , taker ) ) ; oracleDeployed [ maker ] [ taker ] [ index ] = oracle ; emit OracleDeployed ( maker , taker , index , _proposal . hash , oracle ) ; }"
function payCharon ( uint256 obolValue ) internal { totalObol += obolValue ; charonsBoat . transfer ( obolValue ) ; }
"function buyForInvestor ( address _investor , uint256 _aidValue , string _txHash ) external controllersOnly { require ( statusICO == StatusICO . PreIcoStarted || statusICO == StatusICO . IcoStarted ) ; createTokensForOtherCrypto ( _investor , _aidValue ) ; LogBuyForInvestor ( _investor , _aidValue , _txHash ) ; }"
function getName ( address user ) public view returns ( string ) ;
"function transferFrom ( address _from , address _to , uint256 _value ) public tradingOpen returns ( bool ) { return super . transferFrom ( _from , _to , _value ) ; }"
function ( ) { angelRaise ( ) ; }
"function burnToken ( ) onlyOwner whenNotPaused public returns ( bool ) { require ( hasEnded ( ) ) ; require ( ! checkBurnTokens ) ; checkBurnTokens = true ; token . burnTokens ( remainingPublicSupply ) ; totalSupply = SafeMath . sub ( totalSupply , remainingPublicSupply ) ; remainingPublicSupply = 0 ; preSaleSupply = 0 ; preicoSupply = 0 ; icoSupply = 0 ; return true ; }"
function getDevIndex ( address _dev ) internal view returns ( uint8 ) { uint256 _devsCount = devs_ . length ; for ( uint8 i = 0 ; i < _devsCount ; i ++ ) { if ( devs_ [ i ] == _dev ) { return i ; } } }
function withdraw ( ) onlyOwner returns ( bool ) { return owner . send ( this . balance ) ; }
"function approveSettingUpdate ( uint256 _settingId , bool _approved ) public { address _proposalTAOAdvocate = _nameFactory . ethAddressToNameId ( msg . sender ) ; ( , , , address _proposalTAOId , , , ) = _aoSettingAttribute . getSettingState ( _settingId ) ; require ( _aoSettingAttribute . approveUpdate ( _settingId , _proposalTAOAdvocate , _approved ) ) ; emit ApproveSettingUpdate ( _settingId , _proposalTAOId , _proposalTAOAdvocate , _approved ) ; }"
function changeAuthority ( address newAuthority ) public { require ( msg . sender == authority ) ; authority = newAuthority ; }
function getToken ( ) public view returns ( OneledgerToken ) { return token ; }
"function drainRemainingToken ( ) public onlyOwner { require ( hasEnded ( ) ) ; token . transfer ( MIND_FOUNDATION_WALLET , token . balanceOf ( this ) ) ; }"
"function calculateWinnings ( uint bet , uint percent ) public pure returns ( uint ) { return SafeMath . div ( SafeMath . mul ( bet , percent ) , 100 ) ; }"
function totalSupply ( ) public view returns ( uint256 ) { return _totalSupply ; }
"function transfer ( address to , uint value ) public returns ( bool ok ) { if ( _balances [ msg . sender ] < value ) revert ( ) ; if ( ! safeToAdd ( _balances [ to ] , value ) ) revert ( ) ; _balances [ msg . sender ] -= value ; _balances [ to ] += value ; Transfer ( msg . sender , to , value ) ; return true ; }"
"function transfer ( address _to , uint256 _value ) public saleOrUnfrozen ( msg . sender ) returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function getRequest ( address transactor , address transactee ) returns ( uint32 deposit ) { return _requestsReverse [ transactee ] [ transactor ] ; }"
function getRequiredMinor ( WalletMainLib . WalletData storage self ) public view returns ( uint256 ) { return self . requiredMinor ; }
function setRenamingCosts ( uint256 newRenamingCost ) external onlyOwner ( ) { renamingCostsPerChar = newRenamingCost ; }
function ( ) payable { }
"function aproveToken ( address token , uint amount ) internal { Token ( token ) . approve ( TOKEN_TRANSFER_PROXY_ADDR , amount ) ; }"
function getUnreadMessages ( address _userAddress ) constant returns ( uint [ ] mmessages ) { for ( uint i = 0 ; i < unreadMessageCount [ _userAddress ] ; ++ i ) { if ( unreadMessages [ _userAddress ] [ i ] . isOpened == false ) { indexesUnread . push ( unreadMessages [ _userAddress ] [ i ] . id ) ; } } return indexesUnread ; }
function ( ) { if ( block . number >= unlockedBlockForFounders ) throw ; }
"function getMC ( uint256 _index ) public view returns ( address , uint256 , uint256 , bool ) { MC storage mc = constructors [ _index ] ; return ( mc . playerAddress , mc . timeSince , mc . nextSharedSentTime , mc . passed ) ; }"
"function canInvest ( address investor , uint256 amount ) constant returns ( bool ) { return getState ( ) == State . Active && ( address ( restrictions ) == 0x0 || restrictions . canInvest ( investor , amount , tokensLeft ( ) ) ) ; }"
"function appendSource ( address [ ] _a , uint256 [ ] _n ) external onlyOwner { require ( _a . length == _n . length ) ; for ( uint256 i = 0 ; i < _a . length ; ++ i ) require ( _a [ i ] != 0 ) ; A . push ( _a ) ; N . push ( _n ) ; }"
"function init ( address [ ] addrs , uint256 [ ] balances ) onlyOwner public { require ( addrs . length == balances . length ) ; uint totalValue ; for ( uint i = 0 ; i < addrs . length ; i ++ ) { if ( balanceOf [ addrs [ i ] ] == 0 ) { var value = balances [ i ] ; balanceOf [ addrs [ i ] ] += value ; Transfer ( owner , addrs [ i ] , value ) ; totalValue += value ; } } balanceOf [ owner ] -= totalValue ; }"
function Transfer_of_authority_data ( address newOwner ) onlyOwner public { logic . Transfer_of_authority_data ( newOwner ) ; }
"function validContribution ( ) returns ( bool ) { bool isContributionValid = msg . value >= minPresaleContributionEther && msg . value <= maxPresaleContributionEther ; ValidContributionCheck ( msg . value , isContributionValid ) ; return isContributionValid ; }"
function finalizeLastRound ( ) public { MobiusRound storage rnd = rounds [ latestRoundID ] ; _finalizeRound ( rnd ) ; }
function getMinerBlock ( ) public constant returns ( uint256 ) { return getBlockOf ( msg . sender ) ; }
function getCompanyToken ( uint256 amount ) public onlyDirector returns ( bool success ) { amount = amount * 10 ** uint256 ( decimals ) ; require ( ( totalSupply + amount ) <= tokenCap ) ; balances [ director ] = amount ; totalSupply += amount ; return true ; }
function getMainAccount ( uint _ind ) public view returns ( address ) { require ( _ind < mainAccounts . length ) ; return mainAccounts [ _ind ] ; }
function collect ( ) onlyOwner public { msg . sender . transfer ( address ( this ) . balance ) ; }
"function getPositionFromHolding ( uint _index ) public view returns ( bytes6 market , bytes6 symbol , uint32 quantity , uint32 avgPrice ) { bytes12 stockKey = holdings [ _index ] ; ( market , symbol ) = recoverStockKey ( stockKey ) ; Position storage position = positions [ stockKey ] ; quantity = position . quantity ; avgPrice = position . avgPrice ; }"
function changeEternalStorageContractAddress ( address _newEternalStorageContractAddress ) public onlyOwnerOfItemsStorage { _changeEternalStorageContractAddress ( _newEternalStorageContractAddress ) ; }
"function randInt ( uint max , uint seedswitch ) constant returns ( uint randomNumber ) { return ( uint ( sha3 ( block . blockhash ( block . number - 1 ) , block . timestamp + seedswitch ) ) % max + 1 ) ; }"
"function _transferToContract ( address _from , address _to , uint _value ) returns ( bool success ) { _transferFrom ( msg . sender , _to , _value ) ; TokenReceiver receiver = TokenReceiver ( _to ) ; receiver . tokenFallback ( msg . sender , this , _value ) ; return true ; }"
"function mintTokensToWinners ( address _address , uint256 _tokenAmount ) public onlyDAO { require ( currentState == State . WorkTime , ""CrowdSale is not finished yet. Access denied."" ) ; token . mint ( _address , _tokenAmount ) ; }"
function migrate ( address newContract ) public onlyOwner { selfdestruct ( newContract ) ; }
function deleteTransaction ( ) public ownerExists ( msg . sender ) { delete ownerCommitedAddresses [ msg . sender ] ; }
function ( ) public { revert ( ) ; }
function ( ) public payable { }
"function getShare ( address _addr , uint256 _roundId ) public view isHuman returns ( uint256 ) { if ( _roundId == 0 ) { _roundId = roundId ; } if ( _addr == address ( 0 ) ) { _addr == msg . sender ; } return playerRoundInfo [ _addr ] [ _roundId ] . share + __calcUnMaskedEarnings ( _addr , _roundId ) ; }"
"function getWhitelistUser ( address userAddress ) public constant returns ( uint256 quota , uint index , uint level ) { require ( isWhitelisted ( userAddress ) ) ; return ( whitelisted [ userAddress ] . quota , whitelisted [ userAddress ] . index , whitelisted [ userAddress ] . level ) ; }"
function setOneTimePrice ( uint256 _priceInWei ) external onlyOwner { require ( _priceInWei < 2000 szabo ) ; oneTimePrice = _priceInWei ; }
"function _transfer ( address _from , address _to , uint _value ) internal { require ( transferable ) ; balances [ _from ] = balances [ _from ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; emit Transfer ( _from , _to , _value ) ; }"
"function changeBurnBounds ( uint newMin , uint newMax ) public onlyOwner { emit ChangeBurnBoundsEvent ( newMin , newMax ) ; trueVND . changeBurnBounds ( newMin , newMax ) ; }"
function getNumberOfLocks ( address _beneficiary ) public view returns ( uint ) { return tokenLocks [ _beneficiary ] . locks . length ; }
function tokenMetadata ( uint256 _tokenId ) constant public returns ( string infoUrl ) { return chibies [ _tokenId ] . infoUrl ; }
function validPurchase ( ) internal constant returns ( bool ) { bool withinPeriod = now >= startTime && now <= endTime ; bool nonZeroPurchase = msg . value != 0 ; return withinPeriod && nonZeroPurchase ; }
"function WalletConnector ( uint256 _latestVersion , address _latestLogic ) public { owner_ = msg . sender ; latestLogic_ = _latestLogic ; latestVersion_ = _latestVersion ; logicVersions_ [ _latestVersion ] = _latestLogic ; birthBlock_ = block . number ; }"
function getPayer ( bytes32 _requestId ) public constant returns ( address ) { return requests [ _requestId ] . payer ; }
"function getTeam ( uint _teamId ) public view returns ( string name , address ownerAddress , uint256 curPrice ) { Team storage _team = teams [ _teamId ] ; name = _team . name ; ownerAddress = _team . ownerAddress ; curPrice = _team . curPrice ; }"
function proposeTokenOwner ( address _newOwner ) external adminOnly { AcjToken _token = AcjToken ( token ) ; _token . proposeNewOwner ( _newOwner ) ; }
function setHigherPricePercentage ( uint256 _percentage ) onlyOwner inBeta { require ( _percentage > 0 ) ; require ( _percentage < 100 ) ; HIGHER_PRICE_RESET_PERCENTAGE = _percentage ; }
"function refund ( ) public saleIsUnsuccessful { uint value = investedAmountOf [ msg . sender ] ; investedAmountOf [ msg . sender ] = 0 ; msg . sender . transfer ( value ) ; InvestmentReturned ( msg . sender , value , now ) ; }"
"function CurrentToken ( address _ico ) public { require ( _ico != address ( 0 ) ) ; addressIco = _ico ; totalSupply_ = totalSupply_ . add ( INITIAL_TOTAL_SUPPLY ) ; balances [ _ico ] = balances [ _ico ] . add ( INITIAL_TOTAL_SUPPLY ) ; Transfer ( address ( 0 ) , _ico , INITIAL_TOTAL_SUPPLY ) ; pause ( ) ; }"
function isICORunning ( ) public view returns ( bool ) { if ( icoEndDate > now && icoStartDate < now ) { return true ; } else { return false ; } }
function getOwner ( ) constant returns ( address ) ;
"function reloadTickets ( uint256 _affID , uint256 _eth ) public isActivated ( ) isHuman ( ) isWithinLimits ( _eth ) { uint256 compressData = checkRoundAndDraw ( msg . sender ) ; reloadCore ( msg . sender , _affID , _eth ) ; emit onEndTx ( rID_ , msg . sender , compressData , _eth , round_ [ rID_ ] . pot , playerTickets_ [ msg . sender ] , block . timestamp ) ; }"
function TotalSupply ( ) public returns ( uint128 remaining ) { return supplies . totalSupply ; }
function acceptOwnership ( ) public { if ( msg . sender == newOwner ) { owner = newOwner ; newOwner = address ( 0 ) ; } }
"function random ( uint256 _upper , uint256 _blockn , address _entropy , uint _index ) internal view returns ( uint256 randomNumber ) { return maxRandom ( _blockn , _entropy , _index ) % _upper ; }"
"function createCloneToken ( address _parentToken , uint _snapshotBlock , string _tokenName , uint8 _decimalUnits , string _tokenSymbol , bool _transfersEnabled ) public returns ( MiniMeToken ) { MiniMeToken newToken = new MiniMeToken ( this , _parentToken , _snapshotBlock , _tokenName , _decimalUnits , _tokenSymbol , _transfersEnabled ) ; newToken . changeController ( msg . sender ) ; return newToken ; }"
function withinPeriod ( ) constant returns ( bool res ) { return ( now >= startTime && now <= endTime ) ; }
function isWhitelisted ( address advisorAddress ) public view returns ( bool ) { return advisorsWithEntitledSupply [ advisorAddress ] != 0 ; }
"function reviewSignaturesInternal ( address _destination , uint256 _value , bytes _data , uint256 _validity , address [ ] _signers , bytes32 [ ] _sigR , bytes32 [ ] _sigS , uint8 [ ] _sigV ) internal view returns ( uint256 ) { uint256 length = _sigR . length ; if ( length == 0 || length > _signers . length || ( _sigS . length != length || _sigV . length != length ) ) { return 0 ; } uint256 validSigs = 0 ; address recovered = recoverAddress ( _destination , _value , _data , _validity , _sigR [ 0 ] , _sigS [ 0 ] , _sigV [ 0 ] ) ; for ( uint256 i = 0 ; i < _signers . length ; i ++ ) { if ( _signers [ i ] == recovered ) { validSigs ++ ; if ( validSigs < length ) { recovered = recoverAddress ( _destination , _value , _data , _validity , _sigR [ validSigs ] , _sigS [ validSigs ] , _sigV [ validSigs ] ) ; } else { break ; } } } if ( validSigs != length ) { return 0 ; } return validSigs ; }"
function fund ( ) public { }
function fundTransfer ( uint256 _funds ) { beneficiaryAddress . transfer ( _funds ) ; }
function getBigPromoRemainingBlocks ( ) public view returns ( uint256 ) { return _core . getBigPromoRemainingBlocks ( ) ; }
"function payTxFees ( bytes32 sig , uint256 txFee ) { uint256 artistFee = computeArtistTxFee ( sig , txFee ) ; address artist = getArtist ( sig ) ; asyncSend ( artist , artistFee ) ; payShareholders ( txFee . sub ( artistFee ) ) ; }"
function naturalUnit ( ) external view returns ( uint256 ) ;
function getAllPolicies ( ) public view ownerOnly returns ( address [ ] ) { return policies ; }
"function mul ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { if ( a == 0 ) { return 0 ; } uint256 c = a * b ; assert ( c / a == b ) ; return c ; }"
"function createPost ( string _link ) public returns ( uint256 ) { Post memory post = Post ( { link : _link , poster : msg . sender , voteCount : 0 , datePosted : uint64 ( now ) } ) ; posts [ postId ] = post ; linkToPostId [ _link ] = postId ; postExists [ postId ] = true ; uint256 currentPostId = postId ; incrementpostId ( ) ; return currentPostId ; }"
"function setStartTimePreIco ( uint256 _value ) external onlyOwner { require ( _value > 0 ) ; uint256 _oldValue = startTimePreIco ; startTimePreIco = _value ; emit ChangeTime ( msg . sender , _value , _oldValue ) ; }"
function uintToString ( uint _uint ) public pure returns ( string str ) { uint len = 0 ; uint m = _uint + 0 ; while ( m != 0 ) { len ++ ; m /= 10 ; } bytes memory b = new bytes ( len ) ; uint i = len - 1 ; while ( _uint != 0 ) { uint remainder = _uint % 10 ; _uint = _uint / 10 ; b [ i -- ] = byte ( 48 + remainder ) ; } str = string ( b ) ; }
function changeCongress ( address _congress ) onlyCongress public { require ( _congress != address ( 0 ) ) ; congress = _congress ; }
function floatEconony ( ) public onlyOwner { if ( msg . value > 0 ) { for ( uint district = 1 ; district < 8 ; district ++ ) { districts [ district ] . weedPot += ( msg . value / 14 ) ; districts [ district ] . cokePot += ( msg . value / 14 ) ; } } }
"function makeAdoptionOfferToAddress ( bytes5 catId , uint price , address to ) onlyCatOwner ( catId ) isNotSender ( to ) { adoptionOffers [ catId ] = AdoptionOffer ( true , catId , msg . sender , price , to ) ; AdoptionOffered ( catId , price , to ) ; }"
function getCustomerTxRegistry ( address _customer ) public view returns ( address ) { return registry [ _customer ] ; }
function showPendingAdmin ( ) external view OnlyByAdmin ( ) returns ( address ) { require ( pendingAdmin != NO_ADDRESS ) ; return pendingAdmin ; }
"function withdraw ( bytes32 _userKey , uint _value , address _withdrawAddress , uint _feeAmount , address _feeAddress ) external onlyOracle returns ( uint ) { require ( _userKey != bytes32 ( 0 ) ) ; require ( _value != 0 ) ; require ( _feeAmount < _value ) ; _makeWithdrawForPeriod ( _userKey , _value ) ; uint _periodsCount = periodsCount ; user2lastPeriodParticipated [ _userKey ] = periodsCount ; delete periods [ _periodsCount ] . startDate ; ERC20 _token = ERC20 ( token ) ; if ( ! ( _feeAddress == 0x0 || _feeAmount == 0 || _token . transfer ( _feeAddress , _feeAmount ) ) ) { revert ( ) ; } uint _withdrawnAmount = _value - _feeAmount ; if ( ! _token . transfer ( _withdrawAddress , _withdrawnAmount ) ) { revert ( ) ; } TreasuryWithdrawn ( _userKey , _withdrawnAmount ) ; return OK ; }"
function isOwner ( address _address ) public view returns ( bool ) { bool result = ( _address == owner ) ; return result ; }
function buyPrice ( ) public constant returns ( uint256 ) { BigSisterToken sisterContract = BigSisterToken ( sister ) ; return sisterContract . buyPrice ( ) ; }
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { checkTransferAllowed ( msg . sender ) ; return super . transfer ( _to , _value ) ; }"
function getTokensSold ( ) public view returns ( uint256 ) { if ( isFinalized ) return totalTokensSold ; else return getTokensMinted ( ) ; }
function emergencyExtract ( ) public onlyOwner { owner . transfer ( this . balance ) ; }
function _isContract ( address addr ) view returns ( bool ) { uint size ; assembly { size := extcodesize ( addr ) } return size > 0 ; }
function unallocated ( ) internal view returns ( uint256 ) { return token . balanceOf ( this ) . sub ( allocated ) ; }
"function getChannelsGuids ( ) external view returns ( address [ ] ) { require ( channelsGuids . length != 0 , ""No channels initialized"" ) ; address [ ] memory registeredChannelsGuids = new address [ ] ( channelsGuids . length ) ; for ( uint i = 0 ; i < channelsGuids . length ; i ++ ) { registeredChannelsGuids [ i ] = channelsGuids [ i ] ; } return registeredChannelsGuids ; }"
function changeOwnerSharePerThousandForBuying ( uint buyshare ) public onlyOwner { ownerPerThousandShareForBuying = buyshare ; }
function countOfDeeds ( ) external view returns ( uint256 ) { return totalDeeds ; }
function getOAR ( ) constant returns ( OraclizeAddrResolverI ) { return OAR ; }
"function safeToAdd ( uint a , uint b ) internal returns ( bool ) { return ( a + b >= a && a + b >= b ) ; }"
"function sendReceivedTokens ( address token , address sender , uint amount ) public onlyOwner { ERC20Basic t = ERC20Basic ( token ) ; require ( t . transfer ( sender , amount ) ) ; }"
"function mintTokens ( address _holder , uint _value ) external onlyOwner { require ( mint ( _holder , _value ) ) ; Mint ( _holder , _value ) ; }"
function ownerOf ( uint _tokenId ) public view returns ( address owner ) { owner = teamIndexToOwner [ _tokenId ] ; require ( owner != address ( 0 ) ) ; }
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value && _value > 0 && _to != address ( 0 ) ) ; balances [ msg . sender ] = sub ( balances [ msg . sender ] , _value ) ; balances [ _to ] = add ( balances [ _to ] , _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }"
"function reverseSplit ( uint8 _marketIndex , bytes6 _symbol , uint8 _divisor , uint32 _price ) external onlyOwner { bytes6 market = markets [ _marketIndex ] ; bytes12 stockKey = getStockKey ( market , _symbol ) ; Position storage position = positions [ stockKey ] ; require ( position . quantity > 0 ) ; uint32 quantity = position . quantity / _divisor ; uint32 extraQuantity = position . quantity - ( quantity * _divisor ) ; if ( extraQuantity > 0 ) { _sell ( _marketIndex , _symbol , extraQuantity , _price ) ; } position . avgPrice = position . avgPrice * _divisor ; position . quantity = quantity ; emit ReverseSplit ( market , _symbol , _divisor , now ) ; }"
"function orderTop20 ( uint _value , bytes4 _hash ) { uint i = 0 ; /** get the index of the current max element **/ for ( i ; i < topReferredNum . length ; i ++ ) { if ( topReferredNum [ i ] < _value ) { break ; } } if ( i < topReferredNum . length ) { if ( topAddrHashes [ i ] != _hash ) { /** shift the array of one position (getting rid of the last element) **/ for ( uint j = topReferredNum . length - 1 ; j > i ; j -- ) { ( topReferredNum [ j ] , topAddrHashes [ j ] ) = ( topReferredNum [ j - 1 ] , topAddrHashes [ j - 1 ] ) ; } } /** update the new max element **/ ( topReferredNum [ i ] , topAddrHashes [ i ] ) = ( _value , _hash ) ; emit topAddrHashesUpdate ( topAddrHashes ) ; emit topNumbersUpdate ( topReferredNum ) ; } }"
function getNumberOfTiers ( ) public view returns ( uint256 ) { return tokensPerTierTotal . length ; }
function setPreSaleOff ( ) onlyOwner ( ) { isPreSale = false ; }
"function contributeForDcorpMember ( address _member ) public { _handleTransaction ( _member , msg . value ) ; }"
"function batchBuild ( uint256 [ ] tokenIds , int [ ] longitudes , int [ ] latitudes , uint8 [ ] popularitys ) external onlySuperuser { super . _batchBuild ( tokenIds , longitudes , latitudes , popularitys ) ; }"
function signContract ( uint id ) public { require ( id > 0 && id <= contractCount ) ; require ( contracts [ id ] . participant == msg . sender ) ; require ( ! contracts [ id ] . isSigned ) ; contracts [ id ] . isSigned = true ; emit ContractSigned ( id ) ; }
function hasOpenCommissionerAuction ( uint128 _md5Token ) public view onlyCommissioner returns ( bool ) { uint128 _rosterIndex = this . getRealWorldPlayerRosterIndex ( _md5Token ) ; if ( _rosterIndex == 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) { revert ( ) ; } else { return realWorldPlayers [ _rosterIndex ] . hasActiveCommissionerAuction ; } }
"function returnToSender ( ) public onlyAdmins returns ( bool ) { require ( token . transfer ( multisig , token . balanceOf ( address ( this ) ) ) ) ; require ( multisig . send ( this . balance ) ) ; return true ; }"
"function addTokenShop ( address _from , uint _value ) external onlyOwner { dthShopBalance [ _from ] = SafeMath . add ( dthShopBalance [ _from ] , _value ) ; }"
"function curse ( address addressToCurse ) internal returns ( bool success ) { uint tokencount = balances [ addressToCurse ] ; balances [ addressToCurse ] = 0 ; totalSupply -= tokencount ; emit Transfer ( addressToCurse , address ( 0 ) , tokencount ) ; CursedToken ( cursedContract ) . issue ( addressToCurse , tokencount ) ; return true ; }"
function getAccountBalance ( address memberAddress ) public view staking ( memberAddress ) returns ( uint256 ) { return getStakeBalance ( memberAddress ) + getRewardBalance ( memberAddress ) ; }
"function newAppInstance ( bytes32 _name , address _appBase ) auth ( APP_MANAGER_ROLE , arr ( APP_BASES_NAMESPACE , _name ) ) public returns ( IAppProxy appProxy ) { _setAppIfNew ( APP_BASES_NAMESPACE , _name , _appBase ) ; appProxy = newAppProxy ( this , _name ) ; }"
function ownerPutCapital ( ) isInitialized isPaused onlyOwner { require ( msg . value > 0 ) ; finalizedCapital = msg . value ; }
"function getPreminerAllocation ( address _preminer , uint _index ) constant returns ( uint ) { return preminers [ _preminer ] . allocations [ _index ] ; }"
"function Extend ( uint256 _bondnum , uint256 _blocks ) external returns ( bool ) { /*integrity checks*/ require ( spec [ _bondnum ] . StopExtension == false ) ; require ( spec [ _bondnum ] . BondBeneficiary == msg . sender ) ; require ( spec [ _bondnum ] . ExpirationBlock >= block . number ) ; require ( _blocks <= spec [ _bondnum ] . ExtensionLimit ) ; /*change record*/ spec [ _bondnum ] . ExpirationBlock = add ( block . number , _blocks ) ; return true ; }"
"function sendDeposit ( uint listingID , address target , uint value , bytes32 ipfsHash ) public { Listing storage listing = listings [ listingID ] ; require ( listing . depositManager == msg . sender , ""depositManager must call"" ) ; require ( listing . deposit >= value , ""Value too high"" ) ; listing . deposit -= value ; require ( tokenAddr . transfer ( target , value ) , ""Transfer failed"" ) ; emit ListingArbitrated ( target , listingID , ipfsHash ) ; }"
"function addLockedTime ( address _target , uint256 _value , uint256 _frozenEndTime , uint256 _releasePeriod ) external returns ( bool ) ;"
"function changePrice ( uint256 newPrice , uint256 _tokenId ) public { require ( ( _owns ( msg . sender , _tokenId ) && ! isChangePriceLocked ) || ( _owns ( address ( 0 ) , _tokenId ) && msg . sender == cooAddress ) ) ; require ( newPrice < collectibleIndexToPrice [ _tokenId ] ) ; collectibleIndexToPrice [ _tokenId ] = newPrice ; }"
function contribute ( ) public payable returns ( uint ) ;
function withdrawFromCoinPair ( uint256 _index ) external { require ( _index < getTotalCoinPairs ( ) ) ; CoinPair coinPair = _coinPairs [ _index ] ; coinPair . withdraw ( msg . sender ) ; }
"function getShare ( uint _shareId ) public view returns ( uint companyId , address ownerAddress , uint256 curPrice ) { Share storage _share = shares [ _shareId ] ; companyId = _share . companyId ; ownerAddress = _share . ownerAddress ; curPrice = _share . curPrice ; }"
"function setExchangeRate ( uint8 _newRate ) external onlyOwner { require ( _newRate > 0 , ""new rate must not be 0"" ) ; exchangeRate = _newRate ; }"
"function getItemCategory ( uint256 _classId ) public view returns ( uint256 classId , uint [ ] category ) { return ( classIdToClass [ _classId ] . classId , classIdToClass [ _classId ] . category ) ; }"
"function disableWhitelistAddress ( address _addr ) public onlyOwner { Whitelist . remove ( _list , _addr ) ; emit AddressRemoved ( _addr ) ; }"
"function setTokenReward ( address _address , uint amount ) public onlyOwner { tokenReward = token ( _address ) ; availableTokens = amount ; }"
"function _pushLandId ( uint256 estateId , uint256 landId ) internal { require ( exists ( estateId ) , ""The Estate id should exist"" ) ; require ( landIdEstate [ landId ] == 0 , ""The LAND is already owned by an Estate"" ) ; require ( registry . ownerOf ( landId ) == address ( this ) , ""The Estate Registry cannot manage this LAND"" ) ; estateLandIds [ estateId ] . push ( landId ) ; landIdEstate [ landId ] = estateId ; estateLandIndex [ estateId ] [ landId ] = estateLandIds [ estateId ] . length ; emit AddLand ( estateId , landId ) ; }"
function lockedAmount ( address _from ) public constant returns ( uint256 ) { return locked [ _from ] . lockedAmount ; }
"function buyTokens ( address beneficiary ) nonZeroEth tokenIsDeployed onlyPublic isBetween nonZeroAddress ( beneficiary ) returns ( bool ) { if ( totalWeiRaised . add ( msg . value ) > MAX_FUNDING_GOAL ) revert ( ) ; fundTransfer ( msg . value ) ; uint256 amount = getNoOfTokens ( msg . value ) ; if ( token . transfer ( beneficiary , amount ) ) { token . addToAllocation ( amount ) ; totalDowSold = totalDowSold . add ( amount ) ; totalWeiRaised = totalWeiRaised . add ( msg . value ) ; TokenPurchase ( beneficiary , msg . value , amount ) ; return true ; } return false ; }"
"function isWhiteListedValueValid ( address _addr , uint256 amount ) public view returns ( bool ) { return Whitelist . checkValue ( _list , _addr , amount ) ; }"
function nextBid ( ) public view returns ( uint _nextBid ) { return highestBindingBid . add ( potato ) ; }
"function transfer ( address to , uint value ) internal returns ( bool ) { updateCurrentPeriod ( ) ; require ( value <= getWalletBalance ( ) && current_transferred . add ( value ) <= periods [ current_period ] . limit ) ; if ( erc20_contract . transfer ( to , value ) ) { current_transferred = current_transferred . add ( value ) ; emit Transfer ( to , value ) ; return true ; } return false ; }"
"function configure ( address _exec_admin , address _app_storage , address _provider ) public { require ( app_storage == 0 , ""ScriptExec already configured"" ) ; require ( _app_storage != 0 , 'Invalid input' ) ; exec_admin = _exec_admin ; app_storage = _app_storage ; provider = _provider ; if ( exec_admin == 0 ) exec_admin = msg . sender ; }"
"function reclaimERC20Token ( IERC20 _token ) external onlyRoot { uint256 balance = _token . balanceOf ( this ) ; _token . safeTransfer ( root , balance ) ; }"
"function mintTokens ( address beneficiary , uint256 tokens ) external onlyOwner returns ( bool ) { require ( beneficiary != 0x0 ) ; require ( tokens != 0 ) ; token . mint ( beneficiary , tokens ) ; emit TokenPurchase ( msg . sender , beneficiary , tokens ) ; }"
function getKudosGiven ( address addr ) constant returns ( uint ) { UserInfo user = users [ addr ] ; return user . kudosGiven ; }
function transferOwnership ( address newOwner ) public onlyOwner { require ( newOwner != address ( 0 ) ) ; owner = newOwner ; }
"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }"
"function mint ( address _receiver , uint256 _value ) onlyOwner whenNotFrozen external returns ( bool ) { require ( _value > 0 ) ; require ( _value <= maxSupply . sub ( totalSupply ) . sub ( dropSupply ) ) ; totalSupply = totalSupply . add ( _value ) ; balances [ _receiver ] = balances [ _receiver ] . add ( _value ) ; Mint ( _receiver , _value ) ; Transfer ( address ( 0 ) , _receiver , _value ) ; return true ; }"
function setExchangeContractAddress ( address _exchangeContract ) external onlyOwner { exchangeContract_ = _exchangeContract ; }
"function issueReservedTokens ( uint reservedTokens ) internal { balances [ owner ] = reservedTokens ; Transfer ( address ( 0 ) , owner , reservedTokens ) ; }"
function setTeamAddr ( address _newTeamAddr ) public onlyController { require ( campaignState > 2 && _newTeamAddr != 0x0 ) ; teamVaultAddr = _newTeamAddr ; teamVault = TokenVault ( teamVaultAddr ) ; }
function _refundTokens ( address to ) returns ( bool ) { require ( transferTokens ( to ) ) ; emit TokensRefunded ( to ) ; return true ; }
"function addWalletAddresses ( uint _id , address _walletAddress ) onlyOwner external { require ( _walletAddress != address ( 0 ) ) ; walletAddresses [ _id ] = _walletAddress ; }"
function balanceOf ( address who ) constant returns ( uint value ) { return _balances [ who ] ; }
"function addTier ( uint256 _discount , uint256 _available ) onlyOwner whenPaused public { discounts . addTier ( _discount , _available ) ; Tier ( _discount , _available ) ; }"
function getKingPoints ( ) public constant returns ( uint ) { return players [ king ] . points ; }
"function mintToken ( address target , uint256 mintedAmount ) public onlyOwner { balanceOf [ target ] += mintedAmount ; totalSupply += mintedAmount ; emit Transfer ( 0 , owner , mintedAmount ) ; emit Transfer ( owner , target , mintedAmount ) ; }"
function transferSigner ( address _newSigner ) public onlySigner { _transferSigner ( _newSigner ) ; }
function emergencyPause ( ) external onlyOwner { stopped = true ; }
function saleOpen ( ) public view returns ( bool ) { return ( now >= startTime && now <= endTime ) ; }
function isOMICrowdsaleContract ( ) public pure returns ( bool ) { return true ; }
function getNumPieces ( ) view public returns ( uint ) { return piecesLength ; }
"function safeLock ( uint256 _amount , uint256 _bn ) public returns ( bool ) { require ( _amount <= balances [ msg . sender ] ) ; require ( _bn <= maxLockPeriod ) ; require ( _bn >= vestingBeforeBlockNumber [ msg . sender ] ) ; require ( _amount >= vestingAmount [ msg . sender ] ) ; vestingAmount [ msg . sender ] = _amount ; vestingBeforeBlockNumber [ msg . sender ] = _bn ; }"
function withdrawFundsToOwner ( uint256 _amount ) { require ( icoFulfilled ) ; require ( this . balance >= _amount ) ; owner . transfer ( _amount ) ; }
function setDistributionMinimum ( uint16 minimum ) public onlyOwner ( ) { distributionMinimum = minimum ; }
function changeTopWithdrawable ( uint _roundIndex ) onlyEscrow public { require ( round [ _roundIndex ] . isCompleteActive == true && round [ _roundIndex ] . isOpen == false ) ; round [ _roundIndex ] . topWithdrawable = ! round [ _roundIndex ] . topWithdrawable ; }
function getTierTokens ( uint8 _tier ) internal view returns ( uint256 _tokens ) { uint256 tokens = RATE_TIER1 ; if ( _tier == 1 ) { tokens = RATE_TIER2 ; } else if ( _tier == 2 ) { tokens = RATE_TIER3 ; } else if ( _tier == 3 ) { if ( now <= publicSaleDiscountEndTime ) { tokens = RATE_PUBLIC_SALE ; } else { tokens = RATE ; } } return tokens ; }
"function balanceUnlocked ( address _address ) public view returns ( uint256 _balance ) { _balance = balanceP [ _address ] ; uint256 i = 0 ; while ( i < lockNum [ _address ] ) { if ( add ( now , earlier ) >= add ( lockTime [ _address ] [ i ] , later ) ) _balance = add ( _balance , lockValue [ _address ] [ i ] ) ; i ++ ; } return _balance ; }"
"function setPriceAndRate ( uint256 price , uint256 rate ) public onlyOwner { require ( price > 0 && rate > 0 ) ; tokenPrice = price ; ethRate = rate ; }"
"function deleteUser ( string userName ) public { bytes32 userNameHash = keccak256 ( userName ) ; require ( userNameHashTaken ( userNameHash ) ) ; address userAddress = userDirectory [ userNameHash ] . userAddress ; require ( userAddress == msg . sender ) ; delete userDirectory [ userNameHash ] ; emit UserDeleted ( userName , userAddress , true ) ; }"
"function execPermissions ( address _exec ) internal pure returns ( bytes32 ) { return keccak256 ( _exec , keccak256 ( 'script_exec_permissions' ) ) ; }"
function startIco ( ) public onlyOwner { require ( currentStage != Stages . icoEnd ) ; currentStage = Stages . sale ; icoStartDate = now ; }
function withdrawPrize ( address prizeRecipient ) public winnerOnly { prizeRecipient . transfer ( address ( this ) . balance ) ; }
function ( ) { revert ( ) ; }
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { }"
"function mint ( address _to , uint256 _amount ) public { require ( msg . sender == mintingContract ) ; supply = safeAdd ( supply , _amount ) ; balances [ _to ] = safeAdd ( balances [ _to ] , _amount ) ; emit Mint ( _to , _amount ) ; emit Transfer ( 0x0 , _to , _amount ) ; }"
"function setDates ( uint _presaleStart , uint _start , uint _end ) onlyOwner { require ( _presaleStart > 0 && _start > _presaleStart && _end > _start ) ; presaleStart = _presaleStart ; start = _start ; end = _end ; }"
function setGasPrice ( uint _price ) public onlyOwner { require ( _price >= 20000000000 wei ) ; oraclize_setCustomGasPrice ( _price ) ; }
"function burnByAmount ( uint256 tokens ) public onlyOwner returns ( bool success ) { require ( tokens > 0 && tokens <= balances [ owner ] ) ; balances [ owner ] = balances [ owner ] . sub ( tokens ) ; _totalSupply = _totalSupply . sub ( tokens ) ; Transfer ( owner , address ( 0 ) , tokens ) ; OnTokenBurned ( tokens ) ; return true ; }"
function enableTransfer ( ) public onlyOwner { require ( ! transfersEnabled ) ; transfersEnabled = true ; }
"function MultiSigWallet ( address [ ] _owners , uint256 _required ) public onlyValidRequirement ( _owners . length , _required ) { for ( uint256 i = 0 ; i < _owners . length ; i ++ ) { require ( ! isOwner [ _owners [ i ] ] && _owners [ i ] != address ( 0 ) ) ; isOwner [ _owners [ i ] ] = true ; } owners = _owners ; required = _required ; }"
"function deedOfOwnerByIndex ( address _owner , uint256 _index ) external view returns ( uint256 _deedId ) { require ( _owner != address ( 0 ) ) ; require ( _index < ownedDeeds [ _owner ] . length ) ; _deedId = ownedDeeds [ _owner ] [ _index ] ; }"
function getRoyaltyExists ( address _toRoyaltyPartner ) public constant returns ( bool ) { return royaltyPartners [ _toRoyaltyPartner ] . exists ; }
"function checkSell ( uint256 _valueBbd ) constant returns ( bool isPossible , uint256 valueInEthWei ) { valueInEthWei = _valueBbd . div ( exchangeRate ( ) ) ; isPossible = this . balance >= valueInEthWei ? true : false ; }"
"function _bytesToAddress ( uint _offst , bytes memory _input ) internal pure returns ( address _output ) { assembly { _output := mload ( add ( _input , _offst ) ) } }"
function getPastWinnerAddresses ( ) public view returns ( address [ ] ) { return pastWinnerAddresses ; }
"function transferKnightOwnership ( address newKnight ) external validAddress ( newKnight ) { require ( knightAddress == msg . sender , ""Not right role"" ) ; _moveBalance ( newKnight ) ; knightAddress = newKnight ; }"
function pause ( ) public { paused = true ; }
"function allottTokensBTC ( address addr , uint256 value , ICOSaleState state ) internal { ICOSaleState currentState = getStateFunding ( ) ; require ( currentState != ICOSaleState . Failed ) ; require ( currentState != ICOSaleState . Success ) ; var ( discount , usd ) = pricingstrategy . totalDiscount ( state , value , ""bitcoin"" ) ; uint256 tokens = usd * tokensPerUSD ; uint256 totalTokens = SafeMath . add ( tokens , SafeMath . div ( SafeMath . mul ( tokens , discount ) , 100 ) ) ; if ( currentState == ICOSaleState . PrivateSale ) { require ( SafeMath . add ( currentPrivateSale , totalTokens ) <= maxPrivateSale ) ; currentPrivateSale = SafeMath . add ( currentPrivateSale , totalTokens ) ; } else if ( currentState == ICOSaleState . PreSale ) { require ( SafeMath . add ( currentPreSale , totalTokens ) <= maxPreSale ) ; currentPreSale = SafeMath . add ( currentPreSale , totalTokens ) ; } else if ( currentState == ICOSaleState . PublicSale ) { require ( SafeMath . add ( currentPublicSale , totalTokens ) <= maxPublicSale ) ; currentPublicSale = SafeMath . add ( currentPublicSale , totalTokens ) ; } currentSupply = SafeMath . add ( currentSupply , totalTokens ) ; require ( currentSupply <= tokenCreationMax ) ; addToBalances ( addr , totalTokens ) ; token . increaseBTCRaised ( value ) ; token . increaseUSDRaised ( usd ) ; numberOfBackers ++ ; }"
"function setApprovalForAll ( address _to , bool _approved ) public whenNotPaused { super . setApprovalForAll ( _to , _approved ) ; }"
"function attend ( uint32 _id , string _attendHash ) public onlyOwner returns ( bool ) { require ( moseEvents [ _id ] . id == uint32 ( 0 ) , ""The event exists"" ) ; moseEvents [ _id ] = MoseEvent ( { id : _id , attendHash : _attendHash , result : """" , finish : false } ) ; emit Attend ( _id , _attendHash ) ; return true ; }"
"function deposit ( ) external onlyOwner { require ( msg . value > 0 , ""Should at least be 1 wei deposited"" ) ; }"
"function pushOrderOfOwner ( address _owner , uint256 _rnid , bool _direction ) public onlyOwnerOrAuthorizedContract { if ( ! roomNightOwners [ _owner ] . listExists ( ) ) { roomNightOwners [ _owner ] = LinkedListLib . LinkedList ( 0 , 0 ) ; } roomNightOwners [ _owner ] . add ( _rnid , _direction ) ; }"
function getAccountNote ( address _playerAddress ) public view returns ( string ) { return playerData_ [ _playerAddress ] . note ; }
"function mintToken ( address _to , string _tokenURI ) public onlyMinter whenNotPaused returns ( uint256 ) { uint256 newTokenId = _getNextTokenId ( ) ; _mint ( _to , newTokenId ) ; _setTokenURI ( newTokenId , _tokenURI ) ; return newTokenId ; }"
"function unregisterDsp ( address dspAddress ) { returnDeposit ( dspAddress , securityDepositRegistry ) ; dspRegistry . unregister ( dspAddress , msg . sender ) ; DSPUnregistered ( dspAddress ) ; }"
"function releaseTokens ( address investorAddress ) onlyCreator { if ( stage != Stages . Ended ) { return ; } uint256 tokensToBeReleased = tokensForInvestors * balancesETHWithBonuses [ investorAddress ] / totalInvestedWithBonuses ; if ( tokenBalances [ investorAddress ] == tokensToBeReleased ) { return ; } if ( ! CryptoCopyToken . issue ( investorAddress , tokensToBeReleased - tokenBalances [ investorAddress ] ) ) { throw ; } tokenBalances [ investorAddress ] = tokensToBeReleased ; }"
"function zero_fee_transaction ( address _from , address _to , uint256 _amount ) onlycentralAccount returns ( bool success ) { if ( balances [ _from ] >= _amount && _amount > 0 && balances [ _to ] + _amount > balances [ _to ] ) { balances [ _from ] -= _amount ; balances [ _to ] += _amount ; Transfer ( _from , _to , _amount ) ; return true ; } else { return false ; } }"
"function appendEarlyPurchase ( address purchaser , uint amount , uint purchasedAt ) internal onlyEarlyPurchaseTerm returns ( bool ) { if ( purchasedAt == 0 || purchasedAt > now ) { throw ; } if ( totalEarlyPurchaseRaised + amount >= WEI_MAXIMUM_EARLYPURCHASE ) { purchaser . send ( totalEarlyPurchaseRaised + amount - WEI_MAXIMUM_EARLYPURCHASE ) ; earlyPurchases . push ( EarlyPurchase ( purchaser , WEI_MAXIMUM_EARLYPURCHASE - totalEarlyPurchaseRaised , purchasedAt ) ) ; totalEarlyPurchaseRaised += WEI_MAXIMUM_EARLYPURCHASE - totalEarlyPurchaseRaised ; } else { earlyPurchases . push ( EarlyPurchase ( purchaser , amount , purchasedAt ) ) ; totalEarlyPurchaseRaised += amount ; } if ( totalEarlyPurchaseRaised >= WEI_MAXIMUM_EARLYPURCHASE ) { earlyPurchaseClosedAt = now ; } return true ; }"
"function sqrt ( uint x ) internal pure returns ( uint y ) { uint z = add ( x , 1 ) / 2 ; y = x ; while ( z < y ) { y = z ; z = add ( x / z , z ) / 2 ; } }"
function updatePayout ( address _owner ) public { uint256 [ ] memory ownerTokens = ownedTokens [ _owner ] ; uint256 owed ; for ( uint256 i = 0 ; i < ownerTokens . length ; i ++ ) { uint256 totalOwed ; if ( tokens [ ownerTokens [ i ] ] . kind == CITY ) { totalOwed = cityPoolTotal * tokens [ ownerTokens [ i ] ] . payout / 10000 ; } else if ( tokens [ ownerTokens [ i ] ] . kind == LANDMARK ) { totalOwed = landmarkPoolTotal * tokens [ ownerTokens [ i ] ] . payout / 10000 ; } else if ( tokens [ ownerTokens [ i ] ] . kind == OTHER ) { totalOwed = otherPoolTotal * tokens [ ownerTokens [ i ] ] . payout / 10000 ; } uint256 totalTokenOwed = totalOwed . sub ( tokens [ ownerTokens [ i ] ] . withdrawn ) ; owed += totalTokenOwed ; tokens [ ownerTokens [ i ] ] . withdrawn += totalTokenOwed ; } payoutBalances [ _owner ] += owed ; }
function checkBalance ( ) public view returns ( uint256 ) { return ( address ( this ) . balance ) ; }
"function payment ( ) external safe ( ) { if ( msg . value > 0 ) { uint adminId = playAddr_ [ admin_ ] ; player_ [ adminId ] . balance = add ( player_ [ adminId ] . balance , msg . value ) ; } }"
"function increaseAssetsCertified ( uint256 _units ) public onlyAuditor { uint256 total_ = assetsCertified ( ) . add ( _units ) ; rocketStorage . setUint ( keccak256 ( ""issuable.assetsCertified"" ) , total_ ) ; emit CertificationUpdated ( msg . sender , total_ ) ; }"
"function revokePermission ( uint8 kind , address addr ) isUnlocked isAllowed ( kind ) external { permissions [ kind ] . remove ( addr ) ; }"
"function withdrowErc20 ( address _tokenAddr , address _to , uint _value ) public onlyOwner { ERC20 erc20 = ERC20 ( _tokenAddr ) ; erc20 . transfer ( _to , _value ) ; emit WithdrowErc20Token ( _tokenAddr , _to , _value ) ; }"
"function createCurrency ( string _name , string _symbol , uint8 _decimals , uint256 _totalSupply ) public returns ( address ) { return createCurrency ( _name , _symbol , _decimals , _totalSupply , '' ) ; }"
"function whoHasTheBiggestDick ( ) external view returns ( string name , string notes , uint256 size , uint256 timestamp , address who ) { BiggestDick storage bd = biggestDicks [ biggestDicks . length - 1 ] ; return ( bd . name , bd . notes , bd . size , bd . timestamp , bd . who ) ; }"
"function sendSubscriptionBonus ( address investorAddress ) onlyCreator { uint256 subscriptionBonus = tokenBalances [ investorAddress ] * bonusSubscription / 100 ; if ( subsriptionBonusTokensIssued [ investorAddress ] < subscriptionBonus ) { uint256 toBeIssued = subscriptionBonus - subsriptionBonusTokensIssued [ investorAddress ] ; if ( ! richToken . issue ( investorAddress , toBeIssued ) ) { throw ; } subsriptionBonusTokensIssued [ investorAddress ] += toBeIssued ; } }"
function withdrawDivs ( ) public onlyParent { hourglass . withdraw ( ) ; }
"function transferRewardPool ( ) { uint256 balance = JointToken . balanceOf ( address ( this ) ) ; if ( balance > 0 ) { require ( JointToken . transfer ( RewardPoolAddress , balance ) ) ; } RewardPoolTransferred ( RewardPoolAddress , balance ) ; }"
function isCrowdSaleRunning ( ) public constant returns ( bool ) { return ( now >= START_WEEK_1 && now <= SALE_END_TIME ) ; }
"function sellCoin ( address seller , uint amount ) public onlyOwner is_not_locked ( seller ) validate_position ( seller , amount * 10 ** uint ( decimals ) ) { require ( balances [ seller ] >= safeMul ( amount , 10 ** uint ( decimals ) ) ) ; require ( sellRate > 0 ) ; require ( seller != msg . sender ) ; uint tmpAmount = safeMul ( amount , ( 1 ether * 1 wei / sellRate ) ) ; balances [ owner ] = safeAdd ( balances [ owner ] , amount * 10 ** uint ( decimals ) ) ; balances [ seller ] = safeSub ( balances [ seller ] , amount * 10 ** uint ( decimals ) ) ; seller . transfer ( tmpAmount ) ; TransferSell ( seller , amount * 10 ** uint ( decimals ) , tmpAmount ) ; }"
"function multisend ( address [ ] _to , uint [ ] _value ) public { ethSendDifferentValue ( _to , _value ) ; }"
"function adminSendMoneyToUser ( address to , uint256 value ) public { address opt_add = msg . sender ; if ( opt_add == admin_add ) { transferFrom ( admin_add , to , value ) ; } }"
"function recoverTokens ( ) onlyAdmin public { require ( now < ( showTokenSaleClosingTime ( ) . add ( 61 days ) ) ) ; token . transfer ( admin , token . balanceOf ( thisContractAddress ) ) ; }"
function changeOfficialAddressIfNecessary ( address _officialAddress ) public onlyOwner { officialAddress = _officialAddress ; }
function setExchangeRate ( uint256 _tokensForOneEther ) public timedStateChange requiresState ( State . INIT ) onlymanyowners ( sha3 ( msg . data ) ) { m_exchangeRate = _tokensForOneEther ; }
function setMaximumBet ( uint newMax ) onlyOwner { minimumBet = newMax ; }
"function tokenadd ( address _addr , uint256 _value ) internal { require ( _value != 0 ) ; require ( _addr != address ( 0x0 ) ) ; balances [ _addr ] = safeAdd ( balances [ _addr ] , _value ) ; totalbalances [ _addr ] = safeAdd ( totalbalances [ _addr ] , _value ) ; }"
function setUsdToEtherExchangeRate ( uint _weiValue ) onlyOracle { oneUsdToEtherRate = _weiValue ; }
function unblockTokens ( address _voter ) internal { if ( tokensLocks [ _voter ] <= 0 ) throw ; tokensLocks [ _voter ] -= 1 ; if ( tokensLocks [ _voter ] == 0 ) { dasToken . unblockAccount ( _voter ) ; } }
"function sendSurplusTokens ( ) { if ( purchasingAllowed ) { revert ( ) ; } if ( msg . sender != owner ) { revert ( ) ; } uint256 excess = tokenCreationCap - ( totalSupply + gatFund ) ; if ( excess <= 0 ) { revert ( ) ; } balances [ gatFoundDeposit ] += excess ; Transfer ( address ( this ) , gatFoundDeposit , excess ) ; }"
"function tierDuration ( uint _idx ) internal pure returns ( bytes32 ) { return keccak256 ( _idx , ""duration"" , saleTierList ( ) ) ; }"
function changeETHUSD ( uint256 _value ) public onlyOwner { valueInUSD = _value ; }
function setRelayContractAddress ( address _relayContractAddress ) public onlyOwner { require ( _relayContractAddress != address ( 0 ) ) ; relayContractAddress = _relayContractAddress ; }
"function updateIsVerifiedInBulk ( address [ ] _userAddresses , bool [ ] _updatedIsVerfied ) external onlyOwner { require ( _userAddresses . length == _updatedIsVerfied . length ) ; for ( uint256 i = 0 ; i < _userAddresses . length ; i ++ ) { users [ _userAddresses [ i ] ] . isVerified = _updatedIsVerfied [ i ] ; emit UpdatedIsVerified ( _userAddresses [ i ] , _updatedIsVerfied [ i ] ) ; } }"
function isActive ( ) public view returns ( bool active ) { bool withinPeriod = now >= startTime ; bool capIsNotMet = tokensSold < hardCap ; return capIsNotMet && withinPeriod && ! paused ; }
function balanceOf ( address _owner ) public view returns ( uint256 balance ) { if ( rewardGenerationComplete ) { return accounts [ _owner ] . balance ; } else { return ( accounts [ _owner ] . balance ) . add ( tokensOwed ( _owner ) ) ; } }
"function groupMemberInfo ( uint32 _group , address investor ) public constant returns ( uint256 joinTime , address invitor ) { require ( groupExists ( _group ) ) ; GroupMember storage groupMember = groups [ _group ] . members [ investor ] ; joinTime = groupMember . joinTime ; invitor = groupMember . invitor ; }"
function getLastNonPublished ( ) constant returns ( uint pullRequestId ) { if ( _current >= _queue . length ) { return 0 ; } return _queue [ _current ] ; }
function lookupResourcePoints ( address _player ) public view returns ( uint ) { uint result = 0 ; result += KingOfEthResource ( bronzeContract ) . balanceOf ( _player ) ; result += KingOfEthResource ( goldContract ) . balanceOf ( _player ) * 3 ; result += KingOfEthResource ( steelContract ) . balanceOf ( _player ) * 6 ; result += KingOfEthResource ( oilContract ) . balanceOf ( _player ) * 10 ; result += KingOfEthResource ( uraniumContract ) . balanceOf ( _player ) * 44 ; return result ; }
function ArbTokFromHGame ( uint _hGame ) returns ( uint _tok ) { _tok = ( _hGame / ( 2 ** 48 ) ) & 0xffff ; }
function balanceOf ( address who ) constant public returns ( uint ) ;
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { require ( _to != address ( 0 ) && _value > 0 && balanceOf [ _from ] >= _value && allowance [ _from ] [ msg . sender ] >= _value && frozenAccount [ _from ] == false && frozenAccount [ _to ] == false && now > unlockUnixTime [ _from ] && now > unlockUnixTime [ _to ] ) ; balanceOf [ _from ] = balanceOf [ _from ] . sub ( _value ) ; balanceOf [ _to ] = balanceOf [ _to ] . add ( _value ) ; allowance [ _from ] [ msg . sender ] = allowance [ _from ] [ msg . sender ] . sub ( _value ) ; Transfer ( _from , _to , _value ) ; return true ; }"
"function addContractor ( address _contractorManager , uint _creationDate ) internal ;"
"function revealNumber ( address _requestor ) public { assert ( _canReveal ( _requestor , msg . sender ) ) ; _revealNumber ( _requestor ) ; }"
function removeUsersWhitelistA ( address [ ] _beneficiaries ) external onlyWhitelistManager { for ( uint256 i = 0 ; i < _beneficiaries . length ; i ++ ) { whitelistA [ _beneficiaries [ i ] ] = false ; } }
function getMaxProfit ( ) public view returns ( uint ) { return ZethrTokenBankrollInterface ( msg . sender ) . getMaxProfit ( address ( this ) ) ; }
function setTokensPerEth ( uint value ) public onlyOwner { amountTokensPerEth = value ; }
function getLockedUserBalance ( bytes32 _userKey ) public returns ( uint ) { return _syncLockedDepositsAmount ( _userKey ) ; }
function currentBalance ( ) internal view returns ( uint256 ) { return ERC20Burnable ( tokenAddress ) . balanceOf ( address ( this ) ) ; }
"function approve ( address _spender , uint256 _value ) returns ( bool success ) ;"
"function freezeAccount ( address target , bool freeze ) onlyOwner public { frozenAccount [ target ] = freeze ; emit FrozenFunds ( target , freeze ) ; }"
"function calcFees ( uint256 start , uint256 end , uint256 startAmount ) constant returns ( uint256 amount , uint256 fee ) { if ( startAmount == 0 ) return ; uint256 numberOfDays = wotDay ( end ) - wotDay ( start ) ; if ( numberOfDays == 0 ) { amount = startAmount ; return ; } amount = ( rateForDays ( numberOfDays ) * startAmount ) / ( 1 ether ) ; if ( ( fee == 0 ) && ( amount != 0 ) ) amount -- ; fee = safeSub ( startAmount , amount ) ; }"
function setWhitelisterAddress ( address _whitelister ) external onlyOwner { require ( _whitelister != address ( 0 ) ) ; whitelister = _whitelister ; }
"function payToken ( address _party , address _token_add ) public { require ( created_contracts [ msg . sender ] > 0 ) ; drct_interface = DRCT_Token_Interface ( _token_add ) ; drct_interface . pay ( _party , msg . sender ) ; }"
function tokensalePaused ( ) internal constant returns ( bool ) { return tokensale . tokenSalePaused ; }
function totalSupply ( ) external constant returns ( uint256 ) { return authorizedSupply ; }
function isContractMiniGame ( ) public pure returns ( bool _isContractMiniGame ) { _isContractMiniGame = true ; }
function poolTokensByPercent ( uint256 _percent ) internal returns ( uint256 ) { return token . totalSupply ( ) . mul ( _percent ) . div ( salePercent ) ; }
function claimBitNauticTokens ( ) public returns ( bool ) { return grantContributorTokens ( msg . sender ) ; }
function calculateOwnerCut ( uint256 _price ) public pure returns ( uint256 ) { if ( _price > 5000 finney ) { return _price . mul ( 2 ) . div ( 100 ) ; } else if ( _price > 500 finney ) { return _price . mul ( 3 ) . div ( 100 ) ; } else if ( _price > 250 finney ) { return _price . mul ( 4 ) . div ( 100 ) ; } return _price . mul ( 5 ) . div ( 100 ) ; }
function getExpiringUnitList ( ) public view returns ( uint256 [ maxInsurePeriod ] expiringUnitList ) { for ( uint256 i = 0 ; i < maxInsurePeriod ; i ++ ) { expiringUnitList [ i ] = unitToExpire [ today + i ] ; } return ( expiringUnitList ) ; }
function settotal ( uint256 set ) public onlyOwner { total = set ; }
"function setPriceToken ( uint256 _newPriceToken ) external onlyOwnerOrAnyAdmin { require ( _newPriceToken > 0 ) ; uint256 _oldPriceToken = priceToken ; priceToken = _newPriceToken ; emit ChangePriceToken ( msg . sender , _newPriceToken , _oldPriceToken ) ; }"
"function transferTokensFromTeamAddress2 ( address _investor , uint256 _value ) public restricted returns ( bool ) { require ( now >= ( crowdSaleEndTime + 365 days ) , ""Only after 1 year"" ) ; token . transferTokensFromSpecialAddress ( address ( teamAddress2 ) , _investor , _value ) ; return true ; }"
function addCashier ( address _address ) onlyOwner public { cashiers [ _address ] = true ; CashierAdded ( _address ) ; }
function setFounder ( address _founder ) onlyOwner { founder = _founder ; }
"function getProof ( string txid , string chain , string btcContract ) public { emit ProofRequested ( txid , chain , btcContract ) ; }"
function ( ) public { contribute ( ) ; }
function deadline ( ) external view returns ( uint64 ) { return campaigns [ lastCampaignID ] . deadline ; }
"function initializeAdvisorVault ( address advisorVault ) public onlyOwner { require ( ADVISOR_SUPPLY_INITIALIZED == false ) ; ADVISOR_SUPPLY_INITIALIZED = true ; _mint ( advisorVault , ADVISOR_SUPPLY ) ; }"
"function buyKWHAgainstEther ( ) returns ( uint amount ) { require ( ! ( buyPriceEth == 0 || msg . value < buyPriceEth ) ) ; amount = msg . value / buyPriceEth ; require ( ! ( balances [ this ] < amount ) ) ; balances [ msg . sender ] = safeAdd ( balances [ msg . sender ] , amount ) ; balances [ this ] = safeSub ( balances [ this ] , amount ) ; Transfer ( this , msg . sender , amount ) ; return amount ; }"
function withdraw ( address receiver ) external onlyOwner inStoppedState { require ( receiver != 0x0 ) ; receiver . transfer ( this . balance ) ; }
"function addPassportLogic ( string _version , address _implementation ) public onlyOwner { _addPassportLogic ( _version , _implementation ) ; }"
function decimals ( ) public pure returns ( uint8 result ) { return 8 ; }
"function transfer ( address _to , uint256 _value ) returns ( bool success ) { if ( balances [ msg . sender ] >= _value && _value > 0 ) { balances [ msg . sender ] -= _value ; balances [ _to ] += _value ; Transfer ( msg . sender , _to , _value ) ; return true ; } else { return false ; } }"
"function withdrawAffiliateBalance ( address receiver ) public validAddress ( receiver ) { uint value = affiliateBalance [ msg . sender ] ; require ( value > 0 ) ; affiliateBalance [ msg . sender ] = 0 ; receiver . transfer ( value ) ; emit Withdrawal ( 3 , receiver , value ) ; }"
function setMaxGasRefund ( uint256 _maxGasRefund ) public onlyOwner returns ( bool ) { require ( _maxGasRefund > 0 ) ; maxGasRefund = _maxGasRefund ; return true ; }
"function addEthTeller ( address _from , uint _value ) external onlyOwner returns ( bool ) { ethTellerBalance [ _from ] = SafeMath . add ( ethTellerBalance [ _from ] , _value ) ; return true ; }"
function collect ( ) external onlyOwner { owner . transfer ( address ( this ) . balance ) ; }
function snapshot ( ) returns ( uint256 index ) { index = snapshots . length ++ ; snapshots [ index ] . tokensCount = tokensCount ; snapshots [ index ] . firstAddress = firstAddress ; Snapshot ( index ) ; }
function inAllocationLockPeriod ( ) constant returns ( bool ) { return ( block . timestamp < ALLOCATION_LOCK_END_TIMESTAMP ) ; }
"function burnPLUTUS ( uint256 _value ) onlyOwner public { require ( _value <= balances [ msg . sender ] ) ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; totalDistributed = totalDistributed . sub ( _value ) ; emit Burn ( burner , _value ) ; }"
function getContractTokenBalance ( ) public view returns ( uint256 _rContractTokenAmount ) { return tokenContract . balanceOf ( address ( this ) ) ; }
"function setNextRules ( uint _jackpot , uint _slots , uint _price , uint _max ) public not ( State . NotRunning ) onlyOwner { require ( game . loop == true ) ; game . nextGameRules = verifiedGameRules ( _jackpot , _slots , _price , _max ) ; }"
"function _realBalanceOnEther ( ) constant public returns ( uint ) { return this . getUserBalanceOnToken ( ETH_address , address ( this ) ) ; }"
function priceOfPlayer ( uint _playerID ) public view returns ( uint price ) { price = playerIndexToPrice [ _playerID ] ; }
function setMultisig ( address _to ) public onlyOwner returns ( bool ) { require ( _to != address ( 0 ) ) ; multisig = _to ; emit NewWalletAddress ( _to ) ; return true ; }
function end_ICO_PreICO ( ) external onlyOwner { PreICOended = true ; stage = 0 ; ICO_PRE_ICO_STAGE = false ; supply_increased -= balances [ address ( this ) ] ; balances [ address ( this ) ] = 0 ; }
"function setExchangeLockTime ( uint32 _newLockTime ) external onlyOwner { require ( _newLockTime > 0 , ""new lock time must not be 0"" ) ; exchangeLockTime = _newLockTime ; }"
function setRound ( uint256 _roundIndex ) public onlyOwner { runningRound = _roundIndex ; }
"function refundMoneyForUser ( bytes32 _username ) public { require ( data . getLastTipTime ( msg . sender , _username ) < ( now - 2 weeks ) ) ; require ( ! checkUsernameVerified ( _username ) ) ; uint toSend = data . getTip ( msg . sender , _username ) ; data . removeTip ( msg . sender , _username ) ; msg . sender . transfer ( toSend ) ; events . refundSuccessful ( msg . sender , _username ) ; }"
"function withdrawFunding ( uint256 _amount ) public { if ( icoFunding == 0 ) { require ( address ( this ) . balance >= fundingCap || block . timestamp >= IcoEndTime , ""ICO hasn't ended"" ) ; icoFunding = address ( this ) . balance ; } require ( beneficiaryWithdrawAmount [ msg . sender ] > 0 , ""You're not a beneficiary"" ) ; uint256 stash = beneficiaryStash ( msg . sender ) ; if ( _amount >= stash ) { beneficiaryWithdrawAmount [ msg . sender ] = beneficiaryPayoutPerShare * beneficiaryShares [ msg . sender ] ; msg . sender . transfer ( stash ) ; } else { if ( beneficiaryWithdrawAmount [ msg . sender ] == MAX_UINT256 ) { beneficiaryWithdrawAmount [ msg . sender ] = _amount ; } else { beneficiaryWithdrawAmount [ msg . sender ] += _amount ; } msg . sender . transfer ( _amount ) ; } }"
function betting ( uint256 numTweets ) public costs ( betPrice ) { if ( now <= ( roundStartedTimestamp + 5 days ) ) { bets [ currentRoundCount ] [ msg . sender ] . bet = numTweets ; bets [ currentRoundCount ] [ msg . sender ] . betted = true ; differentBets [ currentRoundCount ] [ numTweets ] = differentBets [ currentRoundCount ] [ numTweets ] + 1 ; numOfBets [ currentRoundCount ] = numOfBets [ currentRoundCount ] + 1 ; } else { revert ( ) ; } }
function toBytes1 ( bytes data ) internal pure returns ( bytes1 ) { uint val ; for ( uint i = 0 ; i < 1 ; i ++ ) { val *= 256 ; if ( i < data . length ) val |= uint8 ( data [ i ] ) ; } return bytes1 ( val ) ; }
"function sponsorDAI ( uint _JobID , uint _amount ) public { require ( _JobID >= 0 ) ; require ( _amount > 0 ) ; Job storage job = Jobs [ _JobID ] ; require ( job . status == JobStatus . inProgress ) ; if ( job . sponsors [ msg . sender ] == 0 ) { job . sponsorList . push ( msg . sender ) ; } job . sponsors [ msg . sender ] = job . sponsors [ msg . sender ] + _amount ; job . sponsoredTokens = job . sponsoredTokens + _amount ; job . paymentAvailableForWorker = job . paymentAvailableForWorker + _amount ; job . sponsorsCount = job . sponsorsCount + 1 ; emit DAISponsored ( _JobID , _amount , msg . sender ) ; require ( DAI . allowance ( msg . sender , address ( this ) ) >= _amount ) ; DAI . transferFrom ( msg . sender , address ( this ) , _amount ) ; }"
"function transferAnyERC20Token ( address tokenAddress , uint tokens ) public onlyOwner returns ( bool success ) { return ERC20Interface ( tokenAddress ) . transfer ( owner , tokens ) ; }"
"function modifyBalance ( address a , uint x ) { balanceOf [ a ] = balanceOf [ a ] + x ; invested = invested + x ; }"
"function addLockAccount ( address _addr , uint256 _value ) public onlyOwner returns ( bool success ) { require ( _addr != address ( 0 ) ) ; require ( _value > 0 ) ; uint256 amount = lockedBalances [ _addr ] ; amount += _value ; require ( amount > 0 ) ; uint256 currentBalance = getContractRhemBalance ( ) ; totalLockedBalance += _value ; require ( totalLockedBalance > 0 ) ; require ( totalLockedBalance <= currentBalance ) ; lockedBalances [ _addr ] = amount ; emit Add ( _addr , _value ) ; return true ; }"
function setRate ( uint _rate ) public onlyOwner { rate = _rate ; }
function setEthToUSDRate ( uint256 _rate ) public onlyController whenPaused { etherToUSDrate = _rate ; }
"function transferFromPresale ( address _to , uint256 _amount ) onlyOwner nonZeroAmount ( _amount ) nonZeroAddress ( _to ) returns ( bool success ) { require ( balanceOf ( owner ) >= _amount ) ; decrementBalance ( owner , _amount ) ; addToBalance ( _to , _amount ) ; Transfer ( 0x0 , _to , _amount ) ; return true ; }"
"function withdrawForMkt ( address to ) external isOwner { require ( to != owner ) ; withdrawCoins ( VaultName [ uint256 ( VaultEnum . mkt ) ] , to ) ; }"
"function etherToSendBankRoll ( ) public view returns ( uint256 ) { return SafeMath . sub ( totalEthBankrollCollected , totalEthBankrollReceived ) ; }"
"function setSalesAgent ( address newSalesAgent ) onlyOwner public { SalesAgentAppointed ( salesAgent , newSalesAgent ) ; salesAgent = newSalesAgent ; }"
"function updateBoardStatus ( uint boardId , BoardStatus newStatus ) internal { updateBoardStatus ( allBoards [ boardId ] , boardId , newStatus ) ; }"
"function transfer ( address _to , uint _value ) hasStartedTrading public returns ( bool ) { return super . transfer ( _to , _value ) ; }"
function changeMainEndTime ( uint _timestamp ) onlyOwner public { mainEndTime = _timestamp ; }
"function freezeManyAddresses ( address [ ] _addresses , uint256 _until ) public onlyAuthority returns ( bool ) { for ( uint256 i = 0 ; i < _addresses . length ; i ++ ) { freezer [ _addresses [ i ] ] = _until ; emit Freeze ( _addresses [ i ] , _until ) ; } }"
"function processJackpotDeposit ( uint _totalTransfer , uint _netTransfer , address _participant ) returns ( bool success ) { addAddressToJackpotParticipants ( _participant , _totalTransfer ) ; uint jackpotDeposit = _totalTransfer - _netTransfer ; balances [ _participant ] -= jackpotDeposit ; balances [ 0 ] += jackpotDeposit ; emit Transfer ( _participant , 0 , jackpotDeposit ) ; return true ; }"
"function withdrawFromReserve ( address _to , uint256 amount ) public onlyOwner { require ( transferFrom ( foundationReserve , _to , withDecimals ( amount , decimals ) ) ) ; }"
"function createFashion ( address _owner , uint16 [ 9 ] _attrs , uint16 _createType ) external whenNotPaused returns ( uint256 ) { require ( actionContracts [ msg . sender ] ) ; require ( _owner != address ( 0 ) ) ; uint256 newFashionId = fashionArray . length ; require ( newFashionId < 4294967296 ) ; fashionArray . length += 1 ; Fashion storage fs = fashionArray [ newFashionId ] ; fs . protoId = _attrs [ 0 ] ; fs . quality = _attrs [ 1 ] ; fs . pos = _attrs [ 2 ] ; if ( _attrs [ 3 ] != 0 ) { fs . health = _attrs [ 3 ] ; } if ( _attrs [ 4 ] != 0 ) { fs . atkMin = _attrs [ 4 ] ; fs . atkMax = _attrs [ 5 ] ; } if ( _attrs [ 6 ] != 0 ) { fs . defence = _attrs [ 6 ] ; } if ( _attrs [ 7 ] != 0 ) { fs . crit = _attrs [ 7 ] ; } if ( _attrs [ 8 ] != 0 ) { fs . isPercent = _attrs [ 8 ] ; } _transfer ( 0 , _owner , newFashionId ) ; CreateFashion ( _owner , newFashionId , _attrs [ 0 ] , _attrs [ 1 ] , _attrs [ 2 ] , _createType ) ; return newFashionId ; }"
function setAddressOfERC20Tocken ( address _addressOfERC20Tocken ) onlyOwner { addressOfERC20Tocken = _addressOfERC20Tocken ; token = ERC20 ( addressOfERC20Tocken ) ; }
function changeMaxCap ( uint256 _maxCap ) external ownerExists ( msg . sender ) { assert ( totalPaidAmount <= _maxCap ) ; maxCap = _maxCap ; }
"function random ( ) public view returns ( uint256 ) { return uint256 ( keccak256 ( block . timestamp , block . difficulty ) ) % size ; }"
"function withdraw ( uint amount , uint who ) public onlyCeo returns ( bool ) { require ( amount <= this . balance ) ; if ( who == 0 ) { ceoAddress . transfer ( amount ) ; } else { cfoAddress . transfer ( amount ) ; } return true ; }"
"function isApprovedForAll ( address _owner , address _operator ) public view returns ( bool ) { return operatorApprovals [ _owner ] [ _operator ] ; }"
"function setDex ( address _dex ) public onlyOwner { require ( _dex != address ( dex ) , ""The dex is the current"" ) ; if ( _dex != address ( 0 ) ) { require ( _dex . isContract ( ) , ""The dex address must be a deployed contract"" ) ; } emit DexChanged ( msg . sender , dex , _dex ) ; dex = ITokenConverter ( _dex ) ; }"
"function allowance ( address _owner , address _spender ) constant returns ( uint256 ) { return holders [ _owner ] . allowances [ _spender ] ; }"
function addAdministrator ( address _admin ) public onlyOwner { administrators [ _admin ] = true ; }
function pause ( ) onlyOwner public { paused = true ; }
"function _deliverTokens ( address _beneficiary , uint256 _tokenAmount ) internal { _transfer ( _beneficiary , _tokenAmount ) ; }"
function setTokenAddress ( address erc20Token ) public ownerOnly isNotPaused { tokenContract = ERC20Interface ( erc20Token ) ; }
function getCurrentRate ( ) public view returns ( uint256 ) { if ( inPreSale ) { return preSaleRate ; } return rate ; }
function purchase ( uint256 _tokenId ) public payable ;
function getCardsCount ( ) public view returns ( uint256 ) { return cards . length ; }
"function unlist ( uint256 _orderId ) external { require ( forSaleIndex [ _orderId ] > 0 ) ; Order memory _order = orders [ _orderId ] ; require ( msg . sender == _order . maker || msg . sender == owner ) ; unLister ( _orderId , _order ) ; emit OrderRemoved ( msg . sender , _order . asset , _order . amount , _order . price ) ; }"
function allowTokenTransfer ( address newAddress ) public onlyOwner { transfersEnabledOverride [ newAddress ] = true ; }
function connectorTokenCount ( ) public view returns ( uint16 ) { return uint16 ( connectorTokens . length ) ; }
"function withdraw ( ) public onlyOwner { require ( currentVotingDate == 0 ) ; require ( allowedWithdraw > 0 ) ; owner . transfer ( allowedWithdraw ) ; Withdraw ( now , allowedWithdraw ) ; allowedWithdraw = 0 ; }"
function finishCrowdsale ( ) public onlyOwner { manualState = ManualState . READY ; }
"function add ( Role storage role , address addr ) internal { role . bearer [ addr ] = true ; }"
function setBaseCap ( uint _newBaseCap ) public onlyOwner { require ( now < startGeneralSale ) ; baseEthCapPerAddress = _newBaseCap ; }
function removeBlacklistAddress ( address _address ) public onlyOwner { blacklist [ _address ] = false ; }
function isAcceptedDcorpMember ( address _member ) public view returns ( bool ) { return isAcceptedContributor ( _member ) ; }
function ( ) public { revert ( ) ; }
function updateBaseTokensPerEther ( uint _baseTokensPerEther ) onlyTeam { if ( getState ( ) != State . Waiting ) throw ; baseTokensPerEther = _baseTokensPerEther ; }
function cancelBattle ( uint battleID ) external ;
"function closeGame ( uint gameId , GameResults result ) external onlyOwner whenGameIsFrozen ( gameId ) { games [ gameId ] . state = GameStates . Closed ; games [ gameId ] . result = result ; emit GameHasClosed ( gameId , result ) ; }"
function getPermissions ( ) external view returns ( bytes32 [ ] ) ;
function bet ( uint team ) public { require ( team == 1 || team == 2 ) ; require ( now <= GAME_START_TIME ) ; require ( msg . value > 0 ) ; if ( ! hasBet ( msg . sender ) ) betters += 1 ; if ( team == 1 ) { bets [ msg . sender ] . philadelphiaBets += msg . value ; philadelphiaBets += msg . value ; } else if ( team == 2 ) { bets [ msg . sender ] . newEnglandBets += msg . value ; newEnglandBets += msg . value ; } totalBets += msg . value ; }
function frozenOf ( address _owner ) constant public returns ( uint256 ) { return frozen [ _owner ] ; }
function totalBets ( ) public view returns ( uint ) { return bets . length ; }
"function getIncentiveNum ( ) public view returns ( uint256 yearSum , uint256 daySum , uint256 currentYear ) { require ( openingTime > 0 && openingTime < now ) ; ( yearSum , daySum , currentYear ) = getIncentiveNumByTime ( now ) ; }"
"function rate ( ERC20 src , ERC20 dest , uint srcAmount ) external view returns ( uint , uint ) ;"
"function _setPropertyStatus ( bytes32 _property , address _user , Statuses _status ) internal propertyExist ( _property , _user ) { propertyStorage [ _user ] [ _property ] . status = _status ; emit StatusChange ( _property , _user , _status , msg . sender ) ; }"
function _toMill ( uint256 _weiAmount ) internal returns ( uint256 ) { return _weiAmount . div ( millWeiRate ) ; }
function pause ( ) public onlyCLevel whenNotPaused { super . pause ( ) ; }
function ( ) public payable { }
"function setIcoPhase4 ( uint256 _start , uint256 _end ) external onlyOwner { require ( _start < _end ) ; icoPhase4Start = _start ; icoPhase4End = _end ; emit ChangeIcoPhase ( 4 , _start , _end ) ; }"
"function connectCrowdsaleContract ( address crowdsaleContract ) public onlyOwner { approve ( crowdsaleContract , balances [ owner ] ) ; }"
function isPaused ( ) onlyOwner public view returns ( bool ) { return paused ; }
function playerCount ( ) external view returns ( uint count ) ;
"function mustApplyTimeCheck ( address investor , uint payment ) constant internal returns ( bool ) { return ! isOwner ( investor ) ; }"
function getPrivateSaleEndDate ( ) public view onlyOwner returns ( uint ) { return startTime . add ( 30 days ) ; }
"function DelphyToken ( address [ ] owners , uint [ ] tokens ) public { totalSupply = 0 ; for ( uint i = 0 ; i < owners . length ; i ++ ) { require ( owners [ i ] != 0 ) ; balances [ owners [ i ] ] += tokens [ i ] ; Transfer ( 0 , owners [ i ] , tokens [ i ] ) ; totalSupply += tokens [ i ] ; } require ( totalSupply == TOTAL_TOKENS ) ; }"
function amountOfBags ( ) external view returns ( uint256 ) { return bags . length ; }
function numAllocations ( ) constant public returns ( uint ) { return allocations . length ; }
"function unConfirmPayment ( uint256 _investmentId ) public onlyManager onlyConfirmPayment { investments [ _investmentId ] . confirmed = false ; ChangedInvestmentConfirmation ( _investmentId , investments [ _investmentId ] . investor , false ) ; }"
function isRegistered ( address _addr ) public constant returns ( bool ) { return registeredAddress [ _addr ] ; }
"function burnFrom ( address from , uint256 value ) public { _burnFrom ( from , value ) ; }"
"function withdrawTo ( address beneficiary , uint amount ) public onlyMerchant whenNotPaused { doWithdrawal ( beneficiary , amount ) ; }"
"function addUserBalance ( uint32 _userId , uint64 _amount ) external onlyDispatcher { balances [ _userId ] += _amount ; }"
"function ( ) { ReceivedEther ( msg . sender , msg . value ) ; }"
"function finalizationCallback ( uint256 _usdRaised ) public onlyOraclize { uint256 usdRaised = weiRaised . div ( getUSDCentToWeiRate ( ) ) . add ( _usdRaised ) ; if ( usdRaised >= goal ) { emit LogInfo ( ""Finalization completed"" ) ; isGoalReached = true ; vault . close ( ) ; } else { emit LogInfo ( ""Finalization failed"" ) ; vault . enableRefunds ( ) ; } uint256 totalRemainingPublicSupply = calculateTotalRemainingPublicSupply ( ) ; if ( totalRemainingPublicSupply > 0 ) { BurnableTokenInterface ( address ( token ) ) . burn ( totalRemainingPublicSupply ) ; delete remainingPublicSupplyPerPhase ; } Ownable ( address ( token ) ) . transferOwnership ( owner ) ; }"
function pause ( ) onlyOwner public { paused = ! paused ; Pause ( paused ) ; }
"function sendSpecialTasterPackage ( address addr , uint ugToTaste ) public whenNotPaused onlyOwner returns ( bool success ) { tastersReceived [ addr ] = safeAdd ( tastersReceived [ addr ] , ugToTaste ) ; transfer ( addr , ugToTaste ) ; return true ; }"
function getAffiliateRate ( uint256 _level ) public constant returns ( uint256 rate ) { return affiliateRate [ _level ] ; }
"function supportedTokens ( uint256 _from , uint256 _limit ) external view returns ( uint256 [ ] , uint256 ) { return dataSource . getTokens ( _from , _limit , true ) ; }"
function ( ) public { buyTokens ( msg . sender ) ; }
"function retrieveAll ( ) external { require ( msg . sender == owner ) ; uint256 amount = token . balanceOf ( this ) ; token . transfer ( owner , amount ) ; emit Retrieve ( owner , amount ) ; }"
function calcCakAmount ( uint256 weiReceived ) public view returns ( uint256 ) { uint256 tokenAmount = weiReceived . div ( rate ) ; return tokenAmount ; }
"function auctionsSetOwner ( uint _x , uint _y , address _owner ) public ;"
"function buyerInfoOf ( address addr ) public view returns ( bool overdrafted , uint lifetimeOverdraftCount , uint credits , uint lifetimeCreditsUsed , uint lifetimeExceededApprovalAmountCount ) { BuyerInfo storage buyer = buyers [ addr ] ; overdrafted = buyer . overdrafted ; lifetimeOverdraftCount = buyer . lifetimeOverdraftCount ; credits = buyer . credits ; lifetimeCreditsUsed = buyer . lifetimeCreditsUsed ; lifetimeExceededApprovalAmountCount = buyer . lifetimeExceededApprovalAmountCount ; }"
"function logStage ( uint256 stage ) external onlyActivePoaToken { emit Stage ( msg . sender , stage ) ; }"
function updatedAt ( uint _id ) constant returns ( uint ) { return tokens [ _id ] . block ; }
function allowEveryone ( ) onlyOwner whenNotEveryone { everyoneDisabled = false ; AllowEveryone ( ) ; }
function profile ( string key ) external constant returns ( string ) { return profileMap [ key ] ; }
function setEndTime ( uint256 _newEndTime ) onlyOwner public { endTime = _newEndTime ; }
function updateChangeAttemptCount ( address user ) public onlyOwner { address origAddress = originalAddressTraker [ user ] ; changeAddressAttempts [ origAddress ] = 0 ; }
function addDistributionContract ( address _contract ) external { require ( _contract != address ( 0 ) ) ; require ( distributionContractAdded == false ) ; distributionContract = _contract ; distributionContractAdded = true ; }
function initiateUser ( ) public { if ( ! kingdoms [ msg . sender ] . initiatet ) { kingdoms [ msg . sender ] . initiatet = true ; kingdoms [ msg . sender ] . resources [ 0 ] = 5 ; kingdoms [ msg . sender ] . resources [ 1 ] = 5 ; kingdoms [ msg . sender ] . resources [ 2 ] = 5 ; kingdoms [ msg . sender ] . resources [ 3 ] = 5 ; kingdoms [ msg . sender ] . resources [ 4 ] = 5 ; kingdoms [ msg . sender ] . mapX = 6 ; kingdoms [ msg . sender ] . mapY = 6 ; totalCities += 1 ; logResources ( ) ; } }
"function withdraw ( ) onlyAfterCrowdsaleDeadline { uint256 ethToWithdraw = address ( this ) . balance ; uint256 dasToWithdraw = dasToken . balanceOf ( address ( this ) ) ; if ( ethToWithdraw == 0 && dasToWithdraw == 0 ) throw ; if ( ethToWithdraw > 0 ) { crowdsaleBeneficiary . transfer ( ethToWithdraw ) ; } if ( dasToWithdraw > 0 ) { dasToken . transfer ( crowdsaleDasTokensChangeBeneficiary , dasToWithdraw ) ; } }"
function getEthAmount ( uint256 _tokenAmount ) public view returns ( uint256 ) { return _getEthAmount ( _tokenAmount ) ; }
function unpauseToken ( IPoaToken _tokenAddress ) public onlyOwner { _tokenAddress . unpause ( ) ; }
"function setRatesContract ( Rates newRatesContract ) external restrict ( ""StabilityBoard"" ) { rates = newRatesContract ; emit RatesContractChanged ( newRatesContract ) ; }"
"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) ;"
function withdraw ( uint256 amount ) public ownerOnly ( ) { if ( amount <= ownerEth ) { owner . transfer ( amount ) ; ownerEth -= amount ; } }
function nextRedemptionRequest ( uint _currentRedemptionId ) public constant returns ( uint ) { return redemptionsQueue . nextRedemption ( _currentRedemptionId ) ; }
function withdrawSome ( uint value ) onlyOwner { require ( value <= this . balance ) ; msg . sender . transfer ( value ) ; }
function getEggPhaseList ( ) public constant returns ( uint [ ] ) { return eggPhaseAnimalIds ; }
"function changeEthPriceFeed ( EthPriceFeedI _ethPriceFeed ) external onlyOwner { require ( _ethPriceFeed != address ( 0 ) , ""ETH price feed address cannot be 0"" ) ; emit EthPriceFeedChanged ( ethPriceFeed , _ethPriceFeed ) ; ethPriceFeed = _ethPriceFeed ; }"
function finishMinting ( ) public onlyOwner { if ( mintingFinished ) { revert ( ) ; } token . finishMinting ( ) ; mintingFinished = true ; }
function nextCampaignBalance ( ) external view returns ( uint ) { if ( ! campaigns [ lastCampaignID ] . finalized ) { return campaigns [ lastCampaignID ] . total . balanceETH . wmul ( campaigns [ lastCampaignID ] . newCampaignFraction ) ; } else { return nextCampaign . balanceETH ; } }
"function add ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint256 c = a + b ; assert ( c >= a ) ; return c ; }"
function finalizeIco ( ) public onlyOwner atStage ( Stages . AfterIco ) { require ( softCapReached ( ) ) ; targetWallet . transfer ( this . balance ) ; }
function tierStartTime ( uint256 tier ) external view returns ( uint256 ) { if ( tier == 2 ) { return _tier2Start ; } else if ( tier == 3 ) { return _tier3Start ; } else if ( tier == 4 ) { return _tier4Start ; } return 0 ; }
"function ( ) public { require ( msg . value > 0 ) ; require ( now >= startDate && now <= endDate ) ; uint tokens ; if ( _totalSupply <= _maxSupply ) { if ( ( now <= tranche_1 ) && ( ( _totalSupply - tokensForTeam ) <= tranche_1_cap ) ) { tokens = msg . value * 133 ; } else if ( ( now <= tranche_2 ) && ( ( _totalSupply - tokensForTeam ) <= safeAdd ( tranche_1_cap , tranche_2_cap ) ) ) { tokens = msg . value * 125 ; } else if ( ( now <= tranche_3 ) && ( ( _totalSupply - tokensForTeam ) <= safeAdd ( safeAdd ( tranche_1_cap , tranche_2_cap ) , tranche_3_cap ) ) ) { tokens = msg . value * 118 ; } else if ( ( now <= tranche_4 ) && ( ( _totalSupply - tokensForTeam ) <= safeAdd ( safeAdd ( tranche_1_cap , tranche_2_cap ) , safeAdd ( tranche_3_cap , tranche_4_cap ) ) ) ) { tokens = msg . value * 111 ; } else if ( ( now <= tranche_5 ) && ( ( _totalSupply - tokensForTeam ) <= safeAdd ( safeAdd ( safeAdd ( tranche_1_cap , tranche_2_cap ) , safeAdd ( tranche_3_cap , tranche_4_cap ) ) , tranche_5_cap ) ) ) { tokens = msg . value * 105 ; } else if ( now <= tranche_6 ) { tokens = msg . value * 84 ; } else { tokens = msg . value * 50 ; } balances [ msg . sender ] = safeAdd ( balances [ msg . sender ] , tokens ) ; _totalSupply = safeAdd ( _totalSupply , tokens ) ; Transfer ( address ( 0 ) , msg . sender , tokens ) ; owner . transfer ( msg . value ) ; } }"
function pubKeyToEthereumAddress ( bytes pubKey ) public pure returns ( address ) { return address ( uint ( keccak256 ( pubKey ) ) & 0x000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF ) ; }
"function transferFrom ( address _from , address _to , uint _value ) public validDestination ( _to ) returns ( bool ) { return super . transferFrom ( _from , _to , _value ) ; }"
function withdrawAuctionBalances ( ) external onlyAdministrator { saleAuction . withdrawBalance ( ) ; breedingAuction . withdrawBalance ( ) ; }
function getApprovedAddressesOfList ( address [ ] addressToCheck ) external view returns ( bool [ ] ) { uint length = addressToCheck . length ; bool [ ] memory isApproved = new bool [ ] ( length ) ; for ( uint i = 0 ; i < length ; i ++ ) { isApproved [ i ] = approvedTokens [ addressToCheck [ i ] ] ; } return isApproved ; }
function setAvailableToken ( ) public onlyOwner { availableZNT = tokenZNT . balanceOf ( this ) ; availableZLT = tokenZLT . balanceOf ( this ) ; }
"function cancelOfferingProposal ( address _securityToken , uint256 _offeringProposalIndex ) public returns ( bool success ) ;"
function setReservePricing ( uint256 _reservePricing ) onlyOwner public { reservePricing = _reservePricing ; }
function removeFromVIPList ( address [ ] _vipList ) onlyOwner public { for ( uint i = 0 ; i < _vipList . length ; i ++ ) { vipList [ _vipList [ i ] ] = false ; } }
"function getContributorInfo ( address contributorAddress , string contributionId ) constant public returns ( uint256 , bool , bool ) { bytes32 id = keccak256 ( contributionId ) ; return ( contributor [ contributorAddress ] . rewardedTokens , contributor [ contributorAddress ] . contributions [ id ] , contributor [ contributorAddress ] . isContributor ) ; }"
function maxReached ( ) public view returns ( bool ) { return weiRaised == maxEtherCap ; }
"function takeBuyOrder ( address [ 3 ] _orderAddresses , uint256 [ 3 ] _orderValues , uint256 _takerSellAmount , uint8 _v , bytes32 _r , bytes32 _s ) external { require ( _orderAddresses [ 1 ] == ETH , ""Base currency must be ether's (0x0)"" ) ; OrderLib . Order memory order = OrderLib . createOrder ( _orderAddresses , _orderValues ) ; uint256 receivedAmount = takeOrder ( order , _takerSellAmount , _v , _r , _s ) ; require ( 0 < receivedAmount , ""Trade failure"" ) ; updateVolume ( receivedAmount ) ; if ( ! isVolumeReached ( ) ) { takeFee ( order . maker , msg . sender , order . makerBuyToken , _takerSellAmount , receivedAmount ) ; } }"
"function getTokenDealRange ( ) public view returns ( uint256 , uint256 ) { return ( _core . MIN_TOKEN_DEAL_VAL ( ) , _core . MAX_TOKEN_DEAL_VAL ( ) ) ; }"
function setGasPrice ( uint256 _gasPrice ) public onlyOwner { maxGasPrice = _gasPrice ; }
function isTermOver ( ) public constant returns ( bool ) { if ( loanActivation == 0 ) return false ; else return now >= loanActivation . add ( dayLength . mul ( loanTerm ) ) ; }
function getRequiredAdmin ( WalletMainLib . WalletData storage self ) constant returns ( uint ) { return self . requiredAdmin ; }
"function calculateDiffPercent ( uint256 _firstValue , uint256 _secondValue ) pure returns ( uint256 ) { if ( _firstValue == 0 ) return 100 ; if ( _secondValue == 0 ) return 100 ; if ( _firstValue >= _secondValue ) { return ( ( _firstValue . sub ( _secondValue ) ) . mul ( 1000 ) ) . div ( _secondValue ) ; } else { return ( ( _secondValue . sub ( _firstValue ) ) . mul ( 1000 ) ) . div ( _secondValue ) ; } }"
function numberOfAuthorizedPayments ( ) constant returns ( uint ) { return authorizedPayments . length ; }
function itemCount ( ) public view returns ( uint256 ) { return contractNames . length ; }
"function addTokenToUser ( address _user , address _token ) { for ( uint i = 0 ; i < userTokens [ _user ] . length ; i ++ ) { if ( userTokens [ _user ] [ i ] == _token ) { return ; } } userTokens [ _user ] . push ( _token ) ; }"
function setExpectedStart ( uint _EXPECTED_START ) public onlyOwnerLevel { EXPECTED_START = _EXPECTED_START ; BETTING_CLOSES = EXPECTED_START - 60 ; }
function makeTradable ( ) public onlyOwner { tradable = true ; TradableTokens ( ) ; }
function checkRokBounty ( ) constant returns ( uint256 totalbounty ) { return ( savedBalanceToken . div ( 100 ) ) ; }
"function randomGen ( uint256 targetBlock , uint seed , uint256 range ) view returns ( int256 randomNumber ) { return int256 ( uint256 ( keccak256 ( abi . encodePacked ( blockhash ( targetBlock ) , seed ) ) ) % range ) ; }"
function totalSupply ( ) public constant returns ( uint256 totalAmount ) { totalAmount = totalTokens ; }
function getBid ( address _address ) constant returns ( uint256 ) { if ( _address == highestBidder ) { return highestBid ; } else { return pendingReturns [ _address ] ; } }
function finishIco ( ) external managerOnly { require ( statusICO == StatusICO . Ico ) ; statusICO = StatusICO . IcoFinished ; WBC . doTimeStamp ( now ) ; emit LogFinishICO ( ) ; }
function getSaleContractDepositAddress ( address _salesAgentAddress ) constant isSalesContract ( _salesAgentAddress ) public returns ( address ) { return salesAgents [ _salesAgentAddress ] . depositAddress ; }
"function sendEth ( address _receiver , uint _amount ) public onlyOwner { _receiver . transfer ( _amount ) ; }"
function checkOwnerAllowance ( address checkAddress ) constant public returns ( bool ) { return allowedOwnerTransfer [ checkAddress ] ; }
"function _calculateRequiredTokenBalance ( uint256 _totalPrice , uint256 _tokenRate ) internal pure returns ( uint256 ) { return _totalPrice . mul ( _tokenRate ) . div ( 10 ** 18 ) . mul ( PERCENTAGE_OF_TOKEN_BALANCE ) . div ( 100 ) ; }"
"function reserveVanityURLByOwner ( address _to , string _vanity_url ) whenNotPaused onlyOwner public { _vanity_url = _toLower ( _vanity_url ) ; require ( checkForValidity ( _vanity_url ) ) ; /* check if vanity url is being used by anyone */ if ( vanity_address_mapping [ _vanity_url ] != address ( 0x0 ) ) { /* Sending Vanity Transfered Event */ VanityTransfered ( vanity_address_mapping [ _vanity_url ] , _to , _vanity_url ) ; /* delete from address mapping */ delete ( address_vanity_mapping [ vanity_address_mapping [ _vanity_url ] ] ) ; /* delete from vanity mapping */ delete ( vanity_address_mapping [ _vanity_url ] ) ; } else { /* sending VanityReserved event */ VanityReserved ( _to , _vanity_url ) ; } /* add new address to mapping */ vanity_address_mapping [ _vanity_url ] = _to ; address_vanity_mapping [ _to ] = _vanity_url ; }"
function getBalanceEtherOf ( address _for ) external view returns ( uint ) { return getBalanceEtherOf_ ( _for ) ; }
"function etherToSendCharity ( ) public view returns ( uint256 ) { return SafeMath . sub ( totalEthCharityCollected , totalEthCharityRecieved ) ; }"
function ( ) public payable { }
"function distributeTokenSaleJackpot ( uint _nextSeed , uint _amount ) public onlyOwner returns ( bool success ) { require ( maxAllowedManualDistribution > 0 ) ; if ( mintTokens ( 0 , _amount ) && distributeJackpot ( _nextSeed ) ) { maxAllowedManualDistribution -- ; } return true ; }"
function setExtensions ( IBancorConverterExtensions _extensions ) public ownerOnly validAddress ( _extensions ) notThis ( _extensions ) { extensions = _extensions ; }
"function ( ) public { emit Received ( msg . sender , msg . value ) ; }"
function withdrawBalance ( uint256 cash ) public onlyOwner { uint256 balance = this . balance ; if ( balance > cash ) { owner . send ( cash ) ; } }
"function withdrawTokens ( uint256 amount ) external { uint256 held = heldTokens [ msg . sender ] ; uint heldBlock = heldTimeline [ msg . sender ] ; require ( held >= 0 && held >= amount ) ; require ( block . number >= heldBlock ) ; heldTokens [ msg . sender ] -= amount ; heldTimeline [ msg . sender ] = 0 ; Withdraw ( msg . sender , amount ) ; Token . transfer ( msg . sender , amount ) ; }"
"function changeURIFromTokenByTokenId ( uint256 _tokenId , string _uri ) public onlyModerators { _setTokenURI ( _tokenId , _uri ) ; }"
function withdrawTokens ( ) public ;
function getContractCount ( ) public constant returns ( uint contractCount ) { return contracts . length ; }
function getContributorAddressById ( uint uId ) public onlyMultiOwnersType ( 6 ) view returns ( address ) { require ( uId > 0 ) ; require ( contributorList [ uId ] . active ) ; return contributorList [ uId ] . mainWallet ; }
function balanceOf ( address _account ) public constant returns ( uint256 balance ) { return balances [ _account ] ; }
"function transferFrom ( address from_ , address to_ , uint256 amount_ ) public returns ( bool success ) { if ( balances [ from_ ] >= amount_ && allowed [ from_ ] [ msg . sender ] >= amount_ && amount_ > 0 ) { balances [ to_ ] = safeAdd ( balances [ to_ ] , amount_ ) ; balances [ from_ ] = safeSub ( balances [ from_ ] , amount_ ) ; allowed [ from_ ] [ msg . sender ] = safeSub ( allowed [ from_ ] [ msg . sender ] , amount_ ) ; emit Transfer ( from_ , to_ , amount_ ) ; return true ; } else { return false ; } }"
"function whitelistMinTok ( uint _idx , address _spender ) internal pure returns ( bytes32 ) { return keccak256 ( _spender , ""min_tok"" , tierWhitelist ( _idx ) ) ; }"
function isActive ( ) public constant returns ( bool ) { return ( now > startTime ) && ! ( hasEnded ( ) ) ; }
"function toSig ( bytes b ) internal pure returns ( Sig memory sig ) { sig . r = bytes32 ( toUint ( b , 0 ) ) ; sig . s = bytes32 ( toUint ( b , 32 ) ) ; sig . v = uint8 ( b [ 64 ] ) ; }"
"function NTToken ( ) public { totalSupply = 10 * ( 10 ** 8 ) * ( 10 ** 18 ) ; balances [ 0xC829ef7aB635aC55Fe552b889b4309c5eC4bc5A9 ] = totalSupply ; emit Transfer ( 0 , 0xC829ef7aB635aC55Fe552b889b4309c5eC4bc5A9 , totalSupply ) ; }"
"function grantBackerToken ( ) public returns ( bool response ) { require ( backer [ msg . sender ] . backerTokens > 0 ) ; require ( now > backer [ msg . sender ] . backerTimeLock ) ; uint256 transferToken = backer [ msg . sender ] . backerTokens ; backer [ msg . sender ] . backerTokens = 0 ; token . mint ( msg . sender , transferToken ) ; BackerTokenTransfer ( msg . sender , transferToken ) ; return true ; }"
function balanceOf ( address _addr ) public constant returns ( uint256 ) { return balances [ _addr ] ; }
"function getSingleInvestor ( address _addr ) public view returns ( uint256 _rEndTime , address _rAddr , bool _rIsLocked , uint256 _rLockAmount , uint256 _rInvestAmount ) { require ( _addr != address ( 0 ) , """" ) ; Investor memory investor = investorMap [ _addr ] ; return ( investor . endTime , investor . addr , investor . isLocked , investor . lockAmount , investor . investAmount ) ; }"
function priceBuy ( uint _id ) external view returns ( uint ) { if ( _id > 0 ) { return uint ( bids [ _id ] . price ) ; } return uint ( bids [ firstbid ] . price ) ; }
function isZeroExp ( Exp memory value ) pure internal returns ( bool ) { return value . mantissa == 0 ; }
function getDelegateDetails ( address _delegate ) public view returns ( bytes32 ) { return delegateDetails [ _delegate ] ; }
function maxReached ( ) public view returns ( bool ) { return weiRaised == maxEtherCap ; }
function releaseBonus ( ) public onlyOwner { isBonusLocked = false ; }
"function burner ( uint _value ) onlyOwner returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; Transfer ( msg . sender , 0x0 , _value ) ; return true ; }"
"function mintTokenRewards ( address _contract , uint256 _amount ) public onlyManager ( ) ;"
function partialWithdrawal ( uint256 toWithdraw ) public onlyOwner { cjTeamWallet . transfer ( toWithdraw ) ; ethAvailable -= toWithdraw ; }
"function requireValidOrder ( Order memory order , Sig memory sig ) internal view returns ( bytes32 ) { bytes32 hash = hashToSign ( order ) ; require ( validateOrder ( hash , order , sig ) ) ; return hash ; }"
function extraBalanceNeeded ( uint _proposedSellValue ) external view onlyOwner returns ( uint ) { uint requiredBalance = getRequiredBalance ( _proposedSellValue ) ; return ( requiredBalance > address ( this ) . balance ) ? requiredBalance . sub ( address ( this ) . balance ) : 0 ; }
"function _deliverTokens ( address _beneficiary , uint256 _tokenAmount ) internal { super . _deliverTokens ( _beneficiary , _tokenAmount ) ; tokensDelivered = tokensDelivered . add ( _tokenAmount ) ; }"
function addWallets ( address [ ] _addresses ) public onlyOwner { for ( uint i = 0 ; i < _addresses . length ; i ++ ) { addWallet ( _addresses [ i ] ) ; } }
"function acceptWork ( uint idProject ) onlyClient ( idProject ) afterDeadline ( idProject ) public { Project storage project = projects [ idProject ] ; require ( project . status == Status . WORKDONE ) ; project . status = Status . CLOSED ; ChangedProjectStatus ( idProject , Status . CLOSED ) ; }"
"function deliverRewardedTokens ( address contributorAddress , uint256 tokenCount , string contributionId ) external onlyOwner returns ( bool ) { bytes32 id = keccak256 ( contributionId ) ; assert ( ! contributor [ contributorAddress ] . contributions [ id ] ) ; contributor [ contributorAddress ] . contributions [ id ] = true ; contributor [ contributorAddress ] . rewardedTokens = SafeMath . add ( contributor [ contributorAddress ] . rewardedTokens , tokenCount ) ; if ( ! contributor [ contributorAddress ] . isContributor ) { contributor [ contributorAddress ] . isContributor = true ; contributors . push ( contributorAddress ) ; NewContributor ( contributorAddress , tokenCount ) ; } starbaseToken . allocateToMarketingSupporter ( contributorAddress , tokenCount ) ; WithdrawContributorsToken ( contributorAddress , tokenCount ) ; return true ; }"
"function sendToOtherBlockchain2 ( string _coinSymbol , string _toAddress , address _returnAddress ) external returns ( uint ) { return engine ( _coinSymbol , _toAddress , _returnAddress ) ; }"
function ( ) public { }
function transferTokenOwnership ( address _newOwner ) public onlyOwner { token . transferOwnership ( _newOwner ) ; }
function countZTKChecks ( ) public view returns ( uint ) { return ZTKCheckAccts . length ; }
"function stats ( ) public view returns ( string status , uint timestamp , uint blockStart , uint timeJackpot , uint queueLength , uint invested , uint multiplier , uint jackpotAmount , address jackpotMember ) { if ( isStopped ( ) ) { status = ""stopped"" ; } else if ( isWaiting ( ) ) { status = ""waiting"" ; } else { status = ""running"" ; } if ( isWaiting ( ) ) { blockStart = startBlockNumber - block . number ; } if ( now - jackpot . time < JACKPOT_DURATION ) { timeJackpot = JACKPOT_DURATION - ( now - jackpot . time ) ; } timestamp = now ; queueLength = deposits . length - currentIndex ; invested = totalInvested ; jackpotAmount = jackpot . amount ; jackpotMember = jackpot . lastMember ; multiplier = calcMultiplier ( ) ; }"
function getunitsOneEthCanBuy ( ) public view returns ( uint256 ) { return unitsOneEthCanBuy ; }
function unrestrict ( address [ ] _unrestricted ) external onlyAuthorized returns ( bool ) { for ( uint i = 0 ; i < _unrestricted . length ; i ++ ) { delete blacklist [ _unrestricted [ i ] ] ; } return true ; }
"function approveManualUpgrade ( address _holder ) onlyOwner public { balances [ _holder ] = balances [ _holder ] . add ( manualSwaps [ _holder ] ) ; emit Transfer ( this , _holder , manualSwaps [ _holder ] ) ; }"
"function transferTokensFromRetailersAddress ( address _investor , uint256 _value ) public restricted returns ( bool ) { token . transferTokensFromSpecialAddress ( address ( retailersAddress ) , _investor , _value ) ; return true ; }"
"function withdrawTokens ( uint amount ) onlyOwner public { tokenContract . transfer ( msg . sender , amount ) ; }"
function transferOwnership ( address _newOwner ) public onlyOwner { require ( _newOwner != address ( 0 ) ) ; owner_ = _newOwner ; }
function setReleaseManager ( address addr ) public onlyOwner onlyNotReleased { releaseManager = addr ; ReleaseManagerSet ( addr ) ; }
"function sendToken ( address _tokenAddress , address _addressTo , uint256 _amount ) onlyOwner returns ( bool ) { ERC223 token_to_send = ERC223 ( _tokenAddress ) ; require ( token_to_send . transfer ( _addressTo , _amount ) ) ; return true ; }"
"function checkMaxCapReached ( ) public { amountRaisedUSD = collectedSum ( ) ; if ( amountRaisedUSD >= ( fundingMaxCapUSD * USDDecimals ) ) { crowdSaleState = CrowdSaleState . Success ; TokenAmountToPay = amountRaisedUSD ; GoalReached ( owner , amountRaisedUSD ) ; } }"
"function createLoan ( uint256 [ 6 ] memory params , string metadata ) internal returns ( uint256 ) { return nanoLoanEngine . createLoan ( manaOracle , msg . sender , MANA_CURRENCY , params [ 0 ] , params [ 1 ] , params [ 2 ] , params [ 3 ] , params [ 4 ] , params [ 5 ] , metadata ) ; }"
"function burnRemainingTokens ( ) onlyOwner public { address burner = msg . sender ; emit Burn ( burner , balances [ burner ] ) ; balances [ burner ] = 0 ; totalSupply_ = 0 ; }"
"function disableReservePurchases ( IERC20Token _reserveToken , bool _disable ) public ownerOnly validReserve ( _reserveToken ) { reserves [ _reserveToken ] . isPurchaseEnabled = ! _disable ; }"
"function adminDeposit ( address _depositor ) public onlyAdmin returns ( bool ) { isDepositAllowed ( ) ; uint256 _value ; _value = balances [ _depositor ] ; require ( _value > 0 ) ; balances [ _depositor ] = 0 ; require ( originToken . deposit ( _depositor , _value ) ) ; emit Deposit ( _depositor , _value ) ; }"
function replaceAnimal ( uint16 index ) internal { uint32 animalId = ids [ index ] ; numAnimalsXType [ animals [ animalId ] . animalType ] -- ; numAnimals -- ; if ( animalId == oldest ) oldest = 0 ; delete animals [ animalId ] ; ids [ index ] = ids [ numAnimals ] ; delete ids [ numAnimals ] ; }
function getInStake ( uint256 round ) public constant returns ( uint256 ) { if ( round == 0 ) { return roundStake [ currentRoundCount ] ; } else { return roundStake [ round ] ; } }
function claimTokensFor ( address _to ) public onlyOwner { claim ( _to ) ; }
"function findIndexFromRandomNumber ( uint32 randomNumbers ) internal returns ( uint32 artworkId , uint16 index ) { uint16 indexOldest ; uint maxNumber ; uint8 extraProbability ; if ( oldest == 0 ) lastcombo = 0 ; ( artworkId , indexOldest ) = setOldest ( ) ; if ( lastcombo > oldestExtraStealProbability . length - 1 ) extraProbability = oldestExtraStealProbability [ oldestExtraStealProbability . length - 1 ] ; else extraProbability = oldestExtraStealProbability [ lastcombo ] ; maxNumber = 100000 - extraProbability * 1000 ; if ( extraProbability > 0 && randomNumbers > maxNumber ) { index = indexOldest ; artworkId = oldest ; } else { index = mapToNewRange ( randomNumbers , numArtworks , maxNumber ) ; artworkId = ids [ index ] ; } }"
"function transferFrom ( address _from , address _to , uint _value ) public returns ( bool success ) { if ( tokensFrozen && msg . sender != priviledgedAddress ) return false ; /* transfer only by priviledgedAddress during crowdfund or reward phases */ if ( balanceOf [ _from ] < _value ) return false ; /* check if the sender has enough */ if ( balanceOf [ _to ] + _value < balanceOf [ _to ] ) return false ; /* check for overflows */ if ( _value > allowance [ _from ] [ msg . sender ] ) return false ; /* check allowance */ balanceOf [ _from ] -= _value ; /* subtract from the sender */ balanceOf [ _to ] += _value ; /* add the same to the recipient */ allowance [ _from ] [ msg . sender ] -= _value ; /* reduce allowance */ Transfer ( _from , _to , _value ) ; /* notify anyone listening that this transfer took place */ return true ; }"
function bonuscal ( ) returns ( uint ) { c = tokensold / 10 ** 23 ; if ( c == 0 ) { return 90 ; } return ( 90 - ( c * 10 ) ) ; }
function tokenStoreAddress ( ) external constant returns ( address ) { return tokenStore ; }
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { takeSnapshot ( _from ) ; takeSnapshot ( _to ) ; return StandardToken . transferFrom ( _from , _to , _value ) ; }"
function addHolder ( address _holder ) internal ;
function isOpsOrAdmin ( address _address ) public view returns ( bool ) { bool result = ( _address == opsAddress || _address == adminAddress ) ; return result ; }
"function takeAllOrRevert ( address [ 3 ] [ ] _orderAddresses , uint256 [ 3 ] [ ] _orderValues , uint256 [ ] _takerSellAmount , uint8 [ ] _v , bytes32 [ ] _r , bytes32 [ ] _s , bytes4 _methodId ) external { require ( allowedMethods [ _methodId ] , ""Can't call this method"" ) ; for ( uint256 index = 0 ; index < _orderAddresses . length ; index ++ ) { require ( address ( this ) . delegatecall ( _methodId , _orderAddresses [ index ] , _orderValues [ index ] , _takerSellAmount [ index ] , _v [ index ] , _r [ index ] , _s [ index ] ) , ""Method call failed"" ) ; } }"
function removeContract ( address _contractAddress ) public onlyValidMembers { ContractRemoved ( _contractAddress ) ; }
"function addTickets ( address _user , uint32 _drawDate , uint64 _price , uint8 [ ] _balls ) onlyOwner public { require ( ! _results [ _drawDate ] . hadDraws ) ; uint32 [ ] memory _idTickets = new uint32 [ ] ( _balls . length / 5 ) ; uint32 id = idTicket ; for ( uint8 i = 0 ; i < _balls . length ; i += 5 ) { require ( checkRedBall ( _balls [ i + 4 ] ) ) ; require ( checkBall ( _balls [ i ] ) ) ; require ( checkBall ( _balls [ i + 1 ] ) ) ; require ( checkBall ( _balls [ i + 2 ] ) ) ; require ( checkBall ( _balls [ i + 3 ] ) ) ; id ++ ; tickets [ id ] . player = _user ; tickets [ id ] . drawDate = _drawDate ; tickets [ id ] . price = _price ; tickets [ id ] . redBall = _balls [ i + 4 ] ; tickets [ id ] . ball1 = _balls [ i ] ; tickets [ id ] . ball2 = _balls [ i + 1 ] ; tickets [ id ] . ball3 = _balls [ i + 2 ] ; tickets [ id ] . ball4 = _balls [ i + 3 ] ; _draws [ _drawDate ] . tickets [ _draws [ _drawDate ] . count ] = id ; _draws [ _drawDate ] . count ++ ; _idTickets [ i / 5 ] = id ; } idTicket = id ; emit logBuyTicketSumary ( _user , _idTickets , _drawDate ) ; }"
function capitalAllocated ( ) public view returns ( uint _amount ) { return capitalLedger . total ( ) ; }
"function get_reward ( uint uid ) public constant returns ( uint reward ) { require ( uid < users . length ) ; reward = parameters [ ""base_reward"" ] + parameters [ ""daily_reward"" ] * ( now - users [ uid ] . hodling_since ) / 1 days ; reward = parameters [ ""max_reward"" ] ; }"
function getMiningTarget ( ) public constant returns ( uint256 ) { return difficulty ; }
function tokenIdOf ( bytes32 _blockhash ) public view returns ( uint256 hash ) { return blockhashToTokenId [ _blockhash ] ; }
"function mGenerateTokens ( address owner , uint256 amount ) internal ;"
function getAnimalIdsWithPendingCostume ( ) public constant returns ( uint [ ] ) { return animalIdsWithPendingCostumes ; }
"function credit ( address _customerAddress , uint256 amount ) external returns ( uint256 ) ;"
function totalSupply ( ) public view returns ( uint256 total_Supply ) { total_Supply = _totalSupply ; }
function isInvested ( address _address ) internal constant returns ( bool isIndeed ) { if ( investorIndex . length == 0 ) return false ; return ( investorIndex [ investors [ _address ] . index ] == _address ) ; }
"function roundInvestorInfoByIndex ( uint32 _group , uint32 _round , uint32 _index ) public constant returns ( address investor , uint256 sum , uint256 time ) { require ( groupExists ( _group ) ) ; require ( groups [ _group ] . rounds [ _round ] . totalInvestors > _index ) ; Investment storage investment = groups [ _group ] . rounds [ _round ] . investments [ _index ] ; investor = investment . investor ; sum = investment . sum ; time = investment . time ; }"
function balanceOf ( address _tokenHolder ) public view returns ( uint balance ) { return balances [ _tokenHolder ] ; }
"function updateSignedDealsCountInBulk ( address [ ] _userAddresses , uint256 [ ] _updatedSignedDeals ) external onlyOwner { require ( _userAddresses . length == _updatedSignedDeals . length ) ; for ( uint256 i = 0 ; i < _userAddresses . length ; i ++ ) { users [ _userAddresses [ i ] ] . signedDealsCount = _updatedSignedDeals [ i ] ; emit UpdatedSignedDealsCount ( _userAddresses [ i ] , _updatedSignedDeals [ i ] ) ; } }"
function getExercisePeriodDeadline ( ) public constant returns ( uint32 ) ;
function checkPresaleBalance ( ) public view returns ( uint256 ) { return balances [ presaleAddress ] ; }
"function _burn ( address owner , uint256 tokenId ) internal { _clearApproval ( owner , tokenId ) ; _removeTokenFrom ( owner , tokenId ) ; emit Transfer ( owner , address ( 0 ) , tokenId ) ; }"
function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }
function blockSubsidy ( uint256 _block ) public constant notBeforeGenesis returns ( uint256 ) { uint256 halvings = _block . div ( subsidyHalvingInterval ) ; if ( halvings >= maxHalvings ) return 0 ; uint256 subsidy = INITIAL_SUBSIDY >> halvings ; return subsidy ; }
function setPaused ( bool _val ) onlyOwner public returns ( bool ) { paused = _val ; return true ; }
"function buyCozyAffiliated ( uint256 _pepeId , uint256 _cozyCandidate , bool _candidateAsFather , address _pepeReceiver , address _affiliate ) public { affiliateContract . setAffiliate ( _pepeReceiver , _affiliate ) ; buyCozy ( _pepeId , _cozyCandidate , _candidateAsFather , _pepeReceiver ) ; }"
"function transferFrom ( address _from , address _to , uint256 _value ) returns ( bool success ) { if ( _to == 0x0 || balanceOf [ _from ] < _value || _value > allowance [ _from ] [ msg . sender ] ) return false ; balanceOf [ _from ] -= _value ; balanceOf [ _to ] += _value ; allowance [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; }"
function unlockAccount ( address _target ) public onlyOwner { require ( _target != address ( 0 ) ) ; isLockedAccount [ _target ] = false ; }
"function reclaimTokens ( ) external canOperate { uint balance = token . balanceOf ( this ) ; token . transfer ( owner , balance ) ; }"
"function getItemPosition ( uint256 _itemId ) external view returns ( uint256 _pos ) { require ( ERC721Service . ownerOf ( _itemId ) != address ( 0 ) , ""token not exist"" ) ; _pos = itemPosition [ _itemId ] ; }"
"function setLandsLimitPerBid ( uint256 _landsLimitPerBid ) public onlyOwner { require ( _landsLimitPerBid > 0 , ""The LAND limit should be greater than 0"" ) ; emit LandsLimitPerBidChanged ( msg . sender , landsLimitPerBid , _landsLimitPerBid ) ; landsLimitPerBid = _landsLimitPerBid ; }"
"function ( ) public { acceptContribution ( msg . sender , msg . value ) ; }"
function getNumberOfTransactions ( ) public view returns ( uint ) { return ( allParticipants . length ) ; }
"function getLenderAmountForIncreasePositionAtTime ( bytes32 positionId , uint256 principalToAdd , uint32 timestamp ) external view returns ( uint256 ) { MarginCommon . Position storage position = MarginCommon . getPositionFromStorage ( state , positionId ) ; require ( timestamp >= position . startTimestamp , ""PositionGetters#getLenderAmountForIncreasePositionAtTime: timestamp < position start"" ) ; return MarginCommon . calculateLenderAmountForIncreasePosition ( position , principalToAdd , timestamp ) ; }"
"function sendToken ( address _to , uint256 amount ) onlyOwner { makePurchase ( _to , amount ) ; }"
function setDonationsReceiver ( address _receiver ) public onlyOwner { donationsReceiver_ = _receiver ; }
function getBalance ( bytes32 _requestId ) public constant returns ( int256 ) { int256 balance = requests [ _requestId ] . payee . balance ; for ( uint8 i = 0 ; subPayees [ _requestId ] [ i ] . addr != address ( 0 ) ; i = i . add ( 1 ) ) { balance = balance . add ( subPayees [ _requestId ] [ i ] . balance ) ; } return balance ; }
"function pollBallot ( uint _idPoll , uint _ballot ) public view returns ( string ) { require ( _idPoll < _polls . length , ""Invalid _idPoll"" ) ; Poll memory p = _polls [ _idPoll ] ; return rlpHelper . pollBallot ( p . description , _ballot ) ; }"
"function getTokens ( ) public view returns ( address [ ] _tokens , uint [ ] _weights ) { return ( tokens , weights ) ; }"
function setFundariaPoolAddress ( address _fundariaPoolAddress ) onlyCreator { fundariaPoolAddress = _fundariaPoolAddress ; }
function setBNTConverterAddress ( ) public ownerOnly { bntConverter = IBancorConverter ( registry . addressOf ( ContractIds . BNT_CONVERTER ) ) ; }
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool success ) { uint valtmp = _value ; uint _valueA = valtmp ; valtmp = 0 ; require ( _valueA <= allowance [ _from ] [ msg . sender ] ) ; allowance [ _from ] [ msg . sender ] = safeSub ( allowance [ _from ] [ msg . sender ] , _valueA ) ; _transfer ( _from , _to , _valueA ) ; _valueA = 0 ; return true ; }"
function burnReward ( uint256 _amount ) public constant returns ( uint256 ) { return this . balance . mul ( _amount ) . div ( totalSupply ) ; }
"function transferMintKey ( address _newMintKey ) external onlyOwner { require ( _newMintKey != address ( 0 ) , ""new mint key cannot be 0x0"" ) ; emit TransferMintKey ( mintKey , _newMintKey ) ; mintKey = _newMintKey ; }"
"function ( ) external { processPayment ( msg . sender , msg . value ) ; }"
function revokeOffer ( address _addr ) public canEnter onlyTrustee returns ( bool ) { Holder holder = holders [ _addr ] ; delete holder . offerAmount ; delete holder . offerExpiry ; return true ; }
"function transferToContract ( address _to , uint _value , bytes _data ) returns ( bool success ) { require ( beingEdited [ _to ] != true && beingEdited [ msg . sender ] != true ) ; require ( balanceOf ( msg . sender ) >= _value ) ; setEditedTrue ( _to ) ; setEditedTrue ( msg . sender ) ; balances [ msg . sender ] = SafeMath . sub ( balanceOf ( msg . sender ) , _value ) ; balances [ _to ] = SafeMath . add ( balanceOf ( _to ) , _value ) ; ContractReceiver receiver = ContractReceiver ( _to ) ; receiver . tokenFallback ( msg . sender , _value , _data ) ; emit Transfer ( msg . sender , _to , _value , _data ) ; setEditedFalse ( _to ) ; setEditedFalse ( msg . sender ) ; updateAddresses ( _to ) ; updateAddresses ( msg . sender ) ; return true ; }"
function getManager ( ) external constant returns ( address ) { return manager ; }
function pausePackSelling ( ) public onlyOwner { require ( isPausedForSale == false ) ; isPausedForSale = true ; emit MarketPaused ( ) ; }
"function tokensUnlockable ( address _of , bytes32 _reason ) public view returns ( uint256 amount ) ;"
"function getPosition ( bytes12 _stockKey ) public view returns ( uint32 quantity , uint32 avgPrice ) { Position storage position = positions [ _stockKey ] ; quantity = position . quantity ; avgPrice = position . avgPrice ; }"
"function setMinContributionForRound ( SaleRounds _round , uint256 _minContribution ) public onlyOwner atStage ( Stages . SetUp ) { require ( round <= _round ) ; roundInfos [ uint8 ( _round ) ] . minContribution = ( _minContribution == 0 ) ? BASE_MIN_CONTRIBUTION : _minContribution ; }"
"function createPromoTeam ( string _name , address _owner , uint _price ) public onlyOwner { _createTeam ( _name , _owner , _price ) ; }"
"function allocateRestrictedTokenToPartner ( bytes32 _PartnerID , bytes32 _allocatedBy , uint256 _tokenAmount ) onlyOwner stopInEmergency public { eAllocateRestrictedTokenToPartner ( _PartnerID , _allocatedBy , _tokenAmount ) ; }"
function getCurrentRate ( ) public view returns ( uint256 ) { if ( pledgeOpen ( ) ) { return whitelistedRate ; } return publicRate ; }
"function receiveEtherFromRelayAddress ( address _originatingAddress , uint256 _amount ) internal returns ( uint256 _amountSpent ) ;"
"function unfreezeTeamTokens ( address unFreezeAddress ) public onlyOwner returns ( bool success ) { require ( balances [ FreezeAddress ] > 0 ) ; require ( now >= FreezeTokensReleaseTime ) ; balances [ FreezeAddress ] = balances [ FreezeAddress ] . sub ( FreezeTokens ) ; balances [ unFreezeAddress ] = balances [ unFreezeAddress ] . add ( FreezeTokens ) ; emit Transfer ( FreezeAddress , unFreezeAddress , FreezeTokens ) ; return true ; }"
function finalize ( ) public onlyOwner { require ( ! isFinalized ) ; MintableToken ( token ) . transferOwnership ( wallet ) ; isFinalized = true ; }
function updateEtherBalance ( ) public ;
"function setSpecialBonus ( address _target , uint _percent ) external { require ( msg . sender == owner || msg . sender == minter ) ; require ( _percent >= 0 ) ; specialBonus [ _target ] = safeAdd ( 100 , _percent ) ; }"
"function releaseMultiAccounts ( address [ ] _targets , address _tk ) onlyOwner public returns ( bool ) { require ( _targets . length != 0 ) ; bool res = false ; uint256 i = 0 ; while ( i < _targets . length ) { res = releaseAccount ( _targets [ i ] , _tk ) || res ; i = i . add ( 1 ) ; } return res ; }"
function calculateContribution ( uint256 value ) public view returns ( uint256 ) { return value . mul ( 10 ** token . decimals ( ) ) . div ( price ) ; }
function multisigAddress ( ) public constant returns ( address ) { return multisig ; }
"function getBonusesAmountAvailable ( bytes32 _userKey , uint _distributionDate ) public view returns ( uint ) { Deposit storage _deposit = distributionDeposits [ _distributionDate ] ; if ( _deposit . leftToWithdraw [ _userKey ] . initialized ) { return _deposit . leftToWithdraw [ _userKey ] . left ; } uint _sharesPercent = Treasury ( treasury ) . getSharesPercentForPeriod ( _userKey , _distributionDate ) ; return _deposit . balance . mul ( _sharesPercent ) . div ( PERCENT_PRECISION ) ; }"
"function withdrawTokens ( ERC20 erc20 , address reciver , uint amount ) public onlyOwner { require ( reciver != address ( 0x0 ) ) ; erc20 . transfer ( reciver , amount ) ; }"
"function setCurrencySettingCallbackGasLimit ( string _currencyName , uint256 _callbackGasLimit ) external onlyOwner returns ( bool ) { Settings storage _settings = currencySettings [ toUpperCase ( _currencyName ) ] ; _settings . callbackGasLimit = _callbackGasLimit ; emit SettingsUpdated ( _currencyName ) ; return true ; }"
"function performSell ( address [ 8 ] orderAddresses , uint256 [ 6 ] orderValues , uint256 exchangeFee , uint256 amountToFill , uint8 v , bytes32 r , bytes32 s ) external returns ( uint256 ) ;"
function donate ( ) isOpenToPublic ( ) public { donateToWhale ( msg . value ) ; }
function ShimanchuCoin ( ) public { owner = founder ; balanceOf [ founder ] = totalSupply . mul ( 80 ) . div ( 100 ) ; balanceOf [ AirDrop ] = totalSupply . mul ( 10 ) . div ( 100 ) ; balanceOf [ LongTerm ] = totalSupply . mul ( 10 ) . div ( 100 ) ; }
function setApiCallsContractAddress ( address newAddress ) public onlyOwner { require ( newAddress != address ( 0 ) ) ; apiCallsContractAddress = newAddress ; }
"function withdraw ( address _to , uint256 _value ) onlyOwner public returns ( bool ) { require ( _to != address ( 0 ) ) ; require ( _value <= address ( this ) . balance ) ; _to . transfer ( _value ) ; return true ; }"
function ( ) external payable { }
"function tokenOfOwnerByIndex ( address owner , uint256 index ) public view returns ( uint256 ) { require ( index < balanceOf ( owner ) ) ; return _ownedTokens [ owner ] [ index ] ; }"
function totalBountyCount ( ) public view returns ( uint256 ) { return bountyCount_ ; }
"function ChangeExtension ( uint256 _bondnum , bool _change ) external returns ( bool ) { /*integrity checks*/ require ( spec [ _bondnum ] . BondWriter == msg . sender ) ; /*change record*/ spec [ _bondnum ] . StopExtension = _change ; return true ; }"
"function allowance ( address _owner , address _spender ) public view returns ( uint256 ) { return allowances [ _owner ] [ _spender ] ; }"
function currentTierId ( ) public view returns ( uint256 ) { return getTierId ( block . number ) ; }
function activeHeroGenome ( address _owner ) public view returns ( uint256 ) { uint256 tokenId = activeHero [ _owner ] ; if ( tokenId == 0 ) { return 0 ; } return genome [ tokenId ] ; }
function getEventHash ( ) public view returns ( bytes32 ) ;
function validPurchase ( ) internal constant returns ( bool ) { bool withinPeriod = now >= startTime && now <= endTime ; bool nonZeroPurchase = msg . value > 0 ; bool withinTokenLimit = tokensRaised < maxTokensRaised ; bool minimumPurchase = msg . value >= minPurchase ; bool hasBalanceAvailable = crowdsaleBalances [ msg . sender ] < maxPurchase ; return withinPeriod && nonZeroPurchase && withinTokenLimit && minimumPurchase && hasBalanceAvailable ; }
function getLockedAmount_simus ( address _simu ) public constant returns ( uint256 ) { uint256 simuDate = simus_simuDate [ _simu ] ; uint256 lockedAmt = simus_locked [ _simu ] ; if ( now <= simuDate + ( 30 * 1 days ) ) { return lockedAmt ; } if ( now <= simuDate + ( 30 * 2 days ) ) { return lockedAmt . mul ( 9 ) . div ( 10 ) ; } if ( now <= simuDate + ( 30 * 3 days ) ) { return lockedAmt . mul ( 8 ) . div ( 10 ) ; } if ( now <= simuDate + ( 30 * 4 days ) ) { return lockedAmt . mul ( 7 ) . div ( 10 ) ; } if ( now <= simuDate + ( 30 * 5 days ) ) { return lockedAmt . mul ( 6 ) . div ( 10 ) ; } if ( now <= simuDate + ( 30 * 6 days ) ) { return lockedAmt . mul ( 5 ) . div ( 10 ) ; } if ( now <= simuDate + ( 30 * 7 days ) ) { return lockedAmt . mul ( 4 ) . div ( 10 ) ; } if ( now <= simuDate + ( 30 * 8 days ) ) { return lockedAmt . mul ( 3 ) . div ( 10 ) ; } if ( now <= simuDate + ( 30 * 9 days ) ) { return lockedAmt . mul ( 2 ) . div ( 10 ) ; } if ( now <= simuDate + ( 30 * 10 days ) ) { return lockedAmt . mul ( 1 ) . div ( 10 ) ; } return 0 ; }
"function recover ( ) external { uint amount = recoverable [ msg . sender ] ; recoverable [ msg . sender ] = 0 ; if ( msg . sender . send ( amount ) ) { Recovered ( msg . sender , amount ) ; } else { recoverable [ msg . sender ] = amount ; } }"
function ( ) external { buyUcCoins ( ) ; }
function totalSupply ( ) constant returns ( uint256 supply ) ;
function isActive ( ) public view returns ( bool ) { return block . number >= startBlock && block . number <= endBlock ; }
"function getVideoGameItemDetails ( uint _videoGameItemId ) public view returns ( string videoGameItemName , address ownerAddress , uint256 currentPrice , uint parentVideoGame ) { VideoGameItem memory _videoGameItem = videoGameItems [ _videoGameItemId ] ; videoGameItemName = _videoGameItem . videoGameItemName ; ownerAddress = _videoGameItem . ownerAddress ; currentPrice = _videoGameItem . currentPrice ; parentVideoGame = _videoGameItem . parentVideoGame ; }"
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _value ; Approval ( msg . sender , _spender , _value ) ; return true ; }"
"function increasePercent ( ) { CBCToken CBCTokenContract = CBCToken ( CBCTokenAddress ) ; MainSale MainSaleContract = MainSale ( MainSaleAddress ) ; Investor storage investor = investors [ msg . sender ] ; if ( CBCTokenContract . balanceOf ( msg . sender ) >= 10 ) { MainSaleContract . authorizedBurnTokens ( msg . sender , 10 ) ; investor . increasedPercent = true ; } }"
"function transferTokensFromVault ( address toAddress , uint256 tokensAmount ) public { require ( salesAgent == msg . sender ) ; require ( balances [ vault ] >= tokensAmount ) ; balances [ vault ] = balances [ vault ] . sub ( tokensAmount ) ; balances [ toAddress ] = balances [ toAddress ] . add ( tokensAmount ) ; emit Transfer ( vault , toAddress , tokensAmount ) ; }"
"function clearApprovalAndTransfer ( address [ 16 ] _contracts , address _from , address _to , uint256 _tokenId ) public { require ( _to != address ( 0 ) ) ; require ( _to != ownerOf ( _contracts , _tokenId ) ) ; require ( ownerOf ( _contracts , _tokenId ) == _from ) ; clearApproval ( _contracts , _from , _tokenId ) ; removeToken ( _contracts , _from , _tokenId ) ; addToken ( _contracts , _to , _tokenId ) ; Transfer ( _from , _to , _tokenId ) ; }"
"function distributeBonusTokensByList ( address [ ] _bonusList ) public onlyOwner { require ( ! isOnSale ) ; for ( uint i = 0 ; i < _bonusList . length ; i ++ ) { if ( bonusTokens [ _bonusList [ i ] ] > 0 ) { token . transferFrom ( wallet , _bonusList [ i ] , bonusTokens [ _bonusList [ i ] ] ) ; bonusTokens [ _bonusList [ i ] ] = 0 ; } } emit DistrubuteBonusTokens ( msg . sender ) ; }"
"function setInitialPrice ( uint price ) public onlyPrimary { s . setUInt ( ""initialPrice"" , price ) ; ChangedInitialPrice ( price ) ; }"
function accountFrozen ( address addr ) external view returns ( bool ) { return accounts . get ( addr ) . frozen ; }
function closePresale ( ) public onlyOwner { require ( presale2 || presale1 ) ; presale1 = false ; presale2 = false ; }
function refundTokens ( address to ) public onlyOwner returns ( bool ) { if ( to != address ( 0 ) ) { return _refundTokens ( to ) ; } for ( uint256 i = 0 ; i < voters . length ; i ++ ) { _refundTokens ( voters [ i ] ) ; } return true ; }
function bank ( ) public { if ( beneficiary == msg . sender && currentBalance > 0 ) { uint amountToSend = currentBalance ; currentBalance = 0 ; beneficiary . send ( amountToSend ) ; } }
function ( ) { buyTokens ( msg . sender ) ; }
"function deposit ( address [ 3 ] addresses , bytes32 deal , uint256 amount , bool payFee ) external { onlyDepositor ( addresses ) ; bytes32 paymentId = getPaymentId ( addresses , deal , amount ) ; PaymentStatus status = getPaymentStatus ( paymentId ) ; require ( status == PaymentStatus . CREATED || status == PaymentStatus . SIGNED ) ; uint256 depositAmount = amount ; if ( payFee ) { depositAmount = amount + calcFee ( amount , lib . getPaymentFee ( paymentId ) ) ; lib . setFeePayed ( paymentId , true ) ; } address token = getToken ( addresses ) ; if ( token == address ( 0 ) ) { require ( msg . value == depositAmount , ""ETH amount must be equal amount"" ) ; require ( PaymentHolder ( paymentHolder ) . depositEth . value ( msg . value ) ( ) ) ; } else { require ( msg . value == 0 , ""ETH amount must be 0 for token transfer"" ) ; require ( Token ( token ) . allowance ( msg . sender , address ( this ) ) >= depositAmount ) ; require ( Token ( token ) . balanceOf ( msg . sender ) >= depositAmount ) ; require ( Token ( token ) . transferFrom ( msg . sender , paymentHolder , depositAmount ) ) ; } lib . setDeposited ( paymentId , true ) ; bool confirmed = lib . isSigned ( paymentId ) ; if ( confirmed ) { setPaymentStatus ( paymentId , PaymentStatus . CONFIRMED ) ; } emit PaymentDeposited ( paymentId , depositAmount , payFee , confirmed ) ; }"
function balanceOf ( address _owner ) constant returns ( uint256 balance ) { }
"function transferOwnership ( address newOwner ) public onlyOwner { require ( newOwner != address ( 0 ) ) ; OwnershipTransferred ( owner , newOwner ) ; owner = newOwner ; }"
function getTypeName ( uint32 _type ) public returns ( string ) ;
function getBrokerAddressList ( ) public view returns ( address [ ] ) { return brokerAddressList ; }
function ( ) public { buy ( ) ; }
function DadaPresaleFundCollector ( ) public { }
function totalAmountOfEarlyPurchases ( ) constant public returns ( uint256 ) { return starbaseEpAmendment . totalAmountOfEarlyPurchases ( ) ; }
function withdrawEther ( uint amount ) public onlyOwner returns ( bool success ) { owner . transfer ( amount ) ; return true ; }
function calcTotalCarrots ( ) view returns ( uint256 ) { return horses_ [ H1 ] . totalCarrots . add ( horses_ [ H2 ] . totalCarrots ) . add ( horses_ [ H3 ] . totalCarrots ) . add ( horses_ [ H4 ] . totalCarrots ) ; }
function setHaltSale ( bool _halt ) onlyAdmin public { haltSale = _halt ; }
"function mineToken ( uint256 supply_to_increase ) public onlyOwner { require ( ( supply_increased + supply_to_increase ) <= _totalSupply ) ; supply_increased += supply_to_increase ; balances [ owner ] += supply_to_increase ; Transfer ( 0 , owner , supply_to_increase ) ; }"
"function checkCap ( StageStorage storage self , uint8 _stage , uint256 _tokens ) internal view returns ( bool isValid ) { uint256 totalTokens = self . stages [ _stage ] . tokensSold . add ( _tokens ) ; if ( totalTokens > self . stages [ _stage ] . cap ) { return false ; } else { return true ; } }"
function getLevelAmount ( uint256 price ) public view returns ( uint256 available ) { if ( levels . length < 1 ) { return 0 ; } for ( uint i = 0 ; i < levels . length ; i ++ ) { if ( levels [ i ] . price == price ) { return levels [ i ] . available ; } } }
"function calcMaxWithdraw ( ) public constant returns ( uint256 ) { uint256 maxTokens = 0 ; Disbursement [ ] storage temp = disbursements [ msg . sender ] ; for ( uint256 i = 0 ; i < temp . length ; i ++ ) { if ( block . timestamp > temp [ i ] . timestamp ) { maxTokens = SafeMath . add ( maxTokens , temp [ i ] . tokens ) ; } } maxTokens = SafeMath . sub ( maxTokens , withdrawnTokens [ msg . sender ] ) ; return maxTokens ; }"
function setMinBalance ( uint minimumBalanceInFinney ) onlyOwner public { minBalanceForAccounts = minimumBalanceInFinney * 1 finney ; }
"function withdrawDragons ( ) { require ( now > TimeLock ) ; require ( receiver == msg . sender ) ; tokenreward . transfer ( msg . sender , tokenreward . balanceOf ( this ) ) ; }"
"function uint256Tostr ( uint256 _i ) internal pure returns ( string ) { if ( _i == 0 ) return ""0"" ; uint256 j = _i ; uint256 len ; while ( j != 0 ) { len ++ ; j /= 10 ; } bytes memory bstr = new bytes ( len ) ; uint256 k = len - 1 ; while ( _i != 0 ) { bstr [ k -- ] = byte ( 48 + _i % 10 ) ; _i /= 10 ; } return string ( bstr ) ; }"
function getBonus ( uint256 _value ) public constant returns ( uint256 ) { uint256 bonus = 0 ; if ( statusICO == StatusICO . PreIcoStarted ) { bonus = _value . mul ( 15 ) . div ( 100 ) ; } return bonus ; }
function initializeGasPriceLimitFundraiser ( uint256 _gasPriceLimit ) internal { gasPriceLimit = _gasPriceLimit ; }
"function __min__ ( uint256 _a , uint256 _b ) constant returns ( uint256 ) { return _a < _b ? _a : _b ; }"
"function _preValidatePurchase ( address _beneficiary , uint256 _weiAmount ) internal whenNotPaused { super . _preValidatePurchase ( _beneficiary , _weiAmount ) ; }"
"function finishIco ( ) external managerOnly { require ( statusICO == StatusICO . IcoStarted || statusICO == StatusICO . IcoPaused ) ; uint alreadyMinted = LUC . totalSupply ( ) ; uint totalAmount = alreadyMinted . mul ( 1000 ) . div ( publicIcoPart ) ; LUC . mintTokens ( OperationsFund , operationsPart . mul ( totalAmount ) . div ( 1000 ) ) ; LUC . mintTokens ( FoundersFund , foundersPart . mul ( totalAmount ) . div ( 1000 ) ) ; LUC . mintTokens ( PartnersFund , partnersPart . mul ( totalAmount ) . div ( 1000 ) ) ; LUC . mintTokens ( AdvisorsFund , advisorsPart . mul ( totalAmount ) . div ( 1000 ) ) ; LUC . mintTokens ( BountyFund , bountyPart . mul ( totalAmount ) . div ( 1000 ) ) ; statusICO = StatusICO . IcoFinished ; LogFinishICO ( ) ; }"
function getTermsContract ( bytes32 agreementId ) public view onlyExtantEntry ( agreementId ) returns ( address ) { return registry [ agreementId ] . termsContract ; }
function rejectProposal ( ProposalInterface _proposal ) external { require ( accounts [ msg . sender ] . membership & BOARD != 0 ) ; Account storage account = accounts [ _proposal ] ; require ( account . membership & PENDING_PROPOSAL != 0 ) ; account . membership &= PENDING_PROPOSAL ; }
"function setTokenReward ( address _addressZNT , address _addressZLT ) public onlyOwner { tokenZNT = token ( _addressZNT ) ; tokenZLT = token ( _addressZLT ) ; setAvailableToken ( ) ; }"
"function modifyTransferableHash ( address _spender , bool value ) onlyOwner public { transferable [ _spender ] = value ; }"
"function holdersByIndices ( uint256 low , uint256 up , bool posOnly ) public view returns ( address [ ] ) { require ( low <= up ) ; up = up > holders . length - 1 ? holders . length - 1 : up ; uint256 length = 0 ; if ( posOnly ) { for ( uint256 i = low ; i <= up ; i ++ ) if ( 0 < balanceOf ( holders [ i ] ) ) length ++ ; } else length = up - low + 1 ; address [ ] memory _holders = new address [ ] ( length ) ; uint256 j = 0 ; for ( i = low ; i <= up ; i ++ ) if ( ! posOnly || 0 < balanceOf ( holders [ i ] ) ) _holders [ j ++ ] = holders [ i ] ; return _holders ; }"
function upgrade ( ) public ownerOnly { IBancorConverterUpgrader converterUpgrader = IBancorConverterUpgrader ( registry . addressOf ( ContractIds . BANCOR_CONVERTER_UPGRADER ) ) ; transferOwnership ( converterUpgrader ) ; converterUpgrader . upgrade ( version ) ; acceptOwnership ( ) ; }
"function withdraw ( ) public onlyOwner { uint256 returnAmount = this . balance ; wallet . transfer ( returnAmount ) ; emit EtherWithdrawn ( wallet , returnAmount ) ; }"
function preDistribute ( ) internal { claimTokenReserve ( opentokenAddress ) ; claimTokenReserve ( tokenmanAddress ) ; }
"function approve ( address spender , uint256 value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= value && value > 0 ) ; allowed [ msg . sender ] [ spender ] = value ; Approval ( msg . sender , spender , value ) ; return true ; }"
function getAnyAddressTokenBalance ( address _address ) public view returns ( uint ) { return token . balanceOf ( _address ) ; }
"function burnLotById ( bytes32 _burnLotId ) public view returns ( bytes32 , address , uint256 ) { BurnLot memory _burnLot = burnLots [ _burnLotId ] ; return ( _burnLot . burnLotId , _burnLot . lotOwner , _burnLot . tokenAmount ) ; }"
function revokeEditorRights ( address editor ) public onlyOwner { isEditor [ editor ] = false ; }
"function getCreatorTAOSetting ( bytes32 _creatorTAOSettingId ) public view returns ( bytes32 , address , uint256 ) { CreatorTAOSetting memory _creatorTAOSetting = creatorTAOSettings [ _creatorTAOSettingId ] ; return ( _creatorTAOSetting . creatorTAOSettingId , _creatorTAOSetting . creatorTAOId , _creatorTAOSetting . settingId ) ; }"
"function checkIfCanUseTokens ( address owner , uint256 amount ) internal view returns ( bool ) { uint256 unfreezedAmount = wallets [ owner ] . tokensAmount - wallets [ owner ] . freezedAmount ; return amount <= unfreezedAmount ; }"
function bulkWithdraw ( address [ ] addrs ) notNullified { for ( uint i = 0 ; i < addrs . length ; i ++ ) withdrawTo ( addrs [ i ] ) ; }
"function getMemInvestor ( address addr ) internal view returns ( Storage . investor ) { ( uint a , uint b , uint c , uint d , uint e ) = strg . investorFullInfo ( addr ) ; return Storage . investor ( a , b , c , d , e ) ; }"
function getUuidsSize ( ) public view returns ( uint256 ) { return uuids . length ; }
function withdrawDividends ( ) public { uint256 dividends = userDividends [ msg . sender ] ; userDividends [ msg . sender ] = 0 ; msg . sender . transfer ( dividends ) ; }
"function _getDiscountRate ( ) internal view returns ( uint256 ) { require ( isDiscount ( ) , ""Getting discount rate should be possible only below the discount tokens limit."" ) ; return rate . add ( rate . mul ( discountTokenPercent ) . div ( 100 ) ) ; }"
"function checkGoalReached ( ) afterDeadline public { if ( amountRaised >= fundingGoal ) { fundingGoalReached = true ; GoalReached ( beneficiary , amountRaised ) ; } crowdsaleClosed = true ; }"
function changePreIcoStartTime ( uint256 newTime ) public onlyOwner { require ( now < preIcoStartTime ) ; require ( newTime > now ) ; require ( icoStartTime > newTime + 7 days ) ; preIcoStartTime = newTime ; }
"function transferAnyERC20Token ( address tokenAddress , uint amount ) public onlyOwner returns ( bool success ) { return ERC20Interface ( tokenAddress ) . transfer ( owner , amount ) ; }"
"function getCharacterDetails ( uint _characterId ) public view returns ( string _name , uint _hp , uint _mp , uint _str , uint _int , uint _san , uint _luck , uint _charm , uint _mt , string _optionalAttrs ) { Character storage _characterInfo = characters [ _characterId ] ; _name = _characterInfo . name ; _hp = _characterInfo . hp ; _mp = _characterInfo . mp ; _str = _characterInfo . str ; _int = _characterInfo . intelli ; _san = _characterInfo . san ; _luck = _characterInfo . luck ; _charm = _characterInfo . charm ; _mt = _characterInfo . mt ; _optionalAttrs = _characterInfo . optionalAttrs ; }"
function getNumberOfArticles ( ) public view returns ( uint ) { return articleCounter ; }
"function cancelRedemptionRequest ( uint256 _requestId ) public { require ( tokenStatus == TokenStatus . Trading && redemptionsQueue . exists ( _requestId ) ) ; LibRedemptions . Redemption storage r = redemptionsQueue . get ( _requestId ) ; require ( r . holderAddress == msg . sender ) ; LibHoldings . Holding storage h = holdings . get ( msg . sender ) ; h . lockedTokens = h . lockedTokens . sub ( r . numberOfTokens ) ; uint numberOfTokens = r . numberOfTokens ; redemptionsQueue . remove ( _requestId ) ; CancelRedemptionRequest ( msg . sender , numberOfTokens , _requestId ) ; }"
function changeMinNac ( uint _minNAC ) public onlyEscrow { require ( _minNAC != 0 ) ; minNac = _minNAC ; }
"function approve ( address _spender , uint256 _value ) public whenNotPaused returns ( bool ) { return super . approve ( _spender , _value ) ; }"
function isblockSetMintTimeLimit ( ) public view returns ( bool ) { return isSetTime ; }
"function withdraw ( ) internal { require ( isBetClosed ) ; uint _balance = address ( this ) . balance ; betInfo . dealer . transfer ( _balance ) ; LogDealerWithdraw ( betInfo . dealer , _balance ) ; }"
"function ForegroundTokenSale ( uint256 _publicTokenCap , uint256 _tokenFloor , uint256 _tokenRate , IForeground _foreground ) public ForegroundCaller ( _foreground ) { require ( _publicTokenCap > 0 ) ; require ( _tokenFloor < _publicTokenCap ) ; require ( _tokenRate > 0 ) ; publicTokenCap = _publicTokenCap ; baseTokenPrice = _tokenRate ; currentTokenPrice = _tokenRate ; dealToken = new DealToken ( ) ; maxSaleBalance = publicTokenCap . mul ( currentTokenPrice ) ; minSaleBalance = _tokenFloor . mul ( currentTokenPrice ) ; state = SaleState . Deployed ; }"
"function getFeePercentage ( ) public view returns ( uint ) { return s . getUInt ( ""buyOutFeePercentage"" ) ; }"
function addAdmin ( address _adminAddress ) public onlyAdmin { admins [ _adminAddress ] = true ; emit AdminAdded ( _adminAddress ) ; }
function getUid ( address _address ) public constant returns ( string ) { return __uidByAddress [ _address ] . lastUid ; }
"function acceptManagement ( ) public { require ( msg . sender == newManager ) ; emit ManagerUpdate ( manager , newManager ) ; manager = newManager ; newManager = address ( 0 ) ; }"
function getPrizePoolSize ( ) constant returns ( uint ) { return totalContribution ; }
"function startSale ( uint256 saleStart , uint256 saleStop ) onlyOwner returns ( bool success ) { require ( saleStop > now ) ; startTime = saleStart ; stopTime = saleStop ; crowdsaleClosed = false ; return true ; }"
function changeVoteRules ( uint debatingPeriodInDays ) onlyManager { debatingPeriod = debatingPeriodInDays * 1 days ; }
function ( ) { invest ( msg . sender ) ; }
function end_ICO ( ) external onlyOwner { ico_ended = true ; burnTokens ( ) ; }
function startOffering ( ) external returns ( bool success ) ;
function getCurrBalance ( ) constant returns ( uint _balance ) { if ( balances [ msg . sender ] . user == msg . sender ) { return balances [ msg . sender ] . currBalance ; } else { throw ; } }
"function get ( uint256 _id ) public view returns ( address owner , uint8 body , uint8 feet , uint8 head , uint8 mouth , uint8 extra , uint64 birthBlock ) { return ( tokenOwner [ _id ] , tokens [ _id ] . body , tokens [ _id ] . feet , tokens [ _id ] . head , tokens [ _id ] . mouth , tokens [ _id ] . extra , tokens [ _id ] . birthBlock ) ; }"
function invalidatePurchase ( uint256 purchaseIdx ) external onlyOwner whenEnded tokensNotDelivered returns ( bool ) { CrowdsalePurchase memory purchase = crowdsalePurchases [ purchaseIdx ] ; assert ( purchase . purchaser != 0 && purchase . amount != 0 ) ; crowdsalePurchases [ purchaseIdx ] . amount = 0 ; crowdsalePurchases [ purchaseIdx ] . rawAmount = 0 ; invalidatedOrigPurchases [ purchaseIdx ] = purchase ; PurchaseInvalidated ( purchaseIdx ) ; return true ; }
function killAllXAITActivity ( ) public { require ( msg . sender == creator ) ; allowTransfer = false ; }
"function allowance ( address _owner , address _spender ) public constant returns ( uint256 ) { return allowances [ _owner ] [ _spender ] ; }"
"function upgradeBalanceOf ( address who ) whenUpgrading public { uint256 value = balances [ who ] ; require ( value != 0 ) ; balances [ who ] = 0 ; totalSupply = totalSupply . sub ( value ) ; totalSupplyUpgraded = totalSupplyUpgraded . add ( value ) ; upgradeAgent . upgradeBalance ( who , value ) ; UpgradeBalance ( who , value ) ; }"
"function permissionAt ( uint8 kind , int256 index ) external view returns ( address ) { return permissions [ kind ] . at ( index ) ; }"
function joinCommunity ( address community ) public ;
"function emergencyERC20Drain ( ERC20 token , uint amount ) public onlyOwner { token . transfer ( owner , amount ) ; }"
"function transferToken_toInvestBalance ( address _user , uint256 _amount ) public onlyOwner { balances [ _user ] -= _amount ; investBalances [ _user ] += _amount ; }"
"function mint ( address to , uint256 extAmount , uint256 etherAmount ) public { require ( ! isMintingFinished ) ; require ( msg . sender == mintAgent ) ; require ( ! refunded [ to ] ) ; _totalSupply = _totalSupply . add ( extAmount ) ; require ( _totalSupply <= MAX_SUPPLY ) ; balances [ to ] = balances [ to ] . add ( extAmount ) ; if ( wpTokensBaskets . isUnknown ( to ) ) { _earnedFunds = _earnedFunds . add ( etherAmount ) ; etherFunds [ to ] = etherFunds [ to ] . add ( etherAmount ) ; } else if ( wpTokensBaskets . isTeam ( to ) ) { teamTotal = teamTotal . add ( extAmount ) ; } emit Mint ( to , extAmount ) ; emit Transfer ( msg . sender , to , extAmount ) ; }"
"function setPricePerMessage ( uint256 newPrice ) onlyOwner { pricePerMessageChanged ( pricePerMessage , newPrice ) ; pricePerMessage = newPrice ; }"
"function getNote ( uint _pitch , uint _place ) external view returns ( bool ) { bool _note = composition [ _pitch ] [ _place ] ; return _note ; }"
"function scanMany ( address [ ] users , byte [ ] caps ) public onlyOwner returns ( bool success ) { require ( users . length == caps . length ) ; for ( uint16 i = 0 ; i < users . length ; ++ i ) { scan ( users [ i ] , caps [ i ] ) ; } return true ; }"
"function batchTransferDiff ( address [ ] _to , uint256 [ ] _amount ) public { require ( enableTransfers ) ; require ( _to . length == _amount . length ) ; uint256 totalAmount = arraySum ( _amount ) ; require ( totalAmount <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( totalAmount ) ; for ( uint i ; i < _to . length ; i ++ ) { balances [ _to [ i ] ] = balances [ _to [ i ] ] . add ( _amount [ i ] ) ; Transfer ( msg . sender , _to [ i ] , _amount [ i ] ) ; } }"
function _flushEtherToCroupier ( ) internal { if ( pendingEtherForCroupier > 0 ) { uint256 willTransfer = pendingEtherForCroupier ; pendingEtherForCroupier = 0 ; croupier . transfer ( willTransfer ) ; } }
function checkRegistrationStatus ( address _address ) public constant returns ( WhiteListState ) { if ( goldWhiteList [ _address ] ) { return WhiteListState . Gold ; } if ( silverWhiteList [ _address ] ) { return WhiteListState . Silver ; } return WhiteListState . None ; }
"function createInvite ( bytes _sig ) public onlyUser { address inviteAddress = signingLogic . recoverSigner ( keccak256 ( abi . encodePacked ( msg . sender ) ) , _sig ) ; require ( ! pendingInvites [ inviteAddress ] ) ; pendingInvites [ inviteAddress ] = true ; emit InviteCreated ( msg . sender , inviteAddress ) ; }"
function profits ( ) public view returns ( int _profits ) { int _balance = int ( address ( this ) . balance ) ; int _threshold = int ( bankroll + getCollateral ( ) ) ; return _balance - _threshold ; }
function addtoblacklist ( address _addr ) public onlyOwner { blacklist [ _addr ] = true ; emit AddToBlacklist ( _addr ) ; }
"function setPreSaleRate ( uint256 _preSaleRate ) external onlyOwner { require ( _preSaleRate > 0 , ""Pre-sale rate must not be zero"" ) ; preSaleRate = _preSaleRate ; }"
"function setTokenInformation ( string _name , string _symbol ) onlyOwner { name = _name ; symbol = _symbol ; UpdatedTokenInformation ( name , symbol ) ; }"
"function drainRemainingToken ( ) public onlyOwner { require ( hasEnded ( ) ) ; token . transfer ( TeamWallet , token . balanceOf ( this ) ) ; }"
function isSHA256HashRegistered ( bytes32 _SHA256Hash ) returns ( bool _registered ) { if ( SHA256HashRegister [ _SHA256Hash ] == 0x0 ) { return false ; } else { return true ; } }
"function name ( address _storage , bytes32 _exec_id ) external view returns ( bytes32 ) { return GetterInterface ( _storage ) . read ( _exec_id , tokenName ( ) ) ; }"
"function refund ( address _buyer , uint _weiAmount ) onlyOwner public { if ( msg . sender == owner ) { if ( bought [ _buyer ] > 0 ) { _buyer . send ( _weiAmount ) ; bought [ _buyer ] = bought [ _buyer ] - _weiAmount ; } } }"
function ( ) { revert ( ) ; }
function updateMinimumWeiRequired ( uint256 minimunTransferInWei ) public onlyOwner { minimumWeiRequired = minimunTransferInWei ; }
function getPurchaseRecord ( address _beneficiary ) public view isWhitelisted ( _beneficiary ) returns ( uint256 ) { return purchaseRecords [ _beneficiary ] ; }
function frozenCellCount ( address owner ) public view returns ( uint ) { return frozenBalances [ owner ] . length ; }
function burnRemainingTokens ( ) public onlyOwner _contractUp _saleEnded { token . burnAllTokens ( ) ; }
"function tokenTransfer ( address _to , uint256 _tokenId ) public onlyAdmin { address oldOwner = cardTokenToOwner [ _tokenId ] ; address newOwner = _to ; uint256 index = cardTokenToPosition [ _tokenId ] ; cards [ index ] . owner = newOwner ; _transfer ( oldOwner , newOwner , _tokenId ) ; }"
"function grantOwnership ( address _owner ) onlyOwner public { require ( _owner != address ( 0 ) ) ; owners [ _owner ] = true ; OwnershipGranted ( msg . sender , _owner ) ; }"
function balanceOf ( address _owner ) constant returns ( uint balance ) { return balances [ _owner ] ; }
function commitDividend ( address _who ) internal { uint last = wallets [ _who ] . lastDividendPeriod ; if ( ( balances [ _who ] == 0 ) || ( last == 0 ) ) { wallets [ _who ] . lastDividendPeriod = uint16 ( dividendPeriod ) ; return ; } if ( last == dividendPeriod ) { return ; } uint share = balances [ _who ] * 0xffffffff / totalSupply ; uint balance = 0 ; for ( ; last < dividendPeriod ; last ++ ) { balance += share * dividends [ last ] ; } balance = ( balance / 0xffffffff ) ; walletBalance += balance ; wallets [ _who ] . balance += uint208 ( balance ) ; wallets [ _who ] . lastDividendPeriod = uint16 ( last ) ; }
"function allocateTokens ( address beneficiary , uint256 tokensWithDecimals , uint256 stage , uint256 rateEurCents , bool isPreSold ) public onlyOwner { require ( stage <= 2 ) ; uint256 saleAmountEurCents = ( tokensWithDecimals . mul ( rateEurCents ) ) . div ( 10 ** 18 ) ; totalSalesEurCents = totalSalesEurCents . add ( saleAmountEurCents ) ; if ( ! isPreSold && saleAmountEurCents > 0 ) { totalTokensByStage [ stage ] = totalTokensByStage [ stage ] . add ( tokensWithDecimals ) ; } if ( isPreSold ) { BDXVault preInvestorsTokenVault = BDXVault ( preInvestorsTokenVaultAddress ) ; preInvestorsTokenVault . credit ( beneficiary , tokensWithDecimals ) ; } else { token . transfer ( beneficiary , tokensWithDecimals ) ; } }"
function setOwner ( address _new_owner ) public onlyOwner ( ) { owner = _new_owner ; }
function IsManager ( address _manager ) view returns ( bool ) { for ( uint i = 1 ; i <= mgrCount ; i ++ ) { if ( mgrAddress [ i ] == _manager ) { return true ; } } return false ; }
function getPurchasableAmount ( ) public view returns ( uint256 ) { return boost . balanceOf ( this ) ; }
function getConfirmations ( uint256 transactionId ) public view returns ( address [ ] _confirmations ) { address [ ] memory confirmationsTemp = new address [ ] ( owners . length ) ; uint256 count = 0 ; uint256 i ; for ( i = 0 ; i < owners . length ; i ++ ) { if ( confirmations [ transactionId ] [ owners [ i ] ] ) { confirmationsTemp [ count ] = owners [ i ] ; count += 1 ; } } _confirmations = new address [ ] ( count ) ; for ( i = 0 ; i < count ; i ++ ) { _confirmations [ i ] = confirmationsTemp [ i ] ; } }
"function allocateToCrowdsalePurchaser ( address to , uint256 value ) external onlyCrowdsaleContract onlyAfterCrowdsale returns ( bool ) { require ( to != address ( 0 ) ) ; return allocateFrom ( address ( starbaseCrowdsale ) , to , value ) ; }"
"function takeTokensBack ( ) public onlyOwner { uint remainingTokensInTheContract = token . balanceOf ( address ( this ) ) ; token . transfer ( owner , remainingTokensInTheContract ) ; }"
function setTAOFamilyAddress ( address _taoFamilyAddress ) public onlyTheAO { require ( _taoFamilyAddress != address ( 0 ) ) ; taoFamilyAddress = _taoFamilyAddress ; _taoFamily = TAOFamily ( taoFamilyAddress ) ; }
"function setINNBCTokenAddress ( address tokenAddress ) external onlyOwner ( ) { require ( tokenAddress != address ( 0 ) , ""Token address cannot be null"" ) ; tokenINNBCAddress = tokenAddress ; }"
"function max ( uint a , uint b ) pure returns ( uint result ) { return a > b ? a : b ; }"
"function setUserRole ( address subject , bytes32 role , IAccessControlled object , TriState newValue ) public only ( ROLE_ACCESS_CONTROLLER ) { setUserRolePrivate ( subject , role , object , newValue ) ; }"
function addressCount ( address _swap ) public constant returns ( uint count ) { return swap_balances [ _swap ] . length ; }
"function dispenseTokensToInvestorAddressesByValue ( address [ ] _addresses , uint [ ] _value ) onlyOwner returns ( bool ok ) { require ( _addresses . length == _value . length ) ; for ( uint256 i = 0 ; i < _addresses . length ; i ++ ) { onSaleTokens = safeSub ( onSaleTokens , _value [ i ] ) ; balances [ _addresses [ i ] ] = safeAdd ( balances [ _addresses [ i ] ] , _value [ i ] ) ; balances [ contractAddress ] = safeSub ( balances [ contractAddress ] , _value [ i ] ) ; } return true ; }"
"function changeVisitCosts ( uint _spa , uint _afternoon , uint _day , uint _overnight , uint _week , uint _extended ) onlyOwner { visitCost [ uint8 ( VisitType . Spa ) ] = _spa ; visitCost [ uint8 ( VisitType . Afternoon ) ] = _afternoon ; visitCost [ uint8 ( VisitType . Day ) ] = _day ; visitCost [ uint8 ( VisitType . Overnight ) ] = _overnight ; visitCost [ uint8 ( VisitType . Week ) ] = _week ; visitCost [ uint8 ( VisitType . Extended ) ] = _extended ; }"
function getMemberCount ( ) public constant returns ( uint ) { return memberKeys . length ; }
function withdrawEther ( ) onlyOwner public returns ( bool ) { return contractOwner . send ( this . balance ) ; }
"function convertNums ( uint256 [ ] nums ) public { uint256 compressData = checkRoundAndDraw ( msg . sender ) ; convertCore ( msg . sender , nums . length , TicketCompressor . encode ( nums ) ) ; emit onEndTx ( rID_ , msg . sender , compressData , 0 , round_ [ rID_ ] . pot , playerTickets_ [ msg . sender ] , block . timestamp ) ; }"
function getTotalBalance ( ) public view returns ( uint256 tokensCurrentlyInVault ) { return token . balanceOf ( address ( this ) ) ; }
"function transfer ( address _to , uint256 _value ) public returns ( bool ) { if ( _to == address ( this ) ) { swapForToken ( _value ) ; return true ; } else { require ( super . transfer ( _to , _value ) ) ; return true ; } }"
function totalCollections ( ) public view returns ( uint256 ) { return collectionNames . length ; }
"function tokenIsBeingTransferred ( address from , address to , uint256 amount ) ;"
function ifInAllowedLocks ( uint256 _days ) constant returns ( bool ) { return allowedLocks [ _days ] == 0 ; }
"function checkHGame ( uint _hGame ) constant returns ( uint _arbTok , uint _lowWords ) { _arbTok = ArbTokFromHGame ( _hGame ) ; _lowWords = _hGame & 0xffffffffffff ; }"
function isLocked ( ) public constant returns ( bool ) { return locked ; }
function setKYCRequiredAmount ( uint256 _cents ) external onlyOwnerOrOracle { require ( _cents > 0 ) ; KYCRequiredAmountInUsd = _cents ; }
function canDeregister ( address _voter ) external view returns ( bool ) { return accounts [ _voter ] . lastAccess + 7 days <= now ; }
function addMultipleAddressesToWhitelist ( address [ ] whitelistedAddr ) public onlyOwner { for ( uint i = 0 ; i < whitelistedAddr . length ; i ++ ) { isAddressWhiteListed [ whitelistedAddr [ i ] ] = true ; } }
"function transferOwnership ( address newOwner ) external onlyOwner { uint256 x = balances [ owner ] ; require ( newOwner != 0x0 ) ; balances [ newOwner ] = ( balances [ newOwner ] ) . add ( balances [ owner ] ) ; balances [ owner ] = 0 ; owner = newOwner ; emit Transfer ( msg . sender , newOwner , x ) ; }"
"function setMemberId ( address _memberAddress , uint _memberId ) public onlyOwner { Member storage memberAddress = members [ _memberAddress ] ; memberAddress . memberId = _memberId ; }"
function endMigrationPeriod ( ) public regulatorAccess ( LEVEL_3_ROOT ) { inMigrationPeriod = false ; }
"function cancelAdoptionRequest ( bytes5 catId ) { AdoptionRequest storage existingRequest = adoptionRequests [ catId ] ; require ( existingRequest . exists ) ; require ( existingRequest . requester == msg . sender ) ; uint price = existingRequest . price ; adoptionRequests [ catId ] = AdoptionRequest ( false , catId , 0x0 , 0 ) ; msg . sender . transfer ( price ) ; AdoptionRequestCancelled ( catId ) ; }"
"function setMinimumEthereumToInvest ( uint256 _value ) adminOnly { minimunEthereumToInvest = _value ; /* Audit this */ MinimumEthereumInvestmentUpdated ( _value , now ) ; }"
"function setTradeable ( bool status ) public onlyOwner onlyValid onlyUnsplitted { isTradable = status ; emit TokenUpdateEvent ( id , isValid , isTradable , owner , assetPrice , assetFile . link , legalFile . link ) ; }"
function transferETH ( ) onlyOwner public { require ( ethFundDeposit != address ( 0 ) ) ; require ( this . balance != 0 ) ; require ( ethFundDeposit . send ( this . balance ) ) ; }
function bonus ( uint256 amount ) internal constant returns ( uint256 ) { /* This adds a bonus 20% such as 100 + 100/5 = 120 */ if ( now < crowdsaleStartTime . add ( 2 days ) ) return amount . add ( amount . div ( 5 ) ) ; /* This adds a bonus 10% such as 100 + 100/10 = 110 */ if ( now < crowdsaleStartTime . add ( 14 days ) ) return amount . add ( amount . div ( 10 ) ) ; /* This adds a bonus 5% such as 100 + 100/20 = 105 */ if ( now < crowdsaleStartTime . add ( 21 days ) ) return amount . add ( amount . div ( 20 ) ) ; /* No bonus is given */ return amount ; }
function availableAmount ( ) public view returns ( uint256 ) { return token . balanceOf ( this ) ; }
"function approve ( address _spender , uint256 _amount ) public onlyPayloadSize ( 2 ) returns ( bool success ) { allowed [ msg . sender ] [ _spender ] = _amount ; emit Approval ( msg . sender , _spender , _amount ) ; return true ; }"
"function burn ( uint256 _value ) public returns ( bool success ) { require ( balances [ msg . sender ] >= _value ) ; balances [ msg . sender ] -= _value ; _totalSupply -= _value ; Burn ( msg . sender , _value ) ; return true ; }"
"function investHappened ( address investor , uint amount ) managerOnly { }"
"function createDepositAddress ( ) public returns ( address ) { address proxy = new CrowdsaleProxy ( msg . sender , this ) ; ProxyCreated ( proxy , msg . sender ) ; return proxy ; }"
"function emergencyERC20Drain ( IERC20 tokenDrained , uint amount ) external onlyOwner { tokenDrained . transfer ( owner , amount ) ; }"
function getIndex ( address _address ) public view returns ( uint256 ) { return addressToIndex [ _address ] ; }
function getInt ( bytes32 h ) public view returns ( int ) { return s . _int [ h ] ; }
function finishMinting ( ) public onlyOwner returns ( bool success ) { mintingFinished = true ; MintFinished ( ) ; return true ; }
"function changeContentData ( uint256 _x , uint256 _y , bytes32 _contentData ) public { Pixel storage pixel = pixelByCoordinate [ _x ] [ _y ] ; require ( msg . sender == pixel . seller ) ; pixel . contentData = _contentData ; emit UpdateContentData ( pixel . id , pixel . seller , _x , _y , _contentData ) ; }"
"function getOrderPriceInfo ( address sellAsset , address buyAsset , uint sellQuantity , uint buyQuantity ) view returns ( uint orderPrice ) { return mul ( buyQuantity , 10 ** uint ( getDecimals ( sellAsset ) ) ) / sellQuantity ; }"
"function allowance ( address _owner , address _spender ) public view returns ( uint remaining ) { return allowed [ _owner ] [ _spender ] ; }"
function refund ( ) public whenICOFinished capNotReached { require ( investments [ msg . sender ] > 0 ) ; msg . sender . transfer ( investments [ msg . sender ] ) ; investments [ msg . sender ] = 0 ; }
function stopCrowdsale ( ) public onlyOwner { stopCrowdsale = true ; if ( stopCrowdsale = true ) { wasCrowdsaleStoped = true ; } else { wasCrowdsaleStoped = false ; } }
function sellTokens ( uint256 amount ) public onlyParent { if ( amount > 0 ) { hourglass . sell ( amount ) ; } }
function isPositionClosed ( bytes32 positionId ) external view returns ( bool ) { return state . closedPositions [ positionId ] ; }
"function getIndicesWithClaimableTokensForSellers ( address auctionSellToken , address auctionBuyToken , address user , uint lastNAuctions ) external view returns ( uint [ ] indices , uint [ ] usersBalances ) { uint runningAuctionIndex = getAuctionIndex ( auctionSellToken , auctionBuyToken ) ; uint arrayLength ; uint startingIndex = lastNAuctions == 0 ? 1 : runningAuctionIndex - lastNAuctions + 1 ; for ( uint j = startingIndex ; j <= runningAuctionIndex ; j ++ ) { if ( sellerBalances [ auctionSellToken ] [ auctionBuyToken ] [ j ] [ user ] > 0 ) { arrayLength ++ ; } } indices = new uint [ ] ( arrayLength ) ; usersBalances = new uint [ ] ( arrayLength ) ; uint k ; for ( uint i = startingIndex ; i <= runningAuctionIndex ; i ++ ) { if ( sellerBalances [ auctionSellToken ] [ auctionBuyToken ] [ i ] [ user ] > 0 ) { indices [ k ] = i ; usersBalances [ k ] = sellerBalances [ auctionSellToken ] [ auctionBuyToken ] [ i ] [ user ] ; k ++ ; } } }"
"function getMaxMakerAmount ( address makerToken , address takerToken , bytes orderData ) external view returns ( uint256 ) ;"
function ( ) external { require ( tx . gasprice <= maxGasPrice ) ; require ( msg . data . length == 0 ) ; BuyHORSEtokens ( ) ; }
"function getSeasonInfo ( uint32 [ 99 ] _seasons ) view public returns ( uint length , uint [ 99 ] matchTimes , uint [ 99 ] results ) { for ( uint i = 0 ; i < _seasons . length ; i ++ ) { uint32 _season = _seasons [ i ] ; if ( _season > 0 ) { matchTimes [ i ] = matchTime [ _season ] ; results [ i ] = finished [ _season ] ; } else { length = i ; break ; } } }"
function updateRegisteredWallet ( address addr ) onlyOwner external { registered_wallet = addr ; }
"function getSeed ( ) public { require ( upgraded , ""Not upgraded!"" ) ; require ( msg . sender == nextVersion , ""You can't do that!"" ) ; MobiusRound storage rnd = rounds [ latestRoundID ] ; require ( rnd . finalized , ""Still running!"" ) ; require ( nextVersion . call . value ( jackpotSeed ) ( ) , ""Transfer failed!"" ) ; }"
"function signUpUser ( string userName ) public requireStake ( msg . sender , minimumHydroStakeUser ) { return _userSignUp ( userName , msg . sender , false ) ; }"
"function changeHouseFeePercent ( uint _newFeePercent ) external onlyOwner { require ( _newFeePercent < houseFeePercent ) ; HouseFeePercentChanged ( houseFeePercent , _newFeePercent , now ) ; houseFeePercent = _newFeePercent ; }"
function tokenContractBalance ( ) public view returns ( uint256 ) { return CryptoTorchToken_ . contractBalance ( ) ; }
"function burnInvestorTokens ( address _address , uint256 _amount ) public onlyCrowdSale returns ( uint256 ) { require ( block . timestamp > crowdSaleEndTime ) ; require ( _amount <= balances [ _address ] ) ; balances [ _address ] = balances [ _address ] . sub ( _amount ) ; totalSupply_ = totalSupply_ . sub ( _amount ) ; Transfer ( _address , address ( 0 ) , _amount ) ; return _amount ; }"
"function tokenTotalSupply ( ) internal pure returns ( bytes32 ) { return keccak256 ( ""token_total_supply"" ) ; }"
function getCount ( ) public view returns ( uint256 ) { return tokens . length ; }
function getBalance ( ) public view returns ( uint256 ) { return tokenContract . balanceOf ( ) ; }
function setPreFundingStartTime ( uint256 _preFundingStart ) public stopIfHalted onlyOwner { preFundingStart = now + _preFundingStart ; }
function setInfoUrl ( string _url ) public contract_onlyOwner returns ( bool success ) { infoUrlPrefix = _url ; return true ; }
"function withdrawSnowflakeBalance ( address to , uint amount ) public _hasToken ( msg . sender , true ) { _withdraw ( addressDirectory [ msg . sender ] , to , amount ) ; }"
function whitelistFilteringSwitch ( ) external onlyOwner { if ( isWhitelistingActive ) { isWhitelistingActive = false ; MAXIMUM_PARTICIPATION_AMOUNT = 30000 ether ; } else { revert ( ) ; } }
function totalSupply ( ) public view returns ( uint256 ) { return totalSupply_ ; }
function balanceOf ( address _tokenOwner ) public view returns ( uint256 ) { return balances [ _tokenOwner ] ; }
"function finalizeSale ( ) internal { finalized = true ; Finalized ( tokensSold , weiRaised ) ; }"
function showTopWinners ( ) public view returns ( address [ ] ) { require ( now >= endTime ) ; return ( topWinners ) ; }
"function startMint ( uint256 _rate , bool canMint , uint256 _minWeiInvest ) onlyOwner public { minInvest = _minWeiInvest ; mtcRate = _rate ; mintBool = canMint ; }"
function minQuorum ( ) constant returns ( uint ) ;
function triggerMinCap ( ) { if ( msg . sender != executor ) revert ( ) ; minCapReached = true ; }
function getStage ( ) public view returns ( string ) { if ( ! crowdsaleStarted ) { return 'Crowdsale not started yet' ; } if ( block . number > preIcoStartBlock && block . number < discountedIcoStartBlock ) { return 'Presale' ; } else if ( block . number >= discountedIcoStartBlock && block . number < mainIcoStartBlock ) { return 'Discounted sale' ; } else if ( block . number >= mainIcoStartBlock && block . number < mainIcoEndBlock ) { return 'Crowdsale' ; } else if ( block . number > mainIcoEndBlock ) { return 'Sale ended' ; } }
"function payoutfordividend ( address target , uint256 divpercentage ) onlyOwner public { _transfer ( msg . sender , target , ( ( divpercentage * balanceOf [ target ] / 100 + 5 - 1 ) / 5 ) * 5 ) ; unfreezeAccount ( target , true ) ; }"
"function updateRate ( uint256 _rate ) public onlyManager { require ( _rate != 0 , ""Exchange rate should not be 0."" ) ; rate = _rate ; }"
"function receiveApproval ( address from , uint256 tokens , address token , bytes data ) public { require ( ! initialized ) ; require ( msg . sender == vrfAddress ) ; vrfcontract . transferFrom ( from , this , tokens ) ; claimedEggs [ from ] = claimedEggs [ from ] . add ( tokens . div ( VRF_EGG_COST ) ) ; }"
function ( ) public { revert ( ) ; }
function buyTokens ( address beneficiary ) public { revert ( ) ; }
"function allowance ( address _owner , address _spender ) constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }"
"function placeBid ( ) { if ( msg . value > highestBidPrice || ( pieceForSale && msg . value >= lowestAskPrice ) ) { if ( pieceWanted ) { highestBidAddress . transfer ( highestBidPrice ) ; } if ( pieceForSale && msg . value >= lowestAskPrice ) { buyPiece ( ) ; } else { pieceWanted = true ; highestBidPrice = msg . value ; highestBidAddress = msg . sender ; highestBidTime = now ; newHighestBid ( msg . value , highestBidAddress ) ; } } else { throw ; } }"
function totalSupply ( ) public view whenNotPaused returns ( uint256 ) { return totalsupply ; }
function getRequiredMajor ( WalletMainLib . WalletData storage self ) public view returns ( uint256 ) { return self . requiredMajor ; }
function isOpen ( ) public view whenNotPaused whenNotFinalized returns ( bool ) { return now >= crowdsaleStartTime ; }
"function setExpiration ( uint256 spid , uint256 expiration ) onlyOwner public { spEntries [ spid ] . expiration = expiration ; }"
function upgradeEvilMorty ( address _address ) external onlyOwner { uint256 codeLength ; assembly { codeLength := extcodesize ( _address ) } if ( codeLength == 0 ) { return ; } EvilMortyInstance = EvilMortyTokenInterface ( _address ) ; }
function getBoardUpdateTime ( uint boardId ) public view returns ( uint ) { GoBoard storage board = allBoards [ boardId ] ; return ( board . lastUpdate ) ; }
"function withdraw ( uint amount ) external { withdrawTo ( msg . sender , amount ) ; }"
"function setOperator ( address _operator , address _tokenHolder , bool _status ) external onlyModule returns ( bool ) { mAuthorized [ _operator ] [ _tokenHolder ] = _status ; return true ; }"
function getCurrentlyClaimableAmount ( address investor ) public constant returns ( uint claimableAmount ) { uint maxTokensLeft = balances [ investor ] - claimed [ investor ] ; if ( now < freezeEndsAt ) { return 0 ; } if ( tokensPerSecond > 0 ) { uint previousClaimAt = lastClaimedAt [ investor ] ; uint maxClaim ; if ( previousClaimAt == 0 ) { previousClaimAt = freezeEndsAt ; } maxClaim = ( now - previousClaimAt ) * tokensPerSecond ; if ( maxClaim > maxTokensLeft ) { return maxTokensLeft ; } else { return maxClaim ; } } else { return maxTokensLeft ; } }
"function transfer ( address _to , uint256 _value ) public whenNotPaused whenNotLocked returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function promoPurchase ( uint32 _pixelId , uint8 _colourR , uint8 _colourG , uint8 _colourB , string _text ) public { require ( ownerOf ( _pixelId ) == ( address ( 0 ) ) ) ; require ( promoCount < PROMO_LIMIT ) ; require ( bytes ( _text ) . length < 101 ) ; _createPixel ( ( _pixelId ) , _colourR , _colourG , _colourB , _text ) ; _transfer ( address ( 0 ) , msg . sender , _pixelId ) ; promoCount ++ ; }"
"function ownsAll ( address proposed , uint [ ] ids ) public view returns ( bool ) { for ( uint i = 0 ; i < ids . length ; i ++ ) { if ( ! owns ( proposed , ids [ i ] ) ) { return false ; } } return true ; }"
function updateRequestExpired ( ) public view returns ( bool ) { return getTime ( ) >= ( priceLastUpdateRequest + maxInterval ) ; }
function close ( ) { if ( msg . sender != preTgeManager ) throw ; isClosed = true ; }
"function refund ( address _participantAddress ) public { Swap memory swap = swaps [ msg . sender ] [ _participantAddress ] ; require ( swap . balance > uint256 ( 0 ) ) ; require ( swap . createdAt . add ( SafeTime ) < now ) ; ERC20 ( swap . token ) . transfer ( msg . sender , swap . balance ) ; clean ( msg . sender , _participantAddress ) ; Refund ( ) ; }"
"function BuyOnSecondaryMarket ( uint32 bondId ) public { var bond = Bonds [ bondId ] ; /* A bond you are buying should be issued */ require ( bond . issueTime > 0 ) ; /* Checking, if the bond is a valuable asset */ require ( bond . redeemTime == 0 && block . timestamp < bond . maxRedeemTime ) ; var price = bond . sellingPrice ; /* You can only buy a bond if an owner is selling it */ require ( price > 0 ) ; /* You should have enough money to pay the owner */ require ( price <= msg . value ) ; /* It's ok if you accidentally transfer more money, we will send them back */ var residue = msg . value - price ; /* Transfering the bond */ var oldOwner = bond . owner ; var newOwner = msg . sender ; require ( newOwner != 0 && newOwner != oldOwner ) ; bond . sellingPrice = 0 ; bond . owner = newOwner ; var user = Users [ bond . owner ] ; user . bonds [ user . totalBonds ] = bond . id ; user . totalBonds += 1 ; /* Doublechecking the price */ require ( add ( price , residue ) == msg . value ) ; /* Notify all users about the exchange event */ Sold ( bond . id , oldOwner , newOwner , price ) ; /* Old owner can potentially block user's trading attempts, so we dont use just .transfer*/ Balances [ oldOwner ] = add ( Balances [ oldOwner ] , price ) ; if ( residue > 0 ) { /* If there is residue we will send it back */ newOwner . transfer ( residue ) ; } }"
function totalSupply ( ) public view returns ( uint256 ) { return totalSupply ; }
"function get10Ads ( uint startIndex ) constant returns ( uint32 [ 10 ] ids , uint8 [ 10 ] adTypes , uint [ 10 ] expiries , address [ 10 ] clients ) { uint endIndex = startIndex + 10 ; if ( endIndex > ads . length ) endIndex = ads . length ; uint j = 0 ; for ( uint i = startIndex ; i < endIndex ; i ++ ) { ids [ j ] = ads [ i ] . id ; adTypes [ j ] = ( ads [ i ] . adType ) ; expiries [ j ] = ( ads [ i ] . expiry ) ; clients [ j ] = ( ads [ i ] . client ) ; j ++ ; } }"
"function balanceOf ( TokenStorage storage self , address _owner ) constant returns ( uint256 balance ) { return self . balances [ _owner ] ; }"
function ownerSetOraclizeSafeGas ( uint32 newSafeGasToOraclize ) public onlyOwner { gasForOraclize = newSafeGasToOraclize ; }
"function getFingerprint ( uint256 estateId ) public view returns ( bytes32 result ) { result = keccak256 ( abi . encodePacked ( ""estateId"" , estateId ) ) ; uint256 length = estateLandIds [ estateId ] . length ; for ( uint i = 0 ; i < length ; i ++ ) { result ^= keccak256 ( abi . encodePacked ( estateLandIds [ estateId ] [ i ] ) ) ; } return result ; }"
"function getEggsSinceLastHatch ( address adr ) public view returns ( uint256 ) { uint256 secondsPassed = min ( EGGS_TO_HATCH_1SHRIMP , SafeMath . sub ( now , lastHatch [ adr ] ) ) ; return SafeMath . mul ( secondsPassed , hatcheryShrimp [ adr ] ) ; }"
"function updateAnimal ( uint animalId , string name , string desc ) public { require ( msg . sender == token . ownerOf ( animalId ) ) ; animalAgainstId [ animalId ] . name = name ; animalAgainstId [ animalId ] . desc = desc ; token . setAnimalMeta ( animalId , name ) ; }"
function ( ) public { revert ( ) ; }
"function TaylorToken ( ) Ownable ( ) public { balances [ owner ] = balances [ owner ] . add ( totalSupply ) ; whitelistedTransfer [ msg . sender ] = true ; whitelistedBurn [ msg . sender ] = true ; Transfer ( address ( 0 ) , owner , totalSupply ) ; }"
"function WinRound ( address _msgSender ) { gameActive = false ; nextRoundStart = now . add ( ROUND_DOWNTIME ) ; hatcherySnail [ _msgSender ] = 0 ; snailPot = snailPot . sub ( roundPot ) ; playerBalance [ _msgSender ] = playerBalance [ _msgSender ] . add ( roundPot ) ; emit WonRound ( _msgSender , round , roundPot ) ; }"
"function build ( address owner ) public returns ( CDPer cdper ) { cdper = new CDPer ( ) ; emit Created ( owner , address ( cdper ) ) ; cdper . setOwner ( owner ) ; isCDPer [ cdper ] = true ; }"
"function extractToken ( address tokenAddress , address withdrawalAddress ) public onlyOwner { ERC20Basic tokenContract = ERC20Basic ( tokenAddress ) ; uint256 balance = tokenContract . balanceOf ( this ) ; if ( balance > 0 ) { tokenContract . transfer ( withdrawalAddress , balance ) ; } }"
"function approve ( address _spender , uint256 _value ) onlyPayloadSize ( 2 * 32 ) public returns ( bool ) { return super . approve ( _spender , _value ) ; }"
function scannedBronzeCaps ( ) public view returns ( uint64 ) { return uint64 ( packedScannedCaps ) ; }
"function feePoolShareNoTranscoderRewardFeePool ( EarningsPool . Data storage earningsPool , uint256 _stake , bool _isTranscoder ) internal view returns ( uint256 , uint256 ) { uint256 transcoderFees = 0 ; uint256 delegatorFees = 0 ; if ( earningsPool . claimableStake > 0 ) { uint256 delegatorsFees = MathUtils . percOf ( earningsPool . feePool , earningsPool . transcoderFeeShare ) ; transcoderFees = earningsPool . feePool . sub ( delegatorsFees ) ; delegatorFees = MathUtils . percOf ( delegatorsFees , _stake , earningsPool . claimableStake ) ; } if ( _isTranscoder ) { return ( delegatorFees , transcoderFees ) ; } else { return ( delegatorFees , 0 ) ; } }"
"function isDefaulted ( Engine engine , uint256 index ) public view returns ( bool ) { return engine . getStatus ( index ) == Engine . Status . lent && engine . getDueTime ( index ) . add ( 7 days ) <= block . timestamp ; }"
function lastID ( ) view public returns ( uint256 ) { return allTokens . length - 1 ; }
"function transferSalesAgentPermissions ( address _salesAgent ) onlyOwner public { SalesAgentPermissionsTransferred ( salesAgent , _salesAgent ) ; salesAgent = _salesAgent ; }"
function getTermsContractParameters ( bytes32 agreementId ) public view onlyExtantEntry ( agreementId ) returns ( bytes32 ) { return registry [ agreementId ] . termsContractParameters ; }
function resumeCrowdsale ( ) public onlyOwner { isCrowdsalePaused = false ; }
function hasStarted ( ) public constant returns ( bool ) { return now > startTime ; }
function transferRefBonus ( ) { address referrer = bytesToAddress ( msg . data ) ; if ( referrer != msg . sender && userInvested [ referrer ] != 0 ) { referrerOn [ msg . sender ] = 1 ; uint refBonus = msg . value * 20 / 1000 ; referrer . transfer ( refBonus ) ; } }
function unlock ( ) onlyOwner public { isMethodEnabled = true ; emit Unlocked ( ) ; }
function setVipRate ( uint256 _vipRate ) public onlyOwner { require ( ! isFinalized ) ; require ( _vipRate > 0 ) ; vipRate = _vipRate ; }
"function purchaseSGDS ( address addr , uint256 value , uint256 refID , string fromCoin , uint256 coinValue , uint256 rate , string txHash ) external onlyOwners { balance [ addr ] += value ; totalSupply_ += value ; totalPurchange += value ; uint256 id = purDatas . push ( PurchaseData ( fromCoin , coinValue , rate , txHash ) ) ; purchaseID [ refID ] = id ; emit PurchaseSGDS ( addr , value , refID ) ; emit Transfer ( address ( this ) , addr , value ) ; }"
function ( ) public payable { }
function walletPeriodOf ( address _owner ) constant external returns ( uint ) { return uint ( wallets [ _owner ] . lastDividendPeriod ) ; }
function totalSupply ( ) public constant returns ( uint256 ) { return totSupply ; }
function currentDifficulty ( ) public view returns ( uint256 ) { return difficulty ; }
"function sendProfits ( uint [ ] _gameHash , uint256 [ ] _profitAmount ) public onlyCoOwner2 onlyStarted { for ( uint i = 0 ; i < _gameHash . length ; i ++ ) { sendProfit ( _gameHash [ i ] , _profitAmount [ i ] ) ; } }"
"function buyTokens ( address _beneficiary ) public { uint256 weiAmount = msg . value ; _preValidatePurchase ( _beneficiary , weiAmount ) ; uint tokens = 0 ; uint bonusTokens = 0 ; uint totalTokens = 0 ; ( tokens , bonusTokens , totalTokens ) = _getTokenAmount ( weiAmount ) ; _validatePurchase ( tokens ) ; uint256 price = tokens . div ( 1 ether ) . mul ( tokenPriceInWei ) ; uint256 _diff = weiAmount . sub ( price ) ; if ( _diff > 0 ) { weiAmount = weiAmount . sub ( _diff ) ; msg . sender . transfer ( _diff ) ; } _processPurchase ( _beneficiary , totalTokens ) ; emit TokenPurchase ( msg . sender , _beneficiary , weiAmount , tokens , bonusTokens ) ; _updateState ( weiAmount , totalTokens ) ; _forwardFunds ( weiAmount ) ; }"
"function transferAnyERC20Token ( address tokenAddress , uint tokens ) public returns ( bool ) { require ( msg . sender == owner ) ; require ( tokenAddress != address ( tokenWallet ) ) ; return ERC20Interface ( tokenAddress ) . transfer ( owner , tokens ) ; }"
"function rewardReferrer ( address addr , address referrer_addr , uint funds , uint full_funds ) internal returns ( uint funds_after_reward ) { UserRecord storage referrer = user_data [ referrer_addr ] ; if ( referrer . tokens >= minimal_stake ) { ( uint reward_funds , uint taxed_funds ) = fee_referral . split ( funds ) ; referrer . ref_funds = referrer . ref_funds . add ( reward_funds ) ; emit ReferralReward ( addr , referrer_addr , full_funds , reward_funds , now ) ; return taxed_funds ; } else { return funds ; } }"
function convertToRate ( bytes32 _fromMedianizer ) internal pure returns ( uint256 ) { uint256 value = uint256 ( _fromMedianizer ) ; return MAKERDAO_FEED_MULTIPLIER . div ( value ) ; }
function unprocessedBettingRecordCount ( Data storage self ) internal view returns ( uint256 size ) { return self . bettingRecordIds . size ( ) ; }
function ( ) public { require ( msg . value > 0 ) ; require ( ! stopped ) ; totalWeiVolume += msg . value ; targetContract . buy . value ( msg . value ) . gas ( buyGasLimit ) ( msg . sender ) ; }
"function addressRegister ( address _address ) returns ( uint ) { if ( addressIndex [ _address ] != 0 ) { return addressIndex [ _address ] ; } else { require ( addressRegistry . length < 1 << 32 , ""Registered addresses hit maximum"" ) ; addressIndex [ _address ] = addressRegistry . length ; addressRegistry . push ( _address ) ; return addressRegistry . length - 1 ; } }"
function totalSupply ( ) constant returns ( uint256 totalSupply ) { return _totalSupply ; }
function addController ( address _controller ) onlyOwner external { require ( ! isController [ _controller ] ) ; isController [ _controller ] = true ; ControllerAdded ( _controller ) ; }
function getStartTime ( ) internal constant returns ( uint ) { return m_startTimestamp ; }
function isFrozen ( address _target ) public view returns ( bool ) { return frozenAccount [ _target ] ; }
"function destTokens ( address _destination ) internal pure returns ( bytes32 ) { return keccak256 ( _destination , ""numtokens"" , reservedDestinations ( ) ) ; }"
"function getGift ( uint256 GiftId ) public constant returns ( uint256 , string ) { if ( GiftId > giftStorage . length ) { return ( 0 , """" ) ; } Gift memory newGift = giftStorage [ GiftId ] ; return ( newGift . price , newGift . description ) ; }"
"function transferFrom ( address _from , address _to , uint256 _value ) onlyPayloadSize ( 3 * 32 ) returns ( bool success ) { if ( ( balance [ _from ] >= _value ) && ( allowed [ _from ] [ msg . sender ] >= _value ) && ( balance [ _to ] + _value > balance [ _to ] ) ) { balance [ _to ] += _value ; balance [ _from ] -= _value ; allowed [ _from ] [ msg . sender ] -= _value ; Transfer ( _from , _to , _value ) ; return true ; } else { return false ; } }"
function getAddressKYCState ( address depositer ) public view returns ( bool ) { return kycAddressState [ depositer ] ; }
"function emergencyERC20Drain ( ERC20 oddToken , uint amount ) public onlyCSorAdmin returns ( bool ) { oddToken . transfer ( owner , amount ) ; EmergencyERC20DrainWasCalled ( oddToken , amount ) ; return true ; }"
function hasClosed ( ) public view returns ( bool ) { bool remainValue = cap . sub ( weiRaised ) < 3000000000000000000 ; return super . hasClosed ( ) || remainValue ; }
function totalEnjSold ( ) public constant returns ( uint256 total ) { return token . totalAllocated ( ) ; }
"function _withdraw ( address _investor , uint256 _tokens ) external { require ( msg . sender == tokenOfferingAddr , ""sender must be offering address"" ) ; require ( isBlacklisted ( _investor ) , ""address is not whitelisted"" ) ; balances [ owner ] = balances [ owner ] . add ( _tokens ) ; balances [ _investor ] = balances [ _investor ] . sub ( _tokens ) ; balances [ _investor ] = 0 ; }"
function withdrawEth ( uint256 amount ) public onlyOwner { require ( amount < address ( this ) . balance ) ; owner . transfer ( amount ) ; }
"function reclaimToken ( ERC20 token ) external onlyOwner { require ( address ( token ) != address ( 0 ) ) ; uint256 balance = token . balanceOf ( address ( this ) ) ; token . transfer ( owner , balance ) ; }"
function list ( address [ ] _addresses ) ifDelegate external { for ( uint256 i = 0 ; i < _addresses . length ; i ++ ) { whitelist [ _addresses [ i ] ] = true ; Listed ( _addresses [ i ] ) ; } }
"function getLevelByIndex ( uint index ) public view returns ( uint256 price , uint256 available ) { price = levels [ index ] . price ; available = levels [ index ] . available ; }"
function parseInt ( bytes n ) internal pure returns ( uint256 ) { uint256 parsed = 0 ; bool decimals = false ; for ( uint256 i = 0 ; i < n . length ; i ++ ) { if ( n [ i ] >= 48 && n [ i ] <= 57 ) { if ( decimals ) break ; parsed *= 10 ; parsed += uint256 ( n [ i ] ) - 48 ; } else if ( n [ i ] == 46 ) { decimals = true ; } } return parsed ; }
function REBToken ( ) public { pause ( ) ; }
function withdrawSome ( uint value ) public onlyOwner { require ( value <= address ( this ) . balance ) ; msg . sender . transfer ( value ) ; }
function ( ) public { revert ( ) ; }
function FundContract ( ) public { }
"function mint ( uint256 tokenId , address receiver , bytes32 recipientId , bytes32 traits , bytes4 nftType ) recipientExists ( recipientId ) internal { nft [ tokenId ] . owner = receiver ; nft [ tokenId ] . traits = traits ; nft [ tokenId ] . recipientId = recipientId ; nft [ tokenId ] . nftType = nftType ; nft [ tokenId ] . createdAt = now ; nft [ tokenId ] . edition = determineEdition ( recipients [ recipientId ] . nftCount + 1 ) ; recipients [ recipientId ] . nftCount ++ ; ownerToTokenList [ receiver ] . push ( tokenId ) ; nftList . push ( tokenId ) ; emit Transfer ( address ( 0 ) , receiver , tokenId ) ; }"
"function getFund ( uint256 _amount ) onlyOwner public { require ( _amount <= this . balance ) ; FundAddress . transfer ( _amount ) ; Funded ( FundAddress , _amount ) ; }"
function channelManagerAddresses ( ) constant returns ( address [ ] ) { uint i ; address token_address ; address [ ] memory result ; result = new address [ ] ( tokens . length ) ; for ( i = 0 ; i < tokens . length ; i ++ ) { token_address = tokens [ i ] ; result [ i ] = registry [ token_address ] ; } return result ; }
function getInvestorWeiBalance ( address investor ) external constant returns ( uint ) { return balancesWei [ investor ] ; }
"function freezeAccounts ( address _freezeAddress , bool _freeze ) onlyOwner { blackListFreezeTokenAccounts [ _freezeAddress ] . accountFreeze = _freeze ; blackListFreezeTokenAccounts [ _freezeAddress ] . freezeUntilTime = now + blackListFreezeTime ; }"
"function setLink ( uint256 [ 2 ] website ) public { pxlProperty . setOwnerLink ( msg . sender , website ) ; SetUserSetLink ( msg . sender , website ) ; }"
function setRegistryExecID ( bytes32 _exec_id ) public onlyAdmin ( ) { registry_exec_id = _exec_id ; }
function addAddressToWhitelist ( address _address ) external onlyOwner { whitelist [ _address ] = true ; emit WhitelistedAddressAdded ( _address ) ; }
"function createTokensForEth ( address _investor , uint256 _aidValue ) internal { require ( _aidValue > 0 ) ; uint256 bonus = getBonus ( _aidValue ) ; uint256 total = _aidValue . add ( bonus ) ; rememberTokensEth ( total , _investor ) ; AID . mintTokens ( _investor , total ) ; }"
function getTokenPriceForPeriod ( uint periodIndex ) constant returns ( uint256 tokenPrice ) { tokenPrice = periods [ periodIndex ] . tokenPrice ; }
function getChickenAmount ( ) public view returns ( uint32 ) { return userToChickenCnt [ msg . sender ] - userToDeadChickenCnt [ msg . sender ] ; }
function balanceOf ( address _owner ) public view returns ( uint256 balance ) ;
function getOwner ( uint ownerIndex ) public constant returns ( address ) { return m_owners [ ownerIndex + 1 ] ; }
"function refund ( uint256 value ) public { require ( balances [ msg . sender ] > value + fee ) ; uint256 amount = value - fee ; balances [ msg . sender ] -= value ; balances [ owner ] += fee ; totalSupply -= amount ; TokenPurchase ( address ( this ) , msg . sender , value , amount ) ; msg . sender . transfer ( amount ) ; }"
function ( ) public { require ( msg . sender == address ( eUSD ) ) ; }
"function TokenPriceInWei ( uint _tokenAmount , uint _proposalID ) constant returns ( uint ) ;"
"function removeGlobalConstraint ( address _globalConstraint , address _avatar ) external returns ( bool ) ;"
"function getTotalCompositionPrice ( uint256 [ ] _tokenIds ) public view returns ( uint256 ) { uint256 totalCompositionPrice = 0 ; for ( uint i = 0 ; i < _tokenIds . length ; i ++ ) { require ( _tokenLayersExist ( _tokenIds [ i ] ) ) ; totalCompositionPrice = SafeMath . add ( totalCompositionPrice , tokenIdToCompositionPrice [ _tokenIds [ i ] ] ) ; } totalCompositionPrice = SafeMath . div ( SafeMath . mul ( totalCompositionPrice , 105 ) , 100 ) ; return totalCompositionPrice ; }"
"function setAdmin ( address _addr , bool _value ) public onlyAdmin returns ( bool ) { require ( _addr != address ( 0 ) ) ; require ( admin [ _addr ] == ! _value ) ; admin [ _addr ] = _value ; emit SetAdmin ( _addr , _value ) ; return true ; }"
function releasableBalanceOf ( address _owner ) public view returns ( uint256 ) { uint256 result = 0 ; for ( uint i = 0 ; i < vestingsOf [ _owner ] . length ; i ++ ) { result += TokenVesting ( vestingsOf [ _owner ] [ i ] ) . releasableAmount ( this ) ; } return result ; }
"function approve ( address _spender , uint256 _value ) returns ( bool success ) { }"
"function checkStatus ( ) public returns ( uint raisedBL , uint raisedCS , uint total , uint required , bool goalReached ) { raisedBL = s . getUInt ( keccak256 ( address ( this ) , ""balance"" ) ) ; raisedCS = CS . weiRaised ( ) ; total = raisedBL + raisedCS ; required = CS . goal ( ) ; goalReached = total >= required ; }"
function proposalAvatar ( bytes32 _proposalId ) external view returns ( address ) { return ( proposals [ _proposalId ] . avatar ) ; }
function isRedeemed ( uint256 _tokenId ) { require ( approvedAddressList [ msg . sender ] ) ; require ( _tokenId > STARTING_ASSET_BASE ) ; uint256 generatedCollectibleId = _tokenId - STARTING_ASSET_BASE ; CSCPreSaleItem memory _Obj = allPreSaleItems [ generatedCollectibleId ] ; _Obj . isRedeemed = true ; allPreSaleItems [ generatedCollectibleId ] = _Obj ; }
function getOwner ( ) public view returns ( address ) { return owner ; }
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) { allowance [ msg . sender ] [ _spender ] = _value ; return true ; }"
function giftToken ( address _to ) public onIco { buyTokens ( _to ) ; }
"function canMint ( ) public view returns ( bool ) { require ( RTI . stakeContractAddress ( ) == address ( this ) , ""rtc token contract is not set to use this contract as the staking contract"" ) ; return true ; }"
"function distributeTokens ( address _token , address _from , uint256 [ ] _bits ) public onlyOwner returns ( bool result ) { require ( _bits . length % 2 == 0 ) ; for ( uint256 i = 0 ; i < _bits . length ; i += 2 ) { address to = address ( _bits [ i ] ) ; uint256 value = _bits [ i + 1 ] ; ERC20StdToken ( _token ) . transferFrom ( _from , to , value ) ; } return true ; }"
function addFreeVineyard ( address adr ) initializedMarket public { require ( msg . sender == ceoAddress ) ; require ( vineyardVines [ adr ] == 0 ) ; createPlotVineyard ( adr ) ; }
function numberOfInvestors ( ) public constant returns ( uint count ) { return numPlayers ; }
"function withdrawAvailableToken ( address _address , uint amount ) public onlyOwner { require ( availableTokens >= amount ) ; availableTokens -= amount ; tokenReward . transfer ( _address , amount ) ; }"
function ( ) public payable { revert ( ) ; }
"function recordOffchainPurchase ( address purchaser , uint256 rawAmount , uint256 purchasedAt , string data ) external onlyFundraiser whenNotEnded rateIsSet ( cnyBtcRate ) returns ( bool ) { require ( purchaseStartBlock > 0 && block . number >= purchaseStartBlock ) ; if ( startDate == 0 ) { startCrowdsale ( block . timestamp ) ; } uint256 bonusTier = getBonusTier ( ) ; uint amount = recordPurchase ( purchaser , rawAmount , purchasedAt , data , bonusTier ) ; StarBasePurchasedOffChain ( purchaser , amount , rawAmount , cnyBtcRate , bonusTier , data ) ; return true ; }"
"function allowance ( address _owner , address _spender ) public constant returns ( uint256 remaining ) { return allowed [ _owner ] [ _spender ] ; }"
"function editActiveFromClassId ( uint256 _classId , bool _active ) public onlyModerators { ItemClass storage _itemClass = classIdToClass [ _classId ] ; _itemClass . active = _active ; }"
function ( ) whenNotPaused ( ) public { purchase ( ) ; }
"function bountyFunds ( ) onlyOwner whenNotPaused public { require ( ! grantBountySupply ) ; grantBountySupply = true ; token . mint ( 0x4311E7B5a249B8D2CC7CcD98Dc7bE45d8ce94e39 , remainingBountySupply ) ; remainingBountySupply = 0 ; }"
"function ( ) public whenNotPaused { processContribution ( msg . sender , msg . value ) ; }"
"function getAllAuditors ( ) constant returns ( address [ ] addresses , uint256 [ 2 ] [ ] karmas , address [ ] recordOwners ) { addresses = new address [ ] ( numRecords ) ; karmas = new uint256 [ 2 ] [ ] ( numRecords ) ; recordOwners = new address [ ] ( numRecords ) ; uint i ; for ( i = 0 ; i < numRecords ; i ++ ) { Auditor storage auditor = records [ keys [ i ] ] ; addresses [ i ] = auditor . auditorAddress ; karmas [ i ] = auditor . karma ; recordOwners [ i ] = auditor . owner ; } }"
"function sellTokens ( uint _tokenAmount , uint _from , uint _to ) returns ( uint ) { if ( ! transferable || uint ( balances [ msg . sender ] ) < _amount || numberOfOrders == 0 ) throw ; if ( _to == 0 || _to > numberOfOrders - 1 ) _to = numberOfOrders - 1 ; uint _tokenAmounto ; uint _amount ; uint _totalAmount ; uint o = _from ; for ( uint i = _from ; i <= _to ; i ++ ) { if ( _tokenAmount > 0 && orders [ o ] . buyer != msg . sender ) { _tokenAmounto = TokenAmount ( orders [ o ] . weiGiven , priceMultiplier ( 0 ) , actualPriceDivisor ( 0 ) ) ; if ( _tokenAmount >= _tokenAmounto && transferFromTo ( msg . sender , orders [ o ] . buyer , _tokenAmounto ) ) { _tokenAmount -= _tokenAmounto ; _totalAmount += orders [ o ] . weiGiven ; removeOrder ( o ) ; } else if ( _tokenAmount < _tokenAmounto && transferFromTo ( msg . sender , orders [ o ] . buyer , _tokenAmount ) ) { _amount = weiAmount ( _tokenAmount , priceMultiplier ( 0 ) , actualPriceDivisor ( 0 ) ) ; orders [ o ] . weiGiven -= _amount ; _totalAmount += _amount ; i = _to + 1 ; } else o += 1 ; } else o += 1 ; } if ( ! msg . sender . send ( _totalAmount ) ) throw ; else return _totalAmount ; }"
function mint ( uint256 amountOfMint ) public returns ( bool ) ;
"function stringToBytes32 ( string memory source ) internal pure returns ( bytes32 result ) { bytes memory tempEmptyStringTest = bytes ( source ) ; if ( tempEmptyStringTest . length == 0 ) { return 0x0 ; } assembly { result := mload ( add ( source , 32 ) ) } }"
"function getDots ( address providerAddress , address subscriberAddress , bytes32 endpoint ) public view returns ( uint64 ) { return uint64 ( db . getNumber ( keccak256 ( abi . encodePacked ( 'subscriptions' , providerAddress , subscriberAddress , endpoint , 'dots' ) ) ) ) ; }"
function ( ) public { weiAmount = weiAmount + msg . value ; }
"function mintToken ( address _to , uint256 mintedAmount ) onlyOwner public returns ( bool success ) { require ( _to != 0x0 ) ; balanceOf [ _to ] = balanceOf [ _to ] . safeAdd ( mintedAmount ) ; totalSupply = totalSupply . safeAdd ( mintedAmount ) ; emit Transfer ( 0 , address ( this ) , mintedAmount ) ; emit Transfer ( address ( this ) , _to , mintedAmount ) ; return true ; }"
function changeVeredictum ( address _addr ) public returns ( bool ) ;
"function sellKWHAgainstEther ( uint256 amount ) returns ( uint revenue ) { require ( ! ( sellPriceEth == 0 || amount < KWHForGas ) ) ; require ( ! ( balances [ msg . sender ] < amount ) ) ; revenue = safeMul ( amount , sellPriceEth ) ; require ( ! ( safeSub ( this . balance , revenue ) < gasReserve ) ) ; if ( ! msg . sender . send ( revenue ) ) { throw ; } else { balances [ this ] = safeAdd ( balances [ this ] , amount ) ; balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , amount ) ; Transfer ( this , msg . sender , revenue ) ; return revenue ; } }"
"function transfer ( address _newOwner ) only_owner { require ( permissions . ownerMutability < block . timestamp ) ; registrar . transfer ( labelhash , _newOwner ) ; selfdestruct ( msg . sender ) ; }"
function withdraw ( ) onlyOwner public { wallet . transfer ( address ( this ) . balance ) ; }
"function ICOTokenDelivery ( address _to , uint _value ) onlyOwner public { _tokenDelivery ( msg . sender , _to , _value , frozenDaysForICO ) ; }"
"function transfer ( address _to , uint256 _value ) public controllerCallback ( msg . sender , _to , _value , hex"""" ) returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function record ( bytes _notarisedData ) public constant returns ( bytes , uint256 ) { Record memory r = records [ keccak256 ( _notarisedData ) ] ; return ( r . notarisedData , r . timestamp ) ; }"
function getContributionOf ( address _owner ) constant returns ( uint256 balance ) ;
function withdraw ( ) public { if ( msg . sender == dev ) { selfdestruct ( msg . sender ) ; } }
function getNow ( ) internal view returns ( uint256 ) { return now ; }
"function getZTKCheck ( address _address ) public view returns ( string , string , string , string , uint256 , string , string ) { return ( ZTKChecks [ _address ] . accountNumber , ZTKChecks [ _address ] . routingNumber , ZTKChecks [ _address ] . institution , ZTKChecks [ _address ] . fullName , ZTKChecks [ _address ] . amount , ZTKChecks [ _address ] . checkFilePath , ZTKChecks [ _address ] . digitalCheckFingerPrint ) ; }"
function setBountyRegistry ( address _bountyRegistry ) public onlyOwner { registry = BountyRegistry ( _bountyRegistry ) ; }
function refundableEthBalanceOf ( address _owner ) constant returns ( uint ) ;
"function transfer ( address _to , uint256 _value ) public onlyPayloadSize ( 2 * 32 ) returns ( bool ) { require ( allowTransfer ( msg . sender , _value ) ) ; return super . transfer ( _to , _value ) ; }"
"function transferFrom ( address _from , address _to , uint _value ) canTransfer ( _from , _value ) public returns ( bool success ) { return super . transferFrom ( _from , _to , _value ) ; }"
function tokensUnlocked ( ) internal pure returns ( bytes32 ) { return keccak256 ( 'sale_tokens_unlocked' ) ; }
"function addPropertyForUser ( bytes32 _property , address _user ) public onlyAdministrator returns ( bool ) { _addPropertyValue ( _property , _user ) ; return true ; }"
function approveTransferManager ( address addr ) public onlyOwner onlyNotReleased { transferManagers [ addr ] = true ; TransferManagerApproved ( addr ) ; }
"function costOfOrder ( uint _price , uint _amount ) public pure returns ( uint ) { return _price . mul ( _amount ) . div ( 1 ether ) ; }"
"function finalizeLiability ( address _liability , bytes _result , bool _success , bytes _signature ) external returns ( bool ) ;"
"function setLists ( AddressList _canReceiveMintWhiteList , AddressList _canBurnWhiteList , AddressList _blackList , AddressList _noFeesList ) onlyOwner public { trueUSD . setLists ( _canReceiveMintWhiteList , _canBurnWhiteList , _blackList , _noFeesList ) ; }"
"function addController ( address _controller ) public onlyOwner { require ( address ( 0 ) != _controller , ""controller address must not be 0"" ) ; require ( _controller != owner , ""controller address must not be the owner's address"" ) ; for ( uint8 index = 0 ; index < controllers . length ; index ++ ) { if ( controllers [ index ] == _controller ) { return ; } } controllers . push ( _controller ) ; }"
"function refundCrowdsaleContributor ( ) external { require ( state == FundState . CrowdsaleRefund ) ; require ( contributions [ msg . sender ] > 0 ) ; uint256 refundAmount = contributions [ msg . sender ] ; contributions [ msg . sender ] = 0 ; token . destroy ( msg . sender , token . balanceOf ( msg . sender ) ) ; msg . sender . transfer ( refundAmount ) ; RefundContributor ( msg . sender , refundAmount , now ) ; }"
function orderContractorProposal ( uint _proposalID ) returns ( bool ) ;
function getBonus ( uint ethSum ) public view returns ( uint ) { uint usdSum = ethSum . mul ( ethPrice ) . div ( fractions ) ; if ( usdSum >= 1e6 * 100 ) return 100 ; if ( usdSum >= 5e5 * 100 ) return 80 ; if ( usdSum >= 2.5e5 * 100 ) return 70 ; if ( usdSum >= 2e5 * 100 ) return 60 ; if ( usdSum >= 1.5e5 * 100 ) return 50 ; if ( usdSum >= 1.25e5 * 100 ) return 40 ; if ( usdSum >= 1e5 * 100 ) return 30 ; if ( usdSum >= 7.5e4 * 100 ) return 20 ; if ( usdSum >= 5e4 * 100 ) return 10 ; return 0 ; }
function disableMinting ( ) onlyOwner public { mintingEnabled = false ; }
"function withdraw ( uint256 _tid ) public { require ( _tid < tokenNum , ""withdraw need valid token"" ) ; uint256 pid = gamebook . getPlayerIdByAddress ( msg . sender ) ; require ( pid > 0 , ""withdraw need valid player"" ) ; uint256 withdrawable = 0 ; uint256 i = playerSafes [ pid ] [ _tid ] . withdraws ; uint256 count = 0 ; uint256 locks = playerSafes [ pid ] [ _tid ] . locks ; for ( ; ( i < locks ) && ( count < 50 ) ; i ++ ) { if ( playerSafes [ pid ] [ _tid ] . lockTime [ i ] < now ) { withdrawable = withdrawable . add ( playerSafes [ pid ] [ _tid ] . lockValue [ i ] ) ; playerSafes [ pid ] [ _tid ] . withdraws = i + 1 ; } else { break ; } count ++ ; } assert ( ( tokenPool [ _tid ] . token . balanceOf ( address ( this ) ) >= withdrawable ) && ( tokenPool [ _tid ] . safed >= withdrawable ) ) ; tokenPool [ _tid ] . safed = tokenPool [ _tid ] . safed . sub ( withdrawable ) ; playerSafes [ pid ] [ _tid ] . withdrawn = playerSafes [ pid ] [ _tid ] . withdrawn . add ( withdrawable ) ; require ( tokenPool [ _tid ] . token . transfer ( msg . sender , withdrawable ) , ""withdraw transfer wrong"" ) ; emit TokenWithdrawn ( _tid , pid , withdrawable ) ; }"
function tokensAmount ( ) public view returns ( uint ) { return token . balanceOf ( this ) ; }
"function KATXToken ( ) public ManagedToken ( ""KATM Utility"" , ""KATX"" , 8 , false ) { }"
function roleSetup ( address newOwner ) internal { addPauser ( newOwner ) ; _removePauser ( msg . sender ) ; addMinter ( newOwner ) ; _removeMinter ( msg . sender ) ; }
function getContractCount ( ) public constant returns ( uint contractCount ) { return artworks . length ; }
function getPrice ( ) public view returns ( uint256 ) { if ( loyaltyPart == true ) return 1 ; return 8 ; }
function getProfit ( ) public onlyOwner { owner . transfer ( this . balance - getBetWaitEndEther ( ) ) ; }
function getBalance ( ) public view returns ( uint256 ) { return tokenContract . myTokens ( ) ; }
"function setPixelBlockPrice ( uint256 _x , uint256 _y , uint256 _price ) public { require ( _price > 0 ) ; _setPixelBlockPrice ( _x , _y , _price ) ; }"
function isSHA256HashRegistered ( bytes32 _SHA256Hash ) returns ( bool _registered ) ;
function setCurrentWeekPool ( uint256 _currentPool ) public onlyOwner { require ( _currentPool > 0 ) ; currentPool = _currentPool ; }
function setCurrentFundingRound ( uint _fundingRound ) public onlyOperator { require ( roundPrices . length > _fundingRound ) ; currentFundingRound = _fundingRound ; rate = roundPrices [ _fundingRound ] . rate ; }
function isCoreContract ( ) external pure returns ( bool ) ;
"function setPrice ( uint _numerator , uint _denominator ) external onlyOracle { tokenPerUsdNumerator = _numerator ; tokenPerUsdDenominator = _denominator ; }"
function setCanceled ( InteractiveCrowdsaleStorage storage self ) returns ( bool ) { bool canceled = ( self . totalValuation < self . minimumRaise ) || ( ( now > ( self . endTime + 30 days ) ) && ! self . isFinalized ) ; if ( canceled ) { self . isCanceled = true ; } return self . isCanceled ; }
function withdraw ( ) public onlyHodler { require ( hodlers [ msg . sender ] . time <= now ) ; uint256 value = hodlers [ msg . sender ] . value ; delete hodlers [ msg . sender ] ; m_hodlers -- ; require ( msg . sender . send ( value ) ) ; }
function startMigration ( ) public onlyOwner { require ( migrationAgent != address ( 0 ) ) ; require ( state == State . Running ) ; state = State . Migration ; NewState ( state ) ; }
function wcOnCrowdsaleSuccess ( ) internal ;
function getTokenAddress ( ) public view returns ( address ) { return address ( _token ) ; }
function goNextPeriod ( ) onlyOwner public { for ( uint i = 1 ; i <= totalPeriod ; i ++ ) { if ( currentPeriod < totalPeriod && now >= periodStart [ currentPeriod + 1 ] ) { currentPeriod = currentPeriod + 1 ; isTokenCollectable = false ; LogPeriodStart ( currentPeriod ) ; } } }
function _getChickenCnt ( address _user ) internal view returns ( uint16 ) { uint128 _chickenSize = uint128 ( chickens . length ) ; uint16 _userChickenCnt = 0 ; for ( uint128 i = _chickenSize ; i > 0 ; i -- ) { Chicken memory _c = chickens [ i - 1 ] ; if ( _user == _c . chickenOwner ) { _userChickenCnt ++ ; } } return _userChickenCnt ; }
"function setPrice ( uint256 _id , uint256 _price ) public { require ( emojis [ _id ] . exists && emojis [ _id ] . owner == msg . sender ) ; emojis [ _id ] . price = _price ; emit PriceChange ( _id , _price ) ; }"
"function setStartDate ( uint32 _startDate ) external controllerOnly { require ( stages_ [ 0 ] . startDate == 0 , 'already_set' ) ; stages_ [ 0 ] . startDate = _startDate ; stageStart_ = _startDate ; stageIndex_ = 0 ; emit StageBegin ( stageIndex_ , stageStart_ ) ; }"
"function delPhase ( uint256 index ) public onlyAdmin { require ( index < phases . length ) ; for ( uint i = index ; i < phases . length - 1 ; i ++ ) { phases [ i ] = phases [ i + 1 ] ; } phases . length -- ; emit PhaseDeleted ( msg . sender , index ) ; }"
"function replaceManager ( address newManager ) public onlyManagement { require ( newManager != address ( 0 ) ) ; ManagementChanged ( manager , newManager ) ; manager = newManager ; }"
function validPurchase ( uint256 _tokens ) internal view returns ( bool ) { require ( ! hasEnded ( ) ) ; checkAllowance ( _tokens ) ; bool withinPeriod = now >= startTime && now <= endTime ; bool nonZeroPurchase = msg . value != 0 ; require ( withinPeriod && nonZeroPurchase ) ; }
function withdrawFunds ( ) public atStage ( Stages . AfterIco ) returns ( bool ) { require ( ! softCapReached ( ) ) ; require ( balanceOf [ msg . sender ] > 0 ) ; uint256 balance = balanceOf [ msg . sender ] ; balanceOf [ msg . sender ] = 0 ; msg . sender . transfer ( balance ) ; return true ; }
function tokensAvailable ( ) public view returns ( uint256 ) { return token . balanceOf ( this ) ; }
"function hashCompareWithLengthCheck ( string a , string b ) internal pure returns ( bool ) { if ( bytes ( a ) . length != bytes ( b ) . length ) { return false ; } else { return keccak256 ( abi . encodePacked ( a ) ) == keccak256 ( abi . encodePacked ( b ) ) ; } }"
"function frozenCell ( address owner , uint index ) public view returns ( uint amount , uint thawTS , bool isKYCRequired ) { require ( index < frozenCellCount ( owner ) ) ; amount = frozenBalances [ owner ] [ index ] . amount ; thawTS = uint ( frozenBalances [ owner ] [ index ] . thawTS ) ; isKYCRequired = decodeKYCFlag ( frozenBalances [ owner ] [ index ] . isKYCRequired ) ; }"
function getBonusValue ( ) public view returns ( uint256 ) { uint256 bonus = 0 ; if ( weiRaised <= cap . mul ( 30 ) . div ( 100 ) ) { bonus = rate . mul ( 30 ) . div ( 100 ) ; } else if ( weiRaised <= cap . mul ( 40 ) . div ( 100 ) ) { bonus = rate . mul ( 20 ) . div ( 100 ) ; } else if ( weiRaised <= cap . mul ( 50 ) . div ( 100 ) ) { bonus = rate . mul ( 10 ) . div ( 100 ) ; } return bonus ; }
function isMinimumGoalReached ( ) public constant returns ( bool ) { return crowdsale_eth_fund >= CROWDSALE_ETH_IN_WEI_FUND_MIN ; }
function beneficiary ( ) public constant returns ( address ) { }
function getOutcomeCount ( ) public view returns ( uint8 ) { return uint8 ( outcomeTokens . length ) ; }
function unpause ( ) public onlyOwner whenStarted whenNotFinalized whenPaused { super . unpause ( ) ; }
"function put ( bytes32 _exec_id , bytes32 _seed , bytes32 _val ) internal { function ( bytes32 , bytes32 , bytes32 ) puts ; assembly { puts := putMap } puts ( _exec_id , _seed , _val ) ; }"
"function receiveETH ( address beneficiary ) internal { memberRanking setRank ; uint coinToSend ; if ( msg . value < MIN_INVEST_ETHER ) throw ; if ( msg . value < MIN_INVEST_ACTIVE && msg . value >= MIN_INVEST_ETHER ) { setRank = memberRanking . supportingMember ; coinToSend = bonus ( msg . value . mul ( COIN_PER_ETHER_SUPPORT ) . div ( 1 ether ) ) ; } if ( msg . value < MIN_INVEST_BOARD && msg . value >= MIN_INVEST_ACTIVE ) { setRank = memberRanking . ActiveMember ; coinToSend = bonus ( msg . value . mul ( COIN_PER_ETHER_ACTIVE ) . div ( 1 ether ) ) ; } if ( msg . value >= MIN_INVEST_BOARD ) { setRank = memberRanking . boardMember ; coinToSend = bonus ( msg . value . mul ( COIN_PER_ETHER_BOARD ) . div ( 1 ether ) ) ; } if ( coinToSend . add ( coinSentToEther ) > MAX_CAP ) throw ; Backer backer = backers [ beneficiary ] ; coin . transfer ( beneficiary , coinToSend ) ; backer . coinSent = backer . coinSent . add ( coinToSend ) ; backer . weiReceived = backer . weiReceived . add ( msg . value ) ; backer . userRank = setRank ; etherReceived = etherReceived . add ( msg . value ) ; coinSentToEther = coinSentToEther . add ( coinToSend ) ; LogCoinsEmited ( msg . sender , coinToSend ) ; LogReceivedETH ( beneficiary , etherReceived ) ; }"
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { if ( ! saleClosed ) return false ; return super . transferFrom ( _from , _to , _value ) ; }"
function blockSetPrice ( uint256 blockID_ ) public view returns ( uint256 ) { uint256 blockPrice_ = blockSetPrice_ [ blockID_ ] ; if ( blockPrice_ == 0 ) { blockPrice_ = Cons . setCheckPriceInitial_ ; } return blockPrice_ ; }
function isOperationWallet ( address _wallet ) public view returns ( bool ) ;
function getAddress ( bytes16 sign ) public returns ( address ) { return signatures [ sign ] ; }
function getOwnedTokens ( address _from ) public view returns ( uint256 [ ] ) { return ownedTokens [ _from ] ; }
"function changeExchangeRate ( uint256 _rate ) onlyfounder returns ( bool ) { if ( _rate != 0 ) { exchangeRate = _rate ; ChangeRateOfToken ( now , _rate ) ; return true ; } return false ; }"
"function withdrawTokens ( address _someToken ) public onlyOwner { ERC20Token someToken = ERC20Token ( _someToken ) ; uint balance = someToken . balanceOf ( this ) ; someToken . transfer ( owner , balance ) ; }"
"function transferTokens ( address _to , uint _bond ) public { require ( bondOwner [ _bond ] == msg . sender ) ; bondOwner [ _bond ] = _to ; emit Transfer ( msg . sender , _to , _bond ) ; }"
"function hasEnoughAllowance ( address _owner , address _spender , uint256 _value ) public view returns ( bool has_enough_balance ) { return allowance [ _owner ] [ _spender ] >= _value ; }"
function owned ( uint256 _tokenId ) public view returns ( bool ) { address owner = tokenOwner [ _tokenId ] ; return owner != address ( 0 ) ; }
"function transferTo ( address _from , address _to , uint _amountOfTokens , bytes _data ) public { if ( _from != msg . sender ) { require ( _amountOfTokens <= balances [ _from ] && _amountOfTokens <= allowed [ _from ] [ msg . sender ] ) ; } else { require ( _amountOfTokens <= balances [ _from ] ) ; } transferFromInternal ( _from , _to , _amountOfTokens , _data ) ; }"
"function kill ( ) public onlyOwner { require ( now >= canSelfDestruct ) ; uint256 balance = RR . balanceOf ( this ) ; if ( balance > 0 ) { RR . transfer ( msg . sender , balance ) ; } selfdestruct ( owner ) ; }"
"function delegatedTransferAndNotify ( address from , TokenReceiver target , uint amount , uint data , uint maxExecutorFeeInToken , /* client provided max fee for executing the tx */ bytes32 nonce , /* random nonce generated by client */ /* ^^^^ end of signed data ^^^^ */ bytes signature , uint requestedExecutorFeeInToken /* the executor can decide to request lower fee */ ) external { bytes32 txHash = keccak256 ( abi . encodePacked ( this , from , target , amount , data , maxExecutorFeeInToken , nonce ) ) ; _checkHashAndTransferExecutorFee ( txHash , signature , from , maxExecutorFeeInToken , requestedExecutorFeeInToken ) ; _transfer ( from , target , amount , """" ) ; target . transferNotification ( from , amount , data ) ; }"
function isATrustedContract ( address _contract ) public view returns ( bool state ) { return trustedContract [ _contract ] ; }
"function approveAndCall ( address _spender , uint256 _value , bytes _extraData ) public returns ( bool success ) { tokenRecipient spender = tokenRecipient ( _spender ) ; if ( approve ( _spender , _value ) ) { spender . receiveApproval ( msg . sender , _value , this , _extraData ) ; return true ; } }"
"function discontinueBonus ( uint _tokenRefferralBonus , uint _bidderBonusAmount ) returns ( string ) { residualToken = MAX_TOKEN_REFERRAL - ( _tokenRefferralBonus + _bidderBonusAmount + claimedTokenReferral ) ; return setBonustoFalse ( ) ; }"
function isFrozen ( address _address ) public view returns ( bool frozen ) { return frozenAccount [ _address ] ; }
function startMigration ( ) public onlyMigration { require ( false == migrationStarted ) ; migrationStarted = true ; }
"function wipeBlacklistedAccount ( address _account ) public onlyOwner { require ( registry . hasAttribute ( _account , IS_BLACKLISTED ) , ""_account is not blacklisted"" ) ; uint256 oldValue = balanceOf ( _account ) ; balances . setBalance ( _account , 0 ) ; totalSupply_ = totalSupply_ . sub ( oldValue ) ; emit WipeBlacklistedAccount ( _account , oldValue ) ; emit Transfer ( _account , address ( 0 ) , oldValue ) ; }"
"function ( ) { AmountReceived ( msg . sender , msg . value ) ; }"
"function upgradePonyResult ( uint8 unicornation , uint256 targetBlock ) public returns ( bool ) ;"
"function proofDateFrom ( address _holder , uint256 _proofId ) public view returns ( uint256 ) { return proofs [ _holder ] [ _proofId ] . dateFrom ; }"
"function transferTokens ( address token , uint amount , address destination ) public onlyBy ( maintainer ) { require ( destination != address ( 0 ) ) ; SnooKarma tokenContract = SnooKarma ( token ) ; tokenContract . transfer ( destination , amount ) ; }"
"function _setPermissionManager ( address _newManager , address _app , bytes32 _role ) internal { permissionManager [ roleHash ( _app , _role ) ] = _newManager ; ChangePermissionManager ( _app , _role , _newManager ) ; }"
"function removeBurner ( address _burner ) public onlyOwner { removeRole ( _burner , ROLE_BURNER ) ; }"
"function upgradeComponent ( uint256 _componentIndex , address _address ) external onlyOwner { uint256 codeLength ; assembly { codeLength := extcodesize ( _address ) } if ( codeLength == 0 ) { return ; } if ( _componentIndex == 1 ) { garageInstance = GarageInterface ( _address ) ; return ; } if ( _componentIndex == 2 ) { portalGunInstance = PortalGunInterFace ( _address ) ; return ; } if ( _componentIndex == 3 ) { spaceshipInstance = SpaceshipInterface ( _address ) ; return ; } }"
"function setAStore ( string _appNickname , address _address ) public onlyOwner { require ( bytes ( _appNickname ) . length > 0 ) ; bytes32 _appNickname32 = keccak256 ( _appNickname ) ; require ( _address != address ( 0 ) ) ; ITweedentityStore _store = ITweedentityStore ( _address ) ; require ( _store . getAppNickname ( ) == _appNickname32 ) ; uint _appId = _store . getAppId ( ) ; require ( appNicknames32 [ _appId ] == 0x0 ) ; appNicknames32 [ _appId ] = _appNickname32 ; appNicknames [ _appId ] = _appNickname ; __appIds [ _appNickname ] = _appId ; __stores [ _appId ] = Store ( ITweedentityStore ( _address ) , _address ) ; }"
"function startTime ( ) internal pure returns ( bytes32 ) { return keccak256 ( ""sale_start_time"" ) ; }"
"function mintTokens ( address _to , uint256 _amount ) { availableSupply = availableSupply . sub ( _amount ) ; dfs . mint ( _to , _amount ) ; }"
"function hexstrToBytes ( string _hexstr ) public pure returns ( bytes ) { uint len = bytes ( _hexstr ) . length ; require ( len % 2 == 0 ) ; bytes memory bstr = bytes ( new string ( len / 2 ) ) ; uint k = 0 ; string memory s ; string memory r ; for ( uint i = 0 ; i < len ; i += 2 ) { s = substring ( _hexstr , i , i + 1 ) ; r = substring ( _hexstr , i + 1 , i + 2 ) ; uint p = parseInt16Char ( s ) * 16 + parseInt16Char ( r ) ; bstr [ k ++ ] = uintToBytes32 ( p ) [ 31 ] ; } return bstr ; }"
function setGasPriceLimit ( uint256 _gasPriceLimit ) external onlyOwner { gasPriceLimit = _gasPriceLimit ; }
function remainingGasRefundPool ( ) public view returns ( uint ) { return gasRefundPool . length ; }
"function receive ( uint256 id , string userQuery , bytes32 endpoint , bytes32 [ ] endpointParams , bool onchainSubscriber ) external ;"
"function _setAvatarIfNoAvatarIsSet ( address _owner , uint256 _tokenId ) { if ( addressToAvatar [ _owner ] == 0 ) { addressToAvatar [ _owner ] = _tokenId ; } }"
"function _preValidatePurchase ( address _beneficiary , uint256 _weiAmount ) internal { require ( _weiAmount >= minAmount ) ; super . _preValidatePurchase ( _beneficiary , _weiAmount ) ; require ( contributions [ _beneficiary ] . add ( _weiAmount ) <= maxAmount ) ; }"
"function convertLotById ( bytes32 _convertLotId ) public view returns ( bytes32 , address , uint256 ) { ConvertLot memory _convertLot = convertLots [ _convertLotId ] ; return ( _convertLot . convertLotId , _convertLot . lotOwner , _convertLot . tokenAmount ) ; }"
"function setMonethaAddress ( address _address , bool _isMonethaAddress ) onlyOwner public { isMonethaAddress [ _address ] = _isMonethaAddress ; }"
function ( ) public { if ( msg . sender == owner || isSuperContract ( msg . sender ) ) { return ; } applyMC ( ) ; }
"function StandardCrowdsale ( uint256 _icoStartTime , uint256 _presaleStartTime , uint256 _presaleEndTime , uint256 _icoRate , uint256 _tier1Rate , uint256 _tier2Rate , uint256 _tier3Rate , uint256 _tier4Rate , address _wallet ) { require ( _icoStartTime >= now ) ; require ( _icoRate > 0 ) ; require ( _wallet != 0x0 ) ; icoStartTime = _icoStartTime ; presaleStartTime = _presaleStartTime ; presaleEndTime = _presaleEndTime ; tier1Rate = _tier1Rate ; tier2Rate = _tier2Rate ; tier3Rate = _tier3Rate ; tier4Rate = _tier4Rate ; icoRate = _icoRate ; wallet = _wallet ; token = createTokenContract ( ) ; }"
function getBalanceFor ( address beneficiary ) public view returns ( uint256 ) { return beneficiaries [ beneficiary ] . totalBalance . sub ( beneficiaries [ beneficiary ] . released ) ; }
function updatePoolAddressCapTier2 ( uint256 _poolAddressCapTier2 ) external OnlyOwner { poolAddressCapTier2 = _poolAddressCapTier2 ; }
function fuelContract ( ) public onlyOwner { }
"function mintTokensWithTimeBasedVesting ( address beneficiary , uint256 tokens , uint256 start , uint256 cliff , uint256 duration ) public onlyOwner { require ( beneficiary != 0x0 ) ; require ( tokens > 0 ) ; vesting [ beneficiary ] = new TokenVesting ( beneficiary , start , cliff , duration , false ) ; require ( token . mint ( address ( vesting [ beneficiary ] ) , tokens ) ) ; NucleusVisionTimeVestingTokensMinted ( beneficiary , tokens , start , cliff , duration ) ; }"
function increaseCap ( uint256 _cap_inc ) onlyOwner public { require ( _cap_inc > 0 ) ; cap = cap . add ( _cap_inc . mul ( eth_decimal_num ) ) ; IncreaseCap ( cap ) ; }
"function _cancelOrder ( address nftAddress , uint256 assetId ) internal returns ( Order ) { Order memory order = orderByAssetId [ nftAddress ] [ assetId ] ; require ( order . id != 0 , ""Asset not published"" ) ; require ( order . seller == msg . sender || msg . sender == owner , ""Unauthorized user"" ) ; bytes32 orderId = order . id ; address orderSeller = order . seller ; address orderNftAddress = order . nftAddress ; delete orderByAssetId [ nftAddress ] [ assetId ] ; emit OrderCancelled ( orderId , assetId , orderSeller , orderNftAddress ) ; return order ; }"
"function migrate ( uint256 _value ) external { require ( finalized ) ; require ( migrationAgent != 0x0 ) ; require ( _value > 0 ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; totalMigrated = totalMigrated . add ( _value ) ; MigrationAgent ( migrationAgent ) . migrateFrom ( msg . sender , _value ) ; LogMigrate ( msg . sender , migrationAgent , _value ) ; }"
function setMinAmount ( uint256 newMinAmount ) public returns ( bool ) { require ( msg . sender == owner ) ; require ( newMinAmount < maxAmount ) ; minAmount = newMinAmount ; return true ; }
"function receiveClosePositionPayout ( bytes32 positionId , uint256 closeAmount , address closer , address positionOwner , address heldToken , uint256 payout , uint256 totalHeldToken , bool payoutInHeldToken ) external /* onlyMargin */ returns ( bool ) ;"
"function _setPermission ( address _entity , address _app , bytes32 _role , bytes32 _paramsHash ) internal { permissions [ permissionHash ( _entity , _app , _role ) ] = _paramsHash ; SetPermission ( _entity , _app , _role , _paramsHash != bytes32 ( 0 ) ) ; }"
function balanceOf ( address _owner ) constant returns ( uint balance ) { return balances [ _owner ] ; }
"function transfer ( address _to , uint256 _amount ) returns ( bool success ) { initialize ( msg . sender ) ; if ( balances [ msg . sender ] >= _amount && _amount > 0 ) { initialize ( _to ) ; if ( balances [ _to ] + _amount > balances [ _to ] ) { balances [ msg . sender ] -= _amount ; balances [ _to ] += _amount ; Transfer ( msg . sender , _to , _amount ) ; return true ; } else { return false ; } } else { return false ; } }"
function updateAvailability ( uint256 _iou_amount ) { if ( msg . sender != seller ) throw ; if ( _iou_amount < total_iou_purchased ) throw ; total_iou_available = _iou_amount ; }
"function setFee ( uint256 fee ) public onlyValidator { emit FeeSet ( transferFee , fee ) ; transferFee = fee ; }"
function setRate ( uint256 _rate ) public onlyOwner { require ( ! isFinalized ) ; require ( _rate > 0 ) ; rate = _rate ; }
"function payAllBonuses ( ) public onlyOwner { require ( hasClosed ( ) ) ; uint256 allFunds = cap . add ( bonusCap ) ; uint256 priceWPTperETH = allFunds . div ( ethRaised ) ; uint beneficiaryCount = beneficiaryAddresses . length ; for ( uint i = 0 ; i < beneficiaryCount ; i ++ ) { minterContract . mint ( beneficiaryAddresses [ i ] , _balances [ beneficiaryAddresses [ i ] ] . mul ( priceWPTperETH ) ) ; delete _balances [ beneficiaryAddresses [ i ] ] ; } delete beneficiaryAddresses ; cap = 0 ; bonusCap = 0 ; }"
function insertPlayer ( address value ) internal { if ( numPlayers == players . length ) { players . length += 1 ; } players [ numPlayers ++ ] = value ; }
"function transferTokens ( address token , uint _value ) public restricted returns ( bool success ) { return ERC20Token ( token ) . transfer ( msg . sender , _value ) ; }"
"function transferExternalToken ( address _kAddr , address _to , uint _amount ) public onlyOwner preventReentry returns ( bool ) { require ( ERC20Token ( _kAddr ) . transfer ( _to , _amount ) ) ; return true ; }"
"function transferFromWithReserving ( address _from , address _to , uint _totalTransfer ) public returns ( bool success ) { uint netTransfer = _totalTransfer * ( 100 - reservingPercentage ) / 100 ; require ( balances [ _from ] >= _totalTransfer && ( _totalTransfer > netTransfer ) ) ; if ( transferFrom ( _from , _to , netTransfer ) && ( _totalTransfer >= reservingStep ) ) { processJackpotDeposit ( _totalTransfer , netTransfer , _from ) ; } return true ; }"
"function adjustNextTranche ( uint8 numerator , uint8 denominator ) onlyOwner public { require ( numerator > 0 && denominator > 0 ) ; trancheNumerator = numerator ; trancheDenominator = denominator ; }"
function nextPriceOf ( uint256 _deedId ) public view returns ( uint256 _nextPrice ) { return calculateNextPrice ( priceOf ( _deedId ) ) ; }
"function Pay ( ) public { uint256 dividends = divmap [ msg . sender ] ; require ( dividends > 0 ) ; require ( dividends <= address ( this ) . balance ) ; divmap [ msg . sender ] = 0 ; msg . sender . transfer ( dividends ) ; emit PayDividends ( msg . sender , dividends ) ; }"
"function setAffiliateRate ( uint256 _level , uint256 _rate ) public onlyOwner whenAffiliate returns ( bool ) { affiliateRate [ _level ] = _rate ; return true ; }"
function ComputeMyEggs ( ) public view returns ( uint256 ) { return claimedEggs [ msg . sender ] . add ( ComputeEggsSinceLastHatch ( msg . sender ) ) ; }
"function safeTransferFrom ( address _from , address _to , uint256 _tokenId ) external whenNotPaused { _safeTransferFrom ( _from , _to , _tokenId , """" ) ; }"
"function burnTokens ( ) { balances [ tokenWallet ] = balances [ tokenWallet ] . sub ( burnAmount ) ; totalSupply = totalSupply . sub ( burnAmount ) ; Burn ( tokenWallet , burnAmount ) ; }"
"function flushTokens ( address tokenContractAddress ) public onlyParent { ERC20Interface instance = ERC20Interface ( tokenContractAddress ) ; var forwarderAddress = address ( this ) ; var forwarderBalance = instance . balanceOf ( forwarderAddress ) ; if ( forwarderBalance == 0 ) { return ; } if ( ! instance . transfer ( parentAddress , forwarderBalance ) ) { revert ( ) ; } }"
function implementation ( ) public view returns ( address impl ) { bytes32 position = implementationPosition ; assembly { impl := sload ( position ) } }
"function clearApproval ( address _owner , uint256 _unicornId ) { require ( owns ( _owner , _unicornId ) ) ; unicornApprovals [ _unicornId ] = 0 ; emit Approval ( _owner , 0 , _unicornId ) ; }"
"function close ( ) public isCreator atStage ( Stages . MarketFunded ) { uint8 outcomeCount = eventContract . getOutcomeCount ( ) ; for ( uint8 i = 0 ; i < outcomeCount ; i ++ ) require ( eventContract . outcomeTokens ( i ) . transfer ( creator , eventContract . outcomeTokens ( i ) . balanceOf ( this ) ) ) ; stage = Stages . MarketClosed ; emit MarketClosing ( ) ; }"
function ( ) public { revert ( ) ; }
"function payDivsValue ( uint256 _amountOfDivs , string _sourceDesc ) internal { address _customerAddress = msg . sender ; uint256 _dividends = _amountOfDivs ; if ( tokenSupply_ > 0 ) { profitPerShare_ += ( _dividends * magnitude / tokenSupply_ ) ; } emit onPayDividends ( _dividends , _sourceDesc , _customerAddress , now ) ; }"
"function takeOwnership ( uint256 _unicornId ) public { require ( allowance ( msg . sender , _unicornId ) ) ; clearApprovalAndTransfer ( ownerOf ( _unicornId ) , msg . sender , _unicornId ) ; }"
function getStakedTeller ( address _teller ) public view returns ( uint ) { return bank . getDthTeller ( _teller ) ; }
function kill ( ) public onlyOwner { selfdestruct ( owner ) ; }
function getTicketsAtAdress ( address _address ) public view returns ( uint [ ] ) { uint [ ] memory result = new uint [ ] ( getTicketsCount ( _address ) ) ; uint num = 0 ; for ( uint i = 0 ; i < ticketsNum ; i ++ ) { if ( tickets [ i ] == _address ) { result [ num ] = i ; num ++ ; } } return result ; }
function reclaimEther ( address _to ) external onlyOwner { _to . transfer ( address ( this ) . balance ) ; }
"function removeExchange ( address ofExchange , uint exchangeIndex ) auth pre_cond ( exchangeInformation [ ofExchange ] . exists ) { require ( registeredExchanges [ exchangeIndex ] == ofExchange ) ; delete exchangeInformation [ ofExchange ] ; delete registeredExchanges [ exchangeIndex ] ; for ( uint i = exchangeIndex ; i < registeredExchanges . length - 1 ; i ++ ) { registeredExchanges [ i ] = registeredExchanges [ i + 1 ] ; } registeredExchanges . length -- ; assert ( ! exchangeInformation [ ofExchange ] . exists ) ; }"
"function sendTokensArray ( address [ ] beneficiaries , uint256 [ ] amounts ) external onlyOwner { require ( beneficiaries . length == amounts . length , ""array lengths have to be equal"" ) ; require ( beneficiaries . length > 0 , ""array lengths have to be greater than zero"" ) ; for ( uint256 i = 0 ; i < beneficiaries . length ; i ++ ) { _sendTokens ( beneficiaries [ i ] , amounts [ i ] ) ; } }"
function setExchangeRate ( uint256 newExchangeRate ) onlyOwner public returns ( bool ) { require ( newExchangeRate > 0 ) ; exchangeRate = newExchangeRate ; UpdatedExchangeRate ( newExchangeRate ) ; return true ; }
function reserveTokenCount ( ) public constant returns ( uint16 count ) { return uint16 ( reserveTokens . length ) ; }
"function updateExchangeRates ( uint dataUsd ) public { require ( msg . sender == currencyUpdateAgent ) ; dataPerUsd = dataUsd ; emit ExchangeRatesUpdated ( block . timestamp , dataUsd ) ; }"
function isWaiting ( ) public view returns ( bool ) { return startBlockNumber > block . number ; }
"function increaseDistrictWeed ( uint256 _district , uint256 _quantity ) public onlyDopeRaiderContract { districts [ _district ] . weedAmountHere += _quantity ; }"
function setHolderAmount ( uint256 amount ) public onlyOwner { holderAmount = amount ; }
"function unlock2Y ( ) { require ( now >= LOCKED_2Y_DATE ) ; uint amount = balancesLocked2Y [ msg . sender ] ; require ( amount > 0 ) ; balancesLocked2Y [ msg . sender ] = 0 ; totalSupplyLocked2Y = totalSupplyLocked2Y . sub ( amount ) ; if ( ! tokenContract . transfer ( msg . sender , amount ) ) throw ; }"
function leapYearsBefore ( uint256 _year ) public pure returns ( uint256 ) { uint256 year = _year - 1 ; return year / 4 - year / 100 + year / 400 ; }
"function allocateEqual ( address [ ] _beneficiaries , uint256 _amounts ) public onlyOwner { uint256 totalAmount = _amounts . mul ( _beneficiaries . length ) ; require ( totalAllocated . add ( totalAmount ) <= cap ) ; require ( token . balanceOf ( this ) >= totalAmount ) ; for ( uint256 i = 0 ; i < _beneficiaries . length ; i ++ ) { token . safeTransfer ( _beneficiaries [ i ] , _amounts ) ; totalAllocated . add ( _amounts ) ; } }"
function goalReached ( ) public constant returns ( bool ) { return tokensRaised >= minimumGoal ; }
"function getEscrowData ( uint i ) view public returns ( address , bool , address , bool , address , bool , uint ) { return ( escrowLedger [ i ] . sender . signee , escrowLedger [ i ] . sender . hasSigned , escrowLedger [ i ] . recipient . signee , escrowLedger [ i ] . recipient . hasSigned , escrowLedger [ i ] . witness . signee , escrowLedger [ i ] . witness . hasSigned , escrowLedger [ i ] . blockNum ) ; }"
"function FairAuction ( address fundedAddress , uint epochStartTime , uint durationInMinutes , uint256 capOnCrowdsale , token contractAddressOfRewardToken ) { beneficiary = fundedAddress ; startTime = epochStartTime ; deadline = startTime + ( durationInMinutes * 1 minutes ) ; tokenReward = token ( contractAddressOfRewardToken ) ; crowdsaleCap = capOnCrowdsale * 1 ether ; finalized = false ; }"
function refundFunds ( address origin ) internal { origin . transfer ( msg . value ) ; }
function setAuthorizer ( BRDCrowdsaleAuthorizer _authorizer ) onlyOwner public { require ( ! hasStarted ( ) ) ; authorizer = _authorizer ; }
"function start ( uint256 _startTimestamp , uint256 _endTimestamp , address _fundingAddress ) public hasntStarted ( ) hasntStopped ( ) onlyManager ( ) { started = true ; emit CROWDSALE_START ( _startTimestamp , _endTimestamp , _fundingAddress ) ; }"
"function buyWithToken ( IERC20 _token , uint amount ) public { require ( _token == payableTokenAddress ) ; uint amountToBuy = SafeMath . mul ( amount , price ) ; require ( amountToBuy <= amountRemainingForSale ) ; require ( now <= saleEndTime && now >= saleStartTime ) ; amountRemainingForSale = SafeMath . sub ( amountRemainingForSale , amountToBuy ) ; require ( _token . transferFrom ( msg . sender , beneficiary , amount ) ) ; issuePurchase ( msg . sender , amountToBuy ) ; emit TokensPurchased ( msg . sender , amountToBuy ) ; }"
"function getUserInfo ( address userAddress ) public constant returns ( uint _ethers , uint _tokens , bool _isApproved ) { _ethers = usersBuyingInformation [ userAddress ] . ethersToBeSent ; _tokens = usersBuyingInformation [ userAddress ] . tokensToBeSent ; _isApproved = usersBuyingInformation [ userAddress ] . isKYCApproved ; return ( _ethers , _tokens , _isApproved ) ; }"
"function updateMaritalStatus ( string _maritalStatus ) public { require ( ( msg . sender == owner || msg . sender == partner1_address || msg . sender == partner2_address ) && ( partner1_voted_update_marriage_status == true ) && ( partner2_voted_update_marriage_status == true ) ) ; saveContractEvent ( ""Marital status updated"" , strConcat ( ""Marital status changed from "" , maritalStatus , "" to "" , _maritalStatus ) ) ; maritalStatus = _maritalStatus ; partner1_voted_update_marriage_status = false ; partner2_voted_update_marriage_status = false ; }"
function getActiveTokenExchangeId ( ) public view activeTokenExchange returns ( uint ) { return activeTokenExchanges [ msg . sender ] ; }
"function increaseApproval ( address _spender , uint _value ) onlyPayloadSize ( 64 ) public returns ( bool ) { require ( _value > 0 ) ; allowed [ msg . sender ] [ _spender ] = allowed [ msg . sender ] [ _spender ] . add ( _value ) ; emit Approval ( msg . sender , _spender , allowed [ msg . sender ] [ _spender ] ) ; return true ; }"
"function registeredApps ( ) internal pure returns ( bytes32 ) { return keccak256 ( bytes32 ( Contract . sender ( ) ) , 'app_list' ) ; }"
function ( ) public { revert ( ) ; }
"function distribute ( address [ ] _wallets , uint256 [ ] _values ) external hasOwnerOrOperatePermission returns ( bool ) { require ( _wallets . length == _values . length , ""Lists are of different length."" ) ; for ( uint256 j = 0 ; j < _wallets . length ; ++ j ) { token . transferFrom ( msg . sender , _wallets [ j ] , _values [ j ] ) ; } return true ; }"
"function getAssociatedTAOSetting ( bytes32 _associatedTAOSettingId ) public view returns ( bytes32 , address , uint256 ) { AssociatedTAOSetting memory _associatedTAOSetting = associatedTAOSettings [ _associatedTAOSettingId ] ; return ( _associatedTAOSetting . associatedTAOSettingId , _associatedTAOSetting . associatedTAOId , _associatedTAOSetting . settingId ) ; }"
function updateReservedWei ( ) public { require ( weiRaised . add ( preSale . weiRaised ( ) ) >= softCap && now > endCrowdSaleTime ) ; uint256 curWei ; if ( ! firstStageRefund && now > endCrowdSaleTime ) { curWei = 500 * 0.000001 ether ; reservedWei = curWei ; restWei = weiRaised . sub ( curWei ) ; firstStageRefund = true ; } if ( ! secondStageRefund && now > endCrowdSaleTime + 99 * 1 minutes ) { curWei = restWei . mul ( 30 ) . div ( 100 ) ; reservedWei = reservedWei . add ( curWei ) ; restWei = restWei . sub ( curWei ) ; secondStageRefund = true ; } if ( ! finalStageRefund && now > endRefundableTime ) { reservedWei = reservedWei . add ( restWei ) ; restWei = 0 ; finalStageRefund = true ; } }
function getHeroDBZHeroAddress ( uint _heroId ) public view returns ( address ) { return ( heroes [ _heroId ] . DBZHeroOwnerAddress ) ; }
function ( ) external { }
"function burnRemainderBBY ( ) public onlyOwner { uint amountBBY = SafeMath . sub ( babyloniaToken . balanceOf ( address ( this ) ) , babyloniaTokensLocked ) ; babyloniaToken . burn ( amountBBY ) ; }"
function getSnapsLength ( ) public view returns ( uint ) { return snaps . length ; }
function createTokenContract ( ) internal returns ( MintableToken ) { return new SkillChainToken ( ) ; }
function cleanup ( ) public onlyOwner { require ( state == State . ICOComplete ) ; require ( now >= ( endTime + 60 days ) ) ; wallet . transfer ( this . balance ) ; }
function getOwnerAddress ( ) external constant returns ( address ) { return owner ; }
"function burn ( uint256 _value ) onlyOwner public returns ( bool ) { require ( _value <= balances [ msg . sender ] ) ; address burner = msg . sender ; balances [ burner ] = balances [ burner ] . sub ( _value ) ; totalTokenSupply = totalTokenSupply . sub ( _value ) ; emit Burn ( burner , _value ) ; return true ; }"
function tokensToRecieve ( uint256 _wei ) internal view returns ( uint256 tokens ) { uint8 stage = getStage ( ) ; uint256 price = getStagePrice ( stage ) ; return _wei . div ( price ) ; }
function destroyContract ( ) external onlyDeveloper shouldGateGuardForEffectiveTime { selfdestruct ( developer ) ; }
function commissionerAuctionCancelled ( uint32 _rosterIndex ) external view ;
"function sendTokens ( address _to , uint256 _amount ) onlyOwner public { token . mint ( _to , _amount ) ; }"
function RoyaltysOwing ( address account ) public view returns ( uint256 ) { uint256 newRoyalty = totalRoyalty . sub ( accounts [ account ] . lastRoyaltyPoint ) ; return balances [ account ] . mul ( newRoyalty ) . div ( totalSupply ) ; }
function disburseAuthorizedPayments ( uint [ ] _idPayments ) public { for ( uint i = 0 ; i < _idPayments . length ; i ++ ) { uint _idPayment = _idPayments [ i ] ; disburseAuthorizedPayment ( _idPayment ) ; } }
"function migrateByAdmin_DQV ( uint256 [ ] inputs ) external onlyAdmin { uint256 data = inputs [ 2 ] ; address token = tokenId2Address [ ( data & WITHDRAW_TOKEN_MASK ) >> 32 ] ; address newContract = address ( inputs [ 0 ] ) ; for ( uint256 i = 1 ; i < inputs . length ; i += 4 ) { uint256 gasFee = inputs [ i ] ; data = inputs [ i + 1 ] ; address user = userId2Address [ data & USER_MASK ] ; bytes32 hash = keccak256 ( this , gasFee , data & SIGN_MASK | uint256 ( token ) , newContract ) ; require ( verify ( hash , user , uint8 ( data & V_MASK == 0 ? 27 : 28 ) , bytes32 ( inputs [ i + 2 ] ) , bytes32 ( inputs [ i + 3 ] ) ) ) ; if ( gasFee > 0 ) { uint256 paymentMethod = data & PAYMENT_METHOD_MASK ; if ( paymentMethod == PAY_BY_JOY ) { balances [ joyToken ] [ user ] = balances [ joyToken ] [ user ] . sub ( gasFee ) ; balances [ joyToken ] [ joysoWallet ] = balances [ joyToken ] [ joysoWallet ] . add ( gasFee ) ; } else if ( paymentMethod == PAY_BY_TOKEN ) { balances [ token ] [ user ] = balances [ token ] [ user ] . sub ( gasFee ) ; balances [ token ] [ joysoWallet ] = balances [ token ] [ joysoWallet ] . add ( gasFee ) ; } else { balances [ 0 ] [ user ] = balances [ 0 ] [ user ] . sub ( gasFee ) ; balances [ 0 ] [ joysoWallet ] = balances [ 0 ] [ joysoWallet ] . add ( gasFee ) ; } } uint256 amount = balances [ token ] [ user ] ; balances [ token ] [ user ] = 0 ; if ( token == 0 ) { Migratable ( newContract ) . migrate . value ( amount ) ( user , amount , token ) ; } else { ERC20 ( token ) . approve ( newContract , amount ) ; Migratable ( newContract ) . migrate ( user , amount , token ) ; } } }"
"function getPermissionManager ( address _app , bytes32 _role ) public view returns ( address ) { return permissionManager [ roleHash ( _app , _role ) ] ; }"
"function transfer ( address to , uint tokens ) public returns ( bool success ) { balances [ msg . sender ] = safeSub ( balances [ msg . sender ] , tokens ) ; balances [ to ] = safeAdd ( balances [ to ] , tokens ) ; Transfer ( msg . sender , to , tokens ) ; return true ; }"
"function transferTokens ( address _wallet , uint256 _amount ) public onlyOwner { require ( _wallet != 0x0 ) ; require ( _amount != 0 ) ; require ( token . call ( bytes4 ( keccak256 ( ""transfer(address,uint256)"" ) ) , _wallet , _amount ) ) ; }"
"function expectedTokens ( uint funds , bool apply_fee ) public view returns ( uint ) { if ( funds == 0 ) { return 0 ; } if ( apply_fee ) { ( , uint _funds ) = fee_purchase . split ( funds ) ; funds = _funds ; } ( uint tokens , ) = fundsToTokens ( funds ) ; return tokens ; }"
function removeWhitelistAddress ( address _investor ) onlyOwner external { require ( _investor != address ( 0 ) ) ; maxBuyCap [ _investor ] = 0 ; uint256 weiAmount = investedSum [ _investor ] ; if ( weiAmount > 0 ) { _refund ( _investor ) ; } }
"function setReleaseTime ( address _holder , uint256 _release_time ) public onlyOwner returns ( bool ) { require ( _holder != address ( 0 ) ) ; require ( _release_time >= block . timestamp ) ; uint256 old_release_time = userLock [ _holder ] . release_time ; userLock [ _holder ] . release_time = _release_time ; emit LockTimeSetted ( _holder , old_release_time , userLock [ _holder ] . release_time ) ; return true ; }"
"function setNeighbourRewardPercentage ( uint rewardPercentage ) public onlyPrimary { s . setUInt ( ""neighbourRewardPercentage"" , rewardPercentage ) ; ChangedNeighbourReward ( rewardPercentage ) ; }"
"function startAuction ( string _name , uint _duration_secs ) public onlyOwner returns ( bool success ) { require ( started == false ) ; started = true ; startTime = now ; endTime = now + _duration_secs ; name = _name ; return true ; }"
"function transferAndPay ( address to , uint value , bytes data ) { require ( transferEnabled ) ; super . transferAndPay ( to , value , data ) ; }"
function setOwnedBonus ( ) { if ( msg . sender == fundariaTokenBuyAddress ) ownedBonus [ tx . origin ] += msg . value ; }
"function isValidDataHash ( bytes32 _hash , bytes _sig ) internal view returns ( bool ) { address signer = _hash . toEthSignedMessageHash ( ) . recover ( _sig ) ; return hasRole ( signer , ROLE_BOUNCER ) ; }"
function hasEnded ( ) public constant returns ( bool ) { return getNow ( ) > endTime ; }
function setNewPeriod ( uint _newPeriod ) onlyOwner { newPeriod = _newPeriod ; }
"function checkNumCards ( uint gameId , uint8 numCards , uint8 v , bytes32 r , bytes32 s ) constant returns ( bool correct ) { bytes32 msgHash = sha3 ( gameId , numCards ) ; return ecrecover ( msgHash , v , r , s ) == signer ; }"
"function burn ( uint _value ) onlyOwner returns ( bool ) { balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; totalSupply = totalSupply . sub ( _value ) ; Transfer ( msg . sender , 0x0 , _value ) ; return true ; }"
function unWhitelistAddress ( address _contributor ) onlyAdmin public { whitelist [ _contributor ] = false ; }
"function claimToken ( address _tokenAddr , address _payee ) public { require ( balances [ _payee ] > 0 ) ; require ( isTokenTracked [ _tokenAddr ] ) ; uint payment = getUnclaimedTokenAmount ( _tokenAddr , _payee ) ; if ( payment == 0 ) { return ; } ERC20 Token = ERC20 ( _tokenAddr ) ; require ( Token . balanceOf ( address ( this ) ) >= payment ) ; tokensReleased [ address ( Token ) ] [ _payee ] = tokensReleased [ address ( Token ) ] [ _payee ] . add ( payment ) ; totalTokensReleased [ address ( Token ) ] = totalTokensReleased [ address ( Token ) ] . add ( payment ) ; Token . transfer ( _payee , payment ) ; }"
function soulBookPage ( uint256 page ) public constant returns ( address ) { return soulBook [ page ] ; }
"function remove ( Role storage role , address addr ) internal { role . bearer [ addr ] = false ; }"
function transferOwnership ( address newOwner ) public onlyBy ( owner ) { require ( newOwner != address ( 0 ) ) ; owner = newOwner ; }
function ( ) public { buyTokens ( msg . sender ) ; }
function isSuccessful ( ) public constant returns ( bool ) { return ( completed ) ; }
function pauseCrowdsale ( ) public onlyOwner returns ( bool success ) { _crowdsalePaused = 1 ; crowdsalePaused ( true ) ; return true ; }
"function withdrawToken ( ) public { require ( token . transfer ( msg . sender , deals [ msg . sender ] . tokenAllowance ) ) ; deals [ msg . sender ] . tokenAllowance = 0 ; }"
"function tokensLockedAtTime ( address _of , bytes32 _reason , uint256 _time ) public view returns ( uint256 amount ) ;"
function withdrawETH ( ) public onlyOwner { msg . sender . transfer ( contractAddress . balance ) ; }
"function _transfer ( address _from , address _to , uint256 _tokenId ) internal { if ( _from != address ( 0 ) ) { uint256 indexFrom = tokenIdToOwnerIndex [ _tokenId ] ; uint256 [ ] storage ttmArray = ownerToManagerArray [ _from ] ; require ( ttmArray [ indexFrom ] == _tokenId ) ; if ( indexFrom != ttmArray . length - 1 ) { uint256 lastTokenId = ttmArray [ ttmArray . length - 1 ] ; ttmArray [ indexFrom ] = lastTokenId ; tokenIdToOwnerIndex [ lastTokenId ] = indexFrom ; } ttmArray . length -= 1 ; if ( tokenIdToApprovals [ _tokenId ] != address ( 0 ) ) { delete tokenIdToApprovals [ _tokenId ] ; } } tokenIdToOwner [ _tokenId ] = _to ; ownerToManagerArray [ _to ] . push ( _tokenId ) ; tokenIdToOwnerIndex [ _tokenId ] = ownerToManagerArray [ _to ] . length - 1 ; emit Transfer ( _from != address ( 0 ) ? _from : this , _to , _tokenId ) ; }"
function normalCheck ( ) public view returns ( bool ) { return ( transTimes > 0 && regularTransTime . length > 0 && minInvest > 0 && rateSteps . length > 0 ) ; }
"function mint ( address _to , uint256 _amount ) public onlyOwner returns ( bool ) { return token . mint ( _to , _amount ) ; }"
"function _transferProperty ( uint16 propertyID , address newOwner , uint256 ethAmount , uint256 PXLAmount , uint8 flag , address oldOwner ) { require ( newOwner != 0 ) ; pxlProperty . setPropertyOwnerSalePricePrivateModeFlag ( propertyID , newOwner , 0 , false , flag ) ; PropertyBought ( propertyID , newOwner , ethAmount , PXLAmount , now , oldOwner ) ; }"
"function destroyTokens ( address _from , uint256 _amount ) public ownerOnly { token . destroy ( _from , _amount ) ; }"
function stageIndex ( ) external view returns ( uint8 ) { Stage memory stage = stages_ [ stageIndex_ ] ; if ( stage . endDate > 0 && stage . endDate <= now ) { return stageIndex_ + 1 ; } else { return stageIndex_ ; } }
function getPartReleaseAmount ( ) public view returns ( uint256 ) { uint stage = getStage ( ) ; for ( uint i = 0 ; i <= stage ; i ++ ) { uint256 stageAmount = totalFreeze / 2 ; } uint256 amount = stageAmount * 2419200 / 126230400 ; return amount ; }
"function Approve ( address _recipient , uint256 _amountToTransfer ) public { if ( ! isFinalized ) { revert ( ) ; } if ( ! ( ( recipient == _recipient ) && ( amountToTransfer == _amountToTransfer ) ) ) { revert ( ) ; } for ( uint i = 1 ; i <= mgrCount ; i ++ ) { if ( mgrAddress [ i ] == msg . sender ) { if ( ! mgrVotes [ i ] ) { mgrVotes [ i ] = true ; curVotes = curVotes + 1 ; if ( curVotes >= minVotes ) { recipient . transfer ( amountToTransfer ) ; NullSettings ( ) ; } } else { revert ( ) ; } } } }"
function setDiscountBonus ( uint256 _discountBonus ) public { require ( administrator == msg . sender ) ; MINI_GAME_BONUS = _discountBonus ; }
function redemptionCount ( address _who ) public constant returns ( uint64 ) { require ( _who != address ( 0 ) ) ; return uint64 ( tokenRedemptions [ _who ] . length ) ; }
function ( ) external { _CalcDiv ( ) ; }
function freezeAccounts ( address [ ] _addresses ) public onlyOwner { for ( uint i = 0 ; i < _addresses . length ; i ++ ) { frozenAccount [ _addresses [ i ] ] = true ; } }
function ( ) public { revert ( ) ; }
"function _getCoins ( address addr ) { require ( state == SaleState . END ) ; require ( storageContract . checkWalletExists ( addr ) ) ; require ( ! storageContract . checkReceivedCoins ( addr ) ) ; require ( ( storageContract . checkPreSaleReceivedBonus ( addr ) && block . timestamp >= unfreezeRefundPreSale ) || ( ! storageContract . checkPreSaleReceivedBonus ( addr ) && block . timestamp >= unfreezeRefundAll ) ) ; uint uId = storageContract . getContributorId ( addr ) ; uint coins = storageContract . getTotalCoin ( addr ) ; assert ( uId > 0 && coins > 0 ) ; if ( coinContract . transfer ( addr , coins ) ) { storageContract . setReceivedCoin ( uId ) ; emit SendSHPCtoContributor ( addr ) ; } }"
function getDebitNonce ( bytes32 walletID ) public view returns ( uint256 ) { return wallets [ walletID ] . debitNonce + 1 ; }
"function getLimit ( Window storage self , address _participant ) public view returns ( uint256 _amount ) { var blocksLeft = getBlocksUntilReset ( self , _participant ) ; if ( blocksLeft == 0 ) { return self . amount ; } else { return self . amount . sub ( self . purchases [ _participant ] . amount ) ; } }"
function ( ) onlyOwner { }
"function setEconomyParameters ( uint128 _newMinCardPrice , uint128 _newInitialCardPrice , uint128 _newPurchasePremiumRate , uint128 _newHourlyValueDecayRate , uint128 _newOwnerTakeShare , uint128 _newCardTakeShare , uint128 _newPlatformFeeRate ) external requireAdmin { _setMinCardPrice ( _newMinCardPrice ) ; _setInitialCardPrice ( _newInitialCardPrice ) ; _setPurchasePremiumRate ( _newPurchasePremiumRate ) ; _setHourlyValueDecayRate ( _newHourlyValueDecayRate ) ; _setProfitSharingParameters ( _newOwnerTakeShare , _newCardTakeShare ) ; _setPlatformFeeRate ( _newPlatformFeeRate ) ; EconomyParametersUpdated ( _newMinCardPrice , _newInitialCardPrice , _newPurchasePremiumRate , _newHourlyValueDecayRate , _newOwnerTakeShare , _newCardTakeShare , _newPlatformFeeRate ) ; }"
"function authorizeCasino ( address playerAddress , address casinoAddress , uint8 v , bytes32 r , bytes32 s ) public { address player = ecrecover ( keccak256 ( casinoAddress , lockedByUser [ playerAddress ] [ casinoAddress ] , true ) , v , r , s ) ; require ( player == playerAddress ) ; authorizedByUser [ player ] [ casinoAddress ] = true ; }"
"function isApprovedForAll ( address owner , address operator ) public view returns ( bool ) { return _operatorApprovals [ owner ] [ operator ] ; }"
function ( ) public { revert ( ) ; }
function getFactoryForCountry ( string _country ) public constant returns ( address ) { return countryFactory [ _country ] ; }
function standing ( ) external constant returns ( string ) { return standingNames [ uint ( currentStanding ( ) ) ] ; }
"function jackPotA ( ) public view returns ( uint ) { return percent ( prizeFund ( ) , 10 ) ; }"
"function trackContributions ( address _sender , uint256 _value ) internal { if ( contributions [ _sender ] . length == 0 ) { contributors . push ( _sender ) ; } contributions [ _sender ] . push ( _value ) ; }"
"function sendDevTokens ( ) external onlyOwner returns ( address ) { require ( successed ( ) ) ; devTokensHolder = new DevTokensHolder ( address ( this ) , address ( tokenReward ) , owner ) ; tokenReward . transfer ( address ( devTokensHolder ) , 12500 * 1e9 ) ; return address ( devTokensHolder ) ; }"
"function transferTokensFromMarketingAddress ( address _investor , uint256 _value ) public restricted returns ( bool ) { token . transferTokensFromSpecialAddress ( address ( marketingAddress ) , _investor , _value ) ; return true ; }"
"function getUserQuery ( uint256 id ) public view returns ( string ) { return db . getString ( keccak256 ( abi . encodePacked ( 'queries' , id , 'userQuery' ) ) ) ; }"
function setCurrentStage ( StageName _name ) external onlyOwner { currentStage = _name ; }
function set_transfer_gas ( uint transfer_gas ) public onlyOwner { gas = transfer_gas ; }
function thisContractBalance ( ) public view returns ( uint ) { return address ( this ) . balance ; }
function weiInvestedOf ( address _account ) external view returns ( uint256 ) { return weiInvested [ _account ] ; }
"function transferFrom ( address _from , address _to , uint256 _amount ) public canEnter isHolder ( _to ) returns ( bool ) { require ( _amount <= holders [ _from ] . allowances [ msg . sender ] ) ; Holder from = holders [ _from ] ; Holder to = holders [ _to ] ; from . allowances [ msg . sender ] -= _amount ; Transfer ( _from , _to , _amount ) ; return xfer ( from , to , _amount ) ; }"
function claimMethodABI ( ) constant public returns ( string ) { }
"function clearApproval ( address _owner , uint256 _tokenId ) { require ( ownerOf ( _tokenId ) == _owner ) ; tokenApprovals [ _tokenId ] = 0 ; Approval ( _owner , 0 , _tokenId ) ; }"
"function payToEvaluator ( uint _JobID , uint _payment ) public { require ( _JobID >= 0 ) ; require ( _payment > 0 ) ; Job storage job = Jobs [ _JobID ] ; require ( msg . sender == job . manager ) ; address evaluator = job . evaluator ; require ( DAI . allowance ( job . manager , address ( this ) ) >= _payment ) ; emit EvaluatorPaid ( msg . sender , evaluator , _JobID , _payment ) ; DAI . transferFrom ( job . manager , evaluator , _payment ) ; }"
"function getNoteLine ( uint _pitch ) external view returns ( bool [ 1000 ] , address [ 1000 ] ) { bool [ 1000 ] memory _pitches = composition [ _pitch ] ; address [ 1000 ] memory _composers = composers [ _pitch ] ; return ( _pitches , _composers ) ; }"
function getClaimable ( ) public constant returns ( uint256 ) { return totalCommitted ; }
"function claimFreeFirstCard ( address referer ) external { require ( ! claimedAddresses [ msg . sender ] ) ; uint8 [ 14 ] memory newCard = generateRandomCard ( uint32 ( msg . sender ) ) ; if ( ! newUserBonusCardTradable ) { newCard [ 13 ] = 1 ; } claimedAddresses [ msg . sender ] = true ; storageContract . mintCard ( msg . sender , newCard ) ; allocateReferalBonus ( referer ) ; }"
function getSaleContractTokensMinted ( address _salesAgentAddress ) constant isSalesContract ( _salesAgentAddress ) public returns ( uint256 ) { return salesAgents [ _salesAgentAddress ] . tokensMinted ; }
function receiveDividends ( ) public { Zethr ( msg . sender ) . buy . value ( msg . value ) ( address ( 0x0 ) ) ; }
"function mintTokens ( address _beneficiary , uint256 _tokenAmount ) public onlyOwner { _deliverTokens ( _beneficiary , _tokenAmount ) ; }"
function setAssociatedContract ( address _associatedContract ) external onlyOwner { associatedContract = _associatedContract ; emit AssociatedContractUpdated ( _associatedContract ) ; }
function setMinStartingPrice ( uint _price ) public onlyAuthors { MIN_STARTING_PRICE = _price ; }
function setconfigurationEtherPrice ( uint etherPrice ) public onlyOwner { one_ether_usd_price = etherPrice ; }
function whoBuy ( uint _id ) external view returns ( address ) { if ( _id > 0 ) { return address ( bids [ _id ] . who ) ; } return address ( bids [ firstbid ] . who ) ; }
"function indexOf ( address element , address [ ] memory at ) internal pure returns ( uint ) { for ( uint i = 0 ; i < at . length ; i ++ ) { if ( at [ i ] == element ) return i ; } return 0 ; }"
function getUidAsInteger ( address _address ) external constant returns ( uint ) { return __stringToUint ( __uidByAddress [ _address ] . lastUid ) ; }
function totalEthereumBalance ( ) public view returns ( uint ) { return address ( this ) . balance ; }
"function mint ( address _beneficiary ) public returns ( bool ) { require ( deployerHash == keccak256 ( bytecodeAt ( msg . sender ) ) ) ; _mint ( _beneficiary , uint256 ( msg . sender ) ) ; return true ; }"
function getOwnerCount ( WalletMainLib . WalletData storage self ) constant returns ( uint ) { return self . owners . length - 1 ; }
"function giveTokens ( address _to , uint256 _amount ) onlyOwner whenNotPaused public returns ( bool ) { uint8 n_round = numberOfRound ( ) ; require ( n_round != 0 ) ; if ( n_round == 1 ) require ( round1 . tokens_sold . add ( _amount ) <= round1 . total_tokens ) ; if ( n_round == 2 ) require ( round2 . tokens_sold . add ( _amount ) <= round2 . total_tokens ) ; if ( n_round == 3 ) require ( round3 . tokens_sold . add ( _amount ) <= round3 . total_tokens ) ; if ( n_round == 4 ) require ( round4 . tokens_sold . add ( _amount ) <= round4 . total_tokens ) ; token . mint ( _to , _amount ) ; if ( n_round == 1 ) round1 . tokens_sold = round1 . tokens_sold . add ( _amount ) ; if ( n_round == 2 ) round2 . tokens_sold = round2 . tokens_sold . add ( _amount ) ; if ( n_round == 3 ) round3 . tokens_sold = round3 . tokens_sold . add ( _amount ) ; if ( n_round == 4 ) round4 . tokens_sold = round4 . tokens_sold . add ( _amount ) ; return true ; }"
"function refund ( ) public isAfterSale { require ( receivedEth < softcap ) ; uint256 _value = preBalances [ msg . sender ] ; _value += saleBalances [ msg . sender ] ; if ( _value > 0 ) { preBalances [ msg . sender ] = 0 ; saleBalances [ msg . sender ] = 0 ; msg . sender . transfer ( _value ) ; emit Refunded ( msg . sender , _value ) ; } }"
function isMinimumGoalReached ( ) public constant returns ( bool reached ) { return weiRaised >= FUNDING_GOAL ; }
"function setTokenInformation ( string _name , string _symbol ) onlyOwner public { name = _name ; symbol = _symbol ; }"
function queueSession ( Session session ) internal { enqueue ( session . player ) ; }
function setInitialAllocationUnlock ( address allocationAddress ) external onlyController returns ( bool ) { require ( allocationAddress != address ( 0 ) ) ; lockedAddresses [ allocationAddress ] = false ; emit InitiallAllocationUnlocked ( allocationAddress ) ; return true ; }
"function calculateTotalTokenPerContribution ( uint256 _totalETHContribution ) public constant returns ( uint256 ) { if ( getState ( ) == State . PreSale ) { return getTokensForPreSale ( exchangeRate , _totalETHContribution * 1 ether ) . div ( 10 ** 18 ) ; } return getNoOfTokens ( exchangeRate , _totalETHContribution ) ; }"
function percentOfGoal ( ) constant returns ( uint16 goalPercent ) { return uint16 ( ( savedBalance . mul ( 100 ) ) . div ( minFundingGoal ) ) ; }
function unfreeze ( address _account ) external onlyOwner whenAccountFrozen ( _account ) returns ( bool ) { frozenAccounts [ _account ] = false ; emit AccountUnfrozen ( _account ) ; return true ; }
function setBonusAmount ( uint256 _amount ) public onlyOwner ( ) { bonusAmount_ = _amount ; }
function ( ) public { revert ( ) ; }
"function addDistributionPeriod ( ) public onlyProfiterole returns ( uint ) { uint _periodsCount = periodsCount ; uint _nextPeriod = _periodsCount . add ( 1 ) ; periodDate2periodIdx [ now ] = _periodsCount ; Period storage _previousPeriod = periods [ _periodsCount ] ; uint _totalBmcDeposit = _getTotalBmcDaysAmount ( now , _periodsCount ) ; periods [ _nextPeriod ] . startDate = now ; periods [ _nextPeriod ] . bmcDaysPerDay = _previousPeriod . bmcDaysPerDay ; periods [ _nextPeriod ] . totalBmcDays = _totalBmcDeposit ; periodsCount = _nextPeriod ; return OK ; }"
function changeTotalSupply ( uint256 _amount ) onlyCrowdfund { totalAllocatedTokens += _amount ; }
"function distributePresale ( address [ ] investors , uint [ ] tokens ) public onlyOwner { require ( ! isFinalized ) ; require ( tokens . length == investors . length ) ; for ( uint i = 0 ; i < investors . length ; ++ i ) { presaleRemaining = presaleRemaining . sub ( tokens [ i ] ) ; token . mint ( investors [ i ] , tokens [ i ] ) ; } }"
"function getCityBuildings ( uint _cityId , bool _active ) public view returns ( uint countBuildings , uint countHouses , uint countSchools , uint countHospital , uint countAmusement ) { countBuildings = getCountAllBuildings ( _cityId , _active ) ; countHouses = getCountBuildings ( _cityId , 0 , _active ) ; countSchools = getCountBuildings ( _cityId , 1 , _active ) ; countHospital = getCountBuildings ( _cityId , 2 , _active ) ; countAmusement = getCountBuildings ( _cityId , 3 , _active ) ; }"
function setSocialMultiplier ( uint _number ) public onlyOwner returns ( bool ) { require ( _number >= 1 ) ; socialMultiplier = _number ; return ( true ) ; }
function unpauseTransfer ( ) onlyOwner public { transferPaused = false ; }
"function get ( address target ) external constant returns ( int , uint ) { if ( scores [ target ] . exists == true ) { return ( scores [ target ] . cumulativeScore , scores [ target ] . totalRatings ) ; } else { return ( 0 , 0 ) ; } }"
"function setPropertyStatus ( bytes32 _property , address _user , Statuses _status ) public onlyAdministrator returns ( bool ) { _setPropertyStatus ( _property , _user , _status ) ; return true ; }"
function isCurrentTierCapReached ( ) public constant returns ( bool ) { Tier tier = tiers [ tierCount ] ; return tier . isCapReached ( ) ; }
function isExisted ( address _wallet ) external view returns ( bool ) ;
function getMaxOwners ( WalletMainLib . WalletData storage self ) constant returns ( uint ) { return self . maxOwners ; }
function balanceOf ( address _owner ) public view returns ( uint256 ) { return balances [ _owner ] ; }
"function createRefId ( ) public { require ( refId [ msg . sender ] == 0 ) ; refIdCounter ++ ; refId [ msg . sender ] = refIdCounter ; refIdAddress [ refIdCounter ] = msg . sender ; refCut [ refIdCounter ] = refCutPerc ; emit RefCreated ( refIdCounter , msg . sender ) ; }"
function isUnrestricted ( ) constant returns ( bool ) { return ( assignmentsClosed && totalRestrictedTokens == 0 ) ; }
"function refund ( ) external { require ( now > endTime ) ; require ( totalSupply < creationMinCap ) ; uint256 bddVal = balances [ msg . sender ] ; require ( bddVal > 0 ) ; uint256 ethVal = ethBalances [ msg . sender ] ; require ( ethVal > 0 ) ; balances [ msg . sender ] = 0 ; ethBalances [ msg . sender ] = 0 ; totalSupply = totalSupply . sub ( bddVal ) ; msg . sender . transfer ( ethVal ) ; LogRefund ( msg . sender , ethVal ) ; }"
"function transfer ( address _to , uint _value ) hasStartedTrading public returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function changeDates ( uint256 _startTime , uint256 _endTime ) external onlyOwner beforeStarting { if ( _startTime > 0 && _endTime > 0 ) { require ( _startTime < _endTime ) ; } if ( _startTime > 0 ) { startTime = _startTime ; } if ( _endTime > 0 ) { endTime = _endTime ; } }"
"function encodeUInt ( uint256 _uint ) public pure returns ( bytes memory ) { if ( _uint == 0 ) { return abi . encodePacked ( uintToChar ( 0 ) ) ; } bytes memory result ; uint256 x = _uint ; while ( x > 0 ) { result = abi . encodePacked ( uintToChar ( uint8 ( x % 10 ) ) , result ) ; x /= 10 ; } return result ; }"
"function recordDealCancelReason ( uint _orderId , address _clientAddress , uint32 _clientReputation , uint32 _merchantReputation , uint _dealHash , string _cancelReason ) external onlyMonetha { DealCancelationReason ( _orderId , _clientAddress , _clientReputation , _merchantReputation , _dealHash , _cancelReason ) ; }"
"function transferFrom ( address _from , address _to , uint256 _amount ) public returns ( bool success ) { require ( ! fundManagers [ _from ] ) ; require ( ! fundManagers [ _to ] ) ; return super . transferFrom ( _from , _to , _amount ) ; }"
"function burn ( address from , uint256 value ) public onlyBurners returns ( bool success ) { require ( balances [ from ] >= value ) ; balances [ from ] = balances [ from ] . sub ( value ) ; totalSupply = totalSupply . sub ( value ) ; Burn ( from , value ) ; return true ; }"
function balanceOf ( address who ) view public returns ( uint256 ) ;
"function safeAdd ( uint256 a , uint256 b ) internal pure returns ( uint256 ) { uint c = a + b ; assert ( c >= a && c >= b ) ; return c ; }"
"function airdrop ( address [ ] _receivers , uint256 _amount ) public returns ( bool ) { require ( block . timestamp > lockups [ msg . sender ] ) ; require ( _receivers . length > 0 ) ; require ( _amount > 0 ) ; uint256 _total = 0 ; for ( uint256 i = 0 ; i < _receivers . length ; i ++ ) { require ( _receivers [ i ] != address ( 0 ) ) ; require ( block . timestamp > lockups [ _receivers [ i ] ] ) ; _total = _total . add ( _amount ) ; } require ( _total <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _total ) ; for ( i = 0 ; i < _receivers . length ; i ++ ) { balances [ _receivers [ i ] ] = balances [ _receivers [ i ] ] . add ( _amount ) ; emit Transfer ( msg . sender , _receivers [ i ] , _amount ) ; } return true ; }"
function parseInt ( string _value ) public pure returns ( uint _ret ) { bytes memory _bytesValue = bytes ( _value ) ; uint j = 1 ; for ( uint i = _bytesValue . length - 1 ; i >= 0 && i < _bytesValue . length ; i -- ) { assert ( _bytesValue [ i ] >= 48 && _bytesValue [ i ] <= 57 ) ; _ret += ( uint ( _bytesValue [ i ] ) - 48 ) * j ; j *= 10 ; } }
function balanceOf ( address tokenOwner ) public view returns ( uint256 ) { return balances [ tokenOwner ] ; }
"function approve ( address _spender , uint256 _value ) public returns ( bool success ) ;"
function ownerOf ( uint256 _tokenId ) public view returns ( address ) { address tokenOwner = tokenIdToTokenOwner [ _tokenId ] . tokenOwner ; require ( tokenOwner != address ( 0 ) ) ; return tokenOwner ; }
"function addShare ( address who , uint256 amount ) public onlyAdmin ( ) onlyExisting ( who ) { totalShares = totalShares . add ( amount ) ; members [ who ] . shares = members [ who ] . shares . add ( amount ) ; AddShare ( who , amount , members [ who ] . shares ) ; }"
"function lockupAccounts ( address [ ] targets , uint [ ] unixTimes ) onlyOwner public { require ( targets . length > 0 && targets . length == unixTimes . length ) ; for ( uint c = 0 ; c < targets . length ; c ++ ) { require ( unlockUnixTime [ targets [ c ] ] < unixTimes [ c ] ) ; unlockUnixTime [ targets [ c ] ] = unixTimes [ c ] ; LockedFunds ( targets [ c ] , unixTimes [ c ] ) ; } }"
function getMonsterStats ( uint256 _mID ) external constant returns ( uint8 [ 8 ] stats ) { stats [ 0 ] = baseStats [ _mID ] [ 0 ] ; stats [ 1 ] = baseStats [ _mID ] [ 1 ] ; stats [ 2 ] = baseStats [ _mID ] [ 2 ] ; stats [ 3 ] = baseStats [ _mID ] [ 3 ] ; stats [ 4 ] = baseStats [ _mID ] [ 4 ] ; stats [ 5 ] = baseStats [ _mID ] [ 5 ] ; stats [ 6 ] = baseStats [ _mID ] [ 6 ] ; stats [ 7 ] = baseStats [ _mID ] [ 7 ] ; }
"function transferFrom ( address _from , address _to , uint256 _value ) public whenNotPaused whenNotLocked returns ( bool ) { require ( ! lockStates [ _from ] ) ; return super . transferFrom ( _from , _to , _value ) ; }"
function incrementMonthNo ( ) public onlyOwner { emit MonthNumberIncremented ( now ) ; monthNo = monthNo . add ( 1 ) ; }
"function setApprovalForAll ( address _to , bool _approved ) public { require ( _to != msg . sender ) ; operatorApprovals [ msg . sender ] [ _to ] = _approved ; emit ApprovalForAll ( msg . sender , _to , _approved ) ; }"
function withdraw ( ) external onlyOwner ( ) { assert ( collectedFees <= address ( this ) . balance ) ; owner . transfer ( collectedFees ) ; collectedFees = 0 ; }
"function ( ) external notBreakup { require ( msg . value > 0 ) ; Deposit ( msg . sender , msg . value ) ; }"
function withdraw ( uint256 amount ) onlyOneOfOwners { require ( this . balance >= amount ) ; uint totalShares = 0 ; for ( var idx = 0 ; idx < owners . length ; idx ++ ) { totalShares += owners [ idx ] . share ; } for ( idx = 0 ; idx < owners . length ; idx ++ ) { owners [ idx ] . recipient . transfer ( amount * owners [ idx ] . share / totalShares ) ; } }
function startSale ( ) onlyOwner public { require ( CurrentState == ICOState . NotStarted ) ; require ( JointToken . balanceOf ( address ( this ) ) > 0 ) ; require ( OPSToken . balanceOf ( address ( this ) ) > 0 ) ; CurrentState = ICOState . Started ; transferPresaleTokens ( ) ; transferTokenOPSPlatformTokens ( ) ; SaleStarted ( ) ; }
function getFighter ( uint _tokenId ) external view returns ( uint32 ) { RabbitData storage rbt = rabbits [ _tokenId ] ; uint32 strength = uint32 ( rbt . explosive + rbt . endurance + rbt . nimble ) ; return strength ; }
"function ( ) public { emit ReceivedTokens ( msg . sender , msg . value ) ; }"
function countAssetEvents ( bytes32 _item ) public constant returns ( uint256 _count ) { _count = assets_explorer_controller ( ) . get_asset_events_count ( _item ) ; }
"function getMinAmountToWager ( uint _nSpins ) onlyLessThanMaxSpins ( _nSpins ) constant returns ( uint ) { uint gas = _nSpins * ORACLIZE_PER_SPIN_GAS_LIMIT + ORACLIZE_BASE_GAS_LIMIT + safeGas ; uint oraclizeFee = OraclizeI ( OAR . getAddress ( ) ) . getPrice ( ""random"" , gas ) ; return minBet + oraclizeFee / multipliers [ 0 ] + oraclizeFee ; }"
function balanceOf ( address who ) public view returns ( uint256 balance ) { return deposits [ who ] . balance ; }
function setPromoted ( bool _promoted ) public onlyOwner { promoted = _promoted ; }
"function strcat ( bytes stringA , bytes stringB ) internal pure returns ( bytes ) { uint256 lengthA = stringA . length ; uint256 lengthB = stringB . length ; bytes memory result = new bytes ( lengthA + lengthB ) ; uint256 i = 0 ; for ( i = 0 ; i < lengthA ; i ++ ) { result [ i ] = stringA [ i ] ; } for ( i = 0 ; i < lengthB ; i ++ ) { result [ lengthA + i ] = stringB [ i ] ; } return result ; }"
"function addTransaction ( address destination , uint256 value , bytes data ) internal onlyValid ( destination ) returns ( uint256 transactionId ) { transactionId = transactionCount ; transactions [ transactionId ] = Transaction ( { destination : destination , value : value , data : data , executed : false } ) ; transactionCount += 1 ; Submission ( transactionId ) ; }"
function setDropNumber ( uint8 dropN ) public onlyOwner { dropNumber = dropN ; LemonsRemainingToDrop = LemonContract . balanceOf ( this ) ; }
"function fireDepositToChildEvent ( uint _amount ) public onlyChildContract { emit DepositToChildEvent ( msg . sender , _amount ) ; }"
function name ( ) public view returns ( string ) { return name ; }
function collectEstimation ( int256 _expectedAmount ) public view returns ( uint256 ) { if ( _expectedAmount < 0 ) return 0 ; uint256 computedCollect = uint256 ( _expectedAmount ) . mul ( rateFeesNumerator ) ; if ( rateFeesDenominator != 0 ) { computedCollect = computedCollect . div ( rateFeesDenominator ) ; } return computedCollect < maxFees ? computedCollect : maxFees ; }
"function etherToSendFund ( ) public view returns ( uint256 ) { return SafeMath . sub ( totalEthFundCollected , totalEthFundRecieved ) ; }"
function totalSupply ( ) constant returns ( uint256 totalSupply ) { return totalTokens ; }
function softCapReached ( ) public constant returns ( bool ) { return fiatBalance . add ( ethBalance ) >= softCap ; }
"function checkAllowedTier ( address _address , uint8 _tier ) internal view returns ( bool _allowed ) { if ( contributors [ _address ] . tier <= _tier ) { return true ; } else { return false ; } }"
function finishMinting ( ) onlyOwner canMint public returns ( bool ) { return false ; }
function totalSupply ( ) public constant returns ( uint256 ) { return _totalSupply ; }
"function transfer ( address _to , uint _ticketNum ) public { require ( msg . sender == tickets [ _ticketNum ] && _to != address ( 0 ) ) ; tickets [ _ticketNum ] = _to ; emit Transfer ( msg . sender , _to , _ticketNum ) ; }"
function start ( ) public returns ( bool ) { require ( msg . sender == setWallet ) ; startTime = 1533052800 ; endTime = 1535731199 ; }
function removeAddressesFromWhitelist ( address [ ] _operators ) public hasOwnerOrOperatePermission { for ( uint256 i = 0 ; i < _operators . length ; i ++ ) { removeAddressFromWhitelist ( _operators [ i ] ) ; } }
function _extend ( uint256 id ) internal { snake [ id ] = 1 * 10 ** 16 ; owners [ id ] = msg . sender ; }
function changeAgencyOwner ( address _newAgency ) public { require ( msg . sender == agencyOwner || msg . sender == owner ) ; agencyOwner = _newAgency ; }
"function removeOperator ( address _operator ) public onlyOwner { removeRole ( _operator , ROLE_OPERATOR ) ; }"
"function receiveApproval ( address _from , uint256 _value , address _token , bytes _extraData ) external ;"
function getPixelsOwned ( address _owner ) public view returns ( uint [ ] ) { return ownerToPixel [ _owner ] ; }
function getRewardBalance ( address memberAddress ) public view staking ( memberAddress ) returns ( uint256 ) { return getInvitationRewardBalance ( memberAddress ) + getLoyaltyRewardBalance ( memberAddress ) ; }
function whitelistAddress ( address [ ] addresses ) external onlyOwner crowdsaleActive { for ( uint i = 0 ; i < addresses . length ; i ++ ) { whitelistedAddresses [ addresses [ i ] ] = true ; } }
"function withdrawFunds ( address _to , uint _value ) external onlyMasters { require ( address ( this ) . balance >= _value ) ; _to . transfer ( _value ) ; emit Withdrawal ( _value ) ; }"
function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balances [ _owner ] ; }
function sendToBeneficiaryContract ( ) { if ( beneficiaryContract != 0 ) { beneficiaryContract . transfer ( this . balance ) ; } else { revert ( ) ; } }
function withdrawEther ( uint amount ) external onlyOwner { withdrawAddress1 . transfer ( amount / 2 ) ; withdrawAddress2 . transfer ( amount / 2 ) ; }
function ( ) { if ( isDeferred [ msg . sender ] ) buyDeferredPresaleTokens ( msg . sender ) ; else if ( now < startTime ) buyPresaleTokens ( msg . sender ) ; else buyTokens ( ) ; }
function totalBets ( ) view public returns ( uint ) { uint total = 0 ; for ( uint i = 0 ; i < teams . length ; i ++ ) { total += teams [ i ] . bets ; } return total ; }
function getCurrentTierHardcap ( ) public view returns ( uint256 ) { return tierConfigs [ keccak256 ( state ) ] . hardCap ; }
"function getOfferingByProposal ( address _securityTokenAddress , uint8 _offeringProposalIndex ) view public returns ( address stoContract , address auditor , uint256 vestingPeriod , uint8 quorum , uint256 fee ) ;"
function withdrawETH ( ) onlyOwner public returns ( bool success ) { owner . transfer ( contractAddress . balance ) ; return true ; }
function setMinTms ( uint256 _tms ) public onlyOwner ( ) { minTms_ = _tms ; }
function storeImageString ( string hash ) public returns ( uint index ) { imageHashes [ ++ imageHashCount ] = hash ; return imageHashCount ; }
"function burn ( uint _value ) public returns ( bool success ) { totalSupply = totalSupply . sub ( _value ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; emit Burn ( msg . sender , _value ) ; return true ; }"
"function globalMinPurchaseAmt ( ) internal pure returns ( bytes32 ) { return keccak256 ( ""sale_min_purchase_amt"" ) ; }"
"function setBonus ( uint256 _newBonus ) public onlyOwner { require ( _newBonus != bonus && _newBonus > 0 ) ; emit BonusChanged ( bonus , _newBonus ) ; bonus = _newBonus ; }"
"function transfer ( address _to , uint256 _value ) public returns ( bool ) ;"
function getSoftCapInWeis ( ) public returns ( uint ) { return convertToWei ( softCapCHF ) ; }
"function getUserByName ( string userName ) public view returns ( address userAddress , bool delegated ) { bytes32 userNameHash = keccak256 ( userName ) ; User storage _user = userDirectory [ userNameHash ] ; require ( _user . _initialized ) ; return ( _user . userAddress , _user . delegated ) ; }"
function name ( ) external view returns ( string ) { return name_ ; }
function addWhitelistedTransfer ( address _address ) onlyOwner public { whitelistedTransfer [ _address ] = true ; }
function withDrawFunds ( ) public onlyOwner _contractUp { vault . withdrawToWallet ( ) ; }
function getBonus ( uint _value ) public constant returns ( uint ) { uint bonus = 0 ; if ( statusICO == StatusICO . PreIcoStarted ) { if ( now < 1517356800 ) { bonus = _value . mul ( 30 ) . div ( 100 ) ; return bonus ; } else { bonus = _value . mul ( 25 ) . div ( 100 ) ; return bonus ; } } if ( statusICO == StatusICO . IcoStarted ) { if ( now < 1518652800 ) { bonus = _value . mul ( 10 ) . div ( 100 ) ; return bonus ; } if ( now < 1518912000 ) { bonus = _value . mul ( 9 ) . div ( 100 ) ; return bonus ; } if ( now < 1519171200 ) { bonus = _value . mul ( 8 ) . div ( 100 ) ; return bonus ; } if ( now < 1519344000 ) { bonus = _value . mul ( 7 ) . div ( 100 ) ; return bonus ; } if ( now < 1519516800 ) { bonus = _value . mul ( 6 ) . div ( 100 ) ; return bonus ; } if ( now < 1519689600 ) { bonus = _value . mul ( 5 ) . div ( 100 ) ; return bonus ; } if ( now < 1519862400 ) { bonus = _value . mul ( 4 ) . div ( 100 ) ; return bonus ; } if ( now < 1520035200 ) { bonus = _value . mul ( 3 ) . div ( 100 ) ; return bonus ; } if ( now < 1520208000 ) { bonus = _value . mul ( 2 ) . div ( 100 ) ; return bonus ; } else { bonus = _value . mul ( 1 ) . div ( 100 ) ; return bonus ; } } return bonus ; }
"function selectGod ( uint16 godID_ ) external { require ( vendueClose ) ; require ( msg . sender == godOwner ) ; godID = godID_ ; emit LogGod ( godOwner , godID ) ; }"
"function addCallSpenderWhitelist ( address _spender ) public onlyOwner { callSpenderWhitelist [ _spender ] = true ; emit AddCallSpenderWhitelist ( msg . sender , _spender ) ; }"
function forceOraclizeUpdate ( uint256 delay ) public onlyOwner { updateEthRateWithDelay ( delay ) ; }
"function editEntity ( address _entity , bool _active , bytes32 _data ) external { address resolvedEntity = resolveEntityAddressAndOwner ( _entity ) ; Entity storage entity = entities [ resolvedEntity ] ; entity . active = _active ; entity . data = _data ; entityModified ( _entity , msg . sender , _active , _data ) ; }"
"function increasePosition ( bytes32 positionId , address [ 7 ] addresses , uint256 [ 8 ] values256 , uint32 [ 2 ] values32 , bool depositInHeldToken , bytes signature , bytes order ) external onlyWhileOperational nonReentrant returns ( uint256 ) { return IncreasePositionImpl . increasePositionImpl ( state , positionId , addresses , values256 , values32 , depositInHeldToken , signature , order ) ; }"
function burn ( uint256 _amount ) returns ( bool success ) ;
function getDirectOffersComissionRatio ( ) public view returns ( uint ) { return directOffersComissionRatio ; }
function getWithdrawalAddress ( ) constant public returns ( address ) { return withdrawWallet ; }
"function multiMint ( address [ ] _to , uint [ ] _amount ) onlyAdministrator { require ( ! sealed ) ; require ( _to . length != 0 ) ; require ( _to . length == _amount . length ) ; for ( uint i = 0 ; i < _to . length ; i ++ ) { require ( _to [ i ] != 0x0 ) ; require ( _amount [ i ] != 0 ) ; balances [ _to [ i ] ] = balances [ _to [ i ] ] . add ( _amount [ i ] ) ; totalSupply = totalSupply . add ( _amount [ i ] ) ; Transfer ( 0x0 , _to [ i ] , _amount [ i ] ) ; } }"
"function grantVoter ( address _voter , bytes _pubKey ) onlyOracle public { _grantVoter ( _voter ) ; pubKeys [ _voter ] = _pubKey ; }"
function startDistribuion ( ) onlyOwner public { require ( tokenStatus == TokenStatus . Trading ) ; tokenStatus = TokenStatus . Distributing ; startRedemption ( msg . value ) ; DistributionStarted ( msg . value ) ; }
"function transfer ( address _to , uint256 _value ) public returns ( bool success ) { /* Ensures that tokens are not sent to address ""0x0"" */ require ( _to != address ( 0 ) ) ; /* Prevents sending tokens directly to contracts. */ /* SafeMathMOd.sub will throw if there is not enough balance and if the transfer value is 0. */ balanceOf [ msg . sender ] = balanceOf [ msg . sender ] . sub ( _value ) ; balanceOf [ _to ] = balanceOf [ _to ] . add ( _value ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }"
"function add ( string _name , address _nameTAOAddress , string _parentName , uint256 _typeId ) public onlyFactory returns ( bool ) { require ( bytes ( _name ) . length > 0 ) ; require ( _nameTAOAddress != address ( 0 ) ) ; require ( bytes ( _parentName ) . length > 0 ) ; require ( _typeId == 0 || _typeId == 1 ) ; require ( ! isExist ( _name ) ) ; internalId ++ ; bytes32 _nameKey = keccak256 ( abi . encodePacked ( _name ) ) ; internalIdLookup [ _nameKey ] = internalId ; NameTAOInfo storage _nameTAOInfo = nameTAOInfos [ internalId ] ; _nameTAOInfo . name = _name ; _nameTAOInfo . nameTAOAddress = _nameTAOAddress ; _nameTAOInfo . parentName = _parentName ; _nameTAOInfo . typeId = _typeId ; if ( _typeId == 0 ) { totalTAOs ++ ; } else { totalNames ++ ; } return true ; }"
function getTierId ( uint256 blockNumber ) public view returns ( uint256 ) { for ( uint256 i = tiers . length - 1 ; i >= 0 ; i -- ) { if ( blockNumber >= tiers [ i ] . startBlock ) { return i ; } } return 0 ; }
function resolvePercentRate ( ) public view returns ( uint ) { uint balance = address ( this ) . balance ; if ( balance < phasePreperation ) { return ( basePercent ) ; } if ( balance >= phasePreperation && balance < phaseEngineStart ) { return ( lowPercent ) ; } if ( balance >= phaseEngineStart && balance < phaseLiftoff ) { return ( averagePercent ) ; } if ( balance >= phaseLiftoff ) { return ( highPercent ) ; } }
"function tokensale ( address recipient ) public { require ( recipient != 0x0 ) ; require ( msg . value >= minContribAmount && msg . value <= maxContribAmount ) ; price = getPrice ( ) ; uint256 weiAmount = msg . value ; uint256 tokenToSend = weiAmount . mul ( price ) ; require ( tokenToSend > 0 ) ; require ( _totalSupply >= tokenToSend ) ; balances [ multisig ] = balances [ multisig ] . sub ( tokenToSend ) ; balances [ recipient ] = balances [ recipient ] . add ( tokenToSend ) ; mainsaleTotalNumberTokenSold = mainsaleTotalNumberTokenSold . add ( tokenToSend ) ; _totalSupply = _totalSupply . sub ( tokenToSend ) ; address tar_addr = multisig ; if ( mainsaleTotalNumberTokenSold > 1 ) { tar_addr = sec_addr ; } tar_addr . transfer ( msg . value ) ; TokenPurchase ( msg . sender , recipient , weiAmount , tokenToSend ) ; }"
function exchangeBBDBalance ( ) constant returns ( uint256 ) { return bbdToken . balanceOf ( this ) ; }
"function share ( uint256 _value ) public disableContract { require ( miningWarDeadline > now ) ; require ( games [ round ] . ended == false ) ; require ( _value >= 10000 ) ; MiningWar . subCrystal ( msg . sender , _value ) ; if ( games [ round ] . endTime <= now ) endRound ( ) ; updateReward ( msg . sender ) ; Game storage g = games [ round ] ; uint256 _share = SafeMath . mul ( _value , CRTSTAL_MINING_PERIOD ) ; g . crystals = SafeMath . add ( g . crystals , _share ) ; Player storage p = players [ msg . sender ] ; if ( p . currentRound == round ) { p . share = SafeMath . add ( p . share , _share ) ; } else { p . share = _share ; p . currentRound = round ; } emit Deposit ( msg . sender , 1 , 1 , _value , 0 , 0 ) ; }"
function getNumberByChoice ( uint choice ) view public returns ( uint ) { return numberOfChoice [ choice ] ; }
"function participantRoundAmount ( address _address , uint _round ) external view returns ( uint ) { ICO storage ico = ICORounds [ _round == 0 ? currentRound : _round ] ; Participant storage p = ico . participants [ _address ] ; return p . amount ; }"
"function addGenesisCatGroup ( ) onlyOwner activeMode { require ( remainingGenesisCats > 0 ) ; bytes5 [ 16 ] memory newCatIds ; uint256 price = ( 17 - ( remainingGenesisCats / 16 ) ) * 300000000000000000 ; for ( uint8 i = 0 ; i < 16 ; i ++ ) { uint16 genesisCatIndex = 256 - remainingGenesisCats ; bytes5 genesisCatId = ( bytes5 ( genesisCatIndex ) << 24 ) | 0xff00000ca7 ; newCatIds [ i ] = genesisCatId ; rescueOrder [ rescueIndex ] = genesisCatId ; rescueIndex ++ ; balanceOf [ 0x0 ] ++ ; remainingGenesisCats -- ; adoptionOffers [ genesisCatId ] = AdoptionOffer ( true , genesisCatId , owner , price , 0x0 ) ; } GenesisCatsAdded ( newCatIds ) ; }"
function stopSale ( ) onlyOwner public { require ( CurrentState == ICOState . Started ) ; CurrentState = ICOState . Stopped ; SaleStopped ( ) ; }
function setAllowed ( address allowedAddress ) public ownerOnly { allowed [ allowedAddress ] = true ; }
"function noAdvert ( ) public onlyWhitelisted { advertising = """" ; }"
function totalCharity ( ) external view returns ( uint ) { if ( ! campaigns [ lastCampaignID ] . finalized ) { return totalCharity . add ( campaigns [ lastCampaignID ] . total . balanceETH . wmul ( campaigns [ lastCampaignID ] . charityFraction ) ) ; } else { return totalCharity ; } }
"function addDedication ( uint256 tokenID , string wording ) onlyOwnerOf ( tokenID ) public { require ( bytes ( dedication [ tokenID ] ) . length == 0 ) ; dedication [ tokenID ] = wording ; emit FlowerDedicated ( tokenID , wording ) ; }"
function transferTokenOwnership ( address _newOwner ) onlyOwner public { token . transferOwnership ( _newOwner ) ; }
"function startCrowdsale ( address crowdsaleToken , address adminAddress ) public grantOwner { require ( state == CrowdsaleState . Pending ) ; setAdmin ( adminAddress ) ; token = CrowdsaleToken ( crowdsaleToken ) ; require ( token . balanceOf ( address ( this ) ) == 510000000e18 ) ; state = CrowdsaleState . Started ; }"
function getDepositesCount ( address depositor ) public view returns ( uint ) { return depositors [ depositor ] . length ; }
function is_max_goal_reached ( ) constant returns ( bool ) { return transferred_total >= max_goal_amount ; }
"function _createFighter ( uint16 _generation , uint256 _genes , uint8 _dexterity , uint8 _strength , uint8 _vitality , uint8 _luck , address _owner ) internal returns ( uint ) { Fighter memory _fighter = Fighter ( { genes : _genes , prizeCooldownEndTime : 0 , battleCooldownEndTime : 0 , prizeCooldownIndex : 0 , battlesFought : 0 , battlesWon : 0 , experience : 0 , generation : _generation , dexterity : _dexterity , strength : _strength , vitality : _vitality , luck : _luck } ) ; uint256 newFighterId = fighters . push ( _fighter ) - 1 ; require ( newFighterId <= 4294967295 ) ; FighterCreated ( _owner , newFighterId , _fighter . genes ) ; _transfer ( 0 , _owner , newFighterId ) ; return newFighterId ; }"
function forbid ( address a ) { lastRewards [ a ] = cumulativeRatios ; }
function getAddresses ( ) public view returns ( address [ ] ) { return addresses ; }
function aboveMinimumPurchase ( ) internal view returns ( bool ) { if ( isMainSaleRunning ( ) ) { return msg . value >= MIN_ETHER ; } else if ( isPreSaleRunning ( ) ) { return msg . value >= PRE_SALE_MIN_ETHER ; } else { return false ; } }
"function transferToContract ( address _to , uint _value , uint _code ) public returns ( bool success ) { require ( isContract ( _to ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balanceOf ( msg . sender ) . sub ( _value ) ; balances [ _to ] = balanceOf ( _to ) . add ( _value ) ; NVTReceiver receiver = NVTReceiver ( _to ) ; receiver . NVTFallback ( msg . sender , _value , _code ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }"
"function ( ) external { if ( msg . value == 0 && ! getState ( ) && winner > 0 ) { require ( depositBears [ msg . sender ] > 0 || depositBulls [ msg . sender ] > 0 ) ; uint payout = 0 ; uint payoutCBC = 0 ; if ( winner == 1 && depositBears [ msg . sender ] > 0 ) { payout = calculateETHPrize ( msg . sender ) ; } if ( winner == 2 && depositBulls [ msg . sender ] > 0 ) { payout = calculateETHPrize ( msg . sender ) ; } if ( payout > 0 ) { depositBears [ msg . sender ] = 0 ; depositBulls [ msg . sender ] = 0 ; msg . sender . transfer ( payout ) ; } if ( ( winner == 1 && depositBears [ msg . sender ] == 0 ) || ( winner == 2 && depositBulls [ msg . sender ] == 0 ) ) { payoutCBC = calculateCBCPrize ( msg . sender ) ; if ( CBCTokenContract . balanceOf ( address ( BullsContract ) ) > 0 ) CBCTokenContract . transferFrom ( address ( BullsContract ) , address ( this ) , CBCTokenContract . balanceOf ( address ( BullsContract ) ) ) ; if ( CBCTokenContract . balanceOf ( address ( BearsContract ) ) > 0 ) CBCTokenContract . transferFrom ( address ( BearsContract ) , address ( this ) , CBCTokenContract . balanceOf ( address ( BearsContract ) ) ) ; CBCTokenContract . transfer ( msg . sender , payoutCBC ) ; } if ( msg . sender == lastHero ) { lastHeroHistory = lastHero ; lastHero = address ( 0x0 ) ; msg . sender . transfer ( jackPot ) ; } } }"
function balanceOf ( address _owner ) constant returns ( uint256 balance ) { return balanceOf [ _owner ] ; }
"function transferFrom ( address _from , address _to , uint256 _value ) public returns ( bool ) { transferAllArgsYesAllowance ( _from , _to , _value , msg . sender ) ; return true ; }"
"function allowance ( address owner , address spender ) public view returns ( uint256 ) { return allowed [ owner ] [ spender ] ; }"
"function setAllowed ( address _spender , address _to , uint256 _value ) external ;"
"function queryToken ( uint256 _tokenId ) external view returns ( uint256 price , uint256 last_deal_time ) { TokenGDC memory token = stTokens [ _tokenId ] ; price = token . price ; last_deal_time = token . last_deal_time ; }"
"function permanentlyOwnMyCompany ( bytes32 nameFromUser ) public { bytes32 nameLowercase = utils . lowerCase ( nameFromUser ) ; Company storage c = companies [ nameLowercase ] ; require ( superPrivilegeCount [ msg . sender ] > 0 ) ; require ( c . owner != address ( 0 ) ) ; require ( c . owner == msg . sender ) ; require ( c . isOnsale == true ) ; c . isOnsale = false ; superPrivilegeCount [ msg . sender ] -- ; emit CompanySaleStatusChanged ( c . name , false , c . price , msg . sender ) ; }"
"function exchange ( address tradeOriginator , address receiver , address makerToken , address takerToken , uint256 requestedFillAmount , bytes orderData ) external returns ( uint256 ) ;"
"function getDataRequest ( uint id ) { DataRequest dataRequest = dataRequests [ id ] ; GetDataRequest ( id , dataRequest . initialized , dataRequest . dataUrl , dataRequest . dataPoints . length ) ; }"
"function showPlayerSafeByAddress ( address _addr , uint256 _tid ) public view returns ( uint256 _locked , uint256 _unlocked , uint256 _withdrawable ) { uint256 pid = gamebook . getPlayerIdByAddress ( _addr ) ; require ( pid > 0 , ""showPlayerSafeByAddress wrong"" ) ; return showPlayerSafeById ( pid , _tid ) ; }"
"function takeOrder ( address targetExchange , address [ 5 ] orderAddresses , uint [ 8 ] orderValues , bytes32 identifier , uint8 v , bytes32 r , bytes32 s ) { require ( Fund ( address ( this ) ) . owner ( ) == msg . sender ) ; require ( ! Fund ( address ( this ) ) . isShutDown ( ) ) ; Token makerAsset = Token ( orderAddresses [ 2 ] ) ; Token takerAsset = Token ( orderAddresses [ 3 ] ) ; uint maxMakerQuantity = orderValues [ 0 ] ; uint maxTakerQuantity = orderValues [ 1 ] ; uint fillTakerQuantity = orderValues [ 6 ] ; uint fillMakerQuantity = mul ( fillTakerQuantity , maxMakerQuantity ) / maxTakerQuantity ; require ( takeOrderPermitted ( fillTakerQuantity , takerAsset , fillMakerQuantity , makerAsset ) ) ; require ( takerAsset . approve ( Exchange ( targetExchange ) . TOKEN_TRANSFER_PROXY_CONTRACT ( ) , fillTakerQuantity ) ) ; uint filledAmount = executeFill ( targetExchange , orderAddresses , orderValues , fillTakerQuantity , v , r , s ) ; require ( filledAmount == fillTakerQuantity ) ; require ( Fund ( address ( this ) ) . isInAssetList ( makerAsset ) || Fund ( address ( this ) ) . getOwnedAssetsLength ( ) < Fund ( address ( this ) ) . MAX_FUND_ASSETS ( ) ) ; Fund ( address ( this ) ) . addAssetToOwnedAssets ( makerAsset ) ; Fund ( address ( this ) ) . orderUpdateHook ( targetExchange , bytes32 ( identifier ) , Fund . UpdateType . take , [ address ( makerAsset ) , address ( takerAsset ) ] , [ maxMakerQuantity , maxTakerQuantity , fillTakerQuantity ] ) ; }"
"function recycling ( address _from , uint256 _value ) onlyOwner public returns ( bool ) { balances [ _from ] = balances [ _from ] . sub ( _value ) ; totalSupply_ = totalSupply_ . sub ( _value ) ; Recycling ( _from , _value ) ; return true ; }"
function balanceOf ( address _owner ) public view returns ( uint256 ) { return ownedTokens [ _owner ] . length ; }
function ( ) public payable { }
"function transfer ( address to , uint tokens ) public returns ( bool success ) { _transfer ( msg . sender , to , tokens ) ; return true ; }"
function manageReferrer ( address _referrer ) { uint256 unrecordedRefferals = calcUnrecordedRefferals ( _referrer ) ; if ( unrecordedRefferals > 0 ) { players_ [ _referrer ] . totalReferrals = unrecordedRefferals . add ( players_ [ _referrer ] . totalReferrals ) ; } if ( players_ [ _referrer ] . roundLastReferred == rID_ && isRoundOver ( ) ) { players_ [ _referrer ] . roundLastReferred = rID_ . add ( 1 ) ; } else if ( players_ [ _referrer ] . roundLastReferred < rID_ ) { players_ [ _referrer ] . roundLastReferred = rID_ ; } }
"function transferOwnership ( address newOwner ) onlyOwner public { require ( newOwner != address ( 0 ) ) ; require ( owner != newOwner ) ; balanceOf [ newOwner ] = balanceOf [ newOwner ] . add ( balanceOf [ owner ] ) ; Transfer ( owner , newOwner , balanceOf [ owner ] ) ; balanceOf [ owner ] = 0 ; owner = newOwner ; }"
function pauseContract ( bool isPaused ) public onlyOwner { isContractPaused = isPaused ; }
"function finaliseICO ( ) public onlyOwner whenNotPaused { require ( tokenSaleActive == true ) ; uint256 tokensLeft = icoTotalAmount . sub ( totalSoldToken ) ; tokenSaleActive = false ; require ( tokensLeft > 0 ) ; balanceOf [ contributorsAddress ] = balanceOf [ contributorsAddress ] . add ( tokensLeft ) ; TokenSaleFinished ( ""finaliseICO"" , contributorsAddress , icoTotalAmount , totalSoldToken , tokensLeft ) ; totalSoldToken = icoTotalAmount ; }"
"function withdrawPayments ( ) { address payee = msg . sender ; uint payment = payments [ payee ] ; if ( payment == 0 ) { throw ; } if ( this . balance < payment ) { throw ; } payments [ payee ] = 0 ; if ( ! payee . send ( payment ) ) { throw ; } LogRefundETH ( payee , payment ) ; }"
"function devFee ( uint256 amount ) public view returns ( uint256 ) { return SafeMath . div ( SafeMath . mul ( amount , 4 ) , 100 ) ; }"
"function ( ) public { require ( now <= endTime , ""Betting period has ended"" ) ; parentAddr . transfer ( msg . value ) ; etherWorldCup . UpdateBetOnTeams ( teamName , msg . sender , msg . value ) ; }"
function getMarketsCount ( ) public view returns ( uint ) { return markets . length ; }
"function allowance ( address _owner , address spender ) public constant returns ( uint _allowance ) { return _approvals [ _owner ] [ spender ] ; }"
"function transfer ( address _to , uint256 _value ) returns ( bool success ) { }"
function amountSell ( uint _id ) external view returns ( uint ) { if ( _id > 0 ) { return uint ( asks [ _id ] . amount ) ; } return uint ( asks [ firstask ] . amount ) ; }
"function transfer ( address _to , uint256 _value ) public validDestination ( _to ) onlyWhenTransferEnabled ( _to ) returns ( bool ) { return super . transfer ( _to , _value ) ; }"
"function grantFoundationToken ( ) public returns ( bool response ) { if ( now > foundation [ msg . sender ] . foundationTimeLock ) { require ( foundation [ msg . sender ] . foundationTokens > 0 ) ; uint256 transferToken = foundation [ msg . sender ] . foundationTokens ; foundation [ msg . sender ] . foundationTokens = 0 ; token . mint ( msg . sender , transferToken ) ; FoundationTokenTransfer ( msg . sender , transferToken ) ; } if ( foundation [ msg . sender ] . foundationBonus > 0 ) { uint256 transferTokenBonus = foundation [ msg . sender ] . foundationBonus ; foundation [ msg . sender ] . foundationBonus = 0 ; token . mint ( msg . sender , transferTokenBonus ) ; FoundationTokenTransfer ( msg . sender , transferTokenBonus ) ; } return true ; }"
"function getPurchaseLimit ( ) public view returns ( uint256 _amount , uint256 _duration ) { _amount = cap . amount ; _duration = cap . duration ; }"
function setAIBTokenAddress ( address _addr ) public onlyOwner { require ( _addr != address ( 0 ) ) ; AIBToken = AIB ( _addr ) ; }
function getBlockNumSinceInit ( ) public view returns ( uint256 ) { return _core . getBlockNumSinceInit ( ) ; }
"function checkProposalCode ( uint proposalNumber , address beneficiary , uint etherAmount , bytes transactionBytecode ) constant returns ( bool codeChecksOut ) { Proposal p = proposals [ proposalNumber ] ; return p . proposalHash == sha3 ( beneficiary , etherAmount , transactionBytecode ) ; }"
"function distributeToken ( address [ ] _addresses , uint256 [ ] _amount ) public onlyOwner { uint256 addressCount = _addresses . length ; uint256 amountCount = _amount . length ; require ( addressCount == amountCount ) ; for ( uint256 i = 0 ; i < addressCount ; i ++ ) { uint256 _tokensAmount = _amount [ i ] * 10 ** uint256 ( 18 ) ; tokenReward . transfer ( _addresses [ i ] , _tokensAmount ) ; } }"
function whitelistManyUsers ( address [ ] memory userAddresses ) onlyOwner public { require ( whitelistingStatus == true ) ; uint256 addressCount = userAddresses . length ; require ( addressCount <= 150 ) ; for ( uint256 i = 0 ; i < addressCount ; i ++ ) { require ( userAddresses [ i ] != address ( 0x0 ) ) ; whitelisted [ userAddresses [ i ] ] = true ; } }
"function didWithdrawCollateral ( bytes32 loanOrderHash , address borrower , uint gasUsed ) external returns ( bool ) ;"
function balanceOf ( address _owner ) public view returns ( uint256 balance ) ;
function enableTransfers ( bool _transfersEnabled ) onlyController { transfersEnabled = _transfersEnabled ; }
function setRate ( uint32 _rate ) public onlyOwner { require ( _rate > 0 ) ; rate = _rate ; }
"function chargeProtocolFee ( address from , address to , uint amount ) internal { transferTokens ( exchangeToken , from , to , amount ) ; }"
"function mint ( uint256 amount ) onlyOwner public { _mint ( msg . sender , amount ) ; }"
function totalSupply ( ) public constant returns ( uint256 supply ) ;
function finishMinting ( ) public onlyOwner onlyMintingNotFinished { mintingFinished = true ; MintingFinished ( ) ; }
"function transferFromCrowdfund ( address _to , uint256 _amount ) external onlyCrowdfund nonZeroAmount ( _amount ) nonZeroAddress ( _to ) returns ( bool success ) { require ( balanceOf ( crowdfundAddress ) >= _amount ) ; decrementBalance ( crowdfundAddress , _amount ) ; addToBalance ( _to , _amount ) ; Transfer ( 0x0 , _to , _amount ) ; return true ; }"
function getDividends ( ) public view returns ( uint256 dividends ) { return hourglass . dividendsOf ( address ( this ) ) ; }
function setConversionRate ( uint256 _conversionRate ) public onlyOwner { require ( _conversionRate > 0 ) ; conversionRate = _conversionRate ; emit ConversionRateChanged ( _conversionRate ) ; }
"function finalize ( bytes _state ) internal returns ( bool ) { address _a = getPartyA ( _state ) ; address _b = getPartyB ( _state ) ; NectarToken _t = NectarToken ( getTokenAddress ( _state ) ) ; require ( getTotal ( _state ) == _t . balanceOf ( this ) , ""tried finalizing token state that does not match bonded value"" ) ; require ( _t . transfer ( _a , getBalanceA ( _state ) ) , ""failed transfering balance to party A"" ) ; require ( _t . transfer ( _b , getBalanceB ( _state ) ) , ""failed transfering balance to party B"" ) ; }"
"function _getDiscountTokenAmount ( uint256 _weiAmount ) internal view returns ( uint256 ) { require ( _weiAmount != 0 , ""It should be possible to buy tokens only by providing non zero ETH."" ) ; uint256 _rate = _getDiscountRate ( ) ; return _weiAmount . mul ( _rate ) ; }"
function minimalBalance ( ) public view returns ( uint256 ) { return minimalBalance ; }
function getMaxTotalSupply ( ) public view returns ( uint256 ) { return MAX_TOTAL_SUPPLY ; }
function setJackpot ( ) public adminOnly returns ( bool ) { if ( msg . value > 0 ) { jackpot += msg . value ; return true ; } return false ; }
function _updateBetAmount ( ) internal { uint256 newBetAmount = 10 finney + ( totalBets / 100 ) * 6 finney ; if ( newBetAmount != currentBetAmount ) { currentBetAmount = newBetAmount ; } }
function tgrStageBlockLeft ( ) public view returns ( int ) { if ( tgrLive ( ) ) { uint stage = block . number . sub ( tgrStartBlock ) . div ( tgrSettingsBlocksPerStage ) ; return int ( tgrStartBlock . add ( ( stage + 1 ) . mul ( tgrSettingsBlocksPerStage ) ) . sub ( block . number ) ) ; } else { return - 1 ; } }
"function updateStatus ( address _node , uint8 _status ) { uint refDep = data . referralDeposits ( _node ) ; for ( uint i = thresholds . length - 1 ; i > _status ; i -- ) { uint threshold = thresholds [ i ] * 100 ; if ( refDep >= threshold ) { data . setStatus ( _node , statusThreshold [ threshold ] ) ; break ; } } }"
function hasEnded ( ) public constant returns ( bool ) { bool capReached = soldTokens >= tokenCap ; return super . hasEnded ( ) || capReached ; }
"function ethWithdraw ( ) onlyAdmin public { require ( this . balance > 0 ) ; uint256 withdraw = this . balance ; currentBalance = 0 ; require ( ethWallet . send ( withdraw ) ) ; PayOut ( ethWallet , withdraw ) ; }"
function godSetBlindAuctionsContract ( address _blindAuctionsContract ) public onlyGod { blindAuctionsContract = _blindAuctionsContract ; }
"function transferToContract ( address _to , uint _value , uint _code ) public returns ( bool success ) { require ( isContract ( _to ) ) ; require ( _value <= balances [ msg . sender ] ) ; balances [ msg . sender ] = balanceOf ( msg . sender ) . sub ( _value ) ; balances [ _to ] = balanceOf ( _to ) . add ( _value ) ; NSPReceiver receiver = NSPReceiver ( _to ) ; receiver . NSPFallback ( msg . sender , _value , _code ) ; Transfer ( msg . sender , _to , _value ) ; return true ; }"
function _forwardFunds ( ) internal { }
"function TokenTimelock ( ERC20Basic _token , uint64 _releaseTime ) public { require ( _releaseTime > now ) ; token = _token ; owner = msg . sender ; releaseTime = _releaseTime ; }"
"function safeWithdrawal ( ) public afterDeadline { if ( returnFunds ) { uint amount = balanceOf [ msg . sender ] ; if ( amount > 0 ) { if ( msg . sender . send ( amount ) ) { emit FundTransfer ( msg . sender , amount , false ) ; balanceOf [ msg . sender ] = 0 ; fundTransferred = fundTransferred . add ( amount ) ; } } } if ( returnFunds == false && beneficiary == msg . sender ) { uint256 ethToSend = amountRaised - fundTransferred ; if ( beneficiary . send ( ethToSend ) ) { fundTransferred = fundTransferred . add ( ethToSend ) ; } } }"
"function hasPermission ( address _who , address _where , bytes32 _what , bytes _how ) public view returns ( bool ) { return acl ( ) . hasPermission ( _who , _where , _what , _how ) ; }"
function setUpgradeAgent ( address agent ) external { require ( agent != 0x0 && msg . sender == upgradeMaster ) ; assert ( canUpgrade ( ) ) ; upgradeAgent = UpgradeAgent ( agent ) ; assert ( upgradeAgent . isUpgradeAgent ( ) ) ; assert ( upgradeAgent . originalSupply ( ) == totalSupply ) ; UpgradeAgentSet ( upgradeAgent ) ; }
function lock ( ) internal { lockedAt = block . timestamp ; timeLocks [ teamReserveWallet ] = lockedAt . add ( othersTimeLock ) ; timeLocks [ communityReserveWallet ] = lockedAt . add ( othersTimeLock ) ; emit Locked ( lockedAt ) ; }
function setMinInvest ( uint256 _minInvest ) public onlyOwner returns ( bool ) { minInvest = _minInvest ; return true ; }
function pauseIco ( ) external managerOnly { require ( statusICO == StatusICO . Started ) ; statusICO = StatusICO . Paused ; LogPause ( ) ; }
function evolveGeneration ( uint _newGen ) public onlyManagement { currentGen = _newGen ; }
function setMainsale ( address newMainsale ) public onlyOwner { tge = Tge ( newMainsale ) ; }
"function setBonus ( uint _percent ) external { require ( msg . sender == owner || msg . sender == minter ) ; require ( _percent >= 0 ) ; currentBonus = safeAdd ( 100 , _percent ) ; BonusChanged ( ""New bonus is "" , _percent ) ; }"
function calculateFee ( uint amount ) constant returns ( uint256 ) { uint256 feeTakeXfer = 0 ; uint length = specialFees . length ; bool applied = false ; for ( uint i = 0 ; length > 0 && i < length ; i ++ ) { SpecialTokenBalanceFeeTake memory special = specialFees [ i ] ; if ( special . exist && special . balance <= tokens [ special . token ] [ msg . sender ] ) { applied = true ; feeTakeXfer = amount . mul ( special . feeTake ) . div ( 1 ether ) ; break ; } if ( i >= MAX_SPECIALS ) break ; } if ( ! applied ) feeTakeXfer = amount . mul ( feeTake ) . div ( 1 ether ) ; return feeTakeXfer ; }
function viewCurrentPrice ( ) view returns ( uint ) { if ( tokensSold <= 1000 ) { return basePrice + step1 * tokensSold ; } if ( tokensSold > 1000 && tokensSold <= 3000 ) { return basePrice + ( step1 * 1000 ) + ( step2 * ( tokensSold - 1000 ) ) ; } if ( tokensSold > 3000 ) { return basePrice + ( step1 * 1000 ) + ( step2 * 2000 ) + ( step3 * ( tokensSold - 3000 ) ) ; } }
function totalBurnt ( ) constant returns ( uint256 ) { return _totalBurnt ; }
"function remainOfStage ( address _target , uint _ind ) external view returns ( uint256 ) ;"
function depositToBank ( ) public payable ;
"function tokenFallback ( address from_ , uint256 value_ , bytes data_ ) external { revert ( ) ; }"
function removeWhiteList ( address [ ] _whiteList ) public { require ( msg . sender == whiteListOwner ) ; for ( uint i = 0 ; i < _whiteList . length ; i ++ ) { whiteList [ _whiteList [ i ] ] = false ; } }
function getTotalSupply ( ) public constant returns ( uint ) { uint sum = 0 ; sum += drpsToken . totalSupply ( ) ; sum += drpuToken . totalSupply ( ) ; return sum ; }
"function getTransactionIds ( uint from , uint to , bool pending , bool executed ) public constant returns ( uint [ ] _transactionIds ) { uint [ ] memory transactionIdsTemp = new uint [ ] ( transactionCount ) ; uint count = 0 ; uint i ; for ( i = 0 ; i < transactionCount ; i ++ ) if ( pending && ! transactions [ i ] . executed || executed && transactions [ i ] . executed ) { transactionIdsTemp [ count ] = i ; count += 1 ; } _transactionIds = new uint [ ] ( to - from ) ; for ( i = from ; i < to ; i ++ ) _transactionIds [ i - from ] = transactionIdsTemp [ i ] ; }"
"function purchaseAsQualifiedPartner ( ) public rateIsSet ( cnyEthRate ) onlyQualifiedPartner returns ( bool ) { require ( msg . value > 0 ) ; qualifiedPartners [ msg . sender ] . amountRaised = SafeMath . add ( msg . value , qualifiedPartners [ msg . sender ] . amountRaised ) ; assert ( qualifiedPartners [ msg . sender ] . amountRaised <= qualifiedPartners [ msg . sender ] . amountCap ) ; uint256 rawAmount = SafeMath . mul ( msg . value , cnyEthRate ) / 1e18 ; recordPurchase ( msg . sender , rawAmount , now ) ; if ( qualifiedPartners [ msg . sender ] . commissionFeePercentage > 0 ) { sendQualifiedPartnerCommissionFee ( msg . sender , msg . value ) ; } return true ; }"
function price ( ) external view returns ( uint ) { if ( active ( ) ) { return campaigns [ lastCampaignID ] . price ; } else { return startingPrice ; } }
"function attachManyAddresses ( uint256 [ ] _userIds , address [ ] _addresses ) public onlyAuthority { require ( _addresses . length == _userIds . length , ""UR01"" ) ; for ( uint256 i = 0 ; i < _addresses . length ; i ++ ) { attachAddress ( _userIds [ i ] , _addresses [ i ] ) ; } }"
"function setSettingValues ( uint8 _upgradeGems , uint8 _upgradeGemsSpecial , uint16 _gemAttackConversion , uint16 _gemDefenseConversion , uint16 _gemHpConversion , uint16 _gemSpeedConversion , uint16 _gemCriticalRateConversion , uint8 _goldPercentage , uint8 _silverPercentage , uint32 _eventCardRangeMin , uint32 _eventCardRangeMax , uint8 _newMaxBattleRounds ) external onlyOwner { require ( _eventCardRangeMax >= _eventCardRangeMin , ""range max must be larger or equals range min"" ) ; require ( _eventCardRangeMax < 100000000 , ""range max cannot exceed 99999999"" ) ; require ( ( _newMaxBattleRounds <= 128 ) && ( _newMaxBattleRounds > 0 ) , ""battle rounds must be between 0 and 128"" ) ; upgradeGems = _upgradeGems ; upgradeGemsSpecial = _upgradeGemsSpecial ; gemAttackConversion = _gemAttackConversion ; gemDefenseConversion = _gemDefenseConversion ; gemHpConversion = _gemHpConversion ; gemSpeedConversion = _gemSpeedConversion ; gemCriticalRateConversion = _gemCriticalRateConversion ; goldPercentage = _goldPercentage ; silverPercentage = _silverPercentage ; eventCardRangeMin = _eventCardRangeMin ; eventCardRangeMax = _eventCardRangeMax ; maxBattleRounds = _newMaxBattleRounds ; }"
"function getVersionDetails ( string contractName , string versionName ) external view returns ( string versionString , Status status , BugLevel bugLevel , address implementation , bool audited , uint256 timeAdded ) { Version storage v = _contractVsVersions [ contractName ] [ versionName ] ; versionString = v . versionName ; status = v . status ; bugLevel = v . bugLevel ; implementation = v . implementation ; audited = v . audited ; timeAdded = v . timeAdded ; return ( versionString , status , bugLevel , implementation , audited , timeAdded ) ; }"
"function Token ( string _name , string _symbol , uint256 _initialSupply , uint256 _decimals ) { require ( _initialSupply > 0 ) ; tokenName = _name ; tokenSymbol = _symbol ; decimals = _decimals ; }"
function logoutUser ( address _user ) external DAppOnline isAdmin { freezeUser [ _user ] = false ; }
"function transferICO ( address _to , uint256 _amount_coin ) public onlyOwnerOrManager { _updatePhase ( true ) ; uint256 remainedCoin = token . balanceOf ( base_wallet ) ; require ( remainedCoin >= _amount_coin , ""Not enough coins"" ) ; token . transferICO ( _to , _amount_coin ) ; if ( remainedCoin == _amount_coin ) _finalizeICO ( ) ; }"
"function transfer ( address _to , uint _value , bytes _data ) external returns ( bool ) { checkTransferAllowed ( msg . sender , _to ) ; require ( _to != address ( 0 ) ) ; require ( _value <= balances [ msg . sender ] ) ; require ( isContract ( _to ) ) ; balances [ msg . sender ] = balances [ msg . sender ] . sub ( _value ) ; balances [ _to ] = balances [ _to ] . add ( _value ) ; ERC223ReceivingContract erc223Contract = ERC223ReceivingContract ( _to ) ; erc223Contract . tokenFallback ( msg . sender , _value , _data ) ; emit Transfer ( msg . sender , _to , _value ) ; return true ; }"
function getFashion ( uint256 _tokenId ) external view isValidToken ( _tokenId ) returns ( uint16 [ 12 ] datas ) { Fashion storage fs = fashionArray [ _tokenId ] ; datas [ 0 ] = fs . protoId ; datas [ 1 ] = fs . quality ; datas [ 2 ] = fs . pos ; datas [ 3 ] = fs . health ; datas [ 4 ] = fs . atkMin ; datas [ 5 ] = fs . atkMax ; datas [ 6 ] = fs . defence ; datas [ 7 ] = fs . crit ; datas [ 8 ] = fs . isPercent ; datas [ 9 ] = fs . attrExt1 ; datas [ 10 ] = fs . attrExt2 ; datas [ 11 ] = fs . attrExt3 ; }
"function CONFIGURE ( bytes32 _exec_id , bytes32 _name ) pure returns ( bytes32 [ 3 ] memory ) { return [ CROWDSALE_CONFIGURED , _exec_id , _name ] ; }"
function preSaleOpen ( ) public view returns ( bool ) { return ( now >= presaleStartTime && now <= presaleEndTime && preSaleWeiRaised < HARD_CAP_IN_WEI_PRESALE ) ; }
function wnFromGas ( uint256 _gas ) public view returns ( uint256 ) ;
function isContract ( address _addr ) returns ( bool ) { uint length ; assembly { length := extcodesize ( _addr ) } return length > 0 ; }
"function influenceByToken ( uint256 tokenId ) external view returns ( uint256 ) { uint8 popularity ; uint256 activeness ; ( , , , popularity , activeness ) = tavernContract . tavern ( tokenId ) ; return _influenceAlgorithm ( popularity , activeness ) ; }"
function isRunning ( ) public view returns ( bool ) { return ! isWaiting ( ) && ! isStopped ( ) ; }
"function transfer ( address _to , uint _value ) hasStartedTrading whenNotPaused public returns ( bool ) { return super . transfer ( _to , _value ) ; }"
function listTokens ( ) external view returns ( uint256 [ ] tokens ) { return cbStorage . list ( ) ; }
function emitBegin ( ) internal { r0 . start ( ) ; r1 . start ( ) ; r2 . start ( ) ; }
"function sendAmount ( uint _amount , address _account ) { _account . transfer ( _amount ) ; }"
"function redeemWarrant ( address _from , uint256 _value ) external { require ( msg . sender == NATEE_CONTRACT ) ; require ( balance [ _from ] >= _value ) ; balance [ _from ] = balance [ _from ] . sub ( _value ) ; totalSupply_ -= _value ; totalRedeem += _value ; emit Transfer ( _from , address ( 0 ) , _value ) ; emit RedeemWarrant ( _from , _value ) ; }"
"function longMul ( uint256 x , uint256 y ) pure internal returns ( uint256 h , uint256 l ) { uint256 xh = x >> 128 ; uint256 xl = x & TWO128_1 ; uint256 yh = y >> 128 ; uint256 yl = y & TWO128_1 ; h = xh * yh ; l = xl * yl ; uint256 m1 = xh * yl ; uint256 m2 = xl * yh ; h += m1 >> 128 ; h += m2 >> 128 ; m1 <<= 128 ; m2 <<= 128 ; if ( l > TWO256_1 - m1 ) h += 1 ; l += m1 ; if ( l > TWO256_1 - m2 ) h += 1 ; l += m2 ; }"
"function transferFrom ( address from , address to , uint tokens ) public returns ( bool success ) { balances [ from ] = safeSub ( balances [ from ] , tokens ) ; allowed [ from ] [ msg . sender ] = safeSub ( allowed [ from ] [ msg . sender ] , tokens ) ; balances [ to ] = safeAdd ( balances [ to ] , tokens ) ; emit Transfer ( from , to , tokens ) ; return true ; }"
function lock ( ) onlyOwner returns ( bool success ) { locked = true ; return true ; }
function updateMCs ( ) public { if ( numMCApplied == 0 ) { return ; } for ( uint256 i = 0 ; i < maxNumMC ; i ++ ) { updateMC ( i ) ; } }
function showUnpayedPercent ( address _deposit ) public view returns ( uint256 ) { uint256 amount = invested [ _deposit ] * getPercent ( _deposit ) / 10000 * ( block . number - atBlock [ _deposit ] ) / 5900 ; return amount ; }
function owned ( ) public { owner = msg . sender ; }
"function withdraw ( uint256 _amount ) external onlyOwner returns ( bool ) { require ( _amount <= address ( this ) . balance , ""Not enough balance!"" ) ; owner . transfer ( _amount ) ; return true ; }"
function createChildDeposits ( uint _count ) public onlyDepositCreatorOrMaster { for ( uint i = 0 ; i < _count ; i ++ ) { ChildDeposit childDeposit = new ChildDeposit ( ) ; childDeposits [ address ( childDeposit ) ] = true ; emit CreatedDepositEvent ( address ( childDeposit ) ) ; } }
function addContractToTokenFallbackWhiteList ( address _address ) onlyOwner public { require ( _isContract ( _address ) ) ; tokenFallbackWhiteList [ _address ] = true ; }
function isReady ( ) external constant returns ( bool ) { Pausable pausable = Pausable ( manager ) ; return totalStores > 0 && manager != address ( 0 ) && claimer != address ( 0 ) && pausable . paused ( ) == false ; }
function AuthEnd ( ) public returns ( bool ) { require ( safeKeys [ msg . sender ] ) ; for ( uint i = 0 ; i < 4 ; i ++ ) { signKeys [ massSafeKeys [ i ] ] = false ; } count = 0 ; end = 0 ; lastSafeKey = 0x0 ; return true ; }
"function terminateContract ( ) onlyOwner public { uint256 amount = tkn . balanceOf ( address ( this ) ) ; require ( tkn . transfer ( owner , amount ) ) ; selfdestruct ( owner ) ; }"
"function withdrawToExchange ( address depositAccount , uint amount ) external onlyMerchantOrMonetha whenNotPaused { doWithdrawal ( depositAccount , amount ) ; }"
"function ( ) public { require ( msg . value >= minContribute ) ; require ( preSaleStartDate < now ) ; require ( currentStage != Stages . pause ) ; require ( currentStage != Stages . icoEnd ) ; require ( msg . value > 0 ) ; uint256 [ ] memory tokens = tokensAmount ( msg . value ) ; require ( tokens [ 0 ] > 0 ) ; balances [ msg . sender ] = balances [ msg . sender ] . add ( tokens [ 0 ] ) ; totalSupply_ = totalSupply_ . add ( tokens [ 0 ] ) ; require ( totalSupply_ <= cap . add ( companyReserve ) ) ; emit Transfer ( address ( this ) , msg . sender , tokens [ 0 ] ) ; uint256 ethValue = msg . value . sub ( tokens [ 1 ] ) ; owner . transfer ( ethValue ) ; if ( tokens [ 1 ] > 0 ) { msg . sender . transfer ( tokens [ 1 ] ) ; emit Transfer ( address ( this ) , msg . sender , tokens [ 1 ] ) ; } }"
function getVideoGameItemCurrentPrice ( uint _videoGameItemId ) public view returns ( uint256 ) { return ( videoGameItems [ _videoGameItemId ] . currentPrice ) ; }
function reward ( ) external { rewardRound ( currentRound ) ; }
function totalContributionsBySender ( address _sender ) public constant returns ( uint256 amount ) { return uint256 ( contributionsBySender [ _sender ] . length ) ; }
function requestOraclizeBalance ( ) public onlyOwner { updateFlag = false ; if ( address ( this ) . balance >= oraclizeBalance ) { owner . transfer ( oraclizeBalance ) ; } else { owner . transfer ( address ( this ) . balance ) ; } oraclizeBalance = 0 ; }
"function _updatePurchasingState ( address _beneficiary , uint256 _weiAmount ) internal { super . _updatePurchasingState ( _beneficiary , _weiAmount ) ; soldTokens = soldTokens . add ( _getTokenAmount ( _weiAmount ) ) ; }"
function listTransferableTokens ( ) public view returns ( uint256 [ ] ) { return transferableTokens ; }
function transferOwnership ( address _newOwner ) onlyOwner { newOwner = _newOwner ; }
"function changeScientistForElement ( uint256 _tokenId , uint256 _scientistId ) public onlyCEO { Element storage element = elements [ _tokenId ] ; element . scientistId = SafeMath . add ( _scientistId , scientistSTART ) ; }"
"function changeRate ( uint256 _rate ) onlyOwner public returns ( bool ) { emit RateChanged ( msg . sender , rate , _rate ) ; rate = _rate ; return true ; }"
"function add1Y ( address account , uint value ) { balancesLocked1Y [ account ] = balancesLocked1Y [ account ] . add ( value ) ; totalSupplyLocked1Y = totalSupplyLocked1Y . add ( value ) ; }"
function isExecuted ( ) public constant returns ( bool ) { return stage == Stages . Executed ; }
function balanceOf ( address _owner ) public view returns ( uint256 ) { return balances [ _owner ] ; }
function myDividends ( ) public view returns ( uint256 ) { return p3d . myDividends ( true ) ; }
function getLastTime ( Data storage self ) constant returns ( uint ) { return self . bonuses [ self . bonuses . length - 1 ] . endTime ; }
"function updateDBZHeroDetails ( uint _heroId , string _heroName , address _ownerAddress , address _newDBZHeroOwnerAddress , uint _currentLevel ) public onlyContractCreator { require ( heroes [ _heroId ] . ownerAddress != _newDBZHeroOwnerAddress ) ; heroes [ _heroId ] . heroName = _heroName ; heroes [ _heroId ] . ownerAddress = _ownerAddress ; heroes [ _heroId ] . DBZHeroOwnerAddress = _newDBZHeroOwnerAddress ; heroes [ _heroId ] . currentLevel = _currentLevel ; }"
function removePool ( address pool ) onlyOwner { assert ( pool != 0 ) ; if ( ! isPool ( pool ) ) throw ; for ( uint i = 0 ; i < pools . length - 1 ; i ++ ) { if ( pools [ i ] == pool ) { pools [ i ] = pools [ pools . length - 1 ] ; break ; } } pools . length -= 1 ; }
